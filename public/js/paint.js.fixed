// Define global variables for use by project-manager.js
window.IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
window.currentImageLabel = 'front';
window.vectorStrokesByImage = {};
window.strokeVisibilityByImage = {};
window.strokeLabelVisibility = {};
window.strokeMeasurements = {};
window.imageScaleByLabel = {};
window.imagePositionByLabel = {};
window.lineStrokesByImage = {}; // Make sure it's exposed globally
window.labelsByImage = {};      // Make sure it's exposed globally
window.originalImages = {};
window.isLoadingProject = false; // <-- Re-adding this line

// At the top of the file, near other global variables
window.debugCoordinates = false; // Global flag to control coordinate debugging

document.addEventListener('DOMContentLoaded', () => {
    // Initialize unit selectors
    const unitSelector = document.getElementById('unitSelector');
    unitSelector.addEventListener('change', updateMeasurementDisplay);
    
    // Add debug toggle button to the controls
    const controlsContainer = document.querySelector('.controls-container');
    const debugToggle = document.createElement('button');
    debugToggle.textContent = '🐞 Debug';
    debugToggle.classList.add('debug-toggle');
    debugToggle.addEventListener('click', () => {
        window.debugCoordinates = !window.debugCoordinates;
        debugToggle.classList.toggle('active', window.debugCoordinates);
        console.log(`Coordinate debugging ${window.debugCoordinates ? 'enabled' : 'disabled'}`);
    });
    controlsContainer.appendChild(debugToggle);
    
    // Initialize the measurement inputs
    const inchWhole = document.getElementById('inchWhole');
    const inchFraction = document.getElementById('inchFraction');
    const cmValue = document.getElementById('cmValue');
    
    // Handle unit conversion when changing values
    inchWhole.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    inchFraction.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    cmValue.addEventListener('change', () => {
        const cm = parseFloat(cmValue.value) || 0;
        const inches = cm / 2.54;
        
        // Update inch values
        inchWhole.value = Math.floor(inches);
        
        // Find closest fraction
        const fractionPart = inches - Math.floor(inches);
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        inchFraction.value = closestFraction;
        
        // Show inch inputs, hide cm inputs
        document.getElementById('inchInputs').style.display = 'flex';
        document.getElementById('cmInputs').style.display = 'none';
    });
    
    const canvas = document.getElementById('canvas');
    // Expose canvas globally for project management
    window.canvas = canvas;
    const ctx = canvas.getContext('2d', { willReadFrequently: true }); // Add willReadFrequently hint
    const colorPicker = document.getElementById('colorPicker');
    const brushSize = document.getElementById('brushSize');
    const clearButton = document.getElementById('clear');
    const saveButton = document.getElementById('save');
    const pasteButton = document.getElementById('paste');
    const strokeCounter = document.getElementById('strokeCounter');
    const imageList = document.getElementById('imageList');
    const drawingModeToggle = document.getElementById('drawingModeToggle');
    
    // Draggable sidebars
    const strokeSidebar = document.getElementById('strokeSidebar');
    const imageSidebar = document.getElementById('imageSidebar');
    const strokeSidebarHeader = document.getElementById('strokeSidebarHeader');
    const imageSidebarHeader = document.getElementById('imageSidebarHeader');

    // Undo/Redo functionality
    const MAX_HISTORY = 50;  // Maximum number of states to store
    const IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
    let currentImageIndex = 0;
    let imageStates = {}; // Store states for each image
    
    // Use the global variables instead of creating new ones
    let strokeDataByImage = {}; // Store additional data for each stroke
    let undoStackByImage = {}; // Separate undo stack for each image
    let redoStackByImage = {}; // Separate redo stack for each image
    let pastedImages = [];  // Store all pasted images
    let isDrawingOrPasting = false;  // Flag to prevent saving states while drawing
    let strokeInProgress = false;  // Track if we're in the middle of a stroke
    let currentStroke = null;  // Store the state before current stroke
    let originalImageDimensions = {}; // Store original image dimensions for scaling
    let isShiftPressed = false; // Track if Shift key is pressed for image movement
    let calculatedLabelOffsets = {}; // Store automatically calculated label offsets

    // Initialize states for default images
    IMAGE_LABELS.forEach(label => {
        // Ensure we initialize global arrays properly
        window.lineStrokesByImage[label] = [];
        window.strokeVisibilityByImage[label] = {}; // Initialize stroke visibility
        window.vectorStrokesByImage[label] = {}; // Initialize vector stroke data
        window.labelsByImage[label] = 'A1';  // Start from A1 instead of A0
        
        strokeDataByImage[label] = {}; // Initialize stroke data
        undoStackByImage[label] = [];
        redoStackByImage[label] = [];  // Initialize redo stack
        imageStates[label] = null;
        // Initialize scale to 100% (1.0)
        window.imageScaleByLabel[label] = 1.0;
        originalImageDimensions[label] = { width: 0, height: 0 };
        // Initialize position offset to center (0, 0)
        window.imagePositionByLabel[label] = { x: 0, y: 0 };
        // Initialize with a blank state when the image is first created
        const blankState = ctx.createImageData(canvas.width, canvas.height);
        imageStates[label] = blankState;
        undoStackByImage[label].push({
            state: cloneImageData(blankState),
            type: 'initial',
            label: null
        });
    });

    let currentImageLabel = IMAGE_LABELS[0]; // Start with 'front'

    // Make addImageToSidebar available globally for the project manager
    window.addImageToSidebar = addImageToSidebar;
    function addImageToSidebar(imageUrl, label) {
        // *** ADDED LOG ***
        console.log(`[addImageToSidebar] Called for label: ${label}, imageUrl: ${imageUrl ? imageUrl.substring(0,30) + '...' : 'null'}`);

        const container = document.createElement('div');
        container.className = 'image-container';
        container.dataset.label = label;
        container.dataset.originalImageUrl = imageUrl; // Store the original image URL for later restoration
        
        const labelElement = document.createElement('div');
        labelElement.className = 'image-label';
        labelElement.textContent = label.charAt(0).toUpperCase() + label.slice(1);
        
        const strokesElement = document.createElement('div');
        strokesElement.className = 'image-strokes';
        strokesElement.textContent = 'Strokes: 0';
        
        const scaleElement = document.createElement('div');
        scaleElement.className = 'image-scale';
        scaleElement.textContent = `Scale: ${Math.round(imageScaleByLabel[label] * 100)}%`;
        scaleElement.id = `scale-${label}`;
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.className = 'pasted-image';
        img.alt = `${label} view`;
        
        container.appendChild(img);
        container.appendChild(labelElement);
        container.appendChild(strokesElement);
        container.appendChild(scaleElement);
        
        container.onclick = () => {
            // ... rest of the handler
            
            console.log(`Switching from ${currentImageLabel} to ${label}`);
            
            // Ensure we have undo stacks for both workspaces
            undoStackByImage[currentImageLabel] = undoStackByImage[currentImageLabel] || [];
            undoStackByImage[label] = undoStackByImage[label] || [];
            
            // Ensure we have redo stacks for both workspaces
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[label] = redoStackByImage[label] || [];
            
            // Ensure we have stroke lists for both workspaces
            lineStrokesByImage[currentImageLabel] = lineStrokesByImage[currentImageLabel] || [];
            lineStrokesByImage[label] = lineStrokesByImage[label] || [];
            
            // Ensure we have stroke visibility for both workspaces
            strokeVisibilityByImage[currentImageLabel] = strokeVisibilityByImage[currentImageLabel] || {};
            strokeVisibilityByImage[label] = strokeVisibilityByImage[label] || {};
            
            // Save current state before switching
            saveState(true, false);
            
            // Switch to the new image
            switchToImage(label);
        };
        
        // *** ADDED LOGS ***
        const imageListElement = document.getElementById('imageList');
        if (!imageListElement) {
            console.error('[addImageToSidebar] Cannot find #imageList element!');
            return; // Stop if the target doesn't exist
        }
        console.log(`[addImageToSidebar] About to append container for ${label} to #imageList.`);
        imageListElement.appendChild(container);
        console.log(`[addImageToSidebar] Successfully appended container for ${label}. #imageList children: ${imageListElement.childElementCount}`);
    }
    

    // Store the original images for each view
    window.originalImages = window.originalImages || {};
    
    // --- MODIFIED Function Signature and Logic --- 
    function pasteImageFromUrl(url, label) {
        // Wrap in a Promise
        return new Promise((resolve, reject) => {
            console.log(`[pasteImageFromUrl] Pasting image for ${label}: ${url.substring(0, 30)}...`);
        
        const img = new Image();
        img.onload = () => {
            // Store the original image for this view
                window.originalImages[label] = url;
                
                // Ensure the object exists before setting properties
                if (!window.originalImageDimensions) {
                    window.originalImageDimensions = {};
                }
            
            // Store original dimensions for scaling
                window.originalImageDimensions[label] = {
                width: img.width,
                height: img.height
            };
                
                // Log dimensions for debugging
                console.log(`[pasteImageFromUrl] Stored dimensions for ${label}: ${img.width}x${img.height}`);
            
            // Clear the canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply current scale factor
                const scale = imageScaleByLabel[label] || 1.0; // Use passed-in label
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of the canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
                const position = imagePositionByLabel[label] || { x: 0, y: 0 }; // Use passed-in label
                const offsetX = position.x;
                const offsetY = position.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;
            
            // Draw the image with scaling and positioning
                console.log(`[pasteImageFromUrl] Drawing image for ${label} at Canvas(${x.toFixed(1)}, ${y.toFixed(1)}) Scale: ${scale * 100}%`);
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Update the scale display in the sidebar
                const scaleElement = document.getElementById(`scale-${label}`);
            if (scaleElement) {
                scaleElement.textContent = `Scale: ${Math.round(scale * 100)}%`;
            }
            
            // Save this as the base state for this image
            const newState = getCanvasState();
                imageStates[label] = cloneImageData(newState); // Use passed-in label
                console.log(`[pasteImageFromUrl] State saved into imageStates[${label}]`);
                
                // If this is the currently active label, update currentStroke
                if (label === currentImageLabel) {
            currentStroke = cloneImageData(newState);
                }
            
                // Initialize the undo stack if needed
                if (!undoStackByImage[label] || undoStackByImage[label].length === 0) {
                    undoStackByImage[label] = [{
                state: cloneImageData(newState),
                type: 'initial',
                label: null
            }];
                    console.log(`[pasteImageFromUrl] Initialized undo stack for ${label}`);
                }
            
                // Update the scale buttons to show active state if this is the current view
                if (label === currentImageLabel) {
            updateScaleButtonsActiveState();
                }
                
                console.log(`[pasteImageFromUrl] Image loaded and state saved for ${label}`);
                resolve(); // Resolve the promise
            };
            
            img.onerror = (err) => {
                console.error(`[pasteImageFromUrl] Error loading image for ${label}:`, err);
                reject(err); // Reject the promise on error
            };
            
        img.src = url;
        });
    }
    // --- END MODIFIED Function ---

    function getNextLabel(imageLabel) {
        const currentLabel = labelsByImage[imageLabel];
        const letter = currentLabel[0];
        const number = parseInt(currentLabel.slice(1)) + 1;
        if (number > 9) {
            return String.fromCharCode(letter.charCodeAt(0) + 1) + '0';
        }
        return letter + number;
    }

    // Make updateStrokeCounter available globally
    window.updateStrokeCounter = updateStrokeCounter;
    function updateStrokeCounter() {
        const strokeCount = lineStrokesByImage[currentImageLabel]?.length || 0;
        strokeCounter.textContent = `Lines: ${strokeCount}`;
        
        // Update visibility controls
        updateStrokeVisibilityControls();
    }
    
    function updateSidebarStrokeCounts() {
        // Update stroke counts in the sidebar
        const imageContainers = document.querySelectorAll('.image-container');
        imageContainers.forEach(container => {
            const label = container.dataset.label;
            if (label) {
                const strokesElement = container.querySelector('.image-strokes');
                if (strokesElement) {
                    const strokes = lineStrokesByImage[label] || [];
                    strokesElement.textContent = `Strokes: ${strokes.length}`;
                }
            }
        });
        
        // Also update visibility controls when sidebar is updated
        updateStrokeVisibilityControls();
    }

    function getCanvasState() {
        return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    function restoreCanvasState(state) {
        if (!state) return;
        ctx.putImageData(state, 0, 0);
    }
    
    // Measurement data for strokes
    let strokeMeasurements = {};
    
    // Initialize measurement data store
    IMAGE_LABELS.forEach(label => {
        strokeMeasurements[label] = {};
    });
    
    // Function to get formatted measurement string
    function getMeasurementString(strokeLabel) {
        const measurement = strokeMeasurements[currentImageLabel]?.[strokeLabel];
        if (!measurement) return '';
        
        const unit = document.getElementById('unitSelector').value;
        
        if (unit === 'inch') {
            const whole = measurement.inchWhole || 0;
            const fraction = measurement.inchFraction || 0;
            
            // Format as 1 1/4" etc.
            let fractionStr = '';
            if (fraction > 0) {
                const fractionMap = {
                    0.125: '1/8',
                    0.25: '1/4',
                    0.375: '3/8',
                    0.5: '1/2',
                    0.625: '5/8',
                    0.75: '3/4',
                    0.875: '7/8'
                };
                fractionStr = ' ' + fractionMap[fraction];
            }
            
            return `${whole}${fractionStr}"`;
        } else {
            // CM with one decimal
            return `${measurement.cm.toFixed(1)} cm`;
        }
    }
    
    // Function to convert between units
    function convertUnits(from, value) {
        if (from === 'inch') {
            // Convert inch to cm
            return value * 2.54;
        } else {
            // Convert cm to inch
            return value / 2.54;
        }
    }
    
    // Function to update all measurements when unit changes
    function updateMeasurementDisplay() {
        const unit = document.getElementById('unitSelector').value;
        const inchWhole = document.getElementById('inchWhole');
        const inchFraction = document.getElementById('inchFraction');
        const cmValue = document.getElementById('cmValue');
        
        // Convert values when switching between units
        if (unit === 'inch') {
            // Converting from cm to inches
            const cm = parseFloat(cmValue.value) || 0;
            const inches = cm / 2.54;
            
            // Update inch values
            inchWhole.value = Math.floor(inches);
            
            // Find closest fraction
            const fractionPart = inches - Math.floor(inches);
            const fractions = [
                {value: '0', text: '0'},
                {value: '0.125', text: '1/8'},
                {value: '0.25', text: '1/4'},
                {value: '0.375', text: '3/8'},
                {value: '0.5', text: '1/2'},
                {value: '0.625', text: '5/8'},
                {value: '0.75', text: '3/4'},
                {value: '0.875', text: '7/8'}
            ];
            
            fractions.forEach(f => {
                const option = document.createElement('option');
                option.value = f.value;
                option.textContent = f.text;
                if (parseFloat(f.value) === fractionPart) {
                    option.selected = true;
                }
                inchFraction.appendChild(option);
            });
            
            // Show inch inputs, hide cm inputs
            document.getElementById('inchInputs').style.display = 'flex';
            document.getElementById('cmInputs').style.display = 'none';
        } else {
            // Converting from inches to cm
            const whole = parseInt(inchWhole.value) || 0;
            const fraction = parseFloat(inchFraction.value) || 0;
            const totalInches = whole + fraction;
            
            // Update cm value with one decimal point
            cmValue.value = (totalInches * 2.54).toFixed(1);
            
            // Show cm inputs, hide inch inputs
            document.getElementById('inchInputs').style.display = 'none';
            document.getElementById('cmInputs').style.display = 'flex';
        }
        
        // Update the stroke visibility display to show new units
        updateStrokeVisibilityControls();
        
        // Redraw the canvas with updated measurement format in labels
        redrawCanvasWithVisibility();
    }

    // Function to update stroke visibility controls
    // Make updateStrokeVisibilityControls available globally
    window.updateStrokeVisibilityControls = updateStrokeVisibilityControls;
    function updateStrokeVisibilityControls() {
        const controlsContainer = document.getElementById('strokeVisibilityControls');
        controlsContainer.innerHTML = ''; // Clear existing controls
        
        // Add a separator at the top
        const topSeparator = document.createElement('hr');
        controlsContainer.appendChild(topSeparator);
        
        // Display current unit
        const unitDisplay = document.createElement('div');
        unitDisplay.className = 'current-unit-display';
        unitDisplay.textContent = `Current Unit: ${document.getElementById('unitSelector').value === 'inch' ? 'Inches' : 'Centimeters'}`;
        controlsContainer.appendChild(unitDisplay);
        
        // Add another separator
        const separator = document.createElement('hr');
        controlsContainer.appendChild(separator);
        
        // Create strokes list
        const strokesList = document.createElement('div');
        strokesList.id = 'strokesList';
        controlsContainer.appendChild(strokesList);
        
        // Get strokes for current image
        const strokes = lineStrokesByImage[currentImageLabel] || [];
        
        if (strokes.length === 0) {
            strokesList.innerHTML = '<p>No strokes to display</p>';
            return;
        }
        
        // Current unit
        const unit = document.getElementById('unitSelector').value;
        
        // Create visibility toggle for each stroke
        strokes.forEach(strokeLabel => {
            // Initialize visibility if not set
            if (strokeVisibilityByImage[currentImageLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel] = {};
            }
            if (strokeVisibilityByImage[currentImageLabel][strokeLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            }
            
            // Initialize label visibility if not set
            if (strokeLabelVisibility[currentImageLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel] = {};
            }
            if (strokeLabelVisibility[currentImageLabel][strokeLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel][strokeLabel] = true; // Labels visible by default
            }
            
            // Initialize measurement if not set
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            if (strokeMeasurements[currentImageLabel][strokeLabel] === undefined) {
                strokeMeasurements[currentImageLabel][strokeLabel] = {
                    inchWhole: 0,
                    inchFraction: 0,
                    cm: 0.0
                };
            }
            
            const isVisible = strokeVisibilityByImage[currentImageLabel][strokeLabel];
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            const measurement = getMeasurementString(strokeLabel);
            const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
            
            const item = document.createElement('div');
            item.className = 'stroke-visibility-item';
            item.dataset.stroke = strokeLabel;
            item.dataset.selected = isSelected ? 'true' : 'false';
            
            // Make all parts of the item selectable (except checkbox and buttons)
            item.addEventListener('click', (e) => {
                // Don't trigger selection if clicking a button or checkbox
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
                    return;
                }
                
                // Toggle selection (if already selected, deselect it)
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                
                // Update the measurement input with the selected stroke's measurement
                    if (typeof updateMeasurementInputWithStroke === 'function') {
                    updateMeasurementInputWithStroke(strokeLabel);
                }
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `visibility-${strokeLabel}`;
            checkbox.checked = isVisible;
            checkbox.addEventListener('change', () => toggleStrokeVisibility(strokeLabel, checkbox.checked));
            
            const labelContainer = document.createElement('div');
            labelContainer.className = 'stroke-label-container';
            
            // Find the stroke color from the undo stack or vector data
            let strokeColor = '#000';
            let strokeType = 'freehand'; // Default type
            
            if (vectorStrokesByImage[currentImageLabel] && 
                vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                const vectorData = vectorStrokesByImage[currentImageLabel][strokeLabel];
                strokeColor = vectorData.color || '#000';
                strokeType = vectorData.type || 'freehand';
            } else {
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel && action.color) {
                        strokeColor = action.color;
                        // Try to determine stroke type from action
                        if (action.type === 'line') {
                            strokeType = 'straight';
                        }
                        break;
                    }
                }
            }
            
            // Create the stroke name element with color matching the stroke
            const strokeName = document.createElement('span');
            strokeName.className = 'stroke-name';
            strokeName.textContent = strokeLabel;
            strokeName.style.borderColor = strokeColor;
            strokeName.style.color = strokeColor;
            
            // Add a small icon to indicate stroke type (optional)
            if (strokeType === 'straight') {
                strokeName.title = 'Straight Line';
            } else {
                strokeName.title = 'Freehand Stroke';
            }
            
            // Make stroke name label clickable for selection as well
            strokeName.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent double handling with the item click
                
                // Toggle selection 
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            // Create measurement text
            const measureText = document.createElement('span');
            measureText.className = 'stroke-measurement';
            measureText.textContent = measurement ? `= ${measurement}` : '';
            
            // Create edit button
            const editBtn = document.createElement('button');
            editBtn.className = 'stroke-edit-btn';
            editBtn.innerHTML = '✏️';
            editBtn.title = 'Edit Stroke';
            editBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                showEditDialog(strokeLabel);
            };
            
            // Create label toggle button
            const labelToggleBtn = document.createElement('button');
            labelToggleBtn.className = 'stroke-label-toggle';
            labelToggleBtn.classList.toggle('active', isLabelVisible);
            labelToggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            labelToggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            labelToggleBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                toggleLabelVisibility(strokeLabel);
            };
            
            // Add elements to container
            labelContainer.appendChild(strokeName);
            labelContainer.appendChild(measureText);
            labelContainer.appendChild(labelToggleBtn);
            labelContainer.appendChild(editBtn);
            
            // Build the complete item
            item.appendChild(checkbox);
            item.appendChild(labelContainer);
            
            // Add to stroke list
            strokesList.appendChild(item);
        });
    }
    
    // Function to toggle label visibility on canvas
    function toggleLabelVisibility(strokeLabel) {
        // Only toggle the label visibility, not the stroke visibility
        strokeLabelVisibility[currentImageLabel][strokeLabel] = !strokeLabelVisibility[currentImageLabel][strokeLabel];
        
        // Update the UI button appearance
        const toggleBtn = document.querySelector(`.stroke-visibility-item[data-stroke="${strokeLabel}"] .stroke-label-toggle`);
        if (toggleBtn) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            toggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            toggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            toggleBtn.classList.toggle('active', isLabelVisible);
        }
        
        // Redraw the canvas with updated label visibility
        // This should not affect the stroke visibility
        redrawCanvasWithVisibility();
    }
    
    // Function to update measurement input with selected stroke's value
    // Function to display a measurement edit dialog
    function showMeasurementDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurement
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Measurement for ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values from inputs
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Determine which unit was changed last and use that value
            const currentUnit = document.getElementById('unitSelector').value;
            let finalCmValue, finalInchWhole, finalInchFraction;
            
            if (currentUnit === 'inch') {
                finalInchWhole = wholeValue;
                finalInchFraction = fractionValue;
                finalCmValue = convertUnits('inch', wholeValue + fractionValue);
            } else {
                finalCmValue = cmValue;
                // Calculate inch equivalent
                const inches = convertUnits('cm', cmValue);
                finalInchWhole = Math.floor(inches);
                finalInchFraction = findClosestFraction(inches - finalInchWhole);
            }
            
            // Update the measurement
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            
            strokeMeasurements[currentImageLabel][strokeLabel] = {
                inchWhole: finalInchWhole,
                inchFraction: finalInchFraction,
                cm: finalCmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update the UI
            updateStrokeVisibilityControls();
            
            // Redraw with the new measurement
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Helper function to find the closest fraction
    function findClosestFraction(fractionPart) {
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        return closestFraction;
    }
    
    // Function to show edit dialog for a stroke
    function showEditDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurements
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Stroke ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Create name edit field
        const nameContainer = document.createElement('div');
        nameContainer.className = 'name-container';
        
        const nameLabel = document.createElement('div');
        nameLabel.textContent = 'Label:';
        nameContainer.appendChild(nameLabel);
        
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = strokeLabel;
        nameInput.placeholder = 'Label';
        nameContainer.appendChild(nameInput);
        
        dialog.appendChild(nameContainer);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Sync between inch and cm inputs
        wholeInput.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        fractionSelect.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        cmInput.addEventListener('change', () => {
            const cmValue = parseFloat(cmInput.value) || 0;
            const inches = convertUnits('cm', cmValue);
            const wholeValue = Math.floor(inches);
            const fractionValue = findClosestFraction(inches - wholeValue);
            
            wholeInput.value = wholeValue;
            fractionSelect.value = fractionValue.toString();
        });
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values
            const newName = nameInput.value.trim();
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Update name if changed
            let finalName = strokeLabel;
            if (newName !== strokeLabel && newName !== '') {
                // The unique name generation is handled inside renameStroke
                finalName = renameStroke(strokeLabel, newName);
                
                // Show feedback if name was modified to make it unique
                if (finalName !== newName) {
                    console.log(`Stroke name automatically adjusted to ${finalName} to avoid duplicates`);
                    
                    // Create and show a temporary notification
                    const notification = document.createElement('div');
                    notification.style.position = 'fixed';
                    notification.style.bottom = '20px';
                    notification.style.left = '50%';
                    notification.style.transform = 'translateX(-50%)';
                    notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                    notification.style.color = 'white';
                    notification.style.padding = '10px 20px';
                    notification.style.borderRadius = '4px';
                    notification.style.zIndex = '10000';
                    notification.textContent = `Renamed to ${finalName} to avoid duplicates`;
                    
                    document.body.appendChild(notification);
                    
                    // Remove after 3 seconds
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 3000);
                }
            }
            
            // Always save both units
            strokeMeasurements[currentImageLabel][finalName] = {
                inchWhole: wholeValue,
                inchFraction: fractionValue,
                cm: cmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update UI
            updateStrokeVisibilityControls();
            
            // Redraw to show updated measurements
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Function to generate a unique stroke name
    function generateUniqueStrokeName(baseName) {
        // If the name is empty or undefined, use a default name
        if (!baseName || baseName.trim() === '') {
            baseName = 'A1';
        }
        
        // If the base name doesn't already exist, we can use it as is
        if (!lineStrokesByImage[currentImageLabel] || 
            !lineStrokesByImage[currentImageLabel].includes(baseName)) {
            return baseName;
        }
        
        // Name already exists, so we need to add a number
        // Extract the base part and any existing numbering
        const match = baseName.match(/^(.+?)(?:\((\d+)\))?$/);
        if (!match) {
            // If the regex didn't match for some reason, append (1) to the name
            return `${baseName}(1)`;
        }
        
        const base = match[1];
        let counter = 1;
        
        // If there was already a number, start from the next one
        if (match[2]) {
            counter = parseInt(match[2]) + 1;
        }
        
        // Keep incrementing until we find a unique name
        let newName;
        do {
            newName = `${base}(${counter})`;
            counter++;
        } while (lineStrokesByImage[currentImageLabel].includes(newName));
        
        return newName;
    }
    
    // Function to rename a stroke
    function renameStroke(oldName, newName) {
        if (oldName === newName) return;
        
        // Generate a unique name if needed - this ensures the new name won't conflict
        // with any existing stroke names, including itself
        const uniqueNewName = generateUniqueStrokeName(newName);
        
        // Find the stroke color from the undo stack or vector data to maintain color after rename
        let strokeColor = '#000';
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            strokeColor = vectorStrokesByImage[currentImageLabel][oldName].color || '#000';
        } else {
            for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                const action = undoStackByImage[currentImageLabel][i];
                if (action.label === oldName && action.color) {
                    strokeColor = action.color;
                    // Try to determine stroke type from action
                    if (action.type === 'line') {
                        strokeType = 'straight';
                    }
                    break;
                }
            }
        }
        
        // Update all relevant data structures
        if (lineStrokesByImage[currentImageLabel]) {
            const index = lineStrokesByImage[currentImageLabel].indexOf(oldName);
            if (index !== -1) {
                lineStrokesByImage[currentImageLabel][index] = uniqueNewName;
            }
        }
        
        // Update visibility
        if (strokeVisibilityByImage[currentImageLabel] && 
            strokeVisibilityByImage[currentImageLabel][oldName] !== undefined) {
            const isVisible = strokeVisibilityByImage[currentImageLabel][oldName];
            strokeVisibilityByImage[currentImageLabel][uniqueNewName] = isVisible;
            delete strokeVisibilityByImage[currentImageLabel][oldName];
        }
        
        // Update label visibility
        if (strokeLabelVisibility[currentImageLabel] && 
            strokeLabelVisibility[currentImageLabel][oldName] !== undefined) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][oldName];
            strokeLabelVisibility[currentImageLabel][uniqueNewName] = isLabelVisible;
            delete strokeLabelVisibility[currentImageLabel][oldName];
        }
        
        // Update stroke data
        if (strokeDataByImage[currentImageLabel] && 
            strokeDataByImage[currentImageLabel][oldName]) {
            strokeDataByImage[currentImageLabel][uniqueNewName] = 
                strokeDataByImage[currentImageLabel][oldName];
            delete strokeDataByImage[currentImageLabel][oldName];
        }
        
        // Update vector data
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            vectorStrokesByImage[currentImageLabel][uniqueNewName] = 
                vectorStrokesByImage[currentImageLabel][oldName];
            delete vectorStrokesByImage[currentImageLabel][oldName];
        }
        
        // Update measurements
        if (strokeMeasurements[currentImageLabel] && 
            strokeMeasurements[currentImageLabel][oldName]) {
            strokeMeasurements[currentImageLabel][uniqueNewName] = 
                strokeMeasurements[currentImageLabel][oldName];
            delete strokeMeasurements[currentImageLabel][oldName];
        }
        
        // Update next label if needed
        if (labelsByImage[currentImageLabel] === oldName) {
            labelsByImage[currentImageLabel] = uniqueNewName;
        }
        
        // Update any references in the undo/redo stacks
        if (undoStackByImage[currentImageLabel]) {
            undoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        if (redoStackByImage[currentImageLabel]) {
            redoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        // Return the actual name used for the stroke (either the original or the uniquified version)
        return uniqueNewName;
    }
    
    // Function to toggle stroke visibility
    function toggleStrokeVisibility(strokeLabel, isVisible) {
        console.log(`Toggling visibility of stroke ${strokeLabel} to ${isVisible}`);
        
        // Update visibility state
        strokeVisibilityByImage[currentImageLabel][strokeLabel] = isVisible;
        
        // Make sure the stroke data is still available and not accidentally cleared
        if (isVisible) {
            // Initialize vectorStrokesByImage for this image if it doesn't exist
            if (!vectorStrokesByImage[currentImageLabel]) {
                vectorStrokesByImage[currentImageLabel] = {};
            }
            
            // If we're making a stroke visible, ensure we still have vector data
            if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                console.log(`Vector data missing for ${strokeLabel}, attempting recovery`);
                
                // Try to recover vector data from the undo stack
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel) {
                        if (action.vectorData) {
                            vectorStrokesByImage[currentImageLabel][strokeLabel] = action.vectorData;
                            console.log(`Recovered vector data for ${strokeLabel}`);
                            break;
                        }
                    }
                }
                
                // If we still couldn't recover the vector data, create a basic one
                // This is especially important for straight lines
                if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                    console.log(`Creating default vector data for ${strokeLabel}`);
                    
                    // Look for color and properties in the undo stack
                    let strokeColor = "#000000";
                    let strokeWidth = 5;
                    let isLine = false;
                    
                    for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                        const action = undoStackByImage[currentImageLabel][i];
                        if (action.label === strokeLabel) {
                            if (action.color) strokeColor = action.color;
                            if (action.width) strokeWidth = action.width;
                            if (action.type === 'line' || action.type === 'straight') isLine = true;
                            break;
                        }
                    }
                    
                    // Create a simple vector representation (placeholder)
                    vectorStrokesByImage[currentImageLabel][strokeLabel] = {
                        points: isLine ? [{x: 0, y: 0}, {x: 1, y: 1}] : [{x: 0, y: 0}],
                        color: strokeColor,
                        width: strokeWidth,
                        type: isLine ? 'straight' : 'freehand'
                    };
                }
            }
        };

        // *** Add redraw call here ***
        redrawCanvasWithVisibility();
    }
    
    // Store for currently selected stroke in each image
    let selectedStrokeByImage = {};
    
    // Initialize stroke label visibility for each image (default to visible)
    IMAGE_LABELS.forEach(label => {
        strokeLabelVisibility[label] = {};
        selectedStrokeByImage[label] = null; // Initialize with no selection
    });
    
    // Store for label custom positions (user-dragged positions)
    let customLabelPositions = {};
    
    // Flag to track if we're dragging a label
    let isDraggingLabel = false;
    let draggedLabelStroke = null;
    let dragStartX = 0;
    let dragStartY = 0;
    
    // Initialize custom label positions for each image
    IMAGE_LABELS.forEach(label => {
        customLabelPositions[label] = {};
    });
    
    // Cache for loaded images to prevent flickering
    const imageCache = {};
    
    // Store for label positions to prevent overlapping
    let currentLabelPositions = [];
    
    // Store for stroke paths to avoid overlapping with lines
    let currentStrokePaths = [];
    
    // Function to redraw canvas respecting stroke visibility
    // Make redrawCanvasWithVisibility available globally
    window.redrawCanvasWithVisibility = redrawCanvasWithVisibility;
    function redrawCanvasWithVisibility() {
        console.log(`--- redrawCanvasWithVisibility called for: ${currentImageLabel} ---`);
        
        // *** Save context and reset transform before drawing anything ***
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset to identity matrix
        console.log("Redraw Start Transform:", ctx.getTransform());
        
        // ADDED: Ensure originalImageDimensions exists and has an entry for this label
        if (!window.originalImageDimensions) {
            window.originalImageDimensions = {};
        }
        
        // ADDED: If we don't have dimensions for this label but we're trying to draw strokes,
        // create default dimensions based on the canvas size to prevent coordinates from being lost
        if (!window.originalImageDimensions[currentImageLabel] && 
            window.vectorStrokesByImage[currentImageLabel] && 
            Object.keys(window.vectorStrokesByImage[currentImageLabel]).length > 0) {
            
            console.log(`Creating default dimensions for ${currentImageLabel} to preserve strokes`);
            window.originalImageDimensions[currentImageLabel] = {
                width: canvas.width,
                height: canvas.height
            };
            console.log(`Set dimensions to match canvas: ${canvas.width}x${canvas.height}`);
        }
        
        // Reset label positions and stroke paths for this redraw
        currentLabelPositions = [];
        currentStrokePaths = [];
        
        // Create a copy of custom label positions for tracking which ones were actually used
        const usedCustomPositions = {};
        
        // We need to rebuild the canvas from scratch using individual stroke data
        const strokes = window.lineStrokesByImage[currentImageLabel] || [];
        
        // Start with a blank canvas or the original image if available
        if (window.originalImages && window.originalImages[currentImageLabel]) {
            // Check if we already have this image in the cache
            const imageUrl = window.originalImages[currentImageLabel];
            
            if (imageCache[imageUrl]) {
                // Use cached image immediately
                drawImageAndStrokes(imageCache[imageUrl]);
            } else {
                // Load the image and cache it
                const img = new Image();
                img.onload = () => {
                    // Add to cache
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                };
                img.src = imageUrl;
                
                // If the image is already cached in the browser, it might be immediately available
                if (img.complete) {
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                } else {
                    // If the image isn't immediately available,
                    // still draw the strokes on a blank canvas so they don't disappear
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the current scale and position
                    const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
                    
                    // For blank canvas mode, we apply the position directly when drawing points
                    // We pass 0,0 for position here since we'll apply it inside applyVisibleStrokes
                    applyVisibleStrokes(scale, 0, 0);
                }
            }
        } else {
            // Otherwise start with a blank canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white'; // Add white background fill
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Get the current scale for the blank canvas state
            const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
            
            // Apply visible strokes - for blank canvas mode, we don't need to apply position offset here
            // since we'll apply it to each point when drawing
            applyVisibleStrokes(scale, 0, 0);
        }
        
        function drawImageAndStrokes(img) {
            // Clear only once within the reset transform state
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply scale
            const scale = window.imageScaleByLabel[currentImageLabel];
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
            const positionOffset = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 }; // Ensure offset exists
            const offsetX = positionOffset.x;
            const offsetY = positionOffset.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;

            // *** ADDED LOGGING ***
            // console.log(`drawImageAndStrokes Calculation:
            //   canvas.width=${canvas.width}, img.width=${img.width}, scaledWidth=${scaledWidth}
            //   scale=${scale}, centerX=${centerX}, offsetX=${offsetX}, final imageX (passed to applyVisibleStrokes)=${x}`);
            // *** END LOGGING ***
            
            // Draw the image with scaling and positioning
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Then apply visible strokes
            applyVisibleStrokes(scale, x, y);
+
+           // Finalize after drawing strokes
+           finalizeRedraw();
        }
        
        function applyVisibleStrokes(scale, imageX, imageY) {
+           console.log("ApplyStrokes Start Transform:", ctx.getTransform()); // Log transform at start
            // console.log(`\nApplying strokes with scale=${scale}, imageX=${imageX}, imageY=${imageY}`); // Keep this commented unless debugging scale/position
            const strokes = window.vectorStrokesByImage[currentImageLabel] || {};
            const strokeOrder = window.lineStrokesByImage[currentImageLabel] || [];
            const visibility = window.strokeVisibilityByImage[currentImageLabel] || {};

            // Loop through strokes in their drawing order
            strokeOrder.forEach((strokeLabel) => {
                const isVisible = visibility[strokeLabel];
                if (!isVisible) return; // Skip invisible strokes

                const vectorData = strokes[strokeLabel];
                // Ensure vectorData and points exist
                if (!vectorData || !vectorData.points || vectorData.points.length === 0) {
                     console.warn(`Skipping stroke ${strokeLabel} in redraw: Missing vector data or points.`);
                     return;
                }

                // Set stroke style based on stored data, scaled by CURRENT scale
                ctx.strokeStyle = vectorData.color || '#000000';
                // *** FIX: Ensure lineWidth uses original stored width * current scale ***
                const scaledLineWidth = (vectorData.width || 5) * scale;
                ctx.lineWidth = scaledLineWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Start drawing the path
                ctx.beginPath();

                // Transform the first point from relative to canvas coordinates
                const firstPointRelative = vectorData.points[0];
                const firstPointCanvas = getCanvasCoords(firstPointRelative.x, firstPointRelative.y);
                ctx.moveTo(firstPointCanvas.x, firstPointCanvas.y);

                // Store canvas path for label collision detection
                const strokePath = [{ x: firstPointCanvas.x, y: firstPointCanvas.y }];

                // Check if this is a straight line (only two points)
                const isStraightLine = vectorData.type === 'straight' || (vectorData.points.length === 2 && !vectorData.type);

                if (isStraightLine && vectorData.points.length >= 2) {
                    // Straight Line: Transform only the last point
                    const lastPointRelative = vectorData.points[vectorData.points.length - 1];
                    const lastPointCanvas = getCanvasCoords(lastPointRelative.x, lastPointRelative.y);
                    ctx.lineTo(lastPointCanvas.x, lastPointCanvas.y);
                    strokePath.push({ x: lastPointCanvas.x, y: lastPointCanvas.y });
                } else {
                    // Freehand: Transform ALL subsequent points
                    for (let i = 1; i < vectorData.points.length; i++) {
                        const pointRelative = vectorData.points[i];
                        // *** FIX: Apply getCanvasCoords to EACH subsequent point ***
                        const pointCanvas = getCanvasCoords(pointRelative.x, pointRelative.y);
                        ctx.lineTo(pointCanvas.x, pointCanvas.y);
                        strokePath.push({ x: pointCanvas.x, y: pointCanvas.y });
                         // Optional logging for debugging coordinate drift:
                         // if (i < 3 || i % 20 === 0) { // Log first few and then every 20th
                         //     console.log(`  Redraw Pt ${i} Rel:(${pointRelative.x.toFixed(1)}, ${pointRelative.y.toFixed(1)}) -> Canv:(${pointCanvas.x.toFixed(1)}, ${pointCanvas.y.toFixed(1)})`);
                         // }
                    }
                }

                // Apply selection highlighting if needed (before stroking)
                const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                if (isSelected) {
                    ctx.save();
                    ctx.shadowColor = '#ffffff'; // White glow
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                }

                // Stroke the path
                ctx.stroke();

                // Restore context if selection highlighting was applied
                if (isSelected) {
                    ctx.restore();
                }

                // Store the calculated canvas path and scaled width for label positioning
                currentStrokePaths.push({
                    label: strokeLabel,
                    path: strokePath, // Store canvas coordinates path
                     // *** FIX: Store correctly scaled width ***
                    width: scaledLineWidth,
                    color: vectorData.color
                });
            }); // End of strokeOrder.forEach

            // --- Label Drawing Logic ---
            // console.log(`--- Redraw: Drawing Labels for ${currentImageLabel} ---`);
            currentLabelPositions = [];
            const usedCustomPositions = {};

            strokeOrder.forEach((strokeLabel) => {
                const isStrokeVisible = visibility[strokeLabel];
                if (!strokeLabelVisibility[currentImageLabel]) strokeLabelVisibility[currentImageLabel] = {};
                const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel] !== false; // Default true
                const vectorData = strokes[strokeLabel];

                if (isStrokeVisible && isLabelVisible && vectorData && vectorData.points.length > 0) {
                    const measurement = getMeasurementString(strokeLabel);
                    const labelText = measurement ? `${strokeLabel}=${measurement}` : strokeLabel;

                    // Determine anchor point (middle of the stroke) using RELATIVE coordinates
                    let anchorPointRelative = { x: 0, y: 0 };
                    const midIndex = Math.floor(vectorData.points.length / 2);
                    anchorPointRelative = vectorData.points[midIndex];

                    // Convert anchor point to CURRENT canvas coordinates
                    const anchorPointCanvas = getCanvasCoords(anchorPointRelative.x, anchorPointRelative.y);

                    if (isNaN(anchorPointCanvas.x) || isNaN(anchorPointCanvas.y)) {
                         console.error(`      Error getting canvas coords for label anchor for ${strokeLabel}. Relative point:`, anchorPointRelative);
                         return; // Skip label if anchor is invalid
                    }

                    // Set label style
                    // Increase font size for better visibility, especially when scaled
                    const baseFontSize = 14;
                    const scaledFontSize = Math.max(10, Math.min(28, baseFontSize / scale)); // Adjust font size based on zoom, within limits
                    ctx.font = `${scaledFontSize}px Arial`;
                    const labelColor = vectorData.color || '#000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';

                    // Calculate label dimensions based on current font size
                    const metrics = ctx.measureText(labelText);
                    const padding = 6 / scale; // Scale padding inversely
                    const labelWidth = metrics.width + padding * 2;
                    const labelHeight = scaledFontSize + padding * 2; // Adjust height based on font size

                    // Initial label rectangle guess (used for optimal position calculation)
                     const initialLabelRect = {
                        width: labelWidth,
                        height: labelHeight,
                        x: anchorPointCanvas.x - labelWidth / 2,
                        y: anchorPointCanvas.y - labelHeight - (15 / scale), // Scale vertical offset
                        strokeLabel: strokeLabel
                    };

                    // Determine final label position
                    let finalPosition; // This will be canvas coordinates {x, y} for the top-left of the label
                    let offset = null; // Relative offset {x, y} from anchorPointCanvas

                    // 1. Check for user-dragged position (stored as relative offset)
                    if (customLabelPositions[currentImageLabel]?.[strokeLabel]) {
                        offset = customLabelPositions[currentImageLabel][strokeLabel];
                        // Apply the stored relative offset to the *current* canvas anchor point
                        finalPosition = { x: anchorPointCanvas.x + offset.x, y: anchorPointCanvas.y + offset.y };
                        usedCustomPositions[strokeLabel] = true; // Mark as used
                         // console.log(`    Using custom offset for ${strokeLabel}. Anchor: (${anchorPointCanvas.x.toFixed(1)}, ${anchorPointCanvas.y.toFixed(1)}), Offset: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)}) -> Final: (${finalPosition.x.toFixed(1)}, ${finalPosition.y.toFixed(1)})`);
                    }
                    // 2. Check for previously calculated offset (stored as relative offset)
                    else if (calculatedLabelOffsets[currentImageLabel]?.[strokeLabel]) {
                        offset = calculatedLabelOffsets[currentImageLabel][strokeLabel];
                        // Apply the stored relative offset to the *current* canvas anchor point
                        finalPosition = { x: anchorPointCanvas.x + offset.x, y: anchorPointCanvas.y + offset.y };
                         // console.log(`    Using calculated offset for ${strokeLabel}. Anchor: (${anchorPointCanvas.x.toFixed(1)}, ${anchorPointCanvas.y.toFixed(1)}), Offset: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)}) -> Final: (${finalPosition.x.toFixed(1)}, ${finalPosition.y.toFixed(1)})`);
                    }
                    // 3. Calculate optimal position and offset for the first time
                    else {
                        if (typeof findOptimalLabelPosition !== 'function') {
                            console.error("     findOptimalLabelPosition function is not defined! Using default position.");
                            finalPosition = { x: initialLabelRect.x, y: initialLabelRect.y }; // Fallback
                        } else {
                            try {
                                const strokePathInfo = currentStrokePaths.find(p => p.label === strokeLabel);
                                const optimalRect = findOptimalLabelPosition(
                                    initialLabelRect, // Initial guess uses current canvas coords & dimensions
                                    anchorPointCanvas, // Anchor is current canvas coords
                                    strokePathInfo // Pass current canvas path info
                                );
                                finalPosition = { x: optimalRect.x, y: optimalRect.y };
                            } catch(err) {
                                console.error(`      Error in findOptimalLabelPosition for ${strokeLabel}:`, err);
                                finalPosition = { x: initialLabelRect.x, y: initialLabelRect.y }; // Fallback
                            }
                        }
                        // Calculate and store the RELATIVE offset based on the calculated position
                        offset = {
                            x: finalPosition.x - anchorPointCanvas.x,
                            y: finalPosition.y - anchorPointCanvas.y
                        };
                        if (!calculatedLabelOffsets[currentImageLabel]) calculatedLabelOffsets[currentImageLabel] = {};
                        calculatedLabelOffsets[currentImageLabel][strokeLabel] = offset; // Store relative offset
                        // console.log(`    Calculated and stored offset for ${strokeLabel}:`, offset);
                    }

                    // Store the final calculated position rect for overlap checks in *this* redraw cycle
                    const finalLabelRect = { ...initialLabelRect, x: finalPosition.x, y: finalPosition.y };
                    currentLabelPositions.push(finalLabelRect);

                    // Draw label background
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(finalLabelRect.x, finalLabelRect.y, finalLabelRect.width, finalLabelRect.height);

                    // Draw label border
                    ctx.strokeStyle = labelColor;
                    ctx.lineWidth = 1; // Keep border thin
                    ctx.strokeRect(finalLabelRect.x, finalLabelRect.y, finalLabelRect.width, finalLabelRect.height);

                    // Draw label text
                    ctx.fillStyle = labelColor;
                    const textX = finalLabelRect.x + finalLabelRect.width / 2;
                    const textY = finalLabelRect.y + finalLabelRect.height - padding; // Adjust baseline using scaled padding
                    ctx.fillText(labelText, textX, textY);

                    // Optionally draw connector line (from label edge to anchor point)
                    if (typeof drawLabelConnector === 'function') {
                        try {
                            drawLabelConnector(finalLabelRect, anchorPointCanvas, labelColor);
                        } catch(err) {
                            console.error(`      Error in drawLabelConnector for ${strokeLabel}:`, err);
                        }
                    }
                }
            }); // End of label drawing loop
            // --- End of Label Drawing Logic ---

            // Save the now-combined state (only if not loading, to prevent infinite loops)
            if (!window.isLoadingProject) {
                const newState = getCanvasState();
                imageStates[currentImageLabel] = cloneImageData(newState);
                 // console.log(`[Redraw] Saved final canvas state for ${currentImageLabel}`); // Optional: Debug state saving
            } else {
                 // console.log("[Redraw] Skipping final state save because isLoadingProject is true.");
            }
            ctx.restore(); // *** Restore the original context state (including transform) ***
            console.log("Redraw End Transform:", ctx.getTransform());
        }
    }

    function cloneImageData(imageData) {
        return new ImageData(
            new Uint8ClampedArray(imageData.data),
            imageData.width,
            imageData.height
        );
    }

    function saveState(force = false, incrementLabel = true, updateStrokeList = true) {
        // *** ADDED LOG ***
        console.log(`[Save State Called] force=${force}, incrementLabel=${incrementLabel}, updateStrokeList=${updateStrokeList}, isDrawingOrPasting=${isDrawingOrPasting}, strokeInProgress=${strokeInProgress}`);

        // Get current state
        const currentState = getCanvasState();

        // Initialize if first save for this image
        if (!imageStates[currentImageLabel]) {
            imageStates[currentImageLabel] = cloneImageData(currentState);
            undoStackByImage[currentImageLabel].push({
                state: cloneImageData(currentState),
                type: 'initial',
                label: null
            });
            updateStrokeCounter();
            return;
        }

        // Only save if we're not in the middle of a stroke or if forced
        if (!force && strokeInProgress) return;

        // Don't save if it's identical to the last state
        const lastState = imageStates[currentImageLabel];
        if (lastState && !force) {
            const currentData = currentState.data;
            const lastData = lastState.data;
            let identical = true;
            for (let i = 0; i < currentData.length; i += 4) {
                if (currentData[i] !== lastData[i] ||
                    currentData[i + 1] !== lastData[i + 1] ||
                    currentData[i + 2] !== lastData[i + 2] ||
                    currentData[i + 3] !== lastData[i + 3]) {
                    identical = false;
                    break;
                }
            }
            if (identical) return;
        }

        // For line strokes, assign the next label before saving
        let strokeLabel = null;
        if (!isDrawingOrPasting && !strokeInProgress && incrementLabel && updateStrokeList) {
            // *** ADDED DETAILED LOGS ***
            console.log(`[Save State] Entering stroke update block.`);
            
            // Get the suggested next label
            const suggestedLabel = window.labelsByImage[currentImageLabel];
            console.log(`[Save State] Suggested next label = "${suggestedLabel}" from labelsByImage[${currentImageLabel}]`);
            
            // *** FIX: Ensure the new stroke gets a UNIQUE label ***
            strokeLabel = generateUniqueStrokeName(suggestedLabel);
            console.log(`[Save State] Assigned UNIQUE strokeLabel = "${strokeLabel}"`);
            
            // Always increment the label counter based on the original suggested label for the next stroke
            const nextLabel = getNextLabel(currentImageLabel); // Uses the value in labelsByImage
            window.labelsByImage[currentImageLabel] = nextLabel;
            console.log(`[Save State] Incremented labelsByImage[${currentImageLabel}] to "${nextLabel}"`);
            
            // Only add the *unique* stroke label to the strokes list
            if (!window.lineStrokesByImage[currentImageLabel]) {
                console.log(`[Save State] Initializing lineStrokesByImage[${currentImageLabel}] as []`);
                window.lineStrokesByImage[currentImageLabel] = []; // Initialize if it doesn't exist
            }
            
            // Check if unique stroke label already exists before pushing (shouldn't happen with generateUniqueStrokeName)
            const labelAlreadyExists = window.lineStrokesByImage[currentImageLabel].includes(strokeLabel);
            
            console.log(`[Save State] BEFORE push: lineStrokesByImage[${currentImageLabel}] =`, JSON.parse(JSON.stringify(window.lineStrokesByImage[currentImageLabel])));
            
            if (!labelAlreadyExists && updateStrokeList) {
                window.lineStrokesByImage[currentImageLabel].push(strokeLabel); // Push the unique label
                console.log(`[Save State] AFTER push: lineStrokesByImage[${currentImageLabel}] =`, JSON.parse(JSON.stringify(window.lineStrokesByImage[currentImageLabel])));
            } else {
                // This case should ideally not be reached if generateUniqueStrokeName works correctly
                console.warn(`[Save State] Generated unique stroke label "${strokeLabel}" already exists? Not pushing again.`);
            }
            
            // Initialize visibility, data etc. using the unique strokeLabel
            window.strokeVisibilityByImage[currentImageLabel] = window.strokeVisibilityByImage[currentImageLabel] || {};
            window.strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            
            window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
            window.strokeLabelVisibility[currentImageLabel][strokeLabel] = true;
            
            strokeDataByImage[currentImageLabel] = strokeDataByImage[currentImageLabel] || {};
            strokeDataByImage[currentImageLabel][strokeLabel] = {
                preState: currentStroke ? cloneImageData(currentStroke) : null,
                postState: cloneImageData(currentState)
            };
        }

        // --- FIX: Handle temporary vector data --- 
        const tempStrokeKey = '_drawingStroke';
        let drawnVectorData = null;
        
        // Debug the state of vectorStrokesByImage before handling temporary data
        console.log(`[Save State] Vector strokes for ${currentImageLabel} before processing:`, 
            window.vectorStrokesByImage[currentImageLabel] ? 
            Object.keys(window.vectorStrokesByImage[currentImageLabel]) : "none");
            
        // Detailed check for _drawingStroke
        if (window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
            console.log(`[Save State] Found _drawingStroke data with ${window.vectorStrokesByImage[currentImageLabel][tempStrokeKey].points.length} points`);
        } else {
            console.log(`[Save State] No _drawingStroke data found:`, 
                window.vectorStrokesByImage[currentImageLabel] ? 
                "vectorStrokesByImage exists for label but no _drawingStroke key" : 
                "vectorStrokesByImage doesn't exist for this label");
        }
        
        if (strokeLabel && window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
            drawnVectorData = JSON.parse(JSON.stringify(window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]));
            // Assign the drawn data to the final unique stroke label
            window.vectorStrokesByImage[currentImageLabel][strokeLabel] = drawnVectorData;
            // Remove the temporary data
            delete window.vectorStrokesByImage[currentImageLabel][tempStrokeKey];
            console.log(`[Save State] Moved vector data from ${tempStrokeKey} to ${strokeLabel}`);
        } else if (strokeLabel) {
            console.warn(`[Save State] No temporary vector data found at ${tempStrokeKey} for stroke ${strokeLabel}`);
            // Attempt to find vector data if it somehow got assigned to the suggested label during draw (fallback)
            const suggestedLabel = window.labelsByImage[currentImageLabel]; // Get the label *before* incrementing
             if (window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][suggestedLabel]) {
                console.log(`[Save State] Fallback: Found data under suggested label ${suggestedLabel}`);
                drawnVectorData = JSON.parse(JSON.stringify(window.vectorStrokesByImage[currentImageLabel][suggestedLabel]));
                window.vectorStrokesByImage[currentImageLabel][strokeLabel] = drawnVectorData;
                // Optionally delete the data under suggestedLabel if it shouldn't be there
                // delete window.vectorStrokesByImage[currentImageLabel][suggestedLabel]; 
            }
        }
        // --- END FIX ---

        // Save new state and add to undo stack
        imageStates[currentImageLabel] = cloneImageData(currentState);
        
        // Determine the type of stroke
        let strokeType = 'other';
        if (force && strokeLabel) {
            strokeType = 'stroke';
            
            // Check for vector data to determine if it's a freehand or straight line
            // Use the vector data we just potentially moved
            if (drawnVectorData) { 
                if (drawnVectorData.type === 'straight') {
                    strokeType = 'line';
                } else if (drawnVectorData.type === 'freehand') {
                    strokeType = 'stroke';
                }
            }
        }
        
        // Add to undo stack with stroke info
        const undoAction = {
            state: cloneImageData(currentState),
            type: strokeType,
            label: strokeLabel, // Use the unique label
            color: colorPicker.value, 
            width: parseInt(brushSize.value) 
        };
        
        // Store vector data with the undo action if available
        // Use the data retrieved from the temporary key
        if (drawnVectorData) {
            undoAction.vectorData = drawnVectorData; 
        }
        
        undoStackByImage[currentImageLabel].push(undoAction);
        
        // Remove oldest state if we've reached max history
        if (undoStackByImage[currentImageLabel].length >= MAX_HISTORY) {
            undoStackByImage[currentImageLabel].shift();
        }

        // Clear redo stack when a new action is performed
        redoStackByImage[currentImageLabel] = [];

        updateStrokeCounter();
        updateSidebarStrokeCounts();
    }

    function undo() {
        console.log(`Attempting to undo in ${currentImageLabel} workspace`);
        console.log(`Current undo stack: ${undoStackByImage[currentImageLabel]?.length || 0} items`);
        console.log(`Current strokes: ${lineStrokesByImage[currentImageLabel]?.join(', ') || 'none'}`);
        
        const currentStack = undoStackByImage[currentImageLabel];
        if (currentStack && currentStack.length > 1) { // Keep at least one state (initial)
            // Get the state we're undoing from
            const lastAction = currentStack.pop();
            console.log(`Undoing action of type: ${lastAction.type}, label: ${lastAction.label || 'none'}`);
            
            // Add to redo stack
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[currentImageLabel].push(lastAction);
            console.log(`Added to redo stack, now has ${redoStackByImage[currentImageLabel].length} items`);
            
            // Skip certain state types when undoing
            if (lastAction.type === 'pre-stroke') {
                console.log('Skipping pre-stroke state');
                // If we encounter a pre-stroke state, undo again to get to the previous complete state
                if (currentStack.length > 1) {
                    return undo();
                }
            }
            
            // Handle snapshot type (created when switching views)
            if (lastAction.type === 'snapshot') {
                console.log('Restoring from snapshot state');
                // If we have stored strokes in the snapshot, restore them
                if (lastAction.strokes) {
                    lineStrokesByImage[currentImageLabel] = [...(lastAction.strokes || [])];
                    console.log(`Restored strokes: ${lineStrokesByImage[currentImageLabel].join(', ')}`);
                }
                
                // Continue to next undo action if possible
                if (currentStack.length > 1) {
                    return undo();
                }
            }
            
            // Get the state we're going back to
            const previousState = currentStack[currentStack.length - 1];
            
            if (lastAction.type === 'line' || lastAction.type === 'stroke') {
                // Remove the last stroke and its label
                if (lineStrokesByImage[currentImageLabel] && lineStrokesByImage[currentImageLabel].length > 0) {
                    const removedStroke = lineStrokesByImage[currentImageLabel].pop();
                    console.log(`Removed stroke: ${removedStroke}`);
                    
                    // Also remove from visibility tracking
                    if (strokeVisibilityByImage[currentImageLabel] && strokeVisibilityByImage[currentImageLabel][removedStroke]) {
                        delete strokeVisibilityByImage[currentImageLabel][removedStroke];
                    }
                    
                    // Also remove from label visibility tracking
                    if (strokeLabelVisibility[currentImageLabel] && strokeLabelVisibility[currentImageLabel][removedStroke]) {
                        // Save label visibility in lastAction for possible redo
                        lastAction.labelVisible = strokeLabelVisibility[currentImageLabel][removedStroke];
                        delete strokeLabelVisibility[currentImageLabel][removedStroke];
                    }
                    
                    // Also remove from stroke data tracking
                    if (strokeDataByImage[currentImageLabel] && strokeDataByImage[currentImageLabel][removedStroke]) {
                        delete strokeDataByImage[currentImageLabel][removedStroke];
                    }
                    
                    // Remove vector stroke data
                    if (vectorStrokesByImage[currentImageLabel] && vectorStrokesByImage[currentImageLabel][removedStroke]) {
                        // Save vector data in lastAction for possible redo
                        lastAction.vectorData = vectorStrokesByImage[currentImageLabel][removedStroke];
                        delete vectorStrokesByImage[currentImageLabel][removedStroke];
                }
                
                    // If this was the last stroke, reset to A1
                    if (lineStrokesByImage[currentImageLabel].length === 0) {
                        labelsByImage[currentImageLabel] = 'A1';
                        console.log(`All strokes undone, reset label counter to A1`);
                    } else {
                // Set the next label to be the one we just removed
                if (lastAction.label) {
                    labelsByImage[currentImageLabel] = lastAction.label;
                    console.log(`Reset label counter to: ${lastAction.label}`);
                        }
                    }
                }
            }
            
            // Ensure we have a valid previous state
            if (previousState && previousState.state) {
                // Restore the canvas state
                const stateToRestore = cloneImageData(previousState.state);
                imageStates[currentImageLabel] = stateToRestore;
                restoreCanvasState(stateToRestore);
                currentStroke = cloneImageData(stateToRestore);
                console.log('Canvas state restored');
            } else {
                console.log('Warning: No valid previous state found');
                // Create a blank state if needed
                const blankState = ctx.createImageData(canvas.width, canvas.height);
                imageStates[currentImageLabel] = blankState;
                restoreCanvasState(blankState);
                currentStroke = cloneImageData(blankState);
            }
            
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
        } else if (currentStack && currentStack.length === 1) {
            // We're at the initial state
            console.log('At initial state, resetting workspace');
            const initialState = currentStack[0];
            
            // Clear all stroke data
            lineStrokesByImage[currentImageLabel] = [];
            strokeVisibilityByImage[currentImageLabel] = {};
            strokeLabelVisibility[currentImageLabel] = {};
            vectorStrokesByImage[currentImageLabel] = {};
            strokeDataByImage[currentImageLabel] = {};
            
            // Reset label counter
            labelsByImage[currentImageLabel] = 'A1';  // Reset to A1
            
            if (initialState && initialState.state) {
                imageStates[currentImageLabel] = cloneImageData(initialState.state);
                restoreCanvasState(initialState.state);
                currentStroke = cloneImageData(initialState.state);
            } else if (window.originalImages[currentImageLabel]) {
                // If we have the original image, redraw it
                console.log('Redrawing from original image');
                const img = new Image();
                img.onload = () => {
                    // Clear the canvas first
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the current scale
                    const scale = window.imageScaleByLabel[currentImageLabel];
                    const scaledWidth = img.width * scale;
                    const scaledHeight = img.height * scale;
                    
                    // Calculate base position (center of canvas)
                    const centerX = (canvas.width - scaledWidth) / 2;
                    const centerY = (canvas.height - scaledHeight) / 2;
                    
                    // Apply position offset
                    const offsetX = window.imagePositionByLabel[currentImageLabel].x;
                    const offsetY = window.imagePositionByLabel[currentImageLabel].y;
                    
                    // Calculate final position
                    const x = centerX + offsetX;
                    const y = centerY + offsetY;
                    
                    // Draw the original image with scale and position
                    ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                    
                    // Save this as the new state
                    const newState = getCanvasState();
                    imageStates[currentImageLabel] = cloneImageData(newState);
                    currentStroke = cloneImageData(newState);
                };
                img.src = window.originalImages[currentImageLabel];
            }
            
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
        } else {
            console.log('No undo history available for this workspace');
        }
    }
    
    function redo() {
        console.log(`Attempting to redo in ${currentImageLabel} workspace`);
        console.log(`Current redo stack: ${redoStackByImage[currentImageLabel]?.length || 0} items`);
        
        const redoStack = redoStackByImage[currentImageLabel];
        if (redoStack && redoStack.length > 0) {
            // Get the action to redo
            const actionToRedo = redoStack.pop();
            console.log(`Redoing action of type: ${actionToRedo.type}, label: ${actionToRedo.label || 'none'}`);
            
            // Add back to undo stack
            undoStackByImage[currentImageLabel].push(actionToRedo);
            
            // Handle stroke type actions (both freehand strokes and straight lines)
            if ((actionToRedo.type === 'line' || actionToRedo.type === 'stroke') && actionToRedo.label) {
                // Add the stroke back to the list
                window.lineStrokesByImage[currentImageLabel] = window.lineStrokesByImage[currentImageLabel] || [];
                window.lineStrokesByImage[currentImageLabel].push(actionToRedo.label);
                console.log(`Added stroke back: ${actionToRedo.label}`);
                
                // Restore stroke visibility
                window.strokeVisibilityByImage[currentImageLabel] = window.strokeVisibilityByImage[currentImageLabel] || {};
                window.strokeVisibilityByImage[currentImageLabel][actionToRedo.label] = true;
                
                // Restore stroke data if we have it
                if (actionToRedo.strokeData) {
                    strokeDataByImage[currentImageLabel] = strokeDataByImage[currentImageLabel] || {};
                    strokeDataByImage[currentImageLabel][actionToRedo.label] = actionToRedo.strokeData;
                }
                
                // Restore vector data if we have it
                if (actionToRedo.vectorData) {
                    window.vectorStrokesByImage[currentImageLabel] = window.vectorStrokesByImage[currentImageLabel] || {};
                    window.vectorStrokesByImage[currentImageLabel][actionToRedo.label] = actionToRedo.vectorData;
                    
                    // If no vector data saved in the action, but we're redoing a line/stroke,
                    // try to recreate basic vector data to ensure label display
                    if (!actionToRedo.vectorData && 
                        (actionToRedo.type === 'line' || actionToRedo.type === 'stroke')) {
                        // Create minimal vector data to ensure label display
                        window.vectorStrokesByImage[currentImageLabel][actionToRedo.label] = {
                            points: [
                                { x: canvas.width/2 - 50, y: canvas.height/2 }, // Dummy points
                                { x: canvas.width/2 + 50, y: canvas.height/2 }
                            ],
                            color: actionToRedo.color || "#000000",
                            width: 5,
                            type: actionToRedo.type === 'line' ? 'straight' : 'freehand'
                        };
                    }
                }
                
                // Restore label visibility if we have it
                if (actionToRedo.labelVisible !== undefined) {
                    window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
                    window.strokeLabelVisibility[currentImageLabel][actionToRedo.label] = actionToRedo.labelVisible;
                } else {
                    // Default to visible for new strokes and redone strokes without saved value
                    window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
                    window.strokeLabelVisibility[currentImageLabel][actionToRedo.label] = true;
                }
                
                // Update the next label - make sure it's one higher than the redone label
                const numPart = parseInt(actionToRedo.label.slice(1));
                if (!isNaN(numPart)) {
                    const letterPart = actionToRedo.label[0];
                    const nextNum = numPart + 1;
                    const nextLabel = nextNum > 9 
                        ? String.fromCharCode(letterPart.charCodeAt(0) + 1) + '0' 
                        : letterPart + nextNum;
                    window.labelsByImage[currentImageLabel] = nextLabel;
                    console.log(`Set next label to: ${nextLabel}`);
                } else {
                    // Fallback to the standard next label function
                window.labelsByImage[currentImageLabel] = getNextLabel(currentImageLabel);
                console.log(`Set next label to: ${window.labelsByImage[currentImageLabel]}`);
                }
            }
            
            // Restore the state
            if (actionToRedo.state) {
                const stateToRestore = cloneImageData(actionToRedo.state);
                imageStates[currentImageLabel] = stateToRestore;
                restoreCanvasState(stateToRestore);
                currentStroke = cloneImageData(stateToRestore);
                console.log('Canvas state restored for redo');
            }
            
            // Update all UI elements
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
            
            // Force redraw with visibility to ensure labels appear immediately
            redrawCanvasWithVisibility();
        } else {
            console.log('No redo actions available for this workspace');
        }
    }

    // Save initial blank state
//    saveState();

    // Set canvas size
    function resizeCanvas() {
        // Account for the sidebars and gaps in our calculation (approximately 420px for sidebars + gaps)
        const sidebarSpace = 440;
        const maxWidth = Math.min(window.innerWidth - sidebarSpace, 1000);  // Cap at 1000px width
        const maxHeight = Math.min(window.innerHeight - 100, 800);  // Cap at 800px height
        
        // Save current state before resizing
        const oldState = imageStates[currentImageLabel];
        
        // Resize the canvas
        canvas.width = maxWidth;
        canvas.height = maxHeight;
        
        // Set default canvas styles
        canvas.style.cursor = 'crosshair';
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Restore the image after resize
        if (oldState) {
            // Try to restore from saved state first
            try {
                restoreCanvasState(oldState);
                currentStroke = cloneImageData(oldState);
            } catch (e) {
                // If that fails, redraw from original image
                if (window.originalImages[currentImageLabel]) {
                    const img = new Image();
                    img.onload = () => {
                        // Clear the canvas first
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Get the current scale
                        const scale = imageScaleByLabel[currentImageLabel];
                        const scaledWidth = img.width * scale;
                        const scaledHeight = img.height * scale;
                        
                        // Calculate base position (center of canvas)
                        const centerX = (canvas.width - scaledWidth) / 2;
                        const centerY = (canvas.height - scaledHeight) / 2;
                        
                        // Apply position offset
                        const offsetX = window.imagePositionByLabel[currentImageLabel].x;
                        const offsetY = window.imagePositionByLabel[currentImageLabel].y;
                        
                        // Calculate final position
                        const x = centerX + offsetX;
                        const y = centerY + offsetY;
                        
                        // Draw the original image with scale and position
                        ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                        
                        // Save this as the new state
                        const newState = getCanvasState();
                        imageStates[currentImageLabel] = cloneImageData(newState);
                        currentStroke = cloneImageData(newState);
                    };
                    img.src = window.originalImages[currentImageLabel];
                } else if (!currentStroke) {
                    // Initialize blank state if needed
                    currentStroke = getCanvasState();
                }
            }
        }
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Drawing state
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let points = [];
    let lastVelocity = 0;
    // --- ADD: Track last RAW coordinates ---
    let lastRawX = 0;
    let lastRawY = 0;
    // --- END ADD ---

    // Drawing mode state
    let drawingMode = 'freehand'; // Options: 'freehand', 'straight'
    let straightLineStart = null; // For straight line mode - start point
    let lastDrawnPoint = null;

    /**
     * Transforms raw canvas coordinates to account for image scaling and positioning
     * @param {number} x - Raw x-coordinate from mouse event
     * @param {number} y - Raw y-coordinate from mouse event
     * @returns {Object} Object with transformed x and y coordinates
     */
    function getTransformedCoords(x, y) {
        // Debug logging
        if (window.debugCoordinates) {
            console.log(`[getTransformedCoords] INPUT: Raw canvas coords (${x.toFixed(1)}, ${y.toFixed(1)})`);
        }
        
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
        const position = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 };
        
        // If we have no image dimensions yet (blank canvas), return raw coordinates
        if (!window.originalImageDimensions[currentImageLabel]) {
            if (window.debugCoordinates) {
                console.log(`[getTransformedCoords] No image dimensions - returning raw coords as relative`);
            }
            return { x, y };
        }
        
        // We do have an image, so need to calculate relative coordinates
        const origDims = window.originalImageDimensions[currentImageLabel];
        const scaledWidth = origDims.width * scale;
        const scaledHeight = origDims.height * scale;
        
        // Base position is canvas center minus half the scaled image size
        const imageBaseX = (canvas.width - scaledWidth) / 2;
        const imageBaseY = (canvas.height - scaledHeight) / 2;
        
        // Final image position includes any panning offset
        const finalImageX = imageBaseX + position.x;
        const finalImageY = imageBaseY + position.y;
        
        // Convert the raw canvas coordinates to coordinates relative to the image
        const relativeX = (x - finalImageX) / scale;
        const relativeY = (y - finalImageY) / scale;
        
        if (window.debugCoordinates) {
            console.log(`[getTransformedCoords] Canvas size: ${canvas.width} × ${canvas.height}`);
            console.log(`[getTransformedCoords] Image scale: ${scale}, position: ${JSON.stringify(position)}`);
            console.log(`[getTransformedCoords] Original dimensions: ${JSON.stringify(origDims)}`);
            console.log(`[getTransformedCoords] Scaled dimensions: ${scaledWidth} × ${scaledHeight}`);
            console.log(`[getTransformedCoords] Image position: base(${imageBaseX.toFixed(1)}, ${imageBaseY.toFixed(1)}) + offset => final(${finalImageX.toFixed(1)}, ${finalImageY.toFixed(1)})`);
            console.log(`[getTransformedCoords] OUTPUT: Relative coords (${relativeX.toFixed(1)}, ${relativeY.toFixed(1)})`);
        }
        
        return { x: relativeX, y: relativeY };
    }

    /**
     * Converts relative image coordinates back to canvas coordinates
     * (Inverse of getTransformedCoords)
     * @param {number} imageX_relative - x-coordinate relative to the image
     * @param {number} imageY_relative - y-coordinate relative to the image
     * @returns {Object} Object with canvas x and y coordinates
     */
    function getCanvasCoords(imageX_relative, imageY_relative) {
        // Debug logging
        if (window.debugCoordinates) {
            console.log(`[getCanvasCoords] INPUT: Relative coords (${imageX_relative.toFixed(1)}, ${imageY_relative.toFixed(1)})`);
        }
        
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
        const position = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 };
        
        // If we have no image dimensions yet (blank canvas), return relative coords as-is
        if (!window.originalImageDimensions[currentImageLabel]) {
            if (window.debugCoordinates) {
                console.log(`[getCanvasCoords] No image dimensions - returning relative coords as canvas coords`);
            }
            return { x: imageX_relative, y: imageY_relative };
        }
        
        // We do have an image, calculate canvas coordinates from relative coords
        const origDims = window.originalImageDimensions[currentImageLabel];
        const scaledWidth = origDims.width * scale;
        const scaledHeight = origDims.height * scale;
        
        // Base position is canvas center minus half the scaled image size
        const imageBaseX = (canvas.width - scaledWidth) / 2;
        const imageBaseY = (canvas.height - scaledHeight) / 2;
        
        // Final image position includes any panning offset
        const finalImageX = imageBaseX + position.x;
        const finalImageY = imageBaseY + position.y;
        
        // Calculate final canvas coordinates from image-relative coordinates
        const canvasX = finalImageX + (imageX_relative * scale);
        const canvasY = finalImageY + (imageY_relative * scale);
        
        if (window.debugCoordinates) {
            console.log(`[getCanvasCoords] Canvas size: ${canvas.width} × ${canvas.height}`);
            console.log(`[getCanvasCoords] Image scale: ${scale}, position: ${JSON.stringify(position)}`);
            console.log(`[getCanvasCoords] Original dimensions: ${JSON.stringify(origDims)}`);
            console.log(`[getCanvasCoords] Scaled dimensions: ${scaledWidth} × ${scaledHeight}`);
            console.log(`[getCanvasCoords] Image position: base(${imageBaseX.toFixed(1)}, ${imageBaseY.toFixed(1)}) + offset => final(${finalImageX.toFixed(1)}, ${finalImageY.toFixed(1)})`);
            console.log(`[getCanvasCoords] OUTPUT: Canvas coords (${canvasX.toFixed(1)}, ${canvasY.toFixed(1)})`);
        }
        
        return { x: canvasX, y: canvasY };
    }

    function draw(e) {
        if (!isDrawing) return;

        if (window.debugCoordinates) {
            console.log("--- Draw Event Start ---");
            console.log("[draw] Transform:", ctx.getTransform());
        }

        // Get precise coordinates relative to the canvas
        const rect = canvas.getBoundingClientRect();
        const rawX = e.clientX - rect.left;
        const rawY = e.clientY - rect.top;
        
        if (window.debugCoordinates) {
            console.log(`[draw] Raw mouse coords: (${rawX.toFixed(1)}, ${rawY.toFixed(1)})`);
        }

        // Get current scale for potential use
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;

        // Test round-trip coordinate conversion accuracy
        if (window.debugCoordinates) {
            const roundTrip = getCanvasCoords(getTransformedCoords(rawX, rawY).x, getTransformedCoords(rawX, rawY).y);
            const roundTripError = Math.sqrt(Math.pow(roundTrip.x - rawX, 2) + Math.pow(roundTrip.y - rawY, 2));
            console.log(`[draw] Round-trip coordinate error: ${roundTripError.toFixed(2)} pixels`);
            console.log("--- Draw Event End ---");
        }
    }

// Define global variables for use by project-manager.js
window.IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
window.currentImageLabel = 'front';
window.vectorStrokesByImage = {};
window.strokeVisibilityByImage = {};
window.strokeLabelVisibility = {};
window.strokeMeasurements = {};
window.imageScaleByLabel = {};
window.imagePositionByLabel = {};
window.lineStrokesByImage = {}; // Make sure it's exposed globally
window.labelsByImage = {};      // Make sure it's exposed globally
window.originalImages = {};
window.isLoadingProject = false; // <-- Re-adding this line

// At the top of the file, near other global variables
window.debugCoordinates = false; // Global flag to control coordinate debugging

document.addEventListener('DOMContentLoaded', () => {
    // Initialize unit selectors
    const unitSelector = document.getElementById('unitSelector');
    unitSelector.addEventListener('change', updateMeasurementDisplay);
    
    // Add debug toggle button to the controls
    const controlsContainer = document.querySelector('.controls-container');
    const debugToggle = document.createElement('button');
    debugToggle.textContent = '🐞 Debug';
    debugToggle.classList.add('debug-toggle');
    debugToggle.addEventListener('click', () => {
        window.debugCoordinates = !window.debugCoordinates;
        debugToggle.classList.toggle('active', window.debugCoordinates);
        console.log(`Coordinate debugging ${window.debugCoordinates ? 'enabled' : 'disabled'}`);
    });
    controlsContainer.appendChild(debugToggle);
    
    // Initialize the measurement inputs
    const inchWhole = document.getElementById('inchWhole');
    const inchFraction = document.getElementById('inchFraction');
    const cmValue = document.getElementById('cmValue');
    
    // Handle unit conversion when changing values
    inchWhole.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    inchFraction.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    cmValue.addEventListener('change', () => {
        const cm = parseFloat(cmValue.value) || 0;
        const inches = cm / 2.54;
        
        // Update inch values
        inchWhole.value = Math.floor(inches);
        
        // Find closest fraction
        const fractionPart = inches - Math.floor(inches);
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        inchFraction.value = closestFraction;
        
        // Show inch inputs, hide cm inputs
        document.getElementById('inchInputs').style.display = 'flex';
        document.getElementById('cmInputs').style.display = 'none';
    });
    
    const canvas = document.getElementById('canvas');
    // Expose canvas globally for project management
    window.canvas = canvas;
    const ctx = canvas.getContext('2d', { willReadFrequently: true }); // Add willReadFrequently hint
    const colorPicker = document.getElementById('colorPicker');
    const brushSize = document.getElementById('brushSize');
    const clearButton = document.getElementById('clear');
    const saveButton = document.getElementById('save');
    const pasteButton = document.getElementById('paste');
    const strokeCounter = document.getElementById('strokeCounter');
    const imageList = document.getElementById('imageList');
    const drawingModeToggle = document.getElementById('drawingModeToggle');
    
    // Draggable sidebars
    const strokeSidebar = document.getElementById('strokeSidebar');
    const imageSidebar = document.getElementById('imageSidebar');
    const strokeSidebarHeader = document.getElementById('strokeSidebarHeader');
    const imageSidebarHeader = document.getElementById('imageSidebarHeader');

    // Undo/Redo functionality
    const MAX_HISTORY = 50;  // Maximum number of states to store
    const IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
    let currentImageIndex = 0;
    let imageStates = {}; // Store states for each image
    
    // Use the global variables instead of creating new ones
    let strokeDataByImage = {}; // Store additional data for each stroke
    let undoStackByImage = {}; // Separate undo stack for each image
    let redoStackByImage = {}; // Separate redo stack for each image
    let pastedImages = [];  // Store all pasted images
    let isDrawingOrPasting = false;  // Flag to prevent saving states while drawing
    let strokeInProgress = false;  // Track if we're in the middle of a stroke
    let currentStroke = null;  // Store the state before current stroke
    let originalImageDimensions = {}; // Store original image dimensions for scaling
    let isShiftPressed = false; // Track if Shift key is pressed for image movement
    let calculatedLabelOffsets = {}; // Store automatically calculated label offsets

    // Initialize states for default images
    IMAGE_LABELS.forEach(label => {
        // Ensure we initialize global arrays properly
        window.lineStrokesByImage[label] = [];
        window.strokeVisibilityByImage[label] = {}; // Initialize stroke visibility
        window.vectorStrokesByImage[label] = {}; // Initialize vector stroke data
        window.labelsByImage[label] = 'A1';  // Start from A1 instead of A0
        
        strokeDataByImage[label] = {}; // Initialize stroke data
        undoStackByImage[label] = [];
        redoStackByImage[label] = [];  // Initialize redo stack
        imageStates[label] = null;
        // Initialize scale to 100% (1.0)
        window.imageScaleByLabel[label] = 1.0;
        originalImageDimensions[label] = { width: 0, height: 0 };
        // Initialize position offset to center (0, 0)
        window.imagePositionByLabel[label] = { x: 0, y: 0 };
        // Initialize with a blank state when the image is first created
        const blankState = ctx.createImageData(canvas.width, canvas.height);
        imageStates[label] = blankState;
        undoStackByImage[label].push({
            state: cloneImageData(blankState),
            type: 'initial',
            label: null
        });
    });

    let currentImageLabel = IMAGE_LABELS[0]; // Start with 'front'

    // Make addImageToSidebar available globally for the project manager
    window.addImageToSidebar = addImageToSidebar;
    function addImageToSidebar(imageUrl, label) {
        // *** ADDED LOG ***
        console.log(`[addImageToSidebar] Called for label: ${label}, imageUrl: ${imageUrl ? imageUrl.substring(0,30) + '...' : 'null'}`);

        const container = document.createElement('div');
        container.className = 'image-container';
        container.dataset.label = label;
        container.dataset.originalImageUrl = imageUrl; // Store the original image URL for later restoration
        
        const labelElement = document.createElement('div');
        labelElement.className = 'image-label';
        labelElement.textContent = label.charAt(0).toUpperCase() + label.slice(1);
        
        const strokesElement = document.createElement('div');
        strokesElement.className = 'image-strokes';
        strokesElement.textContent = 'Strokes: 0';
        
        const scaleElement = document.createElement('div');
        scaleElement.className = 'image-scale';
        scaleElement.textContent = `Scale: ${Math.round(imageScaleByLabel[label] * 100)}%`;
        scaleElement.id = `scale-${label}`;
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.className = 'pasted-image';
        img.alt = `${label} view`;
        
        container.appendChild(img);
        container.appendChild(labelElement);
        container.appendChild(strokesElement);
        container.appendChild(scaleElement);
        
        container.onclick = () => {
            // ... rest of the handler
            
            console.log(`Switching from ${currentImageLabel} to ${label}`);
            
            // Ensure we have undo stacks for both workspaces
            undoStackByImage[currentImageLabel] = undoStackByImage[currentImageLabel] || [];
            undoStackByImage[label] = undoStackByImage[label] || [];
            
            // Ensure we have redo stacks for both workspaces
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[label] = redoStackByImage[label] || [];
            
            // Ensure we have stroke lists for both workspaces
            lineStrokesByImage[currentImageLabel] = lineStrokesByImage[currentImageLabel] || [];
            lineStrokesByImage[label] = lineStrokesByImage[label] || [];
            
            // Ensure we have stroke visibility for both workspaces
            strokeVisibilityByImage[currentImageLabel] = strokeVisibilityByImage[currentImageLabel] || {};
            strokeVisibilityByImage[label] = strokeVisibilityByImage[label] || {};
            
            // Save current state before switching
            saveState(true, false);
            
            // Switch to the new image
            switchToImage(label);
        };
        
        // *** ADDED LOGS ***
        const imageListElement = document.getElementById('imageList');
        if (!imageListElement) {
            console.error('[addImageToSidebar] Cannot find #imageList element!');
            return; // Stop if the target doesn't exist
        }
        console.log(`[addImageToSidebar] About to append container for ${label} to #imageList.`);
        imageListElement.appendChild(container);
        console.log(`[addImageToSidebar] Successfully appended container for ${label}. #imageList children: ${imageListElement.childElementCount}`);
    }
    

    // Store the original images for each view
    window.originalImages = window.originalImages || {};
    
    // --- MODIFIED Function Signature and Logic --- 
    function pasteImageFromUrl(url, label) {
        // Wrap in a Promise
        return new Promise((resolve, reject) => {
            console.log(`[pasteImageFromUrl] Pasting image for ${label}: ${url.substring(0, 30)}...`);
        
        const img = new Image();
        img.onload = () => {
            // Store the original image for this view
                window.originalImages[label] = url;
                
                // Ensure the object exists before setting properties
                if (!window.originalImageDimensions) {
                    window.originalImageDimensions = {};
                }
            
            // Store original dimensions for scaling
                window.originalImageDimensions[label] = {
                width: img.width,
                height: img.height
            };
                
                // Log dimensions for debugging
                console.log(`[pasteImageFromUrl] Stored dimensions for ${label}: ${img.width}x${img.height}`);
            
            // Clear the canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply current scale factor
                const scale = imageScaleByLabel[label] || 1.0; // Use passed-in label
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of the canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
                const position = imagePositionByLabel[label] || { x: 0, y: 0 }; // Use passed-in label
                const offsetX = position.x;
                const offsetY = position.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;
            
            // Draw the image with scaling and positioning
                console.log(`[pasteImageFromUrl] Drawing image for ${label} at Canvas(${x.toFixed(1)}, ${y.toFixed(1)}) Scale: ${scale * 100}%`);
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Update the scale display in the sidebar
                const scaleElement = document.getElementById(`scale-${label}`);
            if (scaleElement) {
                scaleElement.textContent = `Scale: ${Math.round(scale * 100)}%`;
            }
            
            // Save this as the base state for this image
            const newState = getCanvasState();
                imageStates[label] = cloneImageData(newState); // Use passed-in label
                console.log(`[pasteImageFromUrl] State saved into imageStates[${label}]`);
                
                // If this is the currently active label, update currentStroke
                if (label === currentImageLabel) {
            currentStroke = cloneImageData(newState);
                }
            
                // Initialize the undo stack if needed
                if (!undoStackByImage[label] || undoStackByImage[label].length === 0) {
                    undoStackByImage[label] = [{
                state: cloneImageData(newState),
                type: 'initial',
                label: null
            }];
                    console.log(`[pasteImageFromUrl] Initialized undo stack for ${label}`);
                }
            
                // Update the scale buttons to show active state if this is the current view
                if (label === currentImageLabel) {
            updateScaleButtonsActiveState();
                }
                
                console.log(`[pasteImageFromUrl] Image loaded and state saved for ${label}`);
                resolve(); // Resolve the promise
            };
            
            img.onerror = (err) => {
                console.error(`[pasteImageFromUrl] Error loading image for ${label}:`, err);
                reject(err); // Reject the promise on error
            };
            
        img.src = url;
        });
    }
    // --- END MODIFIED Function ---

    function getNextLabel(imageLabel) {
        const currentLabel = labelsByImage[imageLabel];
        const letter = currentLabel[0];
        const number = parseInt(currentLabel.slice(1)) + 1;
        if (number > 9) {
            return String.fromCharCode(letter.charCodeAt(0) + 1) + '0';
        }
        return letter + number;
    }

    // Make updateStrokeCounter available globally
    window.updateStrokeCounter = updateStrokeCounter;
    function updateStrokeCounter() {
        const strokeCount = lineStrokesByImage[currentImageLabel]?.length || 0;
        strokeCounter.textContent = `Lines: ${strokeCount}`;
        
        // Update visibility controls
        updateStrokeVisibilityControls();
    }
    
    function updateSidebarStrokeCounts() {
        // Update stroke counts in the sidebar
        const imageContainers = document.querySelectorAll('.image-container');
        imageContainers.forEach(container => {
            const label = container.dataset.label;
            if (label) {
                const strokesElement = container.querySelector('.image-strokes');
                if (strokesElement) {
                    const strokes = lineStrokesByImage[label] || [];
                    strokesElement.textContent = `Strokes: ${strokes.length}`;
                }
            }
        });
        
        // Also update visibility controls when sidebar is updated
        updateStrokeVisibilityControls();
    }

    function getCanvasState() {
        return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    function restoreCanvasState(state) {
        if (!state) return;
        ctx.putImageData(state, 0, 0);
    }
    
    // Measurement data for strokes
    let strokeMeasurements = {};
    
    // Initialize measurement data store
    IMAGE_LABELS.forEach(label => {
        strokeMeasurements[label] = {};
    });
    
    // Function to get formatted measurement string
    function getMeasurementString(strokeLabel) {
        const measurement = strokeMeasurements[currentImageLabel]?.[strokeLabel];
        if (!measurement) return '';
        
        const unit = document.getElementById('unitSelector').value;
        
        if (unit === 'inch') {
            const whole = measurement.inchWhole || 0;
            const fraction = measurement.inchFraction || 0;
            
            // Format as 1 1/4" etc.
            let fractionStr = '';
            if (fraction > 0) {
                const fractionMap = {
                    0.125: '1/8',
                    0.25: '1/4',
                    0.375: '3/8',
                    0.5: '1/2',
                    0.625: '5/8',
                    0.75: '3/4',
                    0.875: '7/8'
                };
                fractionStr = ' ' + fractionMap[fraction];
            }
            
            return `${whole}${fractionStr}"`;
        } else {
            // CM with one decimal
            return `${measurement.cm.toFixed(1)} cm`;
        }
    }
    
    // Function to convert between units
    function convertUnits(from, value) {
        if (from === 'inch') {
            // Convert inch to cm
            return value * 2.54;
        } else {
            // Convert cm to inch
            return value / 2.54;
        }
    }
    
    // Function to update all measurements when unit changes
    function updateMeasurementDisplay() {
        const unit = document.getElementById('unitSelector').value;
        const inchWhole = document.getElementById('inchWhole');
        const inchFraction = document.getElementById('inchFraction');
        const cmValue = document.getElementById('cmValue');
        
        // Convert values when switching between units
        if (unit === 'inch') {
            // Converting from cm to inches
            const cm = parseFloat(cmValue.value) || 0;
            const inches = cm / 2.54;
            
            // Update inch values
            inchWhole.value = Math.floor(inches);
            
            // Find closest fraction
            const fractionPart = inches - Math.floor(inches);
            const fractions = [
                {value: '0', text: '0'},
                {value: '0.125', text: '1/8'},
                {value: '0.25', text: '1/4'},
                {value: '0.375', text: '3/8'},
                {value: '0.5', text: '1/2'},
                {value: '0.625', text: '5/8'},
                {value: '0.75', text: '3/4'},
                {value: '0.875', text: '7/8'}
            ];
            
            fractions.forEach(f => {
                const option = document.createElement('option');
                option.value = f.value;
                option.textContent = f.text;
                if (parseFloat(f.value) === fractionPart) {
                    option.selected = true;
                }
                inchFraction.appendChild(option);
            });
            
            // Show inch inputs, hide cm inputs
            document.getElementById('inchInputs').style.display = 'flex';
            document.getElementById('cmInputs').style.display = 'none';
        } else {
            // Converting from inches to cm
            const whole = parseInt(inchWhole.value) || 0;
            const fraction = parseFloat(inchFraction.value) || 0;
            const totalInches = whole + fraction;
            
            // Update cm value with one decimal point
            cmValue.value = (totalInches * 2.54).toFixed(1);
            
            // Show cm inputs, hide inch inputs
            document.getElementById('inchInputs').style.display = 'none';
            document.getElementById('cmInputs').style.display = 'flex';
        }
        
        // Update the stroke visibility display to show new units
        updateStrokeVisibilityControls();
        
        // Redraw the canvas with updated measurement format in labels
        redrawCanvasWithVisibility();
    }

    // Function to update stroke visibility controls
    // Make updateStrokeVisibilityControls available globally
    window.updateStrokeVisibilityControls = updateStrokeVisibilityControls;
    function updateStrokeVisibilityControls() {
        const controlsContainer = document.getElementById('strokeVisibilityControls');
        controlsContainer.innerHTML = ''; // Clear existing controls
        
        // Add a separator at the top
        const topSeparator = document.createElement('hr');
        controlsContainer.appendChild(topSeparator);
        
        // Display current unit
        const unitDisplay = document.createElement('div');
        unitDisplay.className = 'current-unit-display';
        unitDisplay.textContent = `Current Unit: ${document.getElementById('unitSelector').value === 'inch' ? 'Inches' : 'Centimeters'}`;
        controlsContainer.appendChild(unitDisplay);
        
        // Add another separator
        const separator = document.createElement('hr');
        controlsContainer.appendChild(separator);
        
        // Create strokes list
        const strokesList = document.createElement('div');
        strokesList.id = 'strokesList';
        controlsContainer.appendChild(strokesList);
        
        // Get strokes for current image
        const strokes = lineStrokesByImage[currentImageLabel] || [];
        
        if (strokes.length === 0) {
            strokesList.innerHTML = '<p>No strokes to display</p>';
            return;
        }
        
        // Current unit
        const unit = document.getElementById('unitSelector').value;
        
        // Create visibility toggle for each stroke
        strokes.forEach(strokeLabel => {
            // Initialize visibility if not set
            if (strokeVisibilityByImage[currentImageLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel] = {};
            }
            if (strokeVisibilityByImage[currentImageLabel][strokeLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            }
            
            // Initialize label visibility if not set
            if (strokeLabelVisibility[currentImageLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel] = {};
            }
            if (strokeLabelVisibility[currentImageLabel][strokeLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel][strokeLabel] = true; // Labels visible by default
            }
            
            // Initialize measurement if not set
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            if (strokeMeasurements[currentImageLabel][strokeLabel] === undefined) {
                strokeMeasurements[currentImageLabel][strokeLabel] = {
                    inchWhole: 0,
                    inchFraction: 0,
                    cm: 0.0
                };
            }
            
            const isVisible = strokeVisibilityByImage[currentImageLabel][strokeLabel];
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            const measurement = getMeasurementString(strokeLabel);
            const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
            
            const item = document.createElement('div');
            item.className = 'stroke-visibility-item';
            item.dataset.stroke = strokeLabel;
            item.dataset.selected = isSelected ? 'true' : 'false';
            
            // Make all parts of the item selectable (except checkbox and buttons)
            item.addEventListener('click', (e) => {
                // Don't trigger selection if clicking a button or checkbox
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
                    return;
                }
                
                // Toggle selection (if already selected, deselect it)
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                
                // Update the measurement input with the selected stroke's measurement
                    if (typeof updateMeasurementInputWithStroke === 'function') {
                    updateMeasurementInputWithStroke(strokeLabel);
                }
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `visibility-${strokeLabel}`;
            checkbox.checked = isVisible;
            checkbox.addEventListener('change', () => toggleStrokeVisibility(strokeLabel, checkbox.checked));
            
            const labelContainer = document.createElement('div');
            labelContainer.className = 'stroke-label-container';
            
            // Find the stroke color from the undo stack or vector data
            let strokeColor = '#000';
            let strokeType = 'freehand'; // Default type
            
            if (vectorStrokesByImage[currentImageLabel] && 
                vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                const vectorData = vectorStrokesByImage[currentImageLabel][strokeLabel];
                strokeColor = vectorData.color || '#000';
                strokeType = vectorData.type || 'freehand';
            } else {
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel && action.color) {
                        strokeColor = action.color;
                        // Try to determine stroke type from action
                        if (action.type === 'line') {
                            strokeType = 'straight';
                        }
                        break;
                    }
                }
            }
            
            // Create the stroke name element with color matching the stroke
            const strokeName = document.createElement('span');
            strokeName.className = 'stroke-name';
            strokeName.textContent = strokeLabel;
            strokeName.style.borderColor = strokeColor;
            strokeName.style.color = strokeColor;
            
            // Add a small icon to indicate stroke type (optional)
            if (strokeType === 'straight') {
                strokeName.title = 'Straight Line';
            } else {
                strokeName.title = 'Freehand Stroke';
            }
            
            // Make stroke name label clickable for selection as well
            strokeName.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent double handling with the item click
                
                // Toggle selection 
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            // Create measurement text
            const measureText = document.createElement('span');
            measureText.className = 'stroke-measurement';
            measureText.textContent = measurement ? `= ${measurement}` : '';
            
            // Create edit button
            const editBtn = document.createElement('button');
            editBtn.className = 'stroke-edit-btn';
            editBtn.innerHTML = '✏️';
            editBtn.title = 'Edit Stroke';
            editBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                showEditDialog(strokeLabel);
            };
            
            // Create label toggle button
            const labelToggleBtn = document.createElement('button');
            labelToggleBtn.className = 'stroke-label-toggle';
            labelToggleBtn.classList.toggle('active', isLabelVisible);
            labelToggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            labelToggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            labelToggleBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                toggleLabelVisibility(strokeLabel);
            };
            
            // Add elements to container
            labelContainer.appendChild(strokeName);
            labelContainer.appendChild(measureText);
            labelContainer.appendChild(labelToggleBtn);
            labelContainer.appendChild(editBtn);
            
            // Build the complete item
            item.appendChild(checkbox);
            item.appendChild(labelContainer);
            
            // Add to stroke list
            strokesList.appendChild(item);
        });
    }
    
    // Function to toggle label visibility on canvas
    function toggleLabelVisibility(strokeLabel) {
        // Only toggle the label visibility, not the stroke visibility
        strokeLabelVisibility[currentImageLabel][strokeLabel] = !strokeLabelVisibility[currentImageLabel][strokeLabel];
        
        // Update the UI button appearance
        const toggleBtn = document.querySelector(`.stroke-visibility-item[data-stroke="${strokeLabel}"] .stroke-label-toggle`);
        if (toggleBtn) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            toggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            toggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            toggleBtn.classList.toggle('active', isLabelVisible);
        }
        
        // Redraw the canvas with updated label visibility
        // This should not affect the stroke visibility
        redrawCanvasWithVisibility();
    }
    
    // Function to update measurement input with selected stroke's value
    // Function to display a measurement edit dialog
    function showMeasurementDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurement
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Measurement for ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values from inputs
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Determine which unit was changed last and use that value
            const currentUnit = document.getElementById('unitSelector').value;
            let finalCmValue, finalInchWhole, finalInchFraction;
            
            if (currentUnit === 'inch') {
                finalInchWhole = wholeValue;
                finalInchFraction = fractionValue;
                finalCmValue = convertUnits('inch', wholeValue + fractionValue);
            } else {
                finalCmValue = cmValue;
                // Calculate inch equivalent
                const inches = convertUnits('cm', cmValue);
                finalInchWhole = Math.floor(inches);
                finalInchFraction = findClosestFraction(inches - finalInchWhole);
            }
            
            // Update the measurement
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            
            strokeMeasurements[currentImageLabel][strokeLabel] = {
                inchWhole: finalInchWhole,
                inchFraction: finalInchFraction,
                cm: finalCmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update the UI
            updateStrokeVisibilityControls();
            
            // Redraw with the new measurement
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Helper function to find the closest fraction
    function findClosestFraction(fractionPart) {
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        return closestFraction;
    }
    
    // Function to show edit dialog for a stroke
    function showEditDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurements
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Stroke ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Create name edit field
        const nameContainer = document.createElement('div');
        nameContainer.className = 'name-container';
        
        const nameLabel = document.createElement('div');
        nameLabel.textContent = 'Label:';
        nameContainer.appendChild(nameLabel);
        
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = strokeLabel;
        nameInput.placeholder = 'Label';
        nameContainer.appendChild(nameInput);
        
        dialog.appendChild(nameContainer);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Sync between inch and cm inputs
        wholeInput.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        fractionSelect.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        cmInput.addEventListener('change', () => {
            const cmValue = parseFloat(cmInput.value) || 0;
            const inches = convertUnits('cm', cmValue);
            const wholeValue = Math.floor(inches);
            const fractionValue = findClosestFraction(inches - wholeValue);
            
            wholeInput.value = wholeValue;
            fractionSelect.value = fractionValue.toString();
        });
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values
            const newName = nameInput.value.trim();
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Update name if changed
            let finalName = strokeLabel;
            if (newName !== strokeLabel && newName !== '') {
                // The unique name generation is handled inside renameStroke
                finalName = renameStroke(strokeLabel, newName);
                
                // Show feedback if name was modified to make it unique
                if (finalName !== newName) {
                    console.log(`Stroke name automatically adjusted to ${finalName} to avoid duplicates`);
                    
                    // Create and show a temporary notification
                    const notification = document.createElement('div');
                    notification.style.position = 'fixed';
                    notification.style.bottom = '20px';
                    notification.style.left = '50%';
                    notification.style.transform = 'translateX(-50%)';
                    notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                    notification.style.color = 'white';
                    notification.style.padding = '10px 20px';
                    notification.style.borderRadius = '4px';
                    notification.style.zIndex = '10000';
                    notification.textContent = `Renamed to ${finalName} to avoid duplicates`;
                    
                    document.body.appendChild(notification);
                    
                    // Remove after 3 seconds
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 3000);
                }
            }
            
            // Always save both units
            strokeMeasurements[currentImageLabel][finalName] = {
                inchWhole: wholeValue,
                inchFraction: fractionValue,
                cm: cmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update UI
            updateStrokeVisibilityControls();
            
            // Redraw to show updated measurements
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Function to generate a unique stroke name
    function generateUniqueStrokeName(baseName) {
        // If the name is empty or undefined, use a default name
        if (!baseName || baseName.trim() === '') {
            baseName = 'A1';
        }
        
        // If the base name doesn't already exist, we can use it as is
        if (!lineStrokesByImage[currentImageLabel] || 
            !lineStrokesByImage[currentImageLabel].includes(baseName)) {
            return baseName;
        }
        
        // Name already exists, so we need to add a number
        // Extract the base part and any existing numbering
        const match = baseName.match(/^(.+?)(?:\((\d+)\))?$/);
        if (!match) {
            // If the regex didn't match for some reason, append (1) to the name
            return `${baseName}(1)`;
        }
        
        const base = match[1];
        let counter = 1;
        
        // If there was already a number, start from the next one
        if (match[2]) {
            counter = parseInt(match[2]) + 1;
        }
        
        // Keep incrementing until we find a unique name
        let newName;
        do {
            newName = `${base}(${counter})`;
            counter++;
        } while (lineStrokesByImage[currentImageLabel].includes(newName));
        
        return newName;
    }
    
    // Function to rename a stroke
    function renameStroke(oldName, newName) {
        if (oldName === newName) return;
        
        // Generate a unique name if needed - this ensures the new name won't conflict
        // with any existing stroke names, including itself
        const uniqueNewName = generateUniqueStrokeName(newName);
        
        // Find the stroke color from the undo stack or vector data to maintain color after rename
        let strokeColor = '#000';
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            strokeColor = vectorStrokesByImage[currentImageLabel][oldName].color || '#000';
        } else {
            for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                const action = undoStackByImage[currentImageLabel][i];
                if (action.label === oldName && action.color) {
                    strokeColor = action.color;
                    // Try to determine stroke type from action
                    if (action.type === 'line') {
                        strokeType = 'straight';
                    }
                    break;
                }
            }
        }
        
        // Update all relevant data structures
        if (lineStrokesByImage[currentImageLabel]) {
            const index = lineStrokesByImage[currentImageLabel].indexOf(oldName);
            if (index !== -1) {
                lineStrokesByImage[currentImageLabel][index] = uniqueNewName;
            }
        }
        
        // Update visibility
        if (strokeVisibilityByImage[currentImageLabel] && 
            strokeVisibilityByImage[currentImageLabel][oldName] !== undefined) {
            const isVisible = strokeVisibilityByImage[currentImageLabel][oldName];
            strokeVisibilityByImage[currentImageLabel][uniqueNewName] = isVisible;
            delete strokeVisibilityByImage[currentImageLabel][oldName];
        }
        
        // Update label visibility
        if (strokeLabelVisibility[currentImageLabel] && 
            strokeLabelVisibility[currentImageLabel][oldName] !== undefined) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][oldName];
            strokeLabelVisibility[currentImageLabel][uniqueNewName] = isLabelVisible;
            delete strokeLabelVisibility[currentImageLabel][oldName];
        }
        
        // Update stroke data
        if (strokeDataByImage[currentImageLabel] && 
            strokeDataByImage[currentImageLabel][oldName]) {
            strokeDataByImage[currentImageLabel][uniqueNewName] = 
                strokeDataByImage[currentImageLabel][oldName];
            delete strokeDataByImage[currentImageLabel][oldName];
        }
        
        // Update vector data
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            vectorStrokesByImage[currentImageLabel][uniqueNewName] = 
                vectorStrokesByImage[currentImageLabel][oldName];
            delete vectorStrokesByImage[currentImageLabel][oldName];
        }
        
        // Update measurements
        if (strokeMeasurements[currentImageLabel] && 
            strokeMeasurements[currentImageLabel][oldName]) {
            strokeMeasurements[currentImageLabel][uniqueNewName] = 
                strokeMeasurements[currentImageLabel][oldName];
            delete strokeMeasurements[currentImageLabel][oldName];
        }
        
        // Update next label if needed
        if (labelsByImage[currentImageLabel] === oldName) {
            labelsByImage[currentImageLabel] = uniqueNewName;
        }
        
        // Update any references in the undo/redo stacks
        if (undoStackByImage[currentImageLabel]) {
            undoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        if (redoStackByImage[currentImageLabel]) {
            redoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        // Return the actual name used for the stroke (either the original or the uniquified version)
        return uniqueNewName;
    }
    
    // Function to toggle stroke visibility
    function toggleStrokeVisibility(strokeLabel, isVisible) {
        console.log(`Toggling visibility of stroke ${strokeLabel} to ${isVisible}`);
        
        // Update visibility state
        strokeVisibilityByImage[currentImageLabel][strokeLabel] = isVisible;
        
        // Make sure the stroke data is still available and not accidentally cleared
        if (isVisible) {
            // Initialize vectorStrokesByImage for this image if it doesn't exist
            if (!vectorStrokesByImage[currentImageLabel]) {
                vectorStrokesByImage[currentImageLabel] = {};
            }
            
            // If we're making a stroke visible, ensure we still have vector data
            if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                console.log(`Vector data missing for ${strokeLabel}, attempting recovery`);
                
                // Try to recover vector data from the undo stack
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel) {
                        if (action.vectorData) {
                            vectorStrokesByImage[currentImageLabel][strokeLabel] = action.vectorData;
                            console.log(`Recovered vector data for ${strokeLabel}`);
                            break;
                        }
                    }
                }
                
                // If we still couldn't recover the vector data, create a basic one
                // This is especially important for straight lines
                if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                    console.log(`Creating default vector data for ${strokeLabel}`);
                    
                    // Look for color and properties in the undo stack
                    let strokeColor = "#000000";
                    let strokeWidth = 5;
                    let isLine = false;
                    
                    for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                        const action = undoStackByImage[currentImageLabel][i];
                        if (action.label === strokeLabel) {
                            if (action.color) strokeColor = action.color;
                            if (action.width) strokeWidth = action.width;
                            if (action.type === 'line' || action.type === 'straight') isLine = true;
                            break;
                        }
                    }
                    
                    // Create a simple vector representation (placeholder)
                    vectorStrokesByImage[currentImageLabel][strokeLabel] = {
                        points: isLine ? [{x: 0, y: 0}, {x: 1, y: 1}] : [{x: 0, y: 0}],
                        color: strokeColor,
                        width: strokeWidth,
                        type: isLine ? 'straight' : 'freehand'
                    };
                }
            }
        };

        // *** Add redraw call here ***
        redrawCanvasWithVisibility();
    }
    
    // Store for currently selected stroke in each image
    let selectedStrokeByImage = {};
    
    // Initialize stroke label visibility for each image (default to visible)
    IMAGE_LABELS.forEach(label => {
        strokeLabelVisibility[label] = {};
        selectedStrokeByImage[label] = null; // Initialize with no selection
    });
    
    // Store for label custom positions (user-dragged positions)
    let customLabelPositions = {};
    
    // Flag to track if we're dragging a label
    let isDraggingLabel = false;
    let draggedLabelStroke = null;
    let dragStartX = 0;
    let dragStartY = 0;
    
    // Initialize custom label positions for each image
    IMAGE_LABELS.forEach(label => {
        customLabelPositions[label] = {};
    });
    
    // Cache for loaded images to prevent flickering
    const imageCache = {};
    
    // Store for label positions to prevent overlapping
    let currentLabelPositions = [];
    
    // Store for stroke paths to avoid overlapping with lines
    let currentStrokePaths = [];
    
    // Function to redraw canvas respecting stroke visibility
    // Make redrawCanvasWithVisibility available globally
    window.redrawCanvasWithVisibility = redrawCanvasWithVisibility;
    function redrawCanvasWithVisibility() {
        console.log(`--- redrawCanvasWithVisibility called for: ${currentImageLabel} ---`);
        
        // *** Save context and reset transform before drawing anything ***
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset to identity matrix
        console.log("Redraw Start Transform:", ctx.getTransform());
        
        // ADDED: Ensure originalImageDimensions exists and has an entry for this label
        if (!window.originalImageDimensions) {
            window.originalImageDimensions = {};
        }
        
        // ADDED: If we don't have dimensions for this label but we're trying to draw strokes,
        // create default dimensions based on the canvas size to prevent coordinates from being lost
        if (!window.originalImageDimensions[currentImageLabel] && 
            window.vectorStrokesByImage[currentImageLabel] && 
            Object.keys(window.vectorStrokesByImage[currentImageLabel]).length > 0) {
            
            console.log(`Creating default dimensions for ${currentImageLabel} to preserve strokes`);
            window.originalImageDimensions[currentImageLabel] = {
                width: canvas.width,
                height: canvas.height
            };
            console.log(`Set dimensions to match canvas: ${canvas.width}x${canvas.height}`);
        }
        
        // Reset label positions and stroke paths for this redraw
        currentLabelPositions = [];
        currentStrokePaths = [];
        
        // Create a copy of custom label positions for tracking which ones were actually used
        const usedCustomPositions = {};
        
        // We need to rebuild the canvas from scratch using individual stroke data
        const strokes = window.lineStrokesByImage[currentImageLabel] || [];
        
        // Start with a blank canvas or the original image if available
        if (window.originalImages && window.originalImages[currentImageLabel]) {
            // Check if we already have this image in the cache
            const imageUrl = window.originalImages[currentImageLabel];
            
            if (imageCache[imageUrl]) {
                // Use cached image immediately
                drawImageAndStrokes(imageCache[imageUrl]);
            } else {
                // Load the image and cache it
                const img = new Image();
                img.onload = () => {
                    // Add to cache
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                };
                img.src = imageUrl;
                
                // If the image is already cached in the browser, it might be immediately available
                if (img.complete) {
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                } else {
                    // If the image isn't immediately available,
                    // still draw the strokes on a blank canvas so they don't disappear
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the current scale and position
                    const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
                    
                    // For blank canvas mode, we apply the position directly when drawing points
                    // We pass 0,0 for position here since we'll apply it inside applyVisibleStrokes
                    applyVisibleStrokes(scale, 0, 0);
                }
            }
        } else {
            // Otherwise start with a blank canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white'; // Add white background fill
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Get the current scale for the blank canvas state
            const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
            
            // Apply visible strokes - for blank canvas mode, we don't need to apply position offset here
            // since we'll apply it to each point when drawing
            applyVisibleStrokes(scale, 0, 0);
        }
        
        function drawImageAndStrokes(img) {
            // Clear only once within the reset transform state
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply scale
            const scale = window.imageScaleByLabel[currentImageLabel];
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
            const positionOffset = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 }; // Ensure offset exists
            const offsetX = positionOffset.x;
            const offsetY = positionOffset.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;

            // *** ADDED LOGGING ***
            // console.log(`drawImageAndStrokes Calculation:
            //   canvas.width=${canvas.width}, img.width=${img.width}, scaledWidth=${scaledWidth}
            //   scale=${scale}, centerX=${centerX}, offsetX=${offsetX}, final imageX (passed to applyVisibleStrokes)=${x}`);
            // *** END LOGGING ***
            
            // Draw the image with scaling and positioning
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Then apply visible strokes
            applyVisibleStrokes(scale, x, y);
        }
        
        function applyVisibleStrokes(scale, imageX, imageY) {
            console.log("ApplyStrokes Start Transform:", ctx.getTransform()); // Log transform at start
// Define global variables for use by project-manager.js
window.IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
window.currentImageLabel = 'front';
window.vectorStrokesByImage = {};
window.strokeVisibilityByImage = {};
window.strokeLabelVisibility = {};
window.strokeMeasurements = {};
window.imageScaleByLabel = {};
window.imagePositionByLabel = {};
window.lineStrokesByImage = {}; // Make sure it's exposed globally
window.labelsByImage = {};      // Make sure it's exposed globally
window.originalImages = {};
window.isLoadingProject = false; // <-- Re-adding this line

// At the top of the file, near other global variables
window.debugCoordinates = false; // Global flag to control coordinate debugging

document.addEventListener('DOMContentLoaded', () => {
    // Initialize unit selectors
    const unitSelector = document.getElementById('unitSelector');
    unitSelector.addEventListener('change', updateMeasurementDisplay);
    
    // Add debug toggle button to the controls
    const controlsContainer = document.querySelector('.controls-container');
    const debugToggle = document.createElement('button');
    debugToggle.textContent = '🐞 Debug';
    debugToggle.classList.add('debug-toggle');
    debugToggle.addEventListener('click', () => {
        window.debugCoordinates = !window.debugCoordinates;
        debugToggle.classList.toggle('active', window.debugCoordinates);
        console.log(`Coordinate debugging ${window.debugCoordinates ? 'enabled' : 'disabled'}`);
    });
    controlsContainer.appendChild(debugToggle);
    
    // Initialize the measurement inputs
    const inchWhole = document.getElementById('inchWhole');
    const inchFraction = document.getElementById('inchFraction');
    const cmValue = document.getElementById('cmValue');
    
    // Handle unit conversion when changing values
    inchWhole.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    inchFraction.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    cmValue.addEventListener('change', () => {
        const cm = parseFloat(cmValue.value) || 0;
        const inches = cm / 2.54;
        
        // Update inch values
        inchWhole.value = Math.floor(inches);
        
        // Find closest fraction
        const fractionPart = inches - Math.floor(inches);
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        inchFraction.value = closestFraction;
        
        // Show inch inputs, hide cm inputs
        document.getElementById('inchInputs').style.display = 'flex';
        document.getElementById('cmInputs').style.display = 'none';
    });
    
    const canvas = document.getElementById('canvas');
    // Expose canvas globally for project management
    window.canvas = canvas;
    const ctx = canvas.getContext('2d', { willReadFrequently: true }); // Add willReadFrequently hint
    const colorPicker = document.getElementById('colorPicker');
    const brushSize = document.getElementById('brushSize');
    const clearButton = document.getElementById('clear');
    const saveButton = document.getElementById('save');
    const pasteButton = document.getElementById('paste');
    const strokeCounter = document.getElementById('strokeCounter');
    const imageList = document.getElementById('imageList');
    const drawingModeToggle = document.getElementById('drawingModeToggle');
    
    // Draggable sidebars
    const strokeSidebar = document.getElementById('strokeSidebar');
    const imageSidebar = document.getElementById('imageSidebar');
    const strokeSidebarHeader = document.getElementById('strokeSidebarHeader');
    const imageSidebarHeader = document.getElementById('imageSidebarHeader');

    // Undo/Redo functionality
    const MAX_HISTORY = 50;  // Maximum number of states to store
    const IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
    let currentImageIndex = 0;
    let imageStates = {}; // Store states for each image
    
    // Use the global variables instead of creating new ones
    let strokeDataByImage = {}; // Store additional data for each stroke
    let undoStackByImage = {}; // Separate undo stack for each image
    let redoStackByImage = {}; // Separate redo stack for each image
    let pastedImages = [];  // Store all pasted images
    let isDrawingOrPasting = false;  // Flag to prevent saving states while drawing
    let strokeInProgress = false;  // Track if we're in the middle of a stroke
    let currentStroke = null;  // Store the state before current stroke
    let originalImageDimensions = {}; // Store original image dimensions for scaling
    let isShiftPressed = false; // Track if Shift key is pressed for image movement
    let calculatedLabelOffsets = {}; // Store automatically calculated label offsets

    // Initialize states for default images
    IMAGE_LABELS.forEach(label => {
        // Ensure we initialize global arrays properly
        window.lineStrokesByImage[label] = [];
        window.strokeVisibilityByImage[label] = {}; // Initialize stroke visibility
        window.vectorStrokesByImage[label] = {}; // Initialize vector stroke data
        window.labelsByImage[label] = 'A1';  // Start from A1 instead of A0
        
        strokeDataByImage[label] = {}; // Initialize stroke data
        undoStackByImage[label] = [];
        redoStackByImage[label] = [];  // Initialize redo stack
        imageStates[label] = null;
        // Initialize scale to 100% (1.0)
        window.imageScaleByLabel[label] = 1.0;
        originalImageDimensions[label] = { width: 0, height: 0 };
        // Initialize position offset to center (0, 0)
        window.imagePositionByLabel[label] = { x: 0, y: 0 };
        // Initialize with a blank state when the image is first created
        const blankState = ctx.createImageData(canvas.width, canvas.height);
        imageStates[label] = blankState;
        undoStackByImage[label].push({
            state: cloneImageData(blankState),
            type: 'initial',
            label: null
        });
    });

    let currentImageLabel = IMAGE_LABELS[0]; // Start with 'front'

    // Make addImageToSidebar available globally for the project manager
    window.addImageToSidebar = addImageToSidebar;
    function addImageToSidebar(imageUrl, label) {
        // *** ADDED LOG ***
        console.log(`[addImageToSidebar] Called for label: ${label}, imageUrl: ${imageUrl ? imageUrl.substring(0,30) + '...' : 'null'}`);

        const container = document.createElement('div');
        container.className = 'image-container';
        container.dataset.label = label;
        container.dataset.originalImageUrl = imageUrl; // Store the original image URL for later restoration
        
        const labelElement = document.createElement('div');
        labelElement.className = 'image-label';
        labelElement.textContent = label.charAt(0).toUpperCase() + label.slice(1);
        
        const strokesElement = document.createElement('div');
        strokesElement.className = 'image-strokes';
        strokesElement.textContent = 'Strokes: 0';
        
        const scaleElement = document.createElement('div');
        scaleElement.className = 'image-scale';
        scaleElement.textContent = `Scale: ${Math.round(imageScaleByLabel[label] * 100)}%`;
        scaleElement.id = `scale-${label}`;
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.className = 'pasted-image';
        img.alt = `${label} view`;
        
        container.appendChild(img);
        container.appendChild(labelElement);
        container.appendChild(strokesElement);
        container.appendChild(scaleElement);
        
        container.onclick = () => {
            // ... rest of the handler
            
            console.log(`Switching from ${currentImageLabel} to ${label}`);
            
            // Ensure we have undo stacks for both workspaces
            undoStackByImage[currentImageLabel] = undoStackByImage[currentImageLabel] || [];
            undoStackByImage[label] = undoStackByImage[label] || [];
            
            // Ensure we have redo stacks for both workspaces
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[label] = redoStackByImage[label] || [];
            
            // Ensure we have stroke lists for both workspaces
            lineStrokesByImage[currentImageLabel] = lineStrokesByImage[currentImageLabel] || [];
            lineStrokesByImage[label] = lineStrokesByImage[label] || [];
            
            // Ensure we have stroke visibility for both workspaces
            strokeVisibilityByImage[currentImageLabel] = strokeVisibilityByImage[currentImageLabel] || {};
            strokeVisibilityByImage[label] = strokeVisibilityByImage[label] || {};
            
            // Save current state before switching
            saveState(true, false);
            
            // Switch to the new image
            switchToImage(label);
        };
        
        // *** ADDED LOGS ***
        const imageListElement = document.getElementById('imageList');
        if (!imageListElement) {
            console.error('[addImageToSidebar] Cannot find #imageList element!');
            return; // Stop if the target doesn't exist
        }
        console.log(`[addImageToSidebar] About to append container for ${label} to #imageList.`);
        imageListElement.appendChild(container);
        console.log(`[addImageToSidebar] Successfully appended container for ${label}. #imageList children: ${imageListElement.childElementCount}`);
    }
    

    // Store the original images for each view
    window.originalImages = window.originalImages || {};
    
    // --- MODIFIED Function Signature and Logic --- 
    function pasteImageFromUrl(url, label) {
        // Wrap in a Promise
        return new Promise((resolve, reject) => {
            console.log(`[pasteImageFromUrl] Pasting image for ${label}: ${url.substring(0, 30)}...`);
        
        const img = new Image();
        img.onload = () => {
            // Store the original image for this view
                window.originalImages[label] = url;
                
                // Ensure the object exists before setting properties
                if (!window.originalImageDimensions) {
                    window.originalImageDimensions = {};
                }
            
            // Store original dimensions for scaling
                window.originalImageDimensions[label] = {
                width: img.width,
                height: img.height
            };
                
                // Log dimensions for debugging
                console.log(`[pasteImageFromUrl] Stored dimensions for ${label}: ${img.width}x${img.height}`);
            
            // Clear the canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply current scale factor
                const scale = imageScaleByLabel[label] || 1.0; // Use passed-in label
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of the canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
                const position = imagePositionByLabel[label] || { x: 0, y: 0 }; // Use passed-in label
                const offsetX = position.x;
                const offsetY = position.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;
            
            // Draw the image with scaling and positioning
                console.log(`[pasteImageFromUrl] Drawing image for ${label} at Canvas(${x.toFixed(1)}, ${y.toFixed(1)}) Scale: ${scale * 100}%`);
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Update the scale display in the sidebar
                const scaleElement = document.getElementById(`scale-${label}`);
            if (scaleElement) {
                scaleElement.textContent = `Scale: ${Math.round(scale * 100)}%`;
            }
            
            // Save this as the base state for this image
            const newState = getCanvasState();
                imageStates[label] = cloneImageData(newState); // Use passed-in label
                console.log(`[pasteImageFromUrl] State saved into imageStates[${label}]`);
                
                // If this is the currently active label, update currentStroke
                if (label === currentImageLabel) {
            currentStroke = cloneImageData(newState);
                }
            
                // Initialize the undo stack if needed
                if (!undoStackByImage[label] || undoStackByImage[label].length === 0) {
                    undoStackByImage[label] = [{
                state: cloneImageData(newState),
                type: 'initial',
                label: null
            }];
                    console.log(`[pasteImageFromUrl] Initialized undo stack for ${label}`);
                }
            
                // Update the scale buttons to show active state if this is the current view
                if (label === currentImageLabel) {
            updateScaleButtonsActiveState();
                }
                
                console.log(`[pasteImageFromUrl] Image loaded and state saved for ${label}`);
                resolve(); // Resolve the promise
            };
            
            img.onerror = (err) => {
                console.error(`[pasteImageFromUrl] Error loading image for ${label}:`, err);
                reject(err); // Reject the promise on error
            };
            
        img.src = url;
        });
    }
    // --- END MODIFIED Function ---

    function getNextLabel(imageLabel) {
        const currentLabel = labelsByImage[imageLabel];
        const letter = currentLabel[0];
        const number = parseInt(currentLabel.slice(1)) + 1;
        if (number > 9) {
            return String.fromCharCode(letter.charCodeAt(0) + 1) + '0';
        }
        return letter + number;
    }

    // Make updateStrokeCounter available globally
    window.updateStrokeCounter = updateStrokeCounter;
    function updateStrokeCounter() {
        const strokeCount = lineStrokesByImage[currentImageLabel]?.length || 0;
        strokeCounter.textContent = `Lines: ${strokeCount}`;
        
        // Update visibility controls
        updateStrokeVisibilityControls();
    }
    
    function updateSidebarStrokeCounts() {
        // Update stroke counts in the sidebar
        const imageContainers = document.querySelectorAll('.image-container');
        imageContainers.forEach(container => {
            const label = container.dataset.label;
            if (label) {
                const strokesElement = container.querySelector('.image-strokes');
                if (strokesElement) {
                    const strokes = lineStrokesByImage[label] || [];
                    strokesElement.textContent = `Strokes: ${strokes.length}`;
                }
            }
        });
        
        // Also update visibility controls when sidebar is updated
        updateStrokeVisibilityControls();
    }

    function getCanvasState() {
        return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    function restoreCanvasState(state) {
        if (!state) return;
        ctx.putImageData(state, 0, 0);
    }
    
    // Measurement data for strokes
    let strokeMeasurements = {};
    
    // Initialize measurement data store
    IMAGE_LABELS.forEach(label => {
        strokeMeasurements[label] = {};
    });
    
    // Function to get formatted measurement string
    function getMeasurementString(strokeLabel) {
        const measurement = strokeMeasurements[currentImageLabel]?.[strokeLabel];
        if (!measurement) return '';
        
        const unit = document.getElementById('unitSelector').value;
        
        if (unit === 'inch') {
            const whole = measurement.inchWhole || 0;
            const fraction = measurement.inchFraction || 0;
            
            // Format as 1 1/4" etc.
            let fractionStr = '';
            if (fraction > 0) {
                const fractionMap = {
                    0.125: '1/8',
                    0.25: '1/4',
                    0.375: '3/8',
                    0.5: '1/2',
                    0.625: '5/8',
                    0.75: '3/4',
                    0.875: '7/8'
                };
                fractionStr = ' ' + fractionMap[fraction];
            }
            
            return `${whole}${fractionStr}"`;
        } else {
            // CM with one decimal
            return `${measurement.cm.toFixed(1)} cm`;
        }
    }
    
    // Function to convert between units
    function convertUnits(from, value) {
        if (from === 'inch') {
            // Convert inch to cm
            return value * 2.54;
        } else {
            // Convert cm to inch
            return value / 2.54;
        }
    }
    
    // Function to update all measurements when unit changes
    function updateMeasurementDisplay() {
        const unit = document.getElementById('unitSelector').value;
        const inchWhole = document.getElementById('inchWhole');
        const inchFraction = document.getElementById('inchFraction');
        const cmValue = document.getElementById('cmValue');
        
        // Convert values when switching between units
        if (unit === 'inch') {
            // Converting from cm to inches
            const cm = parseFloat(cmValue.value) || 0;
            const inches = cm / 2.54;
            
            // Update inch values
            inchWhole.value = Math.floor(inches);
            
            // Find closest fraction
            const fractionPart = inches - Math.floor(inches);
            const fractions = [
                {value: '0', text: '0'},
                {value: '0.125', text: '1/8'},
                {value: '0.25', text: '1/4'},
                {value: '0.375', text: '3/8'},
                {value: '0.5', text: '1/2'},
                {value: '0.625', text: '5/8'},
                {value: '0.75', text: '3/4'},
                {value: '0.875', text: '7/8'}
            ];
            
            fractions.forEach(f => {
                const option = document.createElement('option');
                option.value = f.value;
                option.textContent = f.text;
                if (parseFloat(f.value) === fractionPart) {
                    option.selected = true;
                }
                inchFraction.appendChild(option);
            });
            
            // Show inch inputs, hide cm inputs
            document.getElementById('inchInputs').style.display = 'flex';
            document.getElementById('cmInputs').style.display = 'none';
        } else {
            // Converting from inches to cm
            const whole = parseInt(inchWhole.value) || 0;
            const fraction = parseFloat(inchFraction.value) || 0;
            const totalInches = whole + fraction;
            
            // Update cm value with one decimal point
            cmValue.value = (totalInches * 2.54).toFixed(1);
            
            // Show cm inputs, hide inch inputs
            document.getElementById('inchInputs').style.display = 'none';
            document.getElementById('cmInputs').style.display = 'flex';
        }
        
        // Update the stroke visibility display to show new units
        updateStrokeVisibilityControls();
        
        // Redraw the canvas with updated measurement format in labels
        redrawCanvasWithVisibility();
    }

    // Function to update stroke visibility controls
    // Make updateStrokeVisibilityControls available globally
    window.updateStrokeVisibilityControls = updateStrokeVisibilityControls;
    function updateStrokeVisibilityControls() {
        const controlsContainer = document.getElementById('strokeVisibilityControls');
        controlsContainer.innerHTML = ''; // Clear existing controls
        
        // Add a separator at the top
        const topSeparator = document.createElement('hr');
        controlsContainer.appendChild(topSeparator);
        
        // Display current unit
        const unitDisplay = document.createElement('div');
        unitDisplay.className = 'current-unit-display';
        unitDisplay.textContent = `Current Unit: ${document.getElementById('unitSelector').value === 'inch' ? 'Inches' : 'Centimeters'}`;
        controlsContainer.appendChild(unitDisplay);
        
        // Add another separator
        const separator = document.createElement('hr');
        controlsContainer.appendChild(separator);
        
        // Create strokes list
        const strokesList = document.createElement('div');
        strokesList.id = 'strokesList';
        controlsContainer.appendChild(strokesList);
        
        // Get strokes for current image
        const strokes = lineStrokesByImage[currentImageLabel] || [];
        
        if (strokes.length === 0) {
            strokesList.innerHTML = '<p>No strokes to display</p>';
            return;
        }
        
        // Current unit
        const unit = document.getElementById('unitSelector').value;
        
        // Create visibility toggle for each stroke
        strokes.forEach(strokeLabel => {
            // Initialize visibility if not set
            if (strokeVisibilityByImage[currentImageLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel] = {};
            }
            if (strokeVisibilityByImage[currentImageLabel][strokeLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            }
            
            // Initialize label visibility if not set
            if (strokeLabelVisibility[currentImageLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel] = {};
            }
            if (strokeLabelVisibility[currentImageLabel][strokeLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel][strokeLabel] = true; // Labels visible by default
            }
            
            // Initialize measurement if not set
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            if (strokeMeasurements[currentImageLabel][strokeLabel] === undefined) {
                strokeMeasurements[currentImageLabel][strokeLabel] = {
                    inchWhole: 0,
                    inchFraction: 0,
                    cm: 0.0
                };
            }
            
            const isVisible = strokeVisibilityByImage[currentImageLabel][strokeLabel];
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            const measurement = getMeasurementString(strokeLabel);
            const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
            
            const item = document.createElement('div');
            item.className = 'stroke-visibility-item';
            item.dataset.stroke = strokeLabel;
            item.dataset.selected = isSelected ? 'true' : 'false';
            
            // Make all parts of the item selectable (except checkbox and buttons)
            item.addEventListener('click', (e) => {
                // Don't trigger selection if clicking a button or checkbox
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
                    return;
                }
                
                // Toggle selection (if already selected, deselect it)
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                
                // Update the measurement input with the selected stroke's measurement
                    if (typeof updateMeasurementInputWithStroke === 'function') {
                    updateMeasurementInputWithStroke(strokeLabel);
                }
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `visibility-${strokeLabel}`;
            checkbox.checked = isVisible;
            checkbox.addEventListener('change', () => toggleStrokeVisibility(strokeLabel, checkbox.checked));
            
            const labelContainer = document.createElement('div');
            labelContainer.className = 'stroke-label-container';
            
            // Find the stroke color from the undo stack or vector data
            let strokeColor = '#000';
            let strokeType = 'freehand'; // Default type
            
            if (vectorStrokesByImage[currentImageLabel] && 
                vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                const vectorData = vectorStrokesByImage[currentImageLabel][strokeLabel];
                strokeColor = vectorData.color || '#000';
                strokeType = vectorData.type || 'freehand';
            } else {
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel && action.color) {
                        strokeColor = action.color;
                        // Try to determine stroke type from action
                        if (action.type === 'line') {
                            strokeType = 'straight';
                        }
                        break;
                    }
                }
            }
            
            // Create the stroke name element with color matching the stroke
            const strokeName = document.createElement('span');
            strokeName.className = 'stroke-name';
            strokeName.textContent = strokeLabel;
            strokeName.style.borderColor = strokeColor;
            strokeName.style.color = strokeColor;
            
            // Add a small icon to indicate stroke type (optional)
            if (strokeType === 'straight') {
                strokeName.title = 'Straight Line';
            } else {
                strokeName.title = 'Freehand Stroke';
            }
            
            // Make stroke name label clickable for selection as well
            strokeName.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent double handling with the item click
                
                // Toggle selection 
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            // Create measurement text
            const measureText = document.createElement('span');
            measureText.className = 'stroke-measurement';
            measureText.textContent = measurement ? `= ${measurement}` : '';
            
            // Create edit button
            const editBtn = document.createElement('button');
            editBtn.className = 'stroke-edit-btn';
            editBtn.innerHTML = '✏️';
            editBtn.title = 'Edit Stroke';
            editBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                showEditDialog(strokeLabel);
            };
            
            // Create label toggle button
            const labelToggleBtn = document.createElement('button');
            labelToggleBtn.className = 'stroke-label-toggle';
            labelToggleBtn.classList.toggle('active', isLabelVisible);
            labelToggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            labelToggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            labelToggleBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                toggleLabelVisibility(strokeLabel);
            };
            
            // Add elements to container
            labelContainer.appendChild(strokeName);
            labelContainer.appendChild(measureText);
            labelContainer.appendChild(labelToggleBtn);
            labelContainer.appendChild(editBtn);
            
            // Build the complete item
            item.appendChild(checkbox);
            item.appendChild(labelContainer);
            
            // Add to stroke list
            strokesList.appendChild(item);
        });
    }
    
    // Function to toggle label visibility on canvas
    function toggleLabelVisibility(strokeLabel) {
        // Only toggle the label visibility, not the stroke visibility
        strokeLabelVisibility[currentImageLabel][strokeLabel] = !strokeLabelVisibility[currentImageLabel][strokeLabel];
        
        // Update the UI button appearance
        const toggleBtn = document.querySelector(`.stroke-visibility-item[data-stroke="${strokeLabel}"] .stroke-label-toggle`);
        if (toggleBtn) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            toggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            toggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            toggleBtn.classList.toggle('active', isLabelVisible);
        }
        
        // Redraw the canvas with updated label visibility
        // This should not affect the stroke visibility
        redrawCanvasWithVisibility();
    }
    
    // Function to update measurement input with selected stroke's value
    // Function to display a measurement edit dialog
    function showMeasurementDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurement
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Measurement for ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values from inputs
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Determine which unit was changed last and use that value
            const currentUnit = document.getElementById('unitSelector').value;
            let finalCmValue, finalInchWhole, finalInchFraction;
            
            if (currentUnit === 'inch') {
                finalInchWhole = wholeValue;
                finalInchFraction = fractionValue;
                finalCmValue = convertUnits('inch', wholeValue + fractionValue);
            } else {
                finalCmValue = cmValue;
                // Calculate inch equivalent
                const inches = convertUnits('cm', cmValue);
                finalInchWhole = Math.floor(inches);
                finalInchFraction = findClosestFraction(inches - finalInchWhole);
            }
            
            // Update the measurement
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            
            strokeMeasurements[currentImageLabel][strokeLabel] = {
                inchWhole: finalInchWhole,
                inchFraction: finalInchFraction,
                cm: finalCmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update the UI
            updateStrokeVisibilityControls();
            
            // Redraw with the new measurement
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Helper function to find the closest fraction
    function findClosestFraction(fractionPart) {
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        return closestFraction;
    }
    
    // Function to show edit dialog for a stroke
    function showEditDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurements
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Stroke ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Create name edit field
        const nameContainer = document.createElement('div');
        nameContainer.className = 'name-container';
        
        const nameLabel = document.createElement('div');
        nameLabel.textContent = 'Label:';
        nameContainer.appendChild(nameLabel);
        
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = strokeLabel;
        nameInput.placeholder = 'Label';
        nameContainer.appendChild(nameInput);
        
        dialog.appendChild(nameContainer);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Sync between inch and cm inputs
        wholeInput.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        fractionSelect.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        cmInput.addEventListener('change', () => {
            const cmValue = parseFloat(cmInput.value) || 0;
            const inches = convertUnits('cm', cmValue);
            const wholeValue = Math.floor(inches);
            const fractionValue = findClosestFraction(inches - wholeValue);
            
            wholeInput.value = wholeValue;
            fractionSelect.value = fractionValue.toString();
        });
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values
            const newName = nameInput.value.trim();
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Update name if changed
            let finalName = strokeLabel;
            if (newName !== strokeLabel && newName !== '') {
                // The unique name generation is handled inside renameStroke
                finalName = renameStroke(strokeLabel, newName);
                
                // Show feedback if name was modified to make it unique
                if (finalName !== newName) {
                    console.log(`Stroke name automatically adjusted to ${finalName} to avoid duplicates`);
                    
                    // Create and show a temporary notification
                    const notification = document.createElement('div');
                    notification.style.position = 'fixed';
                    notification.style.bottom = '20px';
                    notification.style.left = '50%';
                    notification.style.transform = 'translateX(-50%)';
                    notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                    notification.style.color = 'white';
                    notification.style.padding = '10px 20px';
                    notification.style.borderRadius = '4px';
                    notification.style.zIndex = '10000';
                    notification.textContent = `Renamed to ${finalName} to avoid duplicates`;
                    
                    document.body.appendChild(notification);
                    
                    // Remove after 3 seconds
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 3000);
                }
            }
            
            // Always save both units
            strokeMeasurements[currentImageLabel][finalName] = {
                inchWhole: wholeValue,
                inchFraction: fractionValue,
                cm: cmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update UI
            updateStrokeVisibilityControls();
            
            // Redraw to show updated measurements
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Function to generate a unique stroke name
    function generateUniqueStrokeName(baseName) {
        // If the name is empty or undefined, use a default name
        if (!baseName || baseName.trim() === '') {
            baseName = 'A1';
        }
        
        // If the base name doesn't already exist, we can use it as is
        if (!lineStrokesByImage[currentImageLabel] || 
            !lineStrokesByImage[currentImageLabel].includes(baseName)) {
            return baseName;
        }
        
        // Name already exists, so we need to add a number
        // Extract the base part and any existing numbering
        const match = baseName.match(/^(.+?)(?:\((\d+)\))?$/);
        if (!match) {
            // If the regex didn't match for some reason, append (1) to the name
            return `${baseName}(1)`;
        }
        
        const base = match[1];
        let counter = 1;
        
        // If there was already a number, start from the next one
        if (match[2]) {
            counter = parseInt(match[2]) + 1;
        }
        
        // Keep incrementing until we find a unique name
        let newName;
        do {
            newName = `${base}(${counter})`;
            counter++;
        } while (lineStrokesByImage[currentImageLabel].includes(newName));
        
        return newName;
    }
    
    // Function to rename a stroke
    function renameStroke(oldName, newName) {
        if (oldName === newName) return;
        
        // Generate a unique name if needed - this ensures the new name won't conflict
        // with any existing stroke names, including itself
        const uniqueNewName = generateUniqueStrokeName(newName);
        
        // Find the stroke color from the undo stack or vector data to maintain color after rename
        let strokeColor = '#000';
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            strokeColor = vectorStrokesByImage[currentImageLabel][oldName].color || '#000';
        } else {
            for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                const action = undoStackByImage[currentImageLabel][i];
                if (action.label === oldName && action.color) {
                    strokeColor = action.color;
                    // Try to determine stroke type from action
                    if (action.type === 'line') {
                        strokeType = 'straight';
                    }
                    break;
                }
            }
        }
        
        // Update all relevant data structures
        if (lineStrokesByImage[currentImageLabel]) {
            const index = lineStrokesByImage[currentImageLabel].indexOf(oldName);
            if (index !== -1) {
                lineStrokesByImage[currentImageLabel][index] = uniqueNewName;
            }
        }
        
        // Update visibility
        if (strokeVisibilityByImage[currentImageLabel] && 
            strokeVisibilityByImage[currentImageLabel][oldName] !== undefined) {
            const isVisible = strokeVisibilityByImage[currentImageLabel][oldName];
            strokeVisibilityByImage[currentImageLabel][uniqueNewName] = isVisible;
            delete strokeVisibilityByImage[currentImageLabel][oldName];
        }
        
        // Update label visibility
        if (strokeLabelVisibility[currentImageLabel] && 
            strokeLabelVisibility[currentImageLabel][oldName] !== undefined) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][oldName];
            strokeLabelVisibility[currentImageLabel][uniqueNewName] = isLabelVisible;
            delete strokeLabelVisibility[currentImageLabel][oldName];
        }
        
        // Update stroke data
        if (strokeDataByImage[currentImageLabel] && 
            strokeDataByImage[currentImageLabel][oldName]) {
            strokeDataByImage[currentImageLabel][uniqueNewName] = 
                strokeDataByImage[currentImageLabel][oldName];
            delete strokeDataByImage[currentImageLabel][oldName];
        }
        
        // Update vector data
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            vectorStrokesByImage[currentImageLabel][uniqueNewName] = 
                vectorStrokesByImage[currentImageLabel][oldName];
            delete vectorStrokesByImage[currentImageLabel][oldName];
        }
        
        // Update measurements
        if (strokeMeasurements[currentImageLabel] && 
            strokeMeasurements[currentImageLabel][oldName]) {
            strokeMeasurements[currentImageLabel][uniqueNewName] = 
                strokeMeasurements[currentImageLabel][oldName];
            delete strokeMeasurements[currentImageLabel][oldName];
        }
        
        // Update next label if needed
        if (labelsByImage[currentImageLabel] === oldName) {
            labelsByImage[currentImageLabel] = uniqueNewName;
        }
        
        // Update any references in the undo/redo stacks
        if (undoStackByImage[currentImageLabel]) {
            undoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        if (redoStackByImage[currentImageLabel]) {
            redoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        // Return the actual name used for the stroke (either the original or the uniquified version)
        return uniqueNewName;
    }
    
    // Function to toggle stroke visibility
    function toggleStrokeVisibility(strokeLabel, isVisible) {
        console.log(`Toggling visibility of stroke ${strokeLabel} to ${isVisible}`);
        
        // Update visibility state
        strokeVisibilityByImage[currentImageLabel][strokeLabel] = isVisible;
        
        // Make sure the stroke data is still available and not accidentally cleared
        if (isVisible) {
            // Initialize vectorStrokesByImage for this image if it doesn't exist
            if (!vectorStrokesByImage[currentImageLabel]) {
                vectorStrokesByImage[currentImageLabel] = {};
            }
            
            // If we're making a stroke visible, ensure we still have vector data
            if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                console.log(`Vector data missing for ${strokeLabel}, attempting recovery`);
                
                // Try to recover vector data from the undo stack
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel) {
                        if (action.vectorData) {
                            vectorStrokesByImage[currentImageLabel][strokeLabel] = action.vectorData;
                            console.log(`Recovered vector data for ${strokeLabel}`);
                            break;
                        }
                    }
                }
                
                // If we still couldn't recover the vector data, create a basic one
                // This is especially important for straight lines
                if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                    console.log(`Creating default vector data for ${strokeLabel}`);
                    
                    // Look for color and properties in the undo stack
                    let strokeColor = "#000000";
                    let strokeWidth = 5;
                    let isLine = false;
                    
                    for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                        const action = undoStackByImage[currentImageLabel][i];
                        if (action.label === strokeLabel) {
                            if (action.color) strokeColor = action.color;
                            if (action.width) strokeWidth = action.width;
                            if (action.type === 'line' || action.type === 'straight') isLine = true;
                            break;
                        }
                    }
                    
                    // Create a simple vector representation (placeholder)
                    vectorStrokesByImage[currentImageLabel][strokeLabel] = {
                        points: isLine ? [{x: 0, y: 0}, {x: 1, y: 1}] : [{x: 0, y: 0}],
                        color: strokeColor,
                        width: strokeWidth,
                        type: isLine ? 'straight' : 'freehand'
                    };
                }
            }
        };

        // *** Add redraw call here ***
        redrawCanvasWithVisibility();
    }
    
    // Store for currently selected stroke in each image
    let selectedStrokeByImage = {};
    
    // Initialize stroke label visibility for each image (default to visible)
    IMAGE_LABELS.forEach(label => {
        strokeLabelVisibility[label] = {};
        selectedStrokeByImage[label] = null; // Initialize with no selection
    });
    
    // Store for label custom positions (user-dragged positions)
    let customLabelPositions = {};
    
    // Flag to track if we're dragging a label
    let isDraggingLabel = false;
    let draggedLabelStroke = null;
    let dragStartX = 0;
    let dragStartY = 0;
    
    // Initialize custom label positions for each image
    IMAGE_LABELS.forEach(label => {
        customLabelPositions[label] = {};
    });
    
    // Cache for loaded images to prevent flickering
    const imageCache = {};
    
    // Store for label positions to prevent overlapping
    let currentLabelPositions = [];
    
    // Store for stroke paths to avoid overlapping with lines
    let currentStrokePaths = [];
    
    // Function to redraw canvas respecting stroke visibility
    // Make redrawCanvasWithVisibility available globally
    window.redrawCanvasWithVisibility = redrawCanvasWithVisibility;
    function redrawCanvasWithVisibility() {
        console.log(`--- redrawCanvasWithVisibility called for: ${currentImageLabel} ---`);
        
        // *** Save context and reset transform before drawing anything ***
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset to identity matrix
        console.log("Redraw Start Transform:", ctx.getTransform());
        
        // ADDED: Ensure originalImageDimensions exists and has an entry for this label
        if (!window.originalImageDimensions) {
            window.originalImageDimensions = {};
        }
        
        // ADDED: If we don't have dimensions for this label but we're trying to draw strokes,
        // create default dimensions based on the canvas size to prevent coordinates from being lost
        if (!window.originalImageDimensions[currentImageLabel] && 
            window.vectorStrokesByImage[currentImageLabel] && 
            Object.keys(window.vectorStrokesByImage[currentImageLabel]).length > 0) {
            
            console.log(`Creating default dimensions for ${currentImageLabel} to preserve strokes`);
            window.originalImageDimensions[currentImageLabel] = {
                width: canvas.width,
                height: canvas.height
            };
            console.log(`Set dimensions to match canvas: ${canvas.width}x${canvas.height}`);
        }
        
        // Reset label positions and stroke paths for this redraw
        currentLabelPositions = [];
        currentStrokePaths = [];
        
        // Create a copy of custom label positions for tracking which ones were actually used
        const usedCustomPositions = {};
        
        // We need to rebuild the canvas from scratch using individual stroke data
        const strokes = window.lineStrokesByImage[currentImageLabel] || [];
        
        // Start with a blank canvas or the original image if available
        if (window.originalImages && window.originalImages[currentImageLabel]) {
            // Check if we already have this image in the cache
            const imageUrl = window.originalImages[currentImageLabel];
            
            if (imageCache[imageUrl]) {
                // Use cached image immediately
                drawImageAndStrokes(imageCache[imageUrl]);
            } else {
                // Load the image and cache it
                const img = new Image();
                img.onload = () => {
                    // Add to cache
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                };
                img.src = imageUrl;
                
                // If the image is already cached in the browser, it might be immediately available
                if (img.complete) {
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                } else {
                    // If the image isn't immediately available,
                    // still draw the strokes on a blank canvas so they don't disappear
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the current scale and position
                    const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
                    
                    // For blank canvas mode, we apply the position directly when drawing points
                    // We pass 0,0 for position here since we'll apply it inside applyVisibleStrokes
                    applyVisibleStrokes(scale, 0, 0);
                }
            }
        } else {
            // Otherwise start with a blank canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white'; // Add white background fill
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Get the current scale for the blank canvas state
            const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
            
            // Apply visible strokes - for blank canvas mode, we don't need to apply position offset here
            // since we'll apply it to each point when drawing
            applyVisibleStrokes(scale, 0, 0);
        }
        
        function drawImageAndStrokes(img) {
            // Clear only once within the reset transform state
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply scale
            const scale = window.imageScaleByLabel[currentImageLabel];
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
            const positionOffset = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 }; // Ensure offset exists
            const offsetX = positionOffset.x;
            const offsetY = positionOffset.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;

            // *** ADDED LOGGING ***
            // console.log(`drawImageAndStrokes Calculation:
            //   canvas.width=${canvas.width}, img.width=${img.width}, scaledWidth=${scaledWidth}
            //   scale=${scale}, centerX=${centerX}, offsetX=${offsetX}, final imageX (passed to applyVisibleStrokes)=${x}`);
            // *** END LOGGING ***
            
            // Draw the image with scaling and positioning
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Then apply visible strokes
            applyVisibleStrokes(scale, x, y);
        }
        
        function applyVisibleStrokes(scale, imageX, imageY) {
            console.log("ApplyStrokes Start Transform:", ctx.getTransform()); // Log transform at start
            // console.log(`\nApplying strokes with scale=${scale}, imageX=${imageX}, imageY=${imageY}`); // Keep this commented unless debugging scale/position
            const strokes = window.vectorStrokesByImage[currentImageLabel] || {};
            const strokeOrder = window.lineStrokesByImage[currentImageLabel] || [];
            const visibility = window.strokeVisibilityByImage[currentImageLabel] || {};

            // Loop through strokes in their drawing order
            strokeOrder.forEach((strokeLabel) => {
                const isVisible = visibility[strokeLabel];
                if (!isVisible) return; // Skip invisible strokes

                const vectorData = strokes[strokeLabel];
                // Ensure vectorData and points exist
                if (!vectorData || !vectorData.points || vectorData.points.length === 0) {
                     console.warn(`Skipping stroke ${strokeLabel} in redraw: Missing vector data or points.`);
                     return;
                }

                // Set stroke style based on stored data, scaled by CURRENT scale
                ctx.strokeStyle = vectorData.color || '#000000';
                // *** FIX: Ensure lineWidth uses original stored width * current scale ***
                const scaledLineWidth = (vectorData.width || 5) * scale;
                ctx.lineWidth = scaledLineWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Start drawing the path
                ctx.beginPath();

                // Transform the first point from relative to canvas coordinates
                const firstPointRelative = vectorData.points[0];
                const firstPointCanvas = getCanvasCoords(firstPointRelative.x, firstPointRelative.y);
                ctx.moveTo(firstPointCanvas.x, firstPointCanvas.y);

                // Store canvas path for label collision detection
                const strokePath = [{ x: firstPointCanvas.x, y: firstPointCanvas.y }];

                // Check if this is a straight line (only two points)
                const isStraightLine = vectorData.type === 'straight' || (vectorData.points.length === 2 && !vectorData.type);

                if (isStraightLine && vectorData.points.length >= 2) {
                    // Straight Line: Transform only the last point
                    const lastPointRelative = vectorData.points[vectorData.points.length - 1];
                    const lastPointCanvas = getCanvasCoords(lastPointRelative.x, lastPointRelative.y);
                    ctx.lineTo(lastPointCanvas.x, lastPointCanvas.y);
                    strokePath.push({ x: lastPointCanvas.x, y: lastPointCanvas.y });
                } else {
                    // Freehand: Transform ALL subsequent points
                    for (let i = 1; i < vectorData.points.length; i++) {
                        const pointRelative = vectorData.points[i];
                        // *** FIX: Apply getCanvasCoords to EACH subsequent point ***
                        const pointCanvas = getCanvasCoords(pointRelative.x, pointRelative.y);
                        ctx.lineTo(pointCanvas.x, pointCanvas.y);
                        strokePath.push({ x: pointCanvas.x, y: pointCanvas.y });
                         // Optional logging for debugging coordinate drift:
                         // if (i < 3 || i % 20 === 0) { // Log first few and then every 20th
                         //     console.log(`  Redraw Pt ${i} Rel:(${pointRelative.x.toFixed(1)}, ${pointRelative.y.toFixed(1)}) -> Canv:(${pointCanvas.x.toFixed(1)}, ${pointCanvas.y.toFixed(1)})`);
                         // }
                    }
                }

                // Apply selection highlighting if needed (before stroking)
                const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                if (isSelected) {
                    ctx.save();
                    ctx.shadowColor = '#ffffff'; // White glow
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                }

                // Stroke the path
                ctx.stroke();

                // Restore context if selection highlighting was applied
                if (isSelected) {
                    ctx.restore();
                }

                // Store the calculated canvas path and scaled width for label positioning
                currentStrokePaths.push({
                    label: strokeLabel,
                    path: strokePath, // Store canvas coordinates path
                     // *** FIX: Store correctly scaled width ***
                    width: scaledLineWidth,
                    color: vectorData.color
                });
            }); // End of strokeOrder.forEach

            // --- Label Drawing Logic ---
            // console.log(`--- Redraw: Drawing Labels for ${currentImageLabel} ---`);
            currentLabelPositions = [];
            const usedCustomPositions = {};

            strokeOrder.forEach((strokeLabel) => {
                const isStrokeVisible = visibility[strokeLabel];
                if (!strokeLabelVisibility[currentImageLabel]) strokeLabelVisibility[currentImageLabel] = {};
                const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel] !== false; // Default true
                const vectorData = strokes[strokeLabel];

                if (isStrokeVisible && isLabelVisible && vectorData && vectorData.points.length > 0) {
                    const measurement = getMeasurementString(strokeLabel);
                    const labelText = measurement ? `${strokeLabel}=${measurement}` : strokeLabel;

                    // Determine anchor point (middle of the stroke) using RELATIVE coordinates
                    let anchorPointRelative = { x: 0, y: 0 };
                    const midIndex = Math.floor(vectorData.points.length / 2);
                    anchorPointRelative = vectorData.points[midIndex];

                    // Convert anchor point to CURRENT canvas coordinates
                    const anchorPointCanvas = getCanvasCoords(anchorPointRelative.x, anchorPointRelative.y);

                    if (isNaN(anchorPointCanvas.x) || isNaN(anchorPointCanvas.y)) {
                         console.error(`      Error getting canvas coords for label anchor for ${strokeLabel}. Relative point:`, anchorPointRelative);
                         return; // Skip label if anchor is invalid
                    }

                    // Set label style
                    // Increase font size for better visibility, especially when scaled
                    const baseFontSize = 14;
                    const scaledFontSize = Math.max(10, Math.min(28, baseFontSize / scale)); // Adjust font size based on zoom, within limits
                    ctx.font = `${scaledFontSize}px Arial`;
                    const labelColor = vectorData.color || '#000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';

                    // Calculate label dimensions based on current font size
                    const metrics = ctx.measureText(labelText);
                    const padding = 6 / scale; // Scale padding inversely
                    const labelWidth = metrics.width + padding * 2;
                    const labelHeight = scaledFontSize + padding * 2; // Adjust height based on font size

                    // Initial label rectangle guess (used for optimal position calculation)
                     const initialLabelRect = {
                        width: labelWidth,
                        height: labelHeight,
                        x: anchorPointCanvas.x - labelWidth / 2,
                        y: anchorPointCanvas.y - labelHeight - (15 / scale), // Scale vertical offset
                        strokeLabel: strokeLabel
                    };

                    // Determine final label position
                    let finalPosition; // This will be canvas coordinates {x, y} for the top-left of the label
                    let offset = null; // Relative offset {x, y} from anchorPointCanvas

                    // 1. Check for user-dragged position (stored as relative offset)
                    if (customLabelPositions[currentImageLabel]?.[strokeLabel]) {
                        offset = customLabelPositions[currentImageLabel][strokeLabel];
                        // Apply the stored relative offset to the *current* canvas anchor point
                        finalPosition = { x: anchorPointCanvas.x + offset.x, y: anchorPointCanvas.y + offset.y };
                        usedCustomPositions[strokeLabel] = true; // Mark as used
                         // console.log(`    Using custom offset for ${strokeLabel}. Anchor: (${anchorPointCanvas.x.toFixed(1)}, ${anchorPointCanvas.y.toFixed(1)}), Offset: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)}) -> Final: (${finalPosition.x.toFixed(1)}, ${finalPosition.y.toFixed(1)})`);
                    }
                    // 2. Check for previously calculated offset (stored as relative offset)
                    else if (calculatedLabelOffsets[currentImageLabel]?.[strokeLabel]) {
                        offset = calculatedLabelOffsets[currentImageLabel][strokeLabel];
                        // Apply the stored relative offset to the *current* canvas anchor point
                        finalPosition = { x: anchorPointCanvas.x + offset.x, y: anchorPointCanvas.y + offset.y };
                         // console.log(`    Using calculated offset for ${strokeLabel}. Anchor: (${anchorPointCanvas.x.toFixed(1)}, ${anchorPointCanvas.y.toFixed(1)}), Offset: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)}) -> Final: (${finalPosition.x.toFixed(1)}, ${finalPosition.y.toFixed(1)})`);
                    }
                    // 3. Calculate optimal position and offset for the first time
                    else {
                        if (typeof findOptimalLabelPosition !== 'function') {
                            console.error("     findOptimalLabelPosition function is not defined! Using default position.");
                            finalPosition = { x: initialLabelRect.x, y: initialLabelRect.y }; // Fallback
                        } else {
                            try {
                                const strokePathInfo = currentStrokePaths.find(p => p.label === strokeLabel);
                                const optimalRect = findOptimalLabelPosition(
                                    initialLabelRect, // Initial guess uses current canvas coords & dimensions
                                    anchorPointCanvas, // Anchor is current canvas coords
                                    strokePathInfo // Pass current canvas path info
                                );
                                finalPosition = { x: optimalRect.x, y: optimalRect.y };
                            } catch(err) {
                                console.error(`      Error in findOptimalLabelPosition for ${strokeLabel}:`, err);
                                finalPosition = { x: initialLabelRect.x, y: initialLabelRect.y }; // Fallback
                            }
                        }
                        // Calculate and store the RELATIVE offset based on the calculated position
                        offset = {
                            x: finalPosition.x - anchorPointCanvas.x,
                            y: finalPosition.y - anchorPointCanvas.y
                        };
                        if (!calculatedLabelOffsets[currentImageLabel]) calculatedLabelOffsets[currentImageLabel] = {};
                        calculatedLabelOffsets[currentImageLabel][strokeLabel] = offset; // Store relative offset
                        // console.log(`    Calculated and stored offset for ${strokeLabel}:`, offset);
                    }

                    // Store the final calculated position rect for overlap checks in *this* redraw cycle
                    const finalLabelRect = { ...initialLabelRect, x: finalPosition.x, y: finalPosition.y };
                    currentLabelPositions.push(finalLabelRect);

                    // Draw label background
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(finalLabelRect.x, finalLabelRect.y, finalLabelRect.width, finalLabelRect.height);

                    // Draw label border
                    ctx.strokeStyle = labelColor;
                    ctx.lineWidth = 1; // Keep border thin
                    ctx.strokeRect(finalLabelRect.x, finalLabelRect.y, finalLabelRect.width, finalLabelRect.height);

                    // Draw label text
                    ctx.fillStyle = labelColor;
                    const textX = finalLabelRect.x + finalLabelRect.width / 2;
                    const textY = finalLabelRect.y + finalLabelRect.height - padding; // Adjust baseline using scaled padding
                    ctx.fillText(labelText, textX, textY);

                    // Optionally draw connector line (from label edge to anchor point)
                    if (typeof drawLabelConnector === 'function') {
                        try {
                            drawLabelConnector(finalLabelRect, anchorPointCanvas, labelColor);
                        } catch(err) {
                            console.error(`      Error in drawLabelConnector for ${strokeLabel}:`, err);
                        }
                    }
                }
            }); // End of label drawing loop
            // --- End of Label Drawing Logic ---

            // Save the now-combined state (only if not loading, to prevent infinite loops)
            if (!window.isLoadingProject) {
                const newState = getCanvasState();
                imageStates[currentImageLabel] = cloneImageData(newState);
                 // console.log(`[Redraw] Saved final canvas state for ${currentImageLabel}`); // Optional: Debug state saving
            } else {
                 // console.log("[Redraw] Skipping final state save because isLoadingProject is true.");
            }
            ctx.restore(); // *** Restore the original context state (including transform) ***
            console.log("Redraw End Transform:", ctx.getTransform());
        }
    }

    function cloneImageData(imageData) {
        return new ImageData(
            new Uint8ClampedArray(imageData.data),
            imageData.width,
            imageData.height
        );
    }

    function saveState(force = false, incrementLabel = true, updateStrokeList = true) {
        // *** ADDED LOG ***
        console.log(`[Save State Called] force=${force}, incrementLabel=${incrementLabel}, updateStrokeList=${updateStrokeList}, isDrawingOrPasting=${isDrawingOrPasting}, strokeInProgress=${strokeInProgress}`);

        // Get current state
        const currentState = getCanvasState();

        // Initialize if first save for this image
        if (!imageStates[currentImageLabel]) {
            imageStates[currentImageLabel] = cloneImageData(currentState);
            undoStackByImage[currentImageLabel].push({
                state: cloneImageData(currentState),
                type: 'initial',
                label: null
            });
            updateStrokeCounter();
            return;
        }

        // Only save if we're not in the middle of a stroke or if forced
        if (!force && strokeInProgress) return;

        // Don't save if it's identical to the last state
        const lastState = imageStates[currentImageLabel];
        if (lastState && !force) {
            const currentData = currentState.data;
            const lastData = lastState.data;
            let identical = true;
            for (let i = 0; i < currentData.length; i += 4) {
                if (currentData[i] !== lastData[i] ||
                    currentData[i + 1] !== lastData[i + 1] ||
                    currentData[i + 2] !== lastData[i + 2] ||
                    currentData[i + 3] !== lastData[i + 3]) {
                    identical = false;
                    break;
                }
            }
            if (identical) return;
        }

        // For line strokes, assign the next label before saving
        let strokeLabel = null;
        if (!isDrawingOrPasting && !strokeInProgress && incrementLabel && updateStrokeList) {
            // *** ADDED DETAILED LOGS ***
            console.log(`[Save State] Entering stroke update block.`);
            
            // Get the suggested next label
            const suggestedLabel = window.labelsByImage[currentImageLabel];
            console.log(`[Save State] Suggested next label = "${suggestedLabel}" from labelsByImage[${currentImageLabel}]`);
            
            // *** FIX: Ensure the new stroke gets a UNIQUE label ***
            strokeLabel = generateUniqueStrokeName(suggestedLabel);
            console.log(`[Save State] Assigned UNIQUE strokeLabel = "${strokeLabel}"`);
            
            // Always increment the label counter based on the original suggested label for the next stroke
            const nextLabel = getNextLabel(currentImageLabel); // Uses the value in labelsByImage
            window.labelsByImage[currentImageLabel] = nextLabel;
            console.log(`[Save State] Incremented labelsByImage[${currentImageLabel}] to "${nextLabel}"`);
            
            // Only add the *unique* stroke label to the strokes list
            if (!window.lineStrokesByImage[currentImageLabel]) {
                console.log(`[Save State] Initializing lineStrokesByImage[${currentImageLabel}] as []`);
                window.lineStrokesByImage[currentImageLabel] = []; // Initialize if it doesn't exist
            }
            
            // Check if unique stroke label already exists before pushing (shouldn't happen with generateUniqueStrokeName)
            const labelAlreadyExists = window.lineStrokesByImage[currentImageLabel].includes(strokeLabel);
            
            console.log(`[Save State] BEFORE push: lineStrokesByImage[${currentImageLabel}] =`, JSON.parse(JSON.stringify(window.lineStrokesByImage[currentImageLabel])));
            
            if (!labelAlreadyExists && updateStrokeList) {
                window.lineStrokesByImage[currentImageLabel].push(strokeLabel); // Push the unique label
                console.log(`[Save State] AFTER push: lineStrokesByImage[${currentImageLabel}] =`, JSON.parse(JSON.stringify(window.lineStrokesByImage[currentImageLabel])));
            } else {
                // This case should ideally not be reached if generateUniqueStrokeName works correctly
                console.warn(`[Save State] Generated unique stroke label "${strokeLabel}" already exists? Not pushing again.`);
            }
            
            // Initialize visibility, data etc. using the unique strokeLabel
            window.strokeVisibilityByImage[currentImageLabel] = window.strokeVisibilityByImage[currentImageLabel] || {};
            window.strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            
            window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
            window.strokeLabelVisibility[currentImageLabel][strokeLabel] = true;
            
            strokeDataByImage[currentImageLabel] = strokeDataByImage[currentImageLabel] || {};
            strokeDataByImage[currentImageLabel][strokeLabel] = {
                preState: currentStroke ? cloneImageData(currentStroke) : null,
                postState: cloneImageData(currentState)
            };
        }

        // --- FIX: Handle temporary vector data --- 
        const tempStrokeKey = '_drawingStroke';
        let drawnVectorData = null;
        
        // Debug the state of vectorStrokesByImage before handling temporary data
        console.log(`[Save State] Vector strokes for ${currentImageLabel} before processing:`, 
            window.vectorStrokesByImage[currentImageLabel] ? 
            Object.keys(window.vectorStrokesByImage[currentImageLabel]) : "none");
            
        // Detailed check for _drawingStroke
        if (window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
            console.log(`[Save State] Found _drawingStroke data with ${window.vectorStrokesByImage[currentImageLabel][tempStrokeKey].points.length} points`);
        } else {
            console.log(`[Save State] No _drawingStroke data found:`, 
                window.vectorStrokesByImage[currentImageLabel] ? 
                "vectorStrokesByImage exists for label but no _drawingStroke key" : 
                "vectorStrokesByImage doesn't exist for this label");
        }
        
        if (strokeLabel && window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
            drawnVectorData = JSON.parse(JSON.stringify(window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]));
            // Assign the drawn data to the final unique stroke label
            window.vectorStrokesByImage[currentImageLabel][strokeLabel] = drawnVectorData;
            // Remove the temporary data
            delete window.vectorStrokesByImage[currentImageLabel][tempStrokeKey];
            console.log(`[Save State] Moved vector data from ${tempStrokeKey} to ${strokeLabel}`);
        } else if (strokeLabel) {
            console.warn(`[Save State] No temporary vector data found at ${tempStrokeKey} for stroke ${strokeLabel}`);
            // Attempt to find vector data if it somehow got assigned to the suggested label during draw (fallback)
            const suggestedLabel = window.labelsByImage[currentImageLabel]; // Get the label *before* incrementing
             if (window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][suggestedLabel]) {
                console.log(`[Save State] Fallback: Found data under suggested label ${suggestedLabel}`);
                drawnVectorData = JSON.parse(JSON.stringify(window.vectorStrokesByImage[currentImageLabel][suggestedLabel]));
                window.vectorStrokesByImage[currentImageLabel][strokeLabel] = drawnVectorData;
                // Optionally delete the data under suggestedLabel if it shouldn't be there
                // delete window.vectorStrokesByImage[currentImageLabel][suggestedLabel]; 
            }
        }
        // --- END FIX ---

        // Save new state and add to undo stack
        imageStates[currentImageLabel] = cloneImageData(currentState);
        
        // Determine the type of stroke
        let strokeType = 'other';
        if (force && strokeLabel) {
            strokeType = 'stroke';
            
            // Check for vector data to determine if it's a freehand or straight line
            // Use the vector data we just potentially moved
            if (drawnVectorData) { 
                if (drawnVectorData.type === 'straight') {
                    strokeType = 'line';
                } else if (drawnVectorData.type === 'freehand') {
                    strokeType = 'stroke';
                }
            }
        }
        
        // Add to undo stack with stroke info
        const undoAction = {
            state: cloneImageData(currentState),
            type: strokeType,
            label: strokeLabel, // Use the unique label
            color: colorPicker.value, 
            width: parseInt(brushSize.value) 
        };
        
        // Store vector data with the undo action if available
        // Use the data retrieved from the temporary key
        if (drawnVectorData) {
            undoAction.vectorData = drawnVectorData; 
        }
        
        undoStackByImage[currentImageLabel].push(undoAction);
        
        // Remove oldest state if we've reached max history
        if (undoStackByImage[currentImageLabel].length >= MAX_HISTORY) {
            undoStackByImage[currentImageLabel].shift();
        }

        // Clear redo stack when a new action is performed
        redoStackByImage[currentImageLabel] = [];

        updateStrokeCounter();
        updateSidebarStrokeCounts();
    }

    function undo() {
        console.log(`Attempting to undo in ${currentImageLabel} workspace`);
        console.log(`Current undo stack: ${undoStackByImage[currentImageLabel]?.length || 0} items`);
        console.log(`Current strokes: ${lineStrokesByImage[currentImageLabel]?.join(', ') || 'none'}`);
        
        const currentStack = undoStackByImage[currentImageLabel];
        if (currentStack && currentStack.length > 1) { // Keep at least one state (initial)
            // Get the state we're undoing from
            const lastAction = currentStack.pop();
            console.log(`Undoing action of type: ${lastAction.type}, label: ${lastAction.label || 'none'}`);
            
            // Add to redo stack
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[currentImageLabel].push(lastAction);
            console.log(`Added to redo stack, now has ${redoStackByImage[currentImageLabel].length} items`);
            
            // Skip certain state types when undoing
            if (lastAction.type === 'pre-stroke') {
                console.log('Skipping pre-stroke state');
                // If we encounter a pre-stroke state, undo again to get to the previous complete state
                if (currentStack.length > 1) {
                    return undo();
                }
            }
            
            // Handle snapshot type (created when switching views)
            if (lastAction.type === 'snapshot') {
                console.log('Restoring from snapshot state');
                // If we have stored strokes in the snapshot, restore them
                if (lastAction.strokes) {
                    lineStrokesByImage[currentImageLabel] = [...(lastAction.strokes || [])];
                    console.log(`Restored strokes: ${lineStrokesByImage[currentImageLabel].join(', ')}`);
                }
                
                // Continue to next undo action if possible
                if (currentStack.length > 1) {
                    return undo();
                }
            }
            
            // Get the state we're going back to
            const previousState = currentStack[currentStack.length - 1];
            
            if (lastAction.type === 'line' || lastAction.type === 'stroke') {
                // Remove the last stroke and its label
                if (lineStrokesByImage[currentImageLabel] && lineStrokesByImage[currentImageLabel].length > 0) {
                    const removedStroke = lineStrokesByImage[currentImageLabel].pop();
                    console.log(`Removed stroke: ${removedStroke}`);
                    
                    // Also remove from visibility tracking
                    if (strokeVisibilityByImage[currentImageLabel] && strokeVisibilityByImage[currentImageLabel][removedStroke]) {
                        delete strokeVisibilityByImage[currentImageLabel][removedStroke];
                    }
                    
                    // Also remove from label visibility tracking
                    if (strokeLabelVisibility[currentImageLabel] && strokeLabelVisibility[currentImageLabel][removedStroke]) {
                        // Save label visibility in lastAction for possible redo
                        lastAction.labelVisible = strokeLabelVisibility[currentImageLabel][removedStroke];
                        delete strokeLabelVisibility[currentImageLabel][removedStroke];
                    }
                    
                    // Also remove from stroke data tracking
                    if (strokeDataByImage[currentImageLabel] && strokeDataByImage[currentImageLabel][removedStroke]) {
                        delete strokeDataByImage[currentImageLabel][removedStroke];
                    }
                    
                    // Remove vector stroke data
                    if (vectorStrokesByImage[currentImageLabel] && vectorStrokesByImage[currentImageLabel][removedStroke]) {
                        // Save vector data in lastAction for possible redo
                        lastAction.vectorData = vectorStrokesByImage[currentImageLabel][removedStroke];
                        delete vectorStrokesByImage[currentImageLabel][removedStroke];
                }
                
                    // If this was the last stroke, reset to A1
                    if (lineStrokesByImage[currentImageLabel].length === 0) {
                        labelsByImage[currentImageLabel] = 'A1';
                        console.log(`All strokes undone, reset label counter to A1`);
                    } else {
                // Set the next label to be the one we just removed
                if (lastAction.label) {
                    labelsByImage[currentImageLabel] = lastAction.label;
                    console.log(`Reset label counter to: ${lastAction.label}`);
                        }
                    }
                }
            }
            
            // Ensure we have a valid previous state
            if (previousState && previousState.state) {
                // Restore the canvas state
                const stateToRestore = cloneImageData(previousState.state);
                imageStates[currentImageLabel] = stateToRestore;
                restoreCanvasState(stateToRestore);
                currentStroke = cloneImageData(stateToRestore);
                console.log('Canvas state restored');
            } else {
                console.log('Warning: No valid previous state found');
                // Create a blank state if needed
                const blankState = ctx.createImageData(canvas.width, canvas.height);
                imageStates[currentImageLabel] = blankState;
                restoreCanvasState(blankState);
                currentStroke = cloneImageData(blankState);
            }
            
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
        } else if (currentStack && currentStack.length === 1) {
            // We're at the initial state
            console.log('At initial state, resetting workspace');
            const initialState = currentStack[0];
            
            // Clear all stroke data
            lineStrokesByImage[currentImageLabel] = [];
            strokeVisibilityByImage[currentImageLabel] = {};
            strokeLabelVisibility[currentImageLabel] = {};
            vectorStrokesByImage[currentImageLabel] = {};
            strokeDataByImage[currentImageLabel] = {};
            
            // Reset label counter
            labelsByImage[currentImageLabel] = 'A1';  // Reset to A1
            
            if (initialState && initialState.state) {
                imageStates[currentImageLabel] = cloneImageData(initialState.state);
                restoreCanvasState(initialState.state);
                currentStroke = cloneImageData(initialState.state);
            } else if (window.originalImages[currentImageLabel]) {
                // If we have the original image, redraw it
                console.log('Redrawing from original image');
                const img = new Image();
                img.onload = () => {
                    // Clear the canvas first
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the current scale
                    const scale = window.imageScaleByLabel[currentImageLabel];
                    const scaledWidth = img.width * scale;
                    const scaledHeight = img.height * scale;
                    
                    // Calculate base position (center of canvas)
                    const centerX = (canvas.width - scaledWidth) / 2;
                    const centerY = (canvas.height - scaledHeight) / 2;
                    
                    // Apply position offset
                    const offsetX = window.imagePositionByLabel[currentImageLabel].x;
                    const offsetY = window.imagePositionByLabel[currentImageLabel].y;
                    
                    // Calculate final position
                    const x = centerX + offsetX;
                    const y = centerY + offsetY;
                    
                    // Draw the original image with scale and position
                    ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                    
                    // Save this as the new state
                    const newState = getCanvasState();
                    imageStates[currentImageLabel] = cloneImageData(newState);
                    currentStroke = cloneImageData(newState);
                };
                img.src = window.originalImages[currentImageLabel];
            }
            
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
        } else {
            console.log('No undo history available for this workspace');
        }
    }
    
    function redo() {
        console.log(`Attempting to redo in ${currentImageLabel} workspace`);
        console.log(`Current redo stack: ${redoStackByImage[currentImageLabel]?.length || 0} items`);
        
        const redoStack = redoStackByImage[currentImageLabel];
        if (redoStack && redoStack.length > 0) {
            // Get the action to redo
            const actionToRedo = redoStack.pop();
            console.log(`Redoing action of type: ${actionToRedo.type}, label: ${actionToRedo.label || 'none'}`);
            
            // Add back to undo stack
            undoStackByImage[currentImageLabel].push(actionToRedo);
            
            // Handle stroke type actions (both freehand strokes and straight lines)
            if ((actionToRedo.type === 'line' || actionToRedo.type === 'stroke') && actionToRedo.label) {
                // Add the stroke back to the list
                window.lineStrokesByImage[currentImageLabel] = window.lineStrokesByImage[currentImageLabel] || [];
                window.lineStrokesByImage[currentImageLabel].push(actionToRedo.label);
                console.log(`Added stroke back: ${actionToRedo.label}`);
                
                // Restore stroke visibility
                window.strokeVisibilityByImage[currentImageLabel] = window.strokeVisibilityByImage[currentImageLabel] || {};
                window.strokeVisibilityByImage[currentImageLabel][actionToRedo.label] = true;
                
                // Restore stroke data if we have it
                if (actionToRedo.strokeData) {
                    strokeDataByImage[currentImageLabel] = strokeDataByImage[currentImageLabel] || {};
                    strokeDataByImage[currentImageLabel][actionToRedo.label] = actionToRedo.strokeData;
                }
                
                // Restore vector data if we have it
                if (actionToRedo.vectorData) {
                    window.vectorStrokesByImage[currentImageLabel] = window.vectorStrokesByImage[currentImageLabel] || {};
                    window.vectorStrokesByImage[currentImageLabel][actionToRedo.label] = actionToRedo.vectorData;
                    
                    // If no vector data saved in the action, but we're redoing a line/stroke,
                    // try to recreate basic vector data to ensure label display
                    if (!actionToRedo.vectorData && 
                        (actionToRedo.type === 'line' || actionToRedo.type === 'stroke')) {
                        // Create minimal vector data to ensure label display
                        window.vectorStrokesByImage[currentImageLabel][actionToRedo.label] = {
                            points: [
                                { x: canvas.width/2 - 50, y: canvas.height/2 }, // Dummy points
                                { x: canvas.width/2 + 50, y: canvas.height/2 }
                            ],
                            color: actionToRedo.color || "#000000",
                            width: 5,
                            type: actionToRedo.type === 'line' ? 'straight' : 'freehand'
                        };
                    }
                }
                
                // Restore label visibility if we have it
                if (actionToRedo.labelVisible !== undefined) {
                    window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
                    window.strokeLabelVisibility[currentImageLabel][actionToRedo.label] = actionToRedo.labelVisible;
                } else {
                    // Default to visible for new strokes and redone strokes without saved value
                    window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
                    window.strokeLabelVisibility[currentImageLabel][actionToRedo.label] = true;
                }
                
                // Update the next label - make sure it's one higher than the redone label
                const numPart = parseInt(actionToRedo.label.slice(1));
                if (!isNaN(numPart)) {
                    const letterPart = actionToRedo.label[0];
                    const nextNum = numPart + 1;
                    const nextLabel = nextNum > 9 
                        ? String.fromCharCode(letterPart.charCodeAt(0) + 1) + '0' 
                        : letterPart + nextNum;
                    window.labelsByImage[currentImageLabel] = nextLabel;
                    console.log(`Set next label to: ${nextLabel}`);
                } else {
                    // Fallback to the standard next label function
                window.labelsByImage[currentImageLabel] = getNextLabel(currentImageLabel);
                console.log(`Set next label to: ${window.labelsByImage[currentImageLabel]}`);
                }
            }
            
            // Restore the state
            if (actionToRedo.state) {
                const stateToRestore = cloneImageData(actionToRedo.state);
                imageStates[currentImageLabel] = stateToRestore;
                restoreCanvasState(stateToRestore);
                currentStroke = cloneImageData(stateToRestore);
                console.log('Canvas state restored for redo');
            }
            
            // Update all UI elements
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
            
            // Force redraw with visibility to ensure labels appear immediately
            redrawCanvasWithVisibility();
        } else {
            console.log('No redo actions available for this workspace');
        }
    }

    // Save initial blank state
//    saveState();

    // Set canvas size
    function resizeCanvas() {
        // Account for the sidebars and gaps in our calculation (approximately 420px for sidebars + gaps)
        const sidebarSpace = 440;
        const maxWidth = Math.min(window.innerWidth - sidebarSpace, 1000);  // Cap at 1000px width
        const maxHeight = Math.min(window.innerHeight - 100, 800);  // Cap at 800px height
        
        // Save current state before resizing
        const oldState = imageStates[currentImageLabel];
        
        // Resize the canvas
        canvas.width = maxWidth;
        canvas.height = maxHeight;
        
        // Set default canvas styles
        canvas.style.cursor = 'crosshair';
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Restore the image after resize
        if (oldState) {
            // Try to restore from saved state first
            try {
                restoreCanvasState(oldState);
                currentStroke = cloneImageData(oldState);
            } catch (e) {
                // If that fails, redraw from original image
                if (window.originalImages[currentImageLabel]) {
                    const img = new Image();
                    img.onload = () => {
                        // Clear the canvas first
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Get the current scale
                        const scale = imageScaleByLabel[currentImageLabel];
                        const scaledWidth = img.width * scale;
                        const scaledHeight = img.height * scale;
                        
                        // Calculate base position (center of canvas)
                        const centerX = (canvas.width - scaledWidth) / 2;
                        const centerY = (canvas.height - scaledHeight) / 2;
                        
                        // Apply position offset
                        const offsetX = window.imagePositionByLabel[currentImageLabel].x;
                        const offsetY = window.imagePositionByLabel[currentImageLabel].y;
                        
                        // Calculate final position
                        const x = centerX + offsetX;
                        const y = centerY + offsetY;
                        
                        // Draw the original image with scale and position
                        ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                        
                        // Save this as the new state
                        const newState = getCanvasState();
                        imageStates[currentImageLabel] = cloneImageData(newState);
                        currentStroke = cloneImageData(newState);
                    };
                    img.src = window.originalImages[currentImageLabel];
                } else if (!currentStroke) {
                    // Initialize blank state if needed
                    currentStroke = getCanvasState();
                }
            }
        }
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Drawing state
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let points = [];
    let lastVelocity = 0;
    // --- ADD: Track last RAW coordinates ---
    let lastRawX = 0;
    let lastRawY = 0;
    // --- END ADD ---

    // Drawing mode state
    let drawingMode = 'freehand'; // Options: 'freehand', 'straight'
    let straightLineStart = null; // For straight line mode - start point
    let lastDrawnPoint = null;

    /**
     * Transforms raw canvas coordinates to account for image scaling and positioning
     * @param {number} x - Raw x-coordinate from mouse event
     * @param {number} y - Raw y-coordinate from mouse event
     * @returns {Object} Object with transformed x and y coordinates
     */
    function getTransformedCoords(x, y) {
        // Debug logging
        if (window.debugCoordinates) {
            console.log(`[getTransformedCoords] INPUT: Raw canvas coords (${x.toFixed(1)}, ${y.toFixed(1)})`);
        }
        
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
        const position = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 };
        
        // If we have no image dimensions yet (blank canvas), return raw coordinates
        if (!window.originalImageDimensions[currentImageLabel]) {
            if (window.debugCoordinates) {
                console.log(`[getTransformedCoords] No image dimensions - returning raw coords as relative`);
            }
            return { x, y };
        }
        
        // We do have an image, so need to calculate relative coordinates
        const origDims = window.originalImageDimensions[currentImageLabel];
        const scaledWidth = origDims.width * scale;
        const scaledHeight = origDims.height * scale;
        
        // Base position is canvas center minus half the scaled image size
        const imageBaseX = (canvas.width - scaledWidth) / 2;
        const imageBaseY = (canvas.height - scaledHeight) / 2;
        
        // Final image position includes any panning offset
        const finalImageX = imageBaseX + position.x;
        const finalImageY = imageBaseY + position.y;
        
        // Convert the raw canvas coordinates to coordinates relative to the image
        const relativeX = (x - finalImageX) / scale;
        const relativeY = (y - finalImageY) / scale;
        
        if (window.debugCoordinates) {
            console.log(`[getTransformedCoords] Canvas size: ${canvas.width} × ${canvas.height}`);
            console.log(`[getTransformedCoords] Image scale: ${scale}, position: ${JSON.stringify(position)}`);
            console.log(`[getTransformedCoords] Original dimensions: ${JSON.stringify(origDims)}`);
            console.log(`[getTransformedCoords] Scaled dimensions: ${scaledWidth} × ${scaledHeight}`);
            console.log(`[getTransformedCoords] Image position: base(${imageBaseX.toFixed(1)}, ${imageBaseY.toFixed(1)}) + offset => final(${finalImageX.toFixed(1)}, ${finalImageY.toFixed(1)})`);
            console.log(`[getTransformedCoords] OUTPUT: Relative coords (${relativeX.toFixed(1)}, ${relativeY.toFixed(1)})`);
        }
        
        return { x: relativeX, y: relativeY };
    }

    /**
     * Converts relative image coordinates back to canvas coordinates
     * (Inverse of getTransformedCoords)
     * @param {number} imageX_relative - x-coordinate relative to the image
     * @param {number} imageY_relative - y-coordinate relative to the image
     * @returns {Object} Object with canvas x and y coordinates
     */
    function getCanvasCoords(imageX_relative, imageY_relative) {
        // Debug logging
        if (window.debugCoordinates) {
            console.log(`[getCanvasCoords] INPUT: Relative coords (${imageX_relative.toFixed(1)}, ${imageY_relative.toFixed(1)})`);
        }
        
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
        const position = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 };
        
        // If we have no image dimensions yet (blank canvas), return relative coords as-is
        if (!window.originalImageDimensions[currentImageLabel]) {
            if (window.debugCoordinates) {
                console.log(`[getCanvasCoords] No image dimensions - returning relative coords as canvas coords`);
            }
            return { x: imageX_relative, y: imageY_relative };
        }
        
        // We do have an image, calculate canvas coordinates from relative coords
        const origDims = window.originalImageDimensions[currentImageLabel];
        const scaledWidth = origDims.width * scale;
        const scaledHeight = origDims.height * scale;
        
        // Base position is canvas center minus half the scaled image size
        const imageBaseX = (canvas.width - scaledWidth) / 2;
        const imageBaseY = (canvas.height - scaledHeight) / 2;
        
        // Final image position includes any panning offset
        const finalImageX = imageBaseX + position.x;
        const finalImageY = imageBaseY + position.y;
        
        // Calculate final canvas coordinates from image-relative coordinates
        const canvasX = finalImageX + (imageX_relative * scale);
        const canvasY = finalImageY + (imageY_relative * scale);
        
        if (window.debugCoordinates) {
            console.log(`[getCanvasCoords] Canvas size: ${canvas.width} × ${canvas.height}`);
            console.log(`[getCanvasCoords] Image scale: ${scale}, position: ${JSON.stringify(position)}`);
            console.log(`[getCanvasCoords] Original dimensions: ${JSON.stringify(origDims)}`);
            console.log(`[getCanvasCoords] Scaled dimensions: ${scaledWidth} × ${scaledHeight}`);
            console.log(`[getCanvasCoords] Image position: base(${imageBaseX.toFixed(1)}, ${imageBaseY.toFixed(1)}) + offset => final(${finalImageX.toFixed(1)}, ${finalImageY.toFixed(1)})`);
            console.log(`[getCanvasCoords] OUTPUT: Canvas coords (${canvasX.toFixed(1)}, ${canvasY.toFixed(1)})`);
        }
        
        return { x: canvasX, y: canvasY };
    }

    function draw(e) {
        if (!isDrawing) return;

        if (window.debugCoordinates) {
            console.log("--- Draw Event Start ---");
            console.log("[draw] Transform:", ctx.getTransform());
        }

        // Get precise coordinates relative to the canvas
        const rect = canvas.getBoundingClientRect();
        const rawX = e.clientX - rect.left;
        const rawY = e.clientY - rect.top;
        
        if (window.debugCoordinates) {
            console.log(`[draw] Raw mouse coords: (${rawX.toFixed(1)}, ${rawY.toFixed(1)})`);
        }

        // Get current scale for potential use
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;

        // Test round-trip coordinate conversion accuracy
        if (window.debugCoordinates) {
            const roundTrip = getCanvasCoords(getTransformedCoords(rawX, rawY).x, getTransformedCoords(rawX, rawY).y);
            const roundTripError = Math.sqrt(Math.pow(roundTrip.x - rawX, 2) + Math.pow(roundTrip.y - rawY, 2));
            console.log(`[draw] Round-trip coordinate error: ${roundTripError.toFixed(2)} pixels`);
            console.log("--- Draw Event End ---");
        }
    }

// Define global variables for use by project-manager.js
window.IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
window.currentImageLabel = 'front';
window.vectorStrokesByImage = {};
window.strokeVisibilityByImage = {};
window.strokeLabelVisibility = {};
window.strokeMeasurements = {};
window.imageScaleByLabel = {};
window.imagePositionByLabel = {};
window.lineStrokesByImage = {}; // Make sure it's exposed globally
window.labelsByImage = {};      // Make sure it's exposed globally
window.originalImages = {};
window.isLoadingProject = false; // <-- Re-adding this line

// At the top of the file, near other global variables
window.debugCoordinates = false; // Global flag to control coordinate debugging

document.addEventListener('DOMContentLoaded', () => {
    // Initialize unit selectors
    const unitSelector = document.getElementById('unitSelector');
    unitSelector.addEventListener('change', updateMeasurementDisplay);
    
    // Add debug toggle button to the controls
    const controlsContainer = document.querySelector('.controls-container');
    const debugToggle = document.createElement('button');
    debugToggle.textContent = '🐞 Debug';
    debugToggle.classList.add('debug-toggle');
    debugToggle.addEventListener('click', () => {
        window.debugCoordinates = !window.debugCoordinates;
        debugToggle.classList.toggle('active', window.debugCoordinates);
        console.log(`Coordinate debugging ${window.debugCoordinates ? 'enabled' : 'disabled'}`);
    });
    controlsContainer.appendChild(debugToggle);
    
    // Initialize the measurement inputs
    const inchWhole = document.getElementById('inchWhole');
    const inchFraction = document.getElementById('inchFraction');
    const cmValue = document.getElementById('cmValue');
    
    // Handle unit conversion when changing values
    inchWhole.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    inchFraction.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    cmValue.addEventListener('change', () => {
        const cm = parseFloat(cmValue.value) || 0;
        const inches = cm / 2.54;
        
        // Update inch values
        inchWhole.value = Math.floor(inches);
        
        // Find closest fraction
        const fractionPart = inches - Math.floor(inches);
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        inchFraction.value = closestFraction;
        
        // Show inch inputs, hide cm inputs
        document.getElementById('inchInputs').style.display = 'flex';
        document.getElementById('cmInputs').style.display = 'none';
    });
    
    const canvas = document.getElementById('canvas');
    // Expose canvas globally for project management
    window.canvas = canvas;
    const ctx = canvas.getContext('2d', { willReadFrequently: true }); // Add willReadFrequently hint
    const colorPicker = document.getElementById('colorPicker');
    const brushSize = document.getElementById('brushSize');
    const clearButton = document.getElementById('clear');
    const saveButton = document.getElementById('save');
    const pasteButton = document.getElementById('paste');
    const strokeCounter = document.getElementById('strokeCounter');
    const imageList = document.getElementById('imageList');
    const drawingModeToggle = document.getElementById('drawingModeToggle');
    
    // Draggable sidebars
    const strokeSidebar = document.getElementById('strokeSidebar');
    const imageSidebar = document.getElementById('imageSidebar');
    const strokeSidebarHeader = document.getElementById('strokeSidebarHeader');
    const imageSidebarHeader = document.getElementById('imageSidebarHeader');

    // Undo/Redo functionality
    const MAX_HISTORY = 50;  // Maximum number of states to store
    const IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
    let currentImageIndex = 0;
    let imageStates = {}; // Store states for each image
    
    // Use the global variables instead of creating new ones
    let strokeDataByImage = {}; // Store additional data for each stroke
    let undoStackByImage = {}; // Separate undo stack for each image
    let redoStackByImage = {}; // Separate redo stack for each image
    let pastedImages = [];  // Store all pasted images
    let isDrawingOrPasting = false;  // Flag to prevent saving states while drawing
    let strokeInProgress = false;  // Track if we're in the middle of a stroke
    let currentStroke = null;  // Store the state before current stroke
    let originalImageDimensions = {}; // Store original image dimensions for scaling
    let isShiftPressed = false; // Track if Shift key is pressed for image movement
    let calculatedLabelOffsets = {}; // Store automatically calculated label offsets

    // Initialize states for default images
    IMAGE_LABELS.forEach(label => {
        // Ensure we initialize global arrays properly
        window.lineStrokesByImage[label] = [];
        window.strokeVisibilityByImage[label] = {}; // Initialize stroke visibility
        window.vectorStrokesByImage[label] = {}; // Initialize vector stroke data
        window.labelsByImage[label] = 'A1';  // Start from A1 instead of A0
        
        strokeDataByImage[label] = {}; // Initialize stroke data
        undoStackByImage[label] = [];
        redoStackByImage[label] = [];  // Initialize redo stack
        imageStates[label] = null;
        // Initialize scale to 100% (1.0)
        window.imageScaleByLabel[label] = 1.0;
        originalImageDimensions[label] = { width: 0, height: 0 };
        // Initialize position offset to center (0, 0)
        window.imagePositionByLabel[label] = { x: 0, y: 0 };
        // Initialize with a blank state when the image is first created
        const blankState = ctx.createImageData(canvas.width, canvas.height);
        imageStates[label] = blankState;
        undoStackByImage[label].push({
            state: cloneImageData(blankState),
            type: 'initial',
            label: null
        });
    });

    let currentImageLabel = IMAGE_LABELS[0]; // Start with 'front'

    // Make addImageToSidebar available globally for the project manager
    window.addImageToSidebar = addImageToSidebar;
    function addImageToSidebar(imageUrl, label) {
        // *** ADDED LOG ***
        console.log(`[addImageToSidebar] Called for label: ${label}, imageUrl: ${imageUrl ? imageUrl.substring(0,30) + '...' : 'null'}`);

        const container = document.createElement('div');
        container.className = 'image-container';
        container.dataset.label = label;
        container.dataset.originalImageUrl = imageUrl; // Store the original image URL for later restoration
        
        const labelElement = document.createElement('div');
        labelElement.className = 'image-label';
        labelElement.textContent = label.charAt(0).toUpperCase() + label.slice(1);
        
        const strokesElement = document.createElement('div');
        strokesElement.className = 'image-strokes';
        strokesElement.textContent = 'Strokes: 0';
        
        const scaleElement = document.createElement('div');
        scaleElement.className = 'image-scale';
        scaleElement.textContent = `Scale: ${Math.round(imageScaleByLabel[label] * 100)}%`;
        scaleElement.id = `scale-${label}`;
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.className = 'pasted-image';
        img.alt = `${label} view`;
        
        container.appendChild(img);
        container.appendChild(labelElement);
        container.appendChild(strokesElement);
        container.appendChild(scaleElement);
        
        container.onclick = () => {
            // ... rest of the handler
            
            console.log(`Switching from ${currentImageLabel} to ${label}`);
            
            // Ensure we have undo stacks for both workspaces
            undoStackByImage[currentImageLabel] = undoStackByImage[currentImageLabel] || [];
            undoStackByImage[label] = undoStackByImage[label] || [];
            
            // Ensure we have redo stacks for both workspaces
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[label] = redoStackByImage[label] || [];
            
            // Ensure we have stroke lists for both workspaces
            lineStrokesByImage[currentImageLabel] = lineStrokesByImage[currentImageLabel] || [];
            lineStrokesByImage[label] = lineStrokesByImage[label] || [];
            
            // Ensure we have stroke visibility for both workspaces
            strokeVisibilityByImage[currentImageLabel] = strokeVisibilityByImage[currentImageLabel] || {};
            strokeVisibilityByImage[label] = strokeVisibilityByImage[label] || {};
            
            // Save current state before switching
            saveState(true, false);
            
            // Switch to the new image
            switchToImage(label);
        };
        
        // *** ADDED LOGS ***
        const imageListElement = document.getElementById('imageList');
        if (!imageListElement) {
            console.error('[addImageToSidebar] Cannot find #imageList element!');
            return; // Stop if the target doesn't exist
        }
        console.log(`[addImageToSidebar] About to append container for ${label} to #imageList.`);
        imageListElement.appendChild(container);
        console.log(`[addImageToSidebar] Successfully appended container for ${label}. #imageList children: ${imageListElement.childElementCount}`);
    }
    

    // Store the original images for each view
    window.originalImages = window.originalImages || {};
    
    // --- MODIFIED Function Signature and Logic --- 
    function pasteImageFromUrl(url, label) {
        // Wrap in a Promise
        return new Promise((resolve, reject) => {
            console.log(`[pasteImageFromUrl] Pasting image for ${label}: ${url.substring(0, 30)}...`);
        
        const img = new Image();
        img.onload = () => {
            // Store the original image for this view
                window.originalImages[label] = url;
                
                // Ensure the object exists before setting properties
                if (!window.originalImageDimensions) {
                    window.originalImageDimensions = {};
                }
            
            // Store original dimensions for scaling
                window.originalImageDimensions[label] = {
                width: img.width,
                height: img.height
            };
                
                // Log dimensions for debugging
                console.log(`[pasteImageFromUrl] Stored dimensions for ${label}: ${img.width}x${img.height}`);
            
            // Clear the canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply current scale factor
                const scale = imageScaleByLabel[label] || 1.0; // Use passed-in label
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of the canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
                const position = imagePositionByLabel[label] || { x: 0, y: 0 }; // Use passed-in label
                const offsetX = position.x;
                const offsetY = position.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;
            
            // Draw the image with scaling and positioning
                console.log(`[pasteImageFromUrl] Drawing image for ${label} at Canvas(${x.toFixed(1)}, ${y.toFixed(1)}) Scale: ${scale * 100}%`);
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Update the scale display in the sidebar
                const scaleElement = document.getElementById(`scale-${label}`);
            if (scaleElement) {
                scaleElement.textContent = `Scale: ${Math.round(scale * 100)}%`;
            }
            
            // Save this as the base state for this image
            const newState = getCanvasState();
                imageStates[label] = cloneImageData(newState); // Use passed-in label
                console.log(`[pasteImageFromUrl] State saved into imageStates[${label}]`);
                
                // If this is the currently active label, update currentStroke
                if (label === currentImageLabel) {
            currentStroke = cloneImageData(newState);
                }
            
                // Initialize the undo stack if needed
                if (!undoStackByImage[label] || undoStackByImage[label].length === 0) {
                    undoStackByImage[label] = [{
                state: cloneImageData(newState),
                type: 'initial',
                label: null
            }];
                    console.log(`[pasteImageFromUrl] Initialized undo stack for ${label}`);
                }
            
                // Update the scale buttons to show active state if this is the current view
                if (label === currentImageLabel) {
            updateScaleButtonsActiveState();
                }
                
                console.log(`[pasteImageFromUrl] Image loaded and state saved for ${label}`);
                resolve(); // Resolve the promise
            };
            
            img.onerror = (err) => {
                console.error(`[pasteImageFromUrl] Error loading image for ${label}:`, err);
                reject(err); // Reject the promise on error
            };
            
        img.src = url;
        });
    }
    // --- END MODIFIED Function ---

    function getNextLabel(imageLabel) {
        const currentLabel = labelsByImage[imageLabel];
        const letter = currentLabel[0];
        const number = parseInt(currentLabel.slice(1)) + 1;
        if (number > 9) {
            return String.fromCharCode(letter.charCodeAt(0) + 1) + '0';
        }
        return letter + number;
    }

    // Make updateStrokeCounter available globally
    window.updateStrokeCounter = updateStrokeCounter;
    function updateStrokeCounter() {
        const strokeCount = lineStrokesByImage[currentImageLabel]?.length || 0;
        strokeCounter.textContent = `Lines: ${strokeCount}`;
        
        // Update visibility controls
        updateStrokeVisibilityControls();
    }
    
    function updateSidebarStrokeCounts() {
        // Update stroke counts in the sidebar
        const imageContainers = document.querySelectorAll('.image-container');
        imageContainers.forEach(container => {
            const label = container.dataset.label;
            if (label) {
                const strokesElement = container.querySelector('.image-strokes');
                if (strokesElement) {
                    const strokes = lineStrokesByImage[label] || [];
                    strokesElement.textContent = `Strokes: ${strokes.length}`;
                }
            }
        });
        
        // Also update visibility controls when sidebar is updated
        updateStrokeVisibilityControls();
    }

    function getCanvasState() {
        return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    function restoreCanvasState(state) {
        if (!state) return;
        ctx.putImageData(state, 0, 0);
    }
    
    // Measurement data for strokes
    let strokeMeasurements = {};
    
    // Initialize measurement data store
    IMAGE_LABELS.forEach(label => {
        strokeMeasurements[label] = {};
    });
    
    // Function to get formatted measurement string
    function getMeasurementString(strokeLabel) {
        const measurement = strokeMeasurements[currentImageLabel]?.[strokeLabel];
        if (!measurement) return '';
        
        const unit = document.getElementById('unitSelector').value;
        
        if (unit === 'inch') {
            const whole = measurement.inchWhole || 0;
            const fraction = measurement.inchFraction || 0;
            
            // Format as 1 1/4" etc.
            let fractionStr = '';
            if (fraction > 0) {
                const fractionMap = {
                    0.125: '1/8',
                    0.25: '1/4',
                    0.375: '3/8',
                    0.5: '1/2',
                    0.625: '5/8',
                    0.75: '3/4',
                    0.875: '7/8'
                };
                fractionStr = ' ' + fractionMap[fraction];
            }
            
            return `${whole}${fractionStr}"`;
        } else {
            // CM with one decimal
            return `${measurement.cm.toFixed(1)} cm`;
        }
    }
    
    // Function to convert between units
    function convertUnits(from, value) {
        if (from === 'inch') {
            // Convert inch to cm
            return value * 2.54;
        } else {
            // Convert cm to inch
            return value / 2.54;
        }
    }
    
    // Function to update all measurements when unit changes
    function updateMeasurementDisplay() {
        const unit = document.getElementById('unitSelector').value;
        const inchWhole = document.getElementById('inchWhole');
        const inchFraction = document.getElementById('inchFraction');
        const cmValue = document.getElementById('cmValue');
        
        // Convert values when switching between units
        if (unit === 'inch') {
            // Converting from cm to inches
            const cm = parseFloat(cmValue.value) || 0;
            const inches = cm / 2.54;
            
            // Update inch values
            inchWhole.value = Math.floor(inches);
            
            // Find closest fraction
            const fractionPart = inches - Math.floor(inches);
            const fractions = [
                {value: '0', text: '0'},
                {value: '0.125', text: '1/8'},
                {value: '0.25', text: '1/4'},
                {value: '0.375', text: '3/8'},
                {value: '0.5', text: '1/2'},
                {value: '0.625', text: '5/8'},
                {value: '0.75', text: '3/4'},
                {value: '0.875', text: '7/8'}
            ];
            
            fractions.forEach(f => {
                const option = document.createElement('option');
                option.value = f.value;
                option.textContent = f.text;
                if (parseFloat(f.value) === fractionPart) {
                    option.selected = true;
                }
                inchFraction.appendChild(option);
            });
            
            // Show inch inputs, hide cm inputs
            document.getElementById('inchInputs').style.display = 'flex';
            document.getElementById('cmInputs').style.display = 'none';
        } else {
            // Converting from inches to cm
            const whole = parseInt(inchWhole.value) || 0;
            const fraction = parseFloat(inchFraction.value) || 0;
            const totalInches = whole + fraction;
            
            // Update cm value with one decimal point
            cmValue.value = (totalInches * 2.54).toFixed(1);
            
            // Show cm inputs, hide inch inputs
            document.getElementById('inchInputs').style.display = 'none';
            document.getElementById('cmInputs').style.display = 'flex';
        }
        
        // Update the stroke visibility display to show new units
        updateStrokeVisibilityControls();
        
        // Redraw the canvas with updated measurement format in labels
        redrawCanvasWithVisibility();
    }

    // Function to update stroke visibility controls
    // Make updateStrokeVisibilityControls available globally
    window.updateStrokeVisibilityControls = updateStrokeVisibilityControls;
    function updateStrokeVisibilityControls() {
        const controlsContainer = document.getElementById('strokeVisibilityControls');
        controlsContainer.innerHTML = ''; // Clear existing controls
        
        // Add a separator at the top
        const topSeparator = document.createElement('hr');
        controlsContainer.appendChild(topSeparator);
        
        // Display current unit
        const unitDisplay = document.createElement('div');
        unitDisplay.className = 'current-unit-display';
        unitDisplay.textContent = `Current Unit: ${document.getElementById('unitSelector').value === 'inch' ? 'Inches' : 'Centimeters'}`;
        controlsContainer.appendChild(unitDisplay);
        
        // Add another separator
        const separator = document.createElement('hr');
        controlsContainer.appendChild(separator);
        
        // Create strokes list
        const strokesList = document.createElement('div');
        strokesList.id = 'strokesList';
        controlsContainer.appendChild(strokesList);
        
        // Get strokes for current image
        const strokes = lineStrokesByImage[currentImageLabel] || [];
        
        if (strokes.length === 0) {
            strokesList.innerHTML = '<p>No strokes to display</p>';
            return;
        }
        
        // Current unit
        const unit = document.getElementById('unitSelector').value;
        
        // Create visibility toggle for each stroke
        strokes.forEach(strokeLabel => {
            // Initialize visibility if not set
            if (strokeVisibilityByImage[currentImageLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel] = {};
            }
            if (strokeVisibilityByImage[currentImageLabel][strokeLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            }
            
            // Initialize label visibility if not set
            if (strokeLabelVisibility[currentImageLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel] = {};
            }
            if (strokeLabelVisibility[currentImageLabel][strokeLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel][strokeLabel] = true; // Labels visible by default
            }
            
            // Initialize measurement if not set
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            if (strokeMeasurements[currentImageLabel][strokeLabel] === undefined) {
                strokeMeasurements[currentImageLabel][strokeLabel] = {
                    inchWhole: 0,
                    inchFraction: 0,
                    cm: 0.0
                };
            }
            
            const isVisible = strokeVisibilityByImage[currentImageLabel][strokeLabel];
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            const measurement = getMeasurementString(strokeLabel);
            const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
            
            const item = document.createElement('div');
            item.className = 'stroke-visibility-item';
            item.dataset.stroke = strokeLabel;
            item.dataset.selected = isSelected ? 'true' : 'false';
            
            // Make all parts of the item selectable (except checkbox and buttons)
            item.addEventListener('click', (e) => {
                // Don't trigger selection if clicking a button or checkbox
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
                    return;
                }
                
                // Toggle selection (if already selected, deselect it)
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                
                // Update the measurement input with the selected stroke's measurement
                    if (typeof updateMeasurementInputWithStroke === 'function') {
                    updateMeasurementInputWithStroke(strokeLabel);
                }
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `visibility-${strokeLabel}`;
            checkbox.checked = isVisible;
            checkbox.addEventListener('change', () => toggleStrokeVisibility(strokeLabel, checkbox.checked));
            
            const labelContainer = document.createElement('div');
            labelContainer.className = 'stroke-label-container';
            
            // Find the stroke color from the undo stack or vector data
            let strokeColor = '#000';
            let strokeType = 'freehand'; // Default type
            
            if (vectorStrokesByImage[currentImageLabel] && 
                vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                const vectorData = vectorStrokesByImage[currentImageLabel][strokeLabel];
                strokeColor = vectorData.color || '#000';
                strokeType = vectorData.type || 'freehand';
            } else {
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel && action.color) {
                        strokeColor = action.color;
                        // Try to determine stroke type from action
                        if (action.type === 'line') {
                            strokeType = 'straight';
                        }
                        break;
                    }
                }
            }
            
            // Create the stroke name element with color matching the stroke
            const strokeName = document.createElement('span');
            strokeName.className = 'stroke-name';
            strokeName.textContent = strokeLabel;
            strokeName.style.borderColor = strokeColor;
            strokeName.style.color = strokeColor;
            
            // Add a small icon to indicate stroke type (optional)
            if (strokeType === 'straight') {
                strokeName.title = 'Straight Line';
            } else {
                strokeName.title = 'Freehand Stroke';
            }
            
            // Make stroke name label clickable for selection as well
            strokeName.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                
                // Toggle selection 
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            // Create measurement text
            const measureText = document.createElement('span');
            measureText.className = 'stroke-measurement';
            measureText.textContent = measurement ? `= ${measurement}` : '';
            
            // Create edit button
            const editBtn = document.createElement('button');
            editBtn.className = 'stroke-edit-btn';
            editBtn.innerHTML = '✏️';
            editBtn.title = 'Edit Stroke';
            editBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                showEditDialog(strokeLabel);
            };
            
            // Create label toggle button
            const labelToggleBtn = document.createElement('button');
            labelToggleBtn.className = 'stroke-label-toggle';
            labelToggleBtn.classList.toggle('active', isLabelVisible);
            labelToggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            labelToggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            labelToggleBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                toggleLabelVisibility(strokeLabel);
            };
            
            // Add elements to container
            labelContainer.appendChild(strokeName);
            labelContainer.appendChild(measureText);
            labelContainer.appendChild(labelToggleBtn);
            labelContainer.appendChild(editBtn);
            
            // Build the complete item
            item.appendChild(checkbox);
            item.appendChild(labelContainer);
            
            // Add to stroke list
            strokesList.appendChild(item);
        });
    }
    
    // Function to toggle label visibility on canvas
    function toggleLabelVisibility(strokeLabel) {
        // Only toggle the label visibility, not the stroke visibility
        strokeLabelVisibility[currentImageLabel][strokeLabel] = !strokeLabelVisibility[currentImageLabel][strokeLabel];
        
        // Update the UI button appearance
        const toggleBtn = document.querySelector(`.stroke-visibility-item[data-stroke="${strokeLabel}"] .stroke-label-toggle`);
        if (toggleBtn) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            toggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            toggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            toggleBtn.classList.toggle('active', isLabelVisible);
        }
        
        // Redraw the canvas with updated label visibility
        // This should not affect the stroke visibility
        redrawCanvasWithVisibility();
    }
    
// Define global variables for use by project-manager.js
window.IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
window.currentImageLabel = 'front';
window.vectorStrokesByImage = {};
window.strokeVisibilityByImage = {};
window.strokeLabelVisibility = {};
window.strokeMeasurements = {};
window.imageScaleByLabel = {};
window.imagePositionByLabel = {};
window.lineStrokesByImage = {}; // Make sure it's exposed globally
window.labelsByImage = {};      // Make sure it's exposed globally
window.originalImages = {};
window.isLoadingProject = false; // <-- Re-adding this line

// At the top of the file, near other global variables
window.debugCoordinates = false; // Global flag to control coordinate debugging

document.addEventListener('DOMContentLoaded', () => {
    // Initialize unit selectors
    const unitSelector = document.getElementById('unitSelector');
    unitSelector.addEventListener('change', updateMeasurementDisplay);
    
    // Add debug toggle button to the controls
    const controlsContainer = document.querySelector('.controls-container');
    const debugToggle = document.createElement('button');
    debugToggle.textContent = '🐞 Debug';
    debugToggle.classList.add('debug-toggle');
    debugToggle.addEventListener('click', () => {
        window.debugCoordinates = !window.debugCoordinates;
        debugToggle.classList.toggle('active', window.debugCoordinates);
        console.log(`Coordinate debugging ${window.debugCoordinates ? 'enabled' : 'disabled'}`);
    });
    controlsContainer.appendChild(debugToggle);
    
    // Initialize the measurement inputs
    const inchWhole = document.getElementById('inchWhole');
    const inchFraction = document.getElementById('inchFraction');
    const cmValue = document.getElementById('cmValue');
    
    // Handle unit conversion when changing values
    inchWhole.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    inchFraction.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    cmValue.addEventListener('change', () => {
        const cm = parseFloat(cmValue.value) || 0;
        const inches = cm / 2.54;
        
        // Update inch values
        inchWhole.value = Math.floor(inches);
        
        // Find closest fraction
        const fractionPart = inches - Math.floor(inches);
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        inchFraction.value = closestFraction;
        
        // Show inch inputs, hide cm inputs
        document.getElementById('inchInputs').style.display = 'flex';
        document.getElementById('cmInputs').style.display = 'none';
    });
    
    const canvas = document.getElementById('canvas');
    // Expose canvas globally for project management
    window.canvas = canvas;
    const ctx = canvas.getContext('2d', { willReadFrequently: true }); // Add willReadFrequently hint
    const colorPicker = document.getElementById('colorPicker');
    const brushSize = document.getElementById('brushSize');
    const clearButton = document.getElementById('clear');
    const saveButton = document.getElementById('save');
    const pasteButton = document.getElementById('paste');
    const strokeCounter = document.getElementById('strokeCounter');
    const imageList = document.getElementById('imageList');
    const drawingModeToggle = document.getElementById('drawingModeToggle');
    
    // Draggable sidebars
    const strokeSidebar = document.getElementById('strokeSidebar');
    const imageSidebar = document.getElementById('imageSidebar');
    const strokeSidebarHeader = document.getElementById('strokeSidebarHeader');
    const imageSidebarHeader = document.getElementById('imageSidebarHeader');

    // Undo/Redo functionality
    const MAX_HISTORY = 50;  // Maximum number of states to store
    const IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
    let currentImageIndex = 0;
    let imageStates = {}; // Store states for each image
    
    // Use the global variables instead of creating new ones
    let strokeDataByImage = {}; // Store additional data for each stroke
    let undoStackByImage = {}; // Separate undo stack for each image
    let redoStackByImage = {}; // Separate redo stack for each image
    let pastedImages = [];  // Store all pasted images
    let isDrawingOrPasting = false;  // Flag to prevent saving states while drawing
    let strokeInProgress = false;  // Track if we're in the middle of a stroke
    let currentStroke = null;  // Store the state before current stroke
    let originalImageDimensions = {}; // Store original image dimensions for scaling
    let isShiftPressed = false; // Track if Shift key is pressed for image movement
    let calculatedLabelOffsets = {}; // Store automatically calculated label offsets

    // Initialize states for default images
    IMAGE_LABELS.forEach(label => {
        // Ensure we initialize global arrays properly
        window.lineStrokesByImage[label] = [];
        window.strokeVisibilityByImage[label] = {}; // Initialize stroke visibility
        window.vectorStrokesByImage[label] = {}; // Initialize vector stroke data
        window.labelsByImage[label] = 'A1';  // Start from A1 instead of A0
        
        strokeDataByImage[label] = {}; // Initialize stroke data
        undoStackByImage[label] = [];
        redoStackByImage[label] = [];  // Initialize redo stack
        imageStates[label] = null;
        // Initialize scale to 100% (1.0)
        window.imageScaleByLabel[label] = 1.0;
        originalImageDimensions[label] = { width: 0, height: 0 };
        // Initialize position offset to center (0, 0)
        window.imagePositionByLabel[label] = { x: 0, y: 0 };
        // Initialize with a blank state when the image is first created
        const blankState = ctx.createImageData(canvas.width, canvas.height);
        imageStates[label] = blankState;
        undoStackByImage[label].push({
            state: cloneImageData(blankState),
            type: 'initial',
            label: null
        });
    });

    let currentImageLabel = IMAGE_LABELS[0]; // Start with 'front'

    // Make addImageToSidebar available globally for the project manager
    window.addImageToSidebar = addImageToSidebar;
    function addImageToSidebar(imageUrl, label) {
        // *** ADDED LOG ***
        console.log(`[addImageToSidebar] Called for label: ${label}, imageUrl: ${imageUrl ? imageUrl.substring(0,30) + '...' : 'null'}`);

        const container = document.createElement('div');
        container.className = 'image-container';
        container.dataset.label = label;
        container.dataset.originalImageUrl = imageUrl; // Store the original image URL for later restoration
        
        const labelElement = document.createElement('div');
        labelElement.className = 'image-label';
        labelElement.textContent = label.charAt(0).toUpperCase() + label.slice(1);
        
        const strokesElement = document.createElement('div');
        strokesElement.className = 'image-strokes';
        strokesElement.textContent = 'Strokes: 0';
        
        const scaleElement = document.createElement('div');
        scaleElement.className = 'image-scale';
        scaleElement.textContent = `Scale: ${Math.round(imageScaleByLabel[label] * 100)}%`;
        scaleElement.id = `scale-${label}`;
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.className = 'pasted-image';
        img.alt = `${label} view`;
        
        container.appendChild(img);
        container.appendChild(labelElement);
        container.appendChild(strokesElement);
        container.appendChild(scaleElement);
        
        container.onclick = () => {
            // ... rest of the handler
            
            console.log(`Switching from ${currentImageLabel} to ${label}`);
            
            // Ensure we have undo stacks for both workspaces
            undoStackByImage[currentImageLabel] = undoStackByImage[currentImageLabel] || [];
            undoStackByImage[label] = undoStackByImage[label] || [];
            
            // Ensure we have redo stacks for both workspaces
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[label] = redoStackByImage[label] || [];
            
            // Ensure we have stroke lists for both workspaces
            lineStrokesByImage[currentImageLabel] = lineStrokesByImage[currentImageLabel] || [];
            lineStrokesByImage[label] = lineStrokesByImage[label] || [];
            
            // Ensure we have stroke visibility for both workspaces
            strokeVisibilityByImage[currentImageLabel] = strokeVisibilityByImage[currentImageLabel] || {};
            strokeVisibilityByImage[label] = strokeVisibilityByImage[label] || {};
            
            // Save current state before switching
            saveState(true, false);
            
            // Switch to the new image
            switchToImage(label);
        };
        
        // *** ADDED LOGS ***
        const imageListElement = document.getElementById('imageList');
        if (!imageListElement) {
            console.error('[addImageToSidebar] Cannot find #imageList element!');
            return; // Stop if the target doesn't exist
        }
        console.log(`[addImageToSidebar] About to append container for ${label} to #imageList.`);
        imageListElement.appendChild(container);
        console.log(`[addImageToSidebar] Successfully appended container for ${label}. #imageList children: ${imageListElement.childElementCount}`);
    }
    

    // Store the original images for each view
    window.originalImages = window.originalImages || {};
    
    // --- MODIFIED Function Signature and Logic --- 
    function pasteImageFromUrl(url, label) {
        // Wrap in a Promise
        return new Promise((resolve, reject) => {
            console.log(`[pasteImageFromUrl] Pasting image for ${label}: ${url.substring(0, 30)}...`);
        
        const img = new Image();
        img.onload = () => {
            // Store the original image for this view
                window.originalImages[label] = url;
                
                // Ensure the object exists before setting properties
                if (!window.originalImageDimensions) {
                    window.originalImageDimensions = {};
                }
            
            // Store original dimensions for scaling
                window.originalImageDimensions[label] = {
                width: img.width,
                height: img.height
            };
                
                // Log dimensions for debugging
                console.log(`[pasteImageFromUrl] Stored dimensions for ${label}: ${img.width}x${img.height}`);
            
            // Clear the canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply current scale factor
                const scale = imageScaleByLabel[label] || 1.0; // Use passed-in label
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of the canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
                const position = imagePositionByLabel[label] || { x: 0, y: 0 }; // Use passed-in label
                const offsetX = position.x;
                const offsetY = position.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;
            
            // Draw the image with scaling and positioning
                console.log(`[pasteImageFromUrl] Drawing image for ${label} at Canvas(${x.toFixed(1)}, ${y.toFixed(1)}) Scale: ${scale * 100}%`);
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Update the scale display in the sidebar
                const scaleElement = document.getElementById(`scale-${label}`);
            if (scaleElement) {
                scaleElement.textContent = `Scale: ${Math.round(scale * 100)}%`;
            }
            
            // Save this as the base state for this image
            const newState = getCanvasState();
                imageStates[label] = cloneImageData(newState); // Use passed-in label
                console.log(`[pasteImageFromUrl] State saved into imageStates[${label}]`);
                
                // If this is the currently active label, update currentStroke
                if (label === currentImageLabel) {
            currentStroke = cloneImageData(newState);
                }
            
                // Initialize the undo stack if needed
                if (!undoStackByImage[label] || undoStackByImage[label].length === 0) {
                    undoStackByImage[label] = [{
                state: cloneImageData(newState),
                type: 'initial',
                label: null
            }];
                    console.log(`[pasteImageFromUrl] Initialized undo stack for ${label}`);
                }
            
                // Update the scale buttons to show active state if this is the current view
                if (label === currentImageLabel) {
            updateScaleButtonsActiveState();
                }
                
                console.log(`[pasteImageFromUrl] Image loaded and state saved for ${label}`);
                resolve(); // Resolve the promise
            };
            
            img.onerror = (err) => {
                console.error(`[pasteImageFromUrl] Error loading image for ${label}:`, err);
                reject(err); // Reject the promise on error
            };
            
        img.src = url;
        });
    }
    // --- END MODIFIED Function ---

    function getNextLabel(imageLabel) {
        const currentLabel = labelsByImage[imageLabel];
        const letter = currentLabel[0];
        const number = parseInt(currentLabel.slice(1)) + 1;
        if (number > 9) {
            return String.fromCharCode(letter.charCodeAt(0) + 1) + '0';
        }
        return letter + number;
    }

    // Make updateStrokeCounter available globally
    window.updateStrokeCounter = updateStrokeCounter;
    function updateStrokeCounter() {
        const strokeCount = lineStrokesByImage[currentImageLabel]?.length || 0;
        strokeCounter.textContent = `Lines: ${strokeCount}`;
        
        // Update visibility controls
        updateStrokeVisibilityControls();
    }
    
    function updateSidebarStrokeCounts() {
        // Update stroke counts in the sidebar
        const imageContainers = document.querySelectorAll('.image-container');
        imageContainers.forEach(container => {
            const label = container.dataset.label;
            if (label) {
                const strokesElement = container.querySelector('.image-strokes');
                if (strokesElement) {
                    const strokes = lineStrokesByImage[label] || [];
                    strokesElement.textContent = `Strokes: ${strokes.length}`;
                }
            }
        });
        
        // Also update visibility controls when sidebar is updated
        updateStrokeVisibilityControls();
    }

    function getCanvasState() {
        return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    function restoreCanvasState(state) {
        if (!state) return;
        ctx.putImageData(state, 0, 0);
    }
    
    // Measurement data for strokes
    let strokeMeasurements = {};
    
    // Initialize measurement data store
    IMAGE_LABELS.forEach(label => {
        strokeMeasurements[label] = {};
    });
    
    // Function to get formatted measurement string
    function getMeasurementString(strokeLabel) {
        const measurement = strokeMeasurements[currentImageLabel]?.[strokeLabel];
        if (!measurement) return '';
        
        const unit = document.getElementById('unitSelector').value;
        
        if (unit === 'inch') {
            const whole = measurement.inchWhole || 0;
            const fraction = measurement.inchFraction || 0;
            
            // Format as 1 1/4" etc.
            let fractionStr = '';
            if (fraction > 0) {
                const fractionMap = {
                    0.125: '1/8',
                    0.25: '1/4',
                    0.375: '3/8',
                    0.5: '1/2',
                    0.625: '5/8',
                    0.75: '3/4',
                    0.875: '7/8'
                };
                fractionStr = ' ' + fractionMap[fraction];
            }
            
            return `${whole}${fractionStr}"`;
        } else {
            // CM with one decimal
            return `${measurement.cm.toFixed(1)} cm`;
        }
    }
    
    // Function to convert between units
    function convertUnits(from, value) {
        if (from === 'inch') {
            // Convert inch to cm
            return value * 2.54;
        } else {
            // Convert cm to inch
            return value / 2.54;
        }
    }
    
    // Function to update all measurements when unit changes
    function updateMeasurementDisplay() {
        const unit = document.getElementById('unitSelector').value;
        const inchWhole = document.getElementById('inchWhole');
        const inchFraction = document.getElementById('inchFraction');
        const cmValue = document.getElementById('cmValue');
        
        // Convert values when switching between units
        if (unit === 'inch') {
            // Converting from cm to inches
            const cm = parseFloat(cmValue.value) || 0;
            const inches = cm / 2.54;
            
            // Update inch values
            inchWhole.value = Math.floor(inches);
            
            // Find closest fraction
            const fractionPart = inches - Math.floor(inches);
            const fractions = [
                {value: '0', text: '0'},
                {value: '0.125', text: '1/8'},
                {value: '0.25', text: '1/4'},
                {value: '0.375', text: '3/8'},
                {value: '0.5', text: '1/2'},
                {value: '0.625', text: '5/8'},
                {value: '0.75', text: '3/4'},
                {value: '0.875', text: '7/8'}
            ];
            
            fractions.forEach(f => {
                const option = document.createElement('option');
                option.value = f.value;
                option.textContent = f.text;
                if (parseFloat(f.value) === fractionPart) {
                    option.selected = true;
                }
                inchFraction.appendChild(option);
            });
            
            // Show inch inputs, hide cm inputs
            document.getElementById('inchInputs').style.display = 'flex';
            document.getElementById('cmInputs').style.display = 'none';
        } else {
            // Converting from inches to cm
            const whole = parseInt(inchWhole.value) || 0;
            const fraction = parseFloat(inchFraction.value) || 0;
            const totalInches = whole + fraction;
            
            // Update cm value with one decimal point
            cmValue.value = (totalInches * 2.54).toFixed(1);
            
            // Show cm inputs, hide inch inputs
            document.getElementById('inchInputs').style.display = 'none';
            document.getElementById('cmInputs').style.display = 'flex';
        }
        
        // Update the stroke visibility display to show new units
        updateStrokeVisibilityControls();
        
        // Redraw the canvas with updated measurement format in labels
        redrawCanvasWithVisibility();
    }

    // Function to update stroke visibility controls
    // Make updateStrokeVisibilityControls available globally
    window.updateStrokeVisibilityControls = updateStrokeVisibilityControls;
    function updateStrokeVisibilityControls() {
        const controlsContainer = document.getElementById('strokeVisibilityControls');
        controlsContainer.innerHTML = ''; // Clear existing controls
        
        // Add a separator at the top
        const topSeparator = document.createElement('hr');
        controlsContainer.appendChild(topSeparator);
        
        // Display current unit
        const unitDisplay = document.createElement('div');
        unitDisplay.className = 'current-unit-display';
        unitDisplay.textContent = `Current Unit: ${document.getElementById('unitSelector').value === 'inch' ? 'Inches' : 'Centimeters'}`;
        controlsContainer.appendChild(unitDisplay);
        
        // Add another separator
        const separator = document.createElement('hr');
        controlsContainer.appendChild(separator);
        
        // Create strokes list
        const strokesList = document.createElement('div');
        strokesList.id = 'strokesList';
        controlsContainer.appendChild(strokesList);
        
        // Get strokes for current image
        const strokes = lineStrokesByImage[currentImageLabel] || [];
        
        if (strokes.length === 0) {
            strokesList.innerHTML = '<p>No strokes to display</p>';
            return;
        }
        
        // Current unit
        const unit = document.getElementById('unitSelector').value;
        
        // Create visibility toggle for each stroke
        strokes.forEach(strokeLabel => {
            // Initialize visibility if not set
            if (strokeVisibilityByImage[currentImageLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel] = {};
            }
            if (strokeVisibilityByImage[currentImageLabel][strokeLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            }
            
            // Initialize label visibility if not set
            if (strokeLabelVisibility[currentImageLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel] = {};
            }
            if (strokeLabelVisibility[currentImageLabel][strokeLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel][strokeLabel] = true; // Labels visible by default
            }
            
            // Initialize measurement if not set
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            if (strokeMeasurements[currentImageLabel][strokeLabel] === undefined) {
                strokeMeasurements[currentImageLabel][strokeLabel] = {
                    inchWhole: 0,
                    inchFraction: 0,
                    cm: 0.0
                };
            }
            
            const isVisible = strokeVisibilityByImage[currentImageLabel][strokeLabel];
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            const measurement = getMeasurementString(strokeLabel);
            const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
            
            const item = document.createElement('div');
            item.className = 'stroke-visibility-item';
            item.dataset.stroke = strokeLabel;
            item.dataset.selected = isSelected ? 'true' : 'false';
            
            // Make all parts of the item selectable (except checkbox and buttons)
            item.addEventListener('click', (e) => {
                // Don't trigger selection if clicking a button or checkbox
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
                    return;
                }
                
                // Toggle selection (if already selected, deselect it)
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                
                // Update the measurement input with the selected stroke's measurement
                    if (typeof updateMeasurementInputWithStroke === 'function') {
                    updateMeasurementInputWithStroke(strokeLabel);
                }
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `visibility-${strokeLabel}`;
            checkbox.checked = isVisible;
            checkbox.addEventListener('change', () => toggleStrokeVisibility(strokeLabel, checkbox.checked));
            
            const labelContainer = document.createElement('div');
            labelContainer.className = 'stroke-label-container';
            
            // Find the stroke color from the undo stack or vector data
            let strokeColor = '#000';
            let strokeType = 'freehand'; // Default type
            
            if (vectorStrokesByImage[currentImageLabel] && 
                vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                const vectorData = vectorStrokesByImage[currentImageLabel][strokeLabel];
                strokeColor = vectorData.color || '#000';
                strokeType = vectorData.type || 'freehand';
            } else {
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel && action.color) {
                        strokeColor = action.color;
                        // Try to determine stroke type from action
                        if (action.type === 'line') {
                            strokeType = 'straight';
                        }
                        break;
                    }
                }
            }
            
            // Create the stroke name element with color matching the stroke
            const strokeName = document.createElement('span');
            strokeName.className = 'stroke-name';
            strokeName.textContent = strokeLabel;
            strokeName.style.borderColor = strokeColor;
            strokeName.style.color = strokeColor;
            
            // Add a small icon to indicate stroke type (optional)
            if (strokeType === 'straight') {
                strokeName.title = 'Straight Line';
            } else {
                strokeName.title = 'Freehand Stroke';
            }
            
            // Make stroke name label clickable for selection as well
            strokeName.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent double handling with the item click
                
                // Toggle selection 
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            // Create measurement text
            const measureText = document.createElement('span');
            measureText.className = 'stroke-measurement';
            measureText.textContent = measurement ? `= ${measurement}` : '';
            
            // Create edit button
            const editBtn = document.createElement('button');
            editBtn.className = 'stroke-edit-btn';
            editBtn.innerHTML = '✏️';
            editBtn.title = 'Edit Stroke';
            editBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                showEditDialog(strokeLabel);
            };
            
            // Create label toggle button
            const labelToggleBtn = document.createElement('button');
            labelToggleBtn.className = 'stroke-label-toggle';
            labelToggleBtn.classList.toggle('active', isLabelVisible);
            labelToggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            labelToggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            labelToggleBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                toggleLabelVisibility(strokeLabel);
            };
            
            // Add elements to container
            labelContainer.appendChild(strokeName);
            labelContainer.appendChild(measureText);
            labelContainer.appendChild(labelToggleBtn);
            labelContainer.appendChild(editBtn);
            
            // Build the complete item
            item.appendChild(checkbox);
            item.appendChild(labelContainer);
            
            // Add to stroke list
            strokesList.appendChild(item);
        });
    }
    
    // Function to toggle label visibility on canvas
    function toggleLabelVisibility(strokeLabel) {
        // Only toggle the label visibility, not the stroke visibility
        strokeLabelVisibility[currentImageLabel][strokeLabel] = !strokeLabelVisibility[currentImageLabel][strokeLabel];
        
        // Update the UI button appearance
        const toggleBtn = document.querySelector(`.stroke-visibility-item[data-stroke="${strokeLabel}"] .stroke-label-toggle`);
        if (toggleBtn) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            toggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            toggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            toggleBtn.classList.toggle('active', isLabelVisible);
        }
        
        // Redraw the canvas with updated label visibility
        // This should not affect the stroke visibility
        redrawCanvasWithVisibility();
    }
    
    // Function to update measurement input with selected stroke's value
    // Function to display a measurement edit dialog
    function showMeasurementDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurement
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Measurement for ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values from inputs
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Determine which unit was changed last and use that value
            const currentUnit = document.getElementById('unitSelector').value;
            let finalCmValue, finalInchWhole, finalInchFraction;
            
            if (currentUnit === 'inch') {
                finalInchWhole = wholeValue;
                finalInchFraction = fractionValue;
                finalCmValue = convertUnits('inch', wholeValue + fractionValue);
            } else {
                finalCmValue = cmValue;
                // Calculate inch equivalent
                const inches = convertUnits('cm', cmValue);
                finalInchWhole = Math.floor(inches);
                finalInchFraction = findClosestFraction(inches - finalInchWhole);
            }
            
            // Update the measurement
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            
            strokeMeasurements[currentImageLabel][strokeLabel] = {
                inchWhole: finalInchWhole,
                inchFraction: finalInchFraction,
                cm: finalCmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update the UI
            updateStrokeVisibilityControls();
            
            // Redraw with the new measurement
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Helper function to find the closest fraction
    function findClosestFraction(fractionPart) {
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        return closestFraction;
    }
    
    // Function to show edit dialog for a stroke
    function showEditDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurements
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Stroke ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Create name edit field
        const nameContainer = document.createElement('div');
        nameContainer.className = 'name-container';
        
        const nameLabel = document.createElement('div');
        nameLabel.textContent = 'Label:';
        nameContainer.appendChild(nameLabel);
        
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = strokeLabel;
        nameInput.placeholder = 'Label';
        nameContainer.appendChild(nameInput);
        
        dialog.appendChild(nameContainer);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Sync between inch and cm inputs
        wholeInput.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        fractionSelect.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        cmInput.addEventListener('change', () => {
            const cmValue = parseFloat(cmInput.value) || 0;
            const inches = convertUnits('cm', cmValue);
            const wholeValue = Math.floor(inches);
            const fractionValue = findClosestFraction(inches - wholeValue);
            
            wholeInput.value = wholeValue;
            fractionSelect.value = fractionValue.toString();
        });
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values
            const newName = nameInput.value.trim();
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Update name if changed
            let finalName = strokeLabel;
            if (newName !== strokeLabel && newName !== '') {
                // The unique name generation is handled inside renameStroke
                finalName = renameStroke(strokeLabel, newName);
                
                // Show feedback if name was modified to make it unique
                if (finalName !== newName) {
                    console.log(`Stroke name automatically adjusted to ${finalName} to avoid duplicates`);
                    
                    // Create and show a temporary notification
                    const notification = document.createElement('div');
                    notification.style.position = 'fixed';
                    notification.style.bottom = '20px';
                    notification.style.left = '50%';
                    notification.style.transform = 'translateX(-50%)';
                    notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                    notification.style.color = 'white';
                    notification.style.padding = '10px 20px';
                    notification.style.borderRadius = '4px';
                    notification.style.zIndex = '10000';
                    notification.textContent = `Renamed to ${finalName} to avoid duplicates`;
                    
                    document.body.appendChild(notification);
                    
                    // Remove after 3 seconds
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 3000);
                }
            }
            
            // Always save both units
            strokeMeasurements[currentImageLabel][finalName] = {
                inchWhole: wholeValue,
                inchFraction: fractionValue,
                cm: cmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update UI
            updateStrokeVisibilityControls();
            
            // Redraw to show updated measurements
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Function to generate a unique stroke name
    function generateUniqueStrokeName(baseName) {
        // If the name is empty or undefined, use a default name
        if (!baseName || baseName.trim() === '') {
            baseName = 'A1';
        }
        
        // If the base name doesn't already exist, we can use it as is
        if (!lineStrokesByImage[currentImageLabel] || 
            !lineStrokesByImage[currentImageLabel].includes(baseName)) {
            return baseName;
        }
        
        // Name already exists, so we need to add a number
        // Extract the base part and any existing numbering
        const match = baseName.match(/^(.+?)(?:\((\d+)\))?$/);
        if (!match) {
            // If the regex didn't match for some reason, append (1) to the name
            return `${baseName}(1)`;
        }
        
        const base = match[1];
        let counter = 1;
        
        // If there was already a number, start from the next one
        if (match[2]) {
            counter = parseInt(match[2]) + 1;
        }
        
        // Keep incrementing until we find a unique name
        let newName;
        do {
            newName = `${base}(${counter})`;
            counter++;
        } while (lineStrokesByImage[currentImageLabel].includes(newName));
        
        return newName;
    }
    
    // Function to rename a stroke
    function renameStroke(oldName, newName) {
        if (oldName === newName) return;
        
        // Generate a unique name if needed - this ensures the new name won't conflict
        // with any existing stroke names, including itself
        const uniqueNewName = generateUniqueStrokeName(newName);
        
        // Find the stroke color from the undo stack or vector data to maintain color after rename
        let strokeColor = '#000';
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            strokeColor = vectorStrokesByImage[currentImageLabel][oldName].color || '#000';
        } else {
            for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                const action = undoStackByImage[currentImageLabel][i];
                if (action.label === oldName && action.color) {
                    strokeColor = action.color;
                    // Try to determine stroke type from action
                    if (action.type === 'line') {
                        strokeType = 'straight';
                    }
                    break;
                }
            }
        }
        
        // Update all relevant data structures
        if (lineStrokesByImage[currentImageLabel]) {
            const index = lineStrokesByImage[currentImageLabel].indexOf(oldName);
            if (index !== -1) {
                lineStrokesByImage[currentImageLabel][index] = uniqueNewName;
            }
        }
        
        // Update visibility
        if (strokeVisibilityByImage[currentImageLabel] && 
            strokeVisibilityByImage[currentImageLabel][oldName] !== undefined) {
            const isVisible = strokeVisibilityByImage[currentImageLabel][oldName];
            strokeVisibilityByImage[currentImageLabel][uniqueNewName] = isVisible;
            delete strokeVisibilityByImage[currentImageLabel][oldName];
        }
        
        // Update label visibility
        if (strokeLabelVisibility[currentImageLabel] && 
            strokeLabelVisibility[currentImageLabel][oldName] !== undefined) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][oldName];
            strokeLabelVisibility[currentImageLabel][uniqueNewName] = isLabelVisible;
            delete strokeLabelVisibility[currentImageLabel][oldName];
        }
        
        // Update stroke data
        if (strokeDataByImage[currentImageLabel] && 
            strokeDataByImage[currentImageLabel][oldName]) {
            strokeDataByImage[currentImageLabel][uniqueNewName] = 
                strokeDataByImage[currentImageLabel][oldName];
            delete strokeDataByImage[currentImageLabel][oldName];
        }
        
        // Update vector data
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            vectorStrokesByImage[currentImageLabel][uniqueNewName] = 
                vectorStrokesByImage[currentImageLabel][oldName];
            delete vectorStrokesByImage[currentImageLabel][oldName];
        }
        
        // Update measurements
        if (strokeMeasurements[currentImageLabel] && 
            strokeMeasurements[currentImageLabel][oldName]) {
            strokeMeasurements[currentImageLabel][uniqueNewName] = 
                strokeMeasurements[currentImageLabel][oldName];
            delete strokeMeasurements[currentImageLabel][oldName];
        }
        
        // Update next label if needed
        if (labelsByImage[currentImageLabel] === oldName) {
            labelsByImage[currentImageLabel] = uniqueNewName;
        }
        
        // Update any references in the undo/redo stacks
        if (undoStackByImage[currentImageLabel]) {
            undoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        if (redoStackByImage[currentImageLabel]) {
            redoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        // Return the actual name used for the stroke (either the original or the uniquified version)
        return uniqueNewName;
    }
    
    // Function to toggle stroke visibility
    function toggleStrokeVisibility(strokeLabel, isVisible) {
        console.log(`Toggling visibility of stroke ${strokeLabel} to ${isVisible}`);
        
        // Update visibility state
        strokeVisibilityByImage[currentImageLabel][strokeLabel] = isVisible;
        
        // Make sure the stroke data is still available and not accidentally cleared
        if (isVisible) {
            // Initialize vectorStrokesByImage for this image if it doesn't exist
            if (!vectorStrokesByImage[currentImageLabel]) {
                vectorStrokesByImage[currentImageLabel] = {};
            }
            
            // If we're making a stroke visible, ensure we still have vector data
            if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                console.log(`Vector data missing for ${strokeLabel}, attempting recovery`);
                
                // Try to recover vector data from the undo stack
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel) {
                        if (action.vectorData) {
                            vectorStrokesByImage[currentImageLabel][strokeLabel] = action.vectorData;
                            console.log(`Recovered vector data for ${strokeLabel}`);
                            break;
                        }
                    }
                }
                
                // If we still couldn't recover the vector data, create a basic one
                // This is especially important for straight lines
                if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                    console.log(`Creating default vector data for ${strokeLabel}`);
                    
                    // Look for color and properties in the undo stack
                    let strokeColor = "#000000";
                    let strokeWidth = 5;
                    let isLine = false;
                    
                    for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                        const action = undoStackByImage[currentImageLabel][i];
                        if (action.label === strokeLabel) {
                            if (action.color) strokeColor = action.color;
                            if (action.width) strokeWidth = action.width;
                            if (action.type === 'line' || action.type === 'straight') isLine = true;
                            break;
                        }
                    }
                    
                    // Create a simple vector representation (placeholder)
                    vectorStrokesByImage[currentImageLabel][strokeLabel] = {
                        points: isLine ? [{x: 0, y: 0}, {x: 1, y: 1}] : [{x: 0, y: 0}],
                        color: strokeColor,
                        width: strokeWidth,
                        type: isLine ? 'straight' : 'freehand'
                    };
                }
            }
        };

        // *** Add redraw call here ***
        redrawCanvasWithVisibility();
    }
    
    // Store for currently selected stroke in each image
    let selectedStrokeByImage = {};
    
    // Initialize stroke label visibility for each image (default to visible)
    IMAGE_LABELS.forEach(label => {
        strokeLabelVisibility[label] = {};
        selectedStrokeByImage[label] = null; // Initialize with no selection
    });
    
    // Store for label custom positions (user-dragged positions)
    let customLabelPositions = {};
    
    // Flag to track if we're dragging a label
    let isDraggingLabel = false;
    let draggedLabelStroke = null;
    let dragStartX = 0;
    let dragStartY = 0;
    
    // Initialize custom label positions for each image
    IMAGE_LABELS.forEach(label => {
        customLabelPositions[label] = {};
    });
    
    // Cache for loaded images to prevent flickering
    const imageCache = {};
    
    // Store for label positions to prevent overlapping
    let currentLabelPositions = [];
    
    // Store for stroke paths to avoid overlapping with lines
    let currentStrokePaths = [];
    
    // Function to redraw canvas respecting stroke visibility
    // Make redrawCanvasWithVisibility available globally
    window.redrawCanvasWithVisibility = redrawCanvasWithVisibility;
    function redrawCanvasWithVisibility() {
        console.log(`--- redrawCanvasWithVisibility called for: ${currentImageLabel} ---`);
        
        // *** Save context and reset transform before drawing anything ***
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset to identity matrix
        console.log("Redraw Start Transform:", ctx.getTransform());
        
        // ADDED: Ensure originalImageDimensions exists and has an entry for this label
        if (!window.originalImageDimensions) {
            window.originalImageDimensions = {};
        }
        
        // ADDED: If we don't have dimensions for this label but we're trying to draw strokes,
        // create default dimensions based on the canvas size to prevent coordinates from being lost
        if (!window.originalImageDimensions[currentImageLabel] && 
            window.vectorStrokesByImage[currentImageLabel] && 
            Object.keys(window.vectorStrokesByImage[currentImageLabel]).length > 0) {
            
            console.log(`Creating default dimensions for ${currentImageLabel} to preserve strokes`);
            window.originalImageDimensions[currentImageLabel] = {
                width: canvas.width,
                height: canvas.height
            };
            console.log(`Set dimensions to match canvas: ${canvas.width}x${canvas.height}`);
        }
        
        // Reset label positions and stroke paths for this redraw
        currentLabelPositions = [];
        currentStrokePaths = [];
        
        // Create a copy of custom label positions for tracking which ones were actually used
        const usedCustomPositions = {};
        
        // We need to rebuild the canvas from scratch using individual stroke data
        const strokes = window.lineStrokesByImage[currentImageLabel] || [];
        
        // Start with a blank canvas or the original image if available
        if (window.originalImages && window.originalImages[currentImageLabel]) {
            // Check if we already have this image in the cache
            const imageUrl = window.originalImages[currentImageLabel];
            
            if (imageCache[imageUrl]) {
                // Use cached image immediately
                drawImageAndStrokes(imageCache[imageUrl]);
            } else {
                // Load the image and cache it
                const img = new Image();
                img.onload = () => {
                    // Add to cache
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                };
                img.src = imageUrl;
                
                // If the image is already cached in the browser, it might be immediately available
                if (img.complete) {
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                } else {
                    // If the image isn't immediately available,
                    // still draw the strokes on a blank canvas so they don't disappear
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the current scale and position
                    const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
                    
                    // For blank canvas mode, we apply the position directly when drawing points
                    // We pass 0,0 for position here since we'll apply it inside applyVisibleStrokes
                    applyVisibleStrokes(scale, 0, 0);
                }
            }
        } else {
            // Otherwise start with a blank canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white'; // Add white background fill
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Get the current scale for the blank canvas state
            const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
            
            // Apply visible strokes - for blank canvas mode, we don't need to apply position offset here
            // since we'll apply it to each point when drawing
            applyVisibleStrokes(scale, 0, 0);
        }
        
        function drawImageAndStrokes(img) {
            // Clear only once within the reset transform state
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply scale
            const scale = window.imageScaleByLabel[currentImageLabel];
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
            const positionOffset = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 }; // Ensure offset exists
            const offsetX = positionOffset.x;
            const offsetY = positionOffset.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;

            // *** ADDED LOGGING ***
            // console.log(`drawImageAndStrokes Calculation:
            //   canvas.width=${canvas.width}, img.width=${img.width}, scaledWidth=${scaledWidth}
            //   scale=${scale}, centerX=${centerX}, offsetX=${offsetX}, final imageX (passed to applyVisibleStrokes)=${x}`);
            // *** END LOGGING ***
            
            // Draw the image with scaling and positioning
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Then apply visible strokes
            applyVisibleStrokes(scale, x, y);
+
+           // Finalize after drawing strokes
+           finalizeRedraw();
        }
        
        function applyVisibleStrokes(scale, imageX, imageY) {
+           console.log("ApplyStrokes Start Transform:", ctx.getTransform()); // Log transform at start
            // console.log(`\nApplying strokes with scale=${scale}, imageX=${imageX}, imageY=${imageY}`); // Keep this commented unless debugging scale/position
            const strokes = window.vectorStrokesByImage[currentImageLabel] || {};
            const strokeOrder = window.lineStrokesByImage[currentImageLabel] || [];
            const visibility = window.strokeVisibilityByImage[currentImageLabel] || {};

            // Loop through strokes in their drawing order
            strokeOrder.forEach((strokeLabel) => {
                const isVisible = visibility[strokeLabel];
                if (!isVisible) return; // Skip invisible strokes

                const vectorData = strokes[strokeLabel];
                // Ensure vectorData and points exist
                if (!vectorData || !vectorData.points || vectorData.points.length === 0) {
                     console.warn(`Skipping stroke ${strokeLabel} in redraw: Missing vector data or points.`);
                     return;
                }

                // Set stroke style based on stored data, scaled by CURRENT scale
                ctx.strokeStyle = vectorData.color || '#000000';
                // *** FIX: Ensure lineWidth uses original stored width * current scale ***
                const scaledLineWidth = (vectorData.width || 5) * scale;
                ctx.lineWidth = scaledLineWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Start drawing the path
                ctx.beginPath();

                // Transform the first point from relative to canvas coordinates
                const firstPointRelative = vectorData.points[0];
                const firstPointCanvas = getCanvasCoords(firstPointRelative.x, firstPointRelative.y);
                ctx.moveTo(firstPointCanvas.x, firstPointCanvas.y);

                // Store canvas path for label collision detection
                const strokePath = [{ x: firstPointCanvas.x, y: firstPointCanvas.y }];

                // Check if this is a straight line (only two points)
                const isStraightLine = vectorData.type === 'straight' || (vectorData.points.length === 2 && !vectorData.type);

                if (isStraightLine && vectorData.points.length >= 2) {
                    // Straight Line: Transform only the last point
                    const lastPointRelative = vectorData.points[vectorData.points.length - 1];
                    const lastPointCanvas = getCanvasCoords(lastPointRelative.x, lastPointRelative.y);
                    ctx.lineTo(lastPointCanvas.x, lastPointCanvas.y);
                    strokePath.push({ x: lastPointCanvas.x, y: lastPointCanvas.y });
                } else {
                    // Freehand: Transform ALL subsequent points
                    for (let i = 1; i < vectorData.points.length; i++) {
                        const pointRelative = vectorData.points[i];
                        // *** FIX: Apply getCanvasCoords to EACH subsequent point ***
                        const pointCanvas = getCanvasCoords(pointRelative.x, pointRelative.y);
                        ctx.lineTo(pointCanvas.x, pointCanvas.y);
                        strokePath.push({ x: pointCanvas.x, y: pointCanvas.y });
                         // Optional logging for debugging coordinate drift:
                         // if (i < 3 || i % 20 === 0) { // Log first few and then every 20th
                         //     console.log(`  Redraw Pt ${i} Rel:(${pointRelative.x.toFixed(1)}, ${pointRelative.y.toFixed(1)}) -> Canv:(${pointCanvas.x.toFixed(1)}, ${pointCanvas.y.toFixed(1)})`);
                         // }
                    }
                }

                // Apply selection highlighting if needed (before stroking)
                const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                if (isSelected) {
                    ctx.save();
                    ctx.shadowColor = '#ffffff'; // White glow
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                }

                // Stroke the path
                ctx.stroke();

                // Restore context if selection highlighting was applied
                if (isSelected) {
                    ctx.restore();
                }

                // Store the calculated canvas path and scaled width for label positioning
                currentStrokePaths.push({
                    label: strokeLabel,
                    path: strokePath, // Store canvas coordinates path
                     // *** FIX: Store correctly scaled width ***
                    width: scaledLineWidth,
                    color: vectorData.color
                });
            }); // End of strokeOrder.forEach

            // --- Label Drawing Logic ---
            // console.log(`--- Redraw: Drawing Labels for ${currentImageLabel} ---`);
            currentLabelPositions = [];
            const usedCustomPositions = {};

            strokeOrder.forEach((strokeLabel) => {
                const isStrokeVisible = visibility[strokeLabel];
                if (!strokeLabelVisibility[currentImageLabel]) strokeLabelVisibility[currentImageLabel] = {};
                const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel] !== false; // Default true
                const vectorData = strokes[strokeLabel];

                if (isStrokeVisible && isLabelVisible && vectorData && vectorData.points.length > 0) {
                    const measurement = getMeasurementString(strokeLabel);
                    const labelText = measurement ? `${strokeLabel}=${measurement}` : strokeLabel;

                    // Determine anchor point (middle of the stroke) using RELATIVE coordinates
                    let anchorPointRelative = { x: 0, y: 0 };
                    const midIndex = Math.floor(vectorData.points.length / 2);
                    anchorPointRelative = vectorData.points[midIndex];

                    // Convert anchor point to CURRENT canvas coordinates
                    const anchorPointCanvas = getCanvasCoords(anchorPointRelative.x, anchorPointRelative.y);

                    if (isNaN(anchorPointCanvas.x) || isNaN(anchorPointCanvas.y)) {
                         console.error(`      Error getting canvas coords for label anchor for ${strokeLabel}. Relative point:`, anchorPointRelative);
                         return; // Skip label if anchor is invalid
                    }

                    // Set label style
                    // Increase font size for better visibility, especially when scaled
                    const baseFontSize = 14;
                    const scaledFontSize = Math.max(10, Math.min(28, baseFontSize / scale)); // Adjust font size based on zoom, within limits
                    ctx.font = `${scaledFontSize}px Arial`;
                    const labelColor = vectorData.color || '#000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';

                    // Calculate label dimensions based on current font size
                    const metrics = ctx.measureText(labelText);
                    const padding = 6 / scale; // Scale padding inversely
                    const labelWidth = metrics.width + padding * 2;
                    const labelHeight = scaledFontSize + padding * 2; // Adjust height based on font size

                    // Initial label rectangle guess (used for optimal position calculation)
                     const initialLabelRect = {
                        width: labelWidth,
                        height: labelHeight,
                        x: anchorPointCanvas.x - labelWidth / 2,
                        y: anchorPointCanvas.y - labelHeight - (15 / scale), // Scale vertical offset
                        strokeLabel: strokeLabel
                    };

                    // Determine final label position
                    let finalPosition; // This will be canvas coordinates {x, y} for the top-left of the label
                    let offset = null; // Relative offset {x, y} from anchorPointCanvas

                    // 1. Check for user-dragged position (stored as relative offset)
                    if (customLabelPositions[currentImageLabel]?.[strokeLabel]) {
                        offset = customLabelPositions[currentImageLabel][strokeLabel];
                        // Apply the stored relative offset to the *current* canvas anchor point
                        finalPosition = { x: anchorPointCanvas.x + offset.x, y: anchorPointCanvas.y + offset.y };
                        usedCustomPositions[strokeLabel] = true; // Mark as used
                         // console.log(`    Using custom offset for ${strokeLabel}. Anchor: (${anchorPointCanvas.x.toFixed(1)}, ${anchorPointCanvas.y.toFixed(1)}), Offset: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)}) -> Final: (${finalPosition.x.toFixed(1)}, ${finalPosition.y.toFixed(1)})`);
                    }
                    // 2. Check for previously calculated offset (stored as relative offset)
                    else if (calculatedLabelOffsets[currentImageLabel]?.[strokeLabel]) {
                        offset = calculatedLabelOffsets[currentImageLabel][strokeLabel];
                        // Apply the stored relative offset to the *current* canvas anchor point
                        finalPosition = { x: anchorPointCanvas.x + offset.x, y: anchorPointCanvas.y + offset.y };
                         // console.log(`    Using calculated offset for ${strokeLabel}. Anchor: (${anchorPointCanvas.x.toFixed(1)}, ${anchorPointCanvas.y.toFixed(1)}), Offset: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)}) -> Final: (${finalPosition.x.toFixed(1)}, ${finalPosition.y.toFixed(1)})`);
                    }
                    // 3. Calculate optimal position and offset for the first time
                    else {
                        if (typeof findOptimalLabelPosition !== 'function') {
                            console.error("     findOptimalLabelPosition function is not defined! Using default position.");
                            finalPosition = { x: initialLabelRect.x, y: initialLabelRect.y }; // Fallback
                        } else {
                            try {
                                const strokePathInfo = currentStrokePaths.find(p => p.label === strokeLabel);
                                const optimalRect = findOptimalLabelPosition(
                                    initialLabelRect, // Initial guess uses current canvas coords & dimensions
                                    anchorPointCanvas, // Anchor is current canvas coords
                                    strokePathInfo // Pass current canvas path info
                                );
                                finalPosition = { x: optimalRect.x, y: optimalRect.y };
                            } catch(err) {
                                console.error(`      Error in findOptimalLabelPosition for ${strokeLabel}:`, err);
                                finalPosition = { x: initialLabelRect.x, y: initialLabelRect.y }; // Fallback
                            }
                        }
                        // Calculate and store the RELATIVE offset based on the calculated position
                        offset = {
                            x: finalPosition.x - anchorPointCanvas.x,
                            y: finalPosition.y - anchorPointCanvas.y
                        };
                        if (!calculatedLabelOffsets[currentImageLabel]) calculatedLabelOffsets[currentImageLabel] = {};
                        calculatedLabelOffsets[currentImageLabel][strokeLabel] = offset; // Store relative offset
                        // console.log(`    Calculated and stored offset for ${strokeLabel}:`, offset);
                    }

                    // Store the final calculated position rect for overlap checks in *this* redraw cycle
                    const finalLabelRect = { ...initialLabelRect, x: finalPosition.x, y: finalPosition.y };
                    currentLabelPositions.push(finalLabelRect);

                    // Draw label background
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(finalLabelRect.x, finalLabelRect.y, finalLabelRect.width, finalLabelRect.height);

                    // Draw label border
                    ctx.strokeStyle = labelColor;
                    ctx.lineWidth = 1; // Keep border thin
                    ctx.strokeRect(finalLabelRect.x, finalLabelRect.y, finalLabelRect.width, finalLabelRect.height);

                    // Draw label text
                    ctx.fillStyle = labelColor;
                    const textX = finalLabelRect.x + finalLabelRect.width / 2;
                    const textY = finalLabelRect.y + finalLabelRect.height - padding; // Adjust baseline using scaled padding
                    ctx.fillText(labelText, textX, textY);

                    // Optionally draw connector line (from label edge to anchor point)
                    if (typeof drawLabelConnector === 'function') {
                        try {
                            drawLabelConnector(finalLabelRect, anchorPointCanvas, labelColor);
                        } catch(err) {
                            console.error(`      Error in drawLabelConnector for ${strokeLabel}:`, err);
                        }
                    }
                }
            }); // End of label drawing loop
            // --- End of Label Drawing Logic ---

            // Save the now-combined state (only if not loading, to prevent infinite loops)
            if (!window.isLoadingProject) {
                const newState = getCanvasState();
                imageStates[currentImageLabel] = cloneImageData(newState);
                 // console.log(`[Redraw] Saved final canvas state for ${currentImageLabel}`); // Optional: Debug state saving
            } else {
                 // console.log("[Redraw] Skipping final state save because isLoadingProject is true.");
            }
            ctx.restore(); // *** Restore the original context state (including transform) ***
            console.log("Redraw End Transform:", ctx.getTransform());
        }
    }

    function cloneImageData(imageData) {
        return new ImageData(
            new Uint8ClampedArray(imageData.data),
            imageData.width,
            imageData.height
        );
    }

    function saveState(force = false, incrementLabel = true, updateStrokeList = true) {
        // *** ADDED LOG ***
        console.log(`[Save State Called] force=${force}, incrementLabel=${incrementLabel}, updateStrokeList=${updateStrokeList}, isDrawingOrPasting=${isDrawingOrPasting}, strokeInProgress=${strokeInProgress}`);

        // Get current state
        const currentState = getCanvasState();

        // Initialize if first save for this image
        if (!imageStates[currentImageLabel]) {
            imageStates[currentImageLabel] = cloneImageData(currentState);
            undoStackByImage[currentImageLabel].push({
                state: cloneImageData(currentState),
                type: 'initial',
                label: null
            });
            updateStrokeCounter();
            return;
        }

        // Only save if we're not in the middle of a stroke or if forced
        if (!force && strokeInProgress) return;

        // Don't save if it's identical to the last state
        const lastState = imageStates[currentImageLabel];
        if (lastState && !force) {
            const currentData = currentState.data;
            const lastData = lastState.data;
            let identical = true;
            for (let i = 0; i < currentData.length; i += 4) {
                if (currentData[i] !== lastData[i] ||
                    currentData[i + 1] !== lastData[i + 1] ||
                    currentData[i + 2] !== lastData[i + 2] ||
                    currentData[i + 3] !== lastData[i + 3]) {
                    identical = false;
                    break;
                }
            }
            if (identical) return;
        }

        // For line strokes, assign the next label before saving
        let strokeLabel = null;
        if (!isDrawingOrPasting && !strokeInProgress && incrementLabel && updateStrokeList) {
            // *** ADDED DETAILED LOGS ***
            console.log(`[Save State] Entering stroke update block.`);
            
            // Get the suggested next label
            const suggestedLabel = window.labelsByImage[currentImageLabel];
            console.log(`[Save State] Suggested next label = "${suggestedLabel}" from labelsByImage[${currentImageLabel}]`);
            
            // *** FIX: Ensure the new stroke gets a UNIQUE label ***
            strokeLabel = generateUniqueStrokeName(suggestedLabel);
            console.log(`[Save State] Assigned UNIQUE strokeLabel = "${strokeLabel}"`);
            
            // Always increment the label counter based on the original suggested label for the next stroke
            const nextLabel = getNextLabel(currentImageLabel); // Uses the value in labelsByImage
            window.labelsByImage[currentImageLabel] = nextLabel;
            console.log(`[Save State] Incremented labelsByImage[${currentImageLabel}] to "${nextLabel}"`);
            
            // Only add the *unique* stroke label to the strokes list
            if (!window.lineStrokesByImage[currentImageLabel]) {
                console.log(`[Save State] Initializing lineStrokesByImage[${currentImageLabel}] as []`);
                window.lineStrokesByImage[currentImageLabel] = []; // Initialize if it doesn't exist
            }
            
            // Check if unique stroke label already exists before pushing (shouldn't happen with generateUniqueStrokeName)
            const labelAlreadyExists = window.lineStrokesByImage[currentImageLabel].includes(strokeLabel);
            
            console.log(`[Save State] BEFORE push: lineStrokesByImage[${currentImageLabel}] =`, JSON.parse(JSON.stringify(window.lineStrokesByImage[currentImageLabel])));
            
            if (!labelAlreadyExists && updateStrokeList) {
                window.lineStrokesByImage[currentImageLabel].push(strokeLabel); // Push the unique label
                console.log(`[Save State] AFTER push: lineStrokesByImage[${currentImageLabel}] =`, JSON.parse(JSON.stringify(window.lineStrokesByImage[currentImageLabel])));
            } else {
                // This case should ideally not be reached if generateUniqueStrokeName works correctly
                console.warn(`[Save State] Generated unique stroke label "${strokeLabel}" already exists? Not pushing again.`);
            }
            
            // Initialize visibility, data etc. using the unique strokeLabel
            window.strokeVisibilityByImage[currentImageLabel] = window.strokeVisibilityByImage[currentImageLabel] || {};
            window.strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            
            window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
            window.strokeLabelVisibility[currentImageLabel][strokeLabel] = true;
            
            strokeDataByImage[currentImageLabel] = strokeDataByImage[currentImageLabel] || {};
            strokeDataByImage[currentImageLabel][strokeLabel] = {
                preState: currentStroke ? cloneImageData(currentStroke) : null,
                postState: cloneImageData(currentState)
            };
        }

        // --- FIX: Handle temporary vector data --- 
        const tempStrokeKey = '_drawingStroke';
        let drawnVectorData = null;
        
        // Debug the state of vectorStrokesByImage before handling temporary data
        console.log(`[Save State] Vector strokes for ${currentImageLabel} before processing:`, 
            window.vectorStrokesByImage[currentImageLabel] ? 
            Object.keys(window.vectorStrokesByImage[currentImageLabel]) : "none");
            
        // Detailed check for _drawingStroke
        if (window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
            console.log(`[Save State] Found _drawingStroke data with ${window.vectorStrokesByImage[currentImageLabel][tempStrokeKey].points.length} points`);
        } else {
            console.log(`[Save State] No _drawingStroke data found:`, 
                window.vectorStrokesByImage[currentImageLabel] ? 
                "vectorStrokesByImage exists for label but no _drawingStroke key" : 
                "vectorStrokesByImage doesn't exist for this label");
        }
        
        if (strokeLabel && window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
            drawnVectorData = JSON.parse(JSON.stringify(window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]));
            // Assign the drawn data to the final unique stroke label
            window.vectorStrokesByImage[currentImageLabel][strokeLabel] = drawnVectorData;
            // Remove the temporary data
            delete window.vectorStrokesByImage[currentImageLabel][tempStrokeKey];
            console.log(`[Save State] Moved vector data from ${tempStrokeKey} to ${strokeLabel}`);
        } else if (strokeLabel) {
            console.warn(`[Save State] No temporary vector data found at ${tempStrokeKey} for stroke ${strokeLabel}`);
            // Attempt to find vector data if it somehow got assigned to the suggested label during draw (fallback)
            const suggestedLabel = window.labelsByImage[currentImageLabel]; // Get the label *before* incrementing
             if (window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][suggestedLabel]) {
                console.log(`[Save State] Fallback: Found data under suggested label ${suggestedLabel}`);
                drawnVectorData = JSON.parse(JSON.stringify(window.vectorStrokesByImage[currentImageLabel][suggestedLabel]));
                window.vectorStrokesByImage[currentImageLabel][strokeLabel] = drawnVectorData;
                // Optionally delete the data under suggestedLabel if it shouldn't be there
                // delete window.vectorStrokesByImage[currentImageLabel][suggestedLabel]; 
            }
        }
        // --- END FIX ---

        // Save new state and add to undo stack
        imageStates[currentImageLabel] = cloneImageData(currentState);
        
        // Determine the type of stroke
        let strokeType = 'other';
        if (force && strokeLabel) {
            strokeType = 'stroke';
            
            // Check for vector data to determine if it's a freehand or straight line
            // Use the vector data we just potentially moved
            if (drawnVectorData) { 
                if (drawnVectorData.type === 'straight') {
                    strokeType = 'line';
                } else if (drawnVectorData.type === 'freehand') {
                    strokeType = 'stroke';
                }
            }
        }
        
        // Add to undo stack with stroke info
        const undoAction = {
            state: cloneImageData(currentState),
            type: strokeType,
            label: strokeLabel, // Use the unique label
            color: colorPicker.value, 
            width: parseInt(brushSize.value) 
        };
        
        // Store vector data with the undo action if available
        // Use the data retrieved from the temporary key
        if (drawnVectorData) {
            undoAction.vectorData = drawnVectorData; 
        }
        
        undoStackByImage[currentImageLabel].push(undoAction);
        
        // Remove oldest state if we've reached max history
        if (undoStackByImage[currentImageLabel].length >= MAX_HISTORY) {
            undoStackByImage[currentImageLabel].shift();
        }

        // Clear redo stack when a new action is performed
        redoStackByImage[currentImageLabel] = [];

        updateStrokeCounter();
        updateSidebarStrokeCounts();
    }

    function undo() {
        console.log(`Attempting to undo in ${currentImageLabel} workspace`);
        console.log(`Current undo stack: ${undoStackByImage[currentImageLabel]?.length || 0} items`);
        console.log(`Current strokes: ${lineStrokesByImage[currentImageLabel]?.join(', ') || 'none'}`);
        
        const currentStack = undoStackByImage[currentImageLabel];
        if (currentStack && currentStack.length > 1) { // Keep at least one state (initial)
            // Get the state we're undoing from
            const lastAction = currentStack.pop();
            console.log(`Undoing action of type: ${lastAction.type}, label: ${lastAction.label || 'none'}`);
            
            // Add to redo stack
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[currentImageLabel].push(lastAction);
            console.log(`Added to redo stack, now has ${redoStackByImage[currentImageLabel].length} items`);
            
            // Skip certain state types when undoing
            if (lastAction.type === 'pre-stroke') {
                console.log('Skipping pre-stroke state');
                // If we encounter a pre-stroke state, undo again to get to the previous complete state
                if (currentStack.length > 1) {
                    return undo();
                }
            }
            
            // Handle snapshot type (created when switching views)
            if (lastAction.type === 'snapshot') {
                console.log('Restoring from snapshot state');
                // If we have stored strokes in the snapshot, restore them
                if (lastAction.strokes) {
                    lineStrokesByImage[currentImageLabel] = [...(lastAction.strokes || [])];
                    console.log(`Restored strokes: ${lineStrokesByImage[currentImageLabel].join(', ')}`);
                }
                
                // Continue to next undo action if possible
                if (currentStack.length > 1) {
                    return undo();
                }
            }
            
            // Get the state we're going back to
            const previousState = currentStack[currentStack.length - 1];
            
            if (lastAction.type === 'line' || lastAction.type === 'stroke') {
                // Remove the last stroke and its label
                if (lineStrokesByImage[currentImageLabel] && lineStrokesByImage[currentImageLabel].length > 0) {
                    const removedStroke = lineStrokesByImage[currentImageLabel].pop();
                    console.log(`Removed stroke: ${removedStroke}`);
                    
                    // Also remove from visibility tracking
                    if (strokeVisibilityByImage[currentImageLabel] && strokeVisibilityByImage[currentImageLabel][removedStroke]) {
                        delete strokeVisibilityByImage[currentImageLabel][removedStroke];
                    }
                    
                    // Also remove from label visibility tracking
                    if (strokeLabelVisibility[currentImageLabel] && strokeLabelVisibility[currentImageLabel][removedStroke]) {
                        // Save label visibility in lastAction for possible redo
                        lastAction.labelVisible = strokeLabelVisibility[currentImageLabel][removedStroke];
                        delete strokeLabelVisibility[currentImageLabel][removedStroke];
                    }
                    
                    // Also remove from stroke data tracking
                    if (strokeDataByImage[currentImageLabel] && strokeDataByImage[currentImageLabel][removedStroke]) {
                        delete strokeDataByImage[currentImageLabel][removedStroke];
                    }
                    
                    // Remove vector stroke data
                    if (vectorStrokesByImage[currentImageLabel] && vectorStrokesByImage[currentImageLabel][removedStroke]) {
                        // Save vector data in lastAction for possible redo
                        lastAction.vectorData = vectorStrokesByImage[currentImageLabel][removedStroke];
                        delete vectorStrokesByImage[currentImageLabel][removedStroke];
                }
                
                    // If this was the last stroke, reset to A1
                    if (lineStrokesByImage[currentImageLabel].length === 0) {
                        labelsByImage[currentImageLabel] = 'A1';
                        console.log(`All strokes undone, reset label counter to A1`);
                    } else {
                // Set the next label to be the one we just removed
                if (lastAction.label) {
                    labelsByImage[currentImageLabel] = lastAction.label;
                    console.log(`Reset label counter to: ${lastAction.label}`);
                        }
                    }
                }
            }
            
            // Ensure we have a valid previous state
            if (previousState && previousState.state) {
                // Restore the canvas state
                const stateToRestore = cloneImageData(previousState.state);
                imageStates[currentImageLabel] = stateToRestore;
                restoreCanvasState(stateToRestore);
                currentStroke = cloneImageData(stateToRestore);
                console.log('Canvas state restored');
            } else {
                console.log('Warning: No valid previous state found');
                // Create a blank state if needed
                const blankState = ctx.createImageData(canvas.width, canvas.height);
                imageStates[currentImageLabel] = blankState;
                restoreCanvasState(blankState);
                currentStroke = cloneImageData(blankState);
            }
            
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
        } else if (currentStack && currentStack.length === 1) {
            // We're at the initial state
            console.log('At initial state, resetting workspace');
            const initialState = currentStack[0];
            
            // Clear all stroke data
            lineStrokesByImage[currentImageLabel] = [];
            strokeVisibilityByImage[currentImageLabel] = {};
            strokeLabelVisibility[currentImageLabel] = {};
            vectorStrokesByImage[currentImageLabel] = {};
            strokeDataByImage[currentImageLabel] = {};
            
            // Reset label counter
            labelsByImage[currentImageLabel] = 'A1';  // Reset to A1
            
            if (initialState && initialState.state) {
                imageStates[currentImageLabel] = cloneImageData(initialState.state);
                restoreCanvasState(initialState.state);
                currentStroke = cloneImageData(initialState.state);
            } else if (window.originalImages[currentImageLabel]) {
                // If we have the original image, redraw it
                console.log('Redrawing from original image');
                const img = new Image();
                img.onload = () => {
                    // Clear the canvas first
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the current scale
                    const scale = window.imageScaleByLabel[currentImageLabel];
                    const scaledWidth = img.width * scale;
                    const scaledHeight = img.height * scale;
                    
                    // Calculate base position (center of canvas)
                    const centerX = (canvas.width - scaledWidth) / 2;
                    const centerY = (canvas.height - scaledHeight) / 2;
                    
                    // Apply position offset
                    const offsetX = window.imagePositionByLabel[currentImageLabel].x;
                    const offsetY = window.imagePositionByLabel[currentImageLabel].y;
                    
                    // Calculate final position
                    const x = centerX + offsetX;
                    const y = centerY + offsetY;
                    
                    // Draw the original image with scale and position
                    ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                    
                    // Save this as the new state
                    const newState = getCanvasState();
                    imageStates[currentImageLabel] = cloneImageData(newState);
                    currentStroke = cloneImageData(newState);
                };
                img.src = window.originalImages[currentImageLabel];
            }
            
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
        } else {
            console.log('No undo history available for this workspace');
        }
    }
    
    function redo() {
        console.log(`Attempting to redo in ${currentImageLabel} workspace`);
        console.log(`Current redo stack: ${redoStackByImage[currentImageLabel]?.length || 0} items`);
        
        const redoStack = redoStackByImage[currentImageLabel];
        if (redoStack && redoStack.length > 0) {
            // Get the action to redo
            const actionToRedo = redoStack.pop();
            console.log(`Redoing action of type: ${actionToRedo.type}, label: ${actionToRedo.label || 'none'}`);
            
            // Add back to undo stack
            undoStackByImage[currentImageLabel].push(actionToRedo);
            
            // Handle stroke type actions (both freehand strokes and straight lines)
            if ((actionToRedo.type === 'line' || actionToRedo.type === 'stroke') && actionToRedo.label) {
                // Add the stroke back to the list
                window.lineStrokesByImage[currentImageLabel] = window.lineStrokesByImage[currentImageLabel] || [];
                window.lineStrokesByImage[currentImageLabel].push(actionToRedo.label);
                console.log(`Added stroke back: ${actionToRedo.label}`);
                
                // Restore stroke visibility
                window.strokeVisibilityByImage[currentImageLabel] = window.strokeVisibilityByImage[currentImageLabel] || {};
                window.strokeVisibilityByImage[currentImageLabel][actionToRedo.label] = true;
                
                // Restore stroke data if we have it
                if (actionToRedo.strokeData) {
                    strokeDataByImage[currentImageLabel] = strokeDataByImage[currentImageLabel] || {};
                    strokeDataByImage[currentImageLabel][actionToRedo.label] = actionToRedo.strokeData;
                }
                
                // Restore vector data if we have it
                if (actionToRedo.vectorData) {
                    window.vectorStrokesByImage[currentImageLabel] = window.vectorStrokesByImage[currentImageLabel] || {};
                    window.vectorStrokesByImage[currentImageLabel][actionToRedo.label] = actionToRedo.vectorData;
                    
                    // If no vector data saved in the action, but we're redoing a line/stroke,
                    // try to recreate basic vector data to ensure label display
                    if (!actionToRedo.vectorData && 
                        (actionToRedo.type === 'line' || actionToRedo.type === 'stroke')) {
                        // Create minimal vector data to ensure label display
                        window.vectorStrokesByImage[currentImageLabel][actionToRedo.label] = {
                            points: [
                                { x: canvas.width/2 - 50, y: canvas.height/2 }, // Dummy points
                                { x: canvas.width/2 + 50, y: canvas.height/2 }
                            ],
                            color: actionToRedo.color || "#000000",
                            width: 5,
                            type: actionToRedo.type === 'line' ? 'straight' : 'freehand'
                        };
                    }
                }
                
                // Restore label visibility if we have it
                if (actionToRedo.labelVisible !== undefined) {
                    window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
                    window.strokeLabelVisibility[currentImageLabel][actionToRedo.label] = actionToRedo.labelVisible;
                } else {
                    // Default to visible for new strokes and redone strokes without saved value
                    window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
                    window.strokeLabelVisibility[currentImageLabel][actionToRedo.label] = true;
                }
                
                // Update the next label - make sure it's one higher than the redone label
                const numPart = parseInt(actionToRedo.label.slice(1));
                if (!isNaN(numPart)) {
                    const letterPart = actionToRedo.label[0];
                    const nextNum = numPart + 1;
                    const nextLabel = nextNum > 9 
                        ? String.fromCharCode(letterPart.charCodeAt(0) + 1) + '0' 
                        : letterPart + nextNum;
                    window.labelsByImage[currentImageLabel] = nextLabel;
                    console.log(`Set next label to: ${nextLabel}`);
                } else {
                    // Fallback to the standard next label function
                window.labelsByImage[currentImageLabel] = getNextLabel(currentImageLabel);
                console.log(`Set next label to: ${window.labelsByImage[currentImageLabel]}`);
                }
            }
            
            // Restore the state
            if (actionToRedo.state) {
                const stateToRestore = cloneImageData(actionToRedo.state);
                imageStates[currentImageLabel] = stateToRestore;
                restoreCanvasState(stateToRestore);
                currentStroke = cloneImageData(stateToRestore);
                console.log('Canvas state restored for redo');
            }
            
            // Update all UI elements
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
            
            // Force redraw with visibility to ensure labels appear immediately
            redrawCanvasWithVisibility();
        } else {
            console.log('No redo actions available for this workspace');
        }
    }

    // Save initial blank state
//    saveState();

    // Set canvas size
    function resizeCanvas() {
        // Account for the sidebars and gaps in our calculation (approximately 420px for sidebars + gaps)
        const sidebarSpace = 440;
        const maxWidth = Math.min(window.innerWidth - sidebarSpace, 1000);  // Cap at 1000px width
        const maxHeight = Math.min(window.innerHeight - 100, 800);  // Cap at 800px height
        
        // Save current state before resizing
        const oldState = imageStates[currentImageLabel];
        
        // Resize the canvas
        canvas.width = maxWidth;
        canvas.height = maxHeight;
        
        // Set default canvas styles
        canvas.style.cursor = 'crosshair';
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Restore the image after resize
        if (oldState) {
            // Try to restore from saved state first
            try {
                restoreCanvasState(oldState);
                currentStroke = cloneImageData(oldState);
            } catch (e) {
                // If that fails, redraw from original image
                if (window.originalImages[currentImageLabel]) {
                    const img = new Image();
                    img.onload = () => {
                        // Clear the canvas first
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Get the current scale
                        const scale = imageScaleByLabel[currentImageLabel];
                        const scaledWidth = img.width * scale;
                        const scaledHeight = img.height * scale;
                        
                        // Calculate base position (center of canvas)
                        const centerX = (canvas.width - scaledWidth) / 2;
                        const centerY = (canvas.height - scaledHeight) / 2;
                        
                        // Apply position offset
                        const offsetX = window.imagePositionByLabel[currentImageLabel].x;
                        const offsetY = window.imagePositionByLabel[currentImageLabel].y;
                        
                        // Calculate final position
                        const x = centerX + offsetX;
                        const y = centerY + offsetY;
                        
                        // Draw the original image with scale and position
                        ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                        
                        // Save this as the new state
                        const newState = getCanvasState();
                        imageStates[currentImageLabel] = cloneImageData(newState);
                        currentStroke = cloneImageData(newState);
                    };
                    img.src = window.originalImages[currentImageLabel];
                } else if (!currentStroke) {
                    // Initialize blank state if needed
                    currentStroke = getCanvasState();
                }
            }
        }
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Drawing state
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let points = [];
    let lastVelocity = 0;
    // --- ADD: Track last RAW coordinates ---
    let lastRawX = 0;
    let lastRawY = 0;
    // --- END ADD ---

    // Drawing mode state
    let drawingMode = 'freehand'; // Options: 'freehand', 'straight'
    let straightLineStart = null; // For straight line mode - start point
    let lastDrawnPoint = null;

    /**
     * Transforms raw canvas coordinates to account for image scaling and positioning
     * @param {number} x - Raw x-coordinate from mouse event
     * @param {number} y - Raw y-coordinate from mouse event
     * @returns {Object} Object with transformed x and y coordinates
     */
    function getTransformedCoords(x, y) {
        // Debug logging
        if (window.debugCoordinates) {
            console.log(`[getTransformedCoords] INPUT: Raw canvas coords (${x.toFixed(1)}, ${y.toFixed(1)})`);
        }
        
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
        const position = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 };
        
        // If we have no image dimensions yet (blank canvas), return raw coordinates
        if (!window.originalImageDimensions[currentImageLabel]) {
            if (window.debugCoordinates) {
                console.log(`[getTransformedCoords] No image dimensions - returning raw coords as relative`);
            }
            return { x, y };
        }
        
        // We do have an image, so need to calculate relative coordinates
        const origDims = window.originalImageDimensions[currentImageLabel];
        const scaledWidth = origDims.width * scale;
        const scaledHeight = origDims.height * scale;
        
        // Base position is canvas center minus half the scaled image size
        const imageBaseX = (canvas.width - scaledWidth) / 2;
        const imageBaseY = (canvas.height - scaledHeight) / 2;
        
        // Final image position includes any panning offset
        const finalImageX = imageBaseX + position.x;
        const finalImageY = imageBaseY + position.y;
        
        // Convert the raw canvas coordinates to coordinates relative to the image
        const relativeX = (x - finalImageX) / scale;
        const relativeY = (y - finalImageY) / scale;
        
        if (window.debugCoordinates) {
            console.log(`[getTransformedCoords] Canvas size: ${canvas.width} × ${canvas.height}`);
            console.log(`[getTransformedCoords] Image scale: ${scale}, position: ${JSON.stringify(position)}`);
            console.log(`[getTransformedCoords] Original dimensions: ${JSON.stringify(origDims)}`);
            console.log(`[getTransformedCoords] Scaled dimensions: ${scaledWidth} × ${scaledHeight}`);
            console.log(`[getTransformedCoords] Image position: base(${imageBaseX.toFixed(1)}, ${imageBaseY.toFixed(1)}) + offset => final(${finalImageX.toFixed(1)}, ${finalImageY.toFixed(1)})`);
            console.log(`[getTransformedCoords] OUTPUT: Relative coords (${relativeX.toFixed(1)}, ${relativeY.toFixed(1)})`);
        }
        
        return { x: relativeX, y: relativeY };
    }

    /**
     * Converts relative image coordinates back to canvas coordinates
     * (Inverse of getTransformedCoords)
     * @param {number} imageX_relative - x-coordinate relative to the image
     * @param {number} imageY_relative - y-coordinate relative to the image
     * @returns {Object} Object with canvas x and y coordinates
     */
    function getCanvasCoords(imageX_relative, imageY_relative) {
        // Debug logging
        if (window.debugCoordinates) {
            console.log(`[getCanvasCoords] INPUT: Relative coords (${imageX_relative.toFixed(1)}, ${imageY_relative.toFixed(1)})`);
        }
        
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
        const position = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 };
        
        // If we have no image dimensions yet (blank canvas), return relative coords as-is
        if (!window.originalImageDimensions[currentImageLabel]) {
            if (window.debugCoordinates) {
                console.log(`[getCanvasCoords] No image dimensions - returning relative coords as canvas coords`);
            }
            return { x: imageX_relative, y: imageY_relative };
        }
        
        // We do have an image, calculate canvas coordinates from relative coords
        const origDims = window.originalImageDimensions[currentImageLabel];
        const scaledWidth = origDims.width * scale;
        const scaledHeight = origDims.height * scale;
        
        // Base position is canvas center minus half the scaled image size
        const imageBaseX = (canvas.width - scaledWidth) / 2;
        const imageBaseY = (canvas.height - scaledHeight) / 2;
        
        // Final image position includes any panning offset
        const finalImageX = imageBaseX + position.x;
        const finalImageY = imageBaseY + position.y;
        
        // Calculate final canvas coordinates from image-relative coordinates
        const canvasX = finalImageX + (imageX_relative * scale);
        const canvasY = finalImageY + (imageY_relative * scale);
        
        if (window.debugCoordinates) {
            console.log(`[getCanvasCoords] Canvas size: ${canvas.width} × ${canvas.height}`);
            console.log(`[getCanvasCoords] Image scale: ${scale}, position: ${JSON.stringify(position)}`);
            console.log(`[getCanvasCoords] Original dimensions: ${JSON.stringify(origDims)}`);
            console.log(`[getCanvasCoords] Scaled dimensions: ${scaledWidth} × ${scaledHeight}`);
            console.log(`[getCanvasCoords] Image position: base(${imageBaseX.toFixed(1)}, ${imageBaseY.toFixed(1)}) + offset => final(${finalImageX.toFixed(1)}, ${finalImageY.toFixed(1)})`);
            console.log(`[getCanvasCoords] OUTPUT: Canvas coords (${canvasX.toFixed(1)}, ${canvasY.toFixed(1)})`);
        }
        
        return { x: canvasX, y: canvasY };
    }

    function draw(e) {
        if (!isDrawing) return;

        if (window.debugCoordinates) {
            console.log("--- Draw Event Start ---");
            console.log("[draw] Transform:", ctx.getTransform());
        }

        // Get precise coordinates relative to the canvas
        const rect = canvas.getBoundingClientRect();
        const rawX = e.clientX - rect.left;
        const rawY = e.clientY - rect.top;
        
        if (window.debugCoordinates) {
            console.log(`[draw] Raw mouse coords: (${rawX.toFixed(1)}, ${rawY.toFixed(1)})`);
        }

        // Get current scale for potential use
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;

        // Test round-trip coordinate conversion accuracy
        if (window.debugCoordinates) {
            const roundTrip = getCanvasCoords(getTransformedCoords(rawX, rawY).x, getTransformedCoords(rawX, rawY).y);
            const roundTripError = Math.sqrt(Math.pow(roundTrip.x - rawX, 2) + Math.pow(roundTrip.y - rawY, 2));
            console.log(`[draw] Round-trip coordinate error: ${roundTripError.toFixed(2)} pixels`);
            console.log("--- Draw Event End ---");
        }
    }

// Define global variables for use by project-manager.js
window.IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
window.currentImageLabel = 'front';
window.vectorStrokesByImage = {};
window.strokeVisibilityByImage = {};
window.strokeLabelVisibility = {};
window.strokeMeasurements = {};
window.imageScaleByLabel = {};
window.imagePositionByLabel = {};
window.lineStrokesByImage = {}; // Make sure it's exposed globally
window.labelsByImage = {};      // Make sure it's exposed globally
window.originalImages = {};
window.isLoadingProject = false; // <-- Re-adding this line

// At the top of the file, near other global variables
window.debugCoordinates = false; // Global flag to control coordinate debugging

document.addEventListener('DOMContentLoaded', () => {
    // Initialize unit selectors
    const unitSelector = document.getElementById('unitSelector');
    unitSelector.addEventListener('change', updateMeasurementDisplay);
    
    // Add debug toggle button to the controls
    const controlsContainer = document.querySelector('.controls-container');
    const debugToggle = document.createElement('button');
    debugToggle.textContent = '🐞 Debug';
    debugToggle.classList.add('debug-toggle');
    debugToggle.addEventListener('click', () => {
        window.debugCoordinates = !window.debugCoordinates;
        debugToggle.classList.toggle('active', window.debugCoordinates);
        console.log(`Coordinate debugging ${window.debugCoordinates ? 'enabled' : 'disabled'}`);
    });
    controlsContainer.appendChild(debugToggle);
    
    // Initialize the measurement inputs
    const inchWhole = document.getElementById('inchWhole');
    const inchFraction = document.getElementById('inchFraction');
    const cmValue = document.getElementById('cmValue');
    
    // Handle unit conversion when changing values
    inchWhole.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    inchFraction.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    cmValue.addEventListener('change', () => {
        const cm = parseFloat(cmValue.value) || 0;
        const inches = cm / 2.54;
        
        // Update inch values
        inchWhole.value = Math.floor(inches);
        
        // Find closest fraction
        const fractionPart = inches - Math.floor(inches);
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        inchFraction.value = closestFraction;
        
        // Show inch inputs, hide cm inputs
        document.getElementById('inchInputs').style.display = 'flex';
        document.getElementById('cmInputs').style.display = 'none';
    });
    
    const canvas = document.getElementById('canvas');
    // Expose canvas globally for project management
    window.canvas = canvas;
    const ctx = canvas.getContext('2d', { willReadFrequently: true }); // Add willReadFrequently hint
    const colorPicker = document.getElementById('colorPicker');
    const brushSize = document.getElementById('brushSize');
    const clearButton = document.getElementById('clear');
    const saveButton = document.getElementById('save');
    const pasteButton = document.getElementById('paste');
    const strokeCounter = document.getElementById('strokeCounter');
    const imageList = document.getElementById('imageList');
    const drawingModeToggle = document.getElementById('drawingModeToggle');
    
    // Draggable sidebars
    const strokeSidebar = document.getElementById('strokeSidebar');
    const imageSidebar = document.getElementById('imageSidebar');
    const strokeSidebarHeader = document.getElementById('strokeSidebarHeader');
    const imageSidebarHeader = document.getElementById('imageSidebarHeader');

    // Undo/Redo functionality
    const MAX_HISTORY = 50;  // Maximum number of states to store
    const IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
    let currentImageIndex = 0;
    let imageStates = {}; // Store states for each image
    
    // Use the global variables instead of creating new ones
    let strokeDataByImage = {}; // Store additional data for each stroke
    let undoStackByImage = {}; // Separate undo stack for each image
    let redoStackByImage = {}; // Separate redo stack for each image
    let pastedImages = [];  // Store all pasted images
    let isDrawingOrPasting = false;  // Flag to prevent saving states while drawing
    let strokeInProgress = false;  // Track if we're in the middle of a stroke
    let currentStroke = null;  // Store the state before current stroke
    let originalImageDimensions = {}; // Store original image dimensions for scaling
    let isShiftPressed = false; // Track if Shift key is pressed for image movement
    let calculatedLabelOffsets = {}; // Store automatically calculated label offsets

    // Initialize states for default images
    IMAGE_LABELS.forEach(label => {
        // Ensure we initialize global arrays properly
        window.lineStrokesByImage[label] = [];
        window.strokeVisibilityByImage[label] = {}; // Initialize stroke visibility
        window.vectorStrokesByImage[label] = {}; // Initialize vector stroke data
        window.labelsByImage[label] = 'A1';  // Start from A1 instead of A0
        
        strokeDataByImage[label] = {}; // Initialize stroke data
        undoStackByImage[label] = [];
        redoStackByImage[label] = [];  // Initialize redo stack
        imageStates[label] = null;
        // Initialize scale to 100% (1.0)
        window.imageScaleByLabel[label] = 1.0;
        originalImageDimensions[label] = { width: 0, height: 0 };
        // Initialize position offset to center (0, 0)
        window.imagePositionByLabel[label] = { x: 0, y: 0 };
        // Initialize with a blank state when the image is first created
        const blankState = ctx.createImageData(canvas.width, canvas.height);
        imageStates[label] = blankState;
        undoStackByImage[label].push({
            state: cloneImageData(blankState),
            type: 'initial',
            label: null
        });
    });

    let currentImageLabel = IMAGE_LABELS[0]; // Start with 'front'

    // Make addImageToSidebar available globally for the project manager
    window.addImageToSidebar = addImageToSidebar;
    function addImageToSidebar(imageUrl, label) {
        // *** ADDED LOG ***
        console.log(`[addImageToSidebar] Called for label: ${label}, imageUrl: ${imageUrl ? imageUrl.substring(0,30) + '...' : 'null'}`);

        const container = document.createElement('div');
        container.className = 'image-container';
        container.dataset.label = label;
        container.dataset.originalImageUrl = imageUrl; // Store the original image URL for later restoration
        
        const labelElement = document.createElement('div');
        labelElement.className = 'image-label';
        labelElement.textContent = label.charAt(0).toUpperCase() + label.slice(1);
        
        const strokesElement = document.createElement('div');
        strokesElement.className = 'image-strokes';
        strokesElement.textContent = 'Strokes: 0';
        
        const scaleElement = document.createElement('div');
        scaleElement.className = 'image-scale';
        scaleElement.textContent = `Scale: ${Math.round(imageScaleByLabel[label] * 100)}%`;
        scaleElement.id = `scale-${label}`;
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.className = 'pasted-image';
        img.alt = `${label} view`;
        
        container.appendChild(img);
        container.appendChild(labelElement);
        container.appendChild(strokesElement);
        container.appendChild(scaleElement);
        
        container.onclick = () => {
            // ... rest of the handler
            
            console.log(`Switching from ${currentImageLabel} to ${label}`);
            
            // Ensure we have undo stacks for both workspaces
            undoStackByImage[currentImageLabel] = undoStackByImage[currentImageLabel] || [];
            undoStackByImage[label] = undoStackByImage[label] || [];
            
            // Ensure we have redo stacks for both workspaces
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[label] = redoStackByImage[label] || [];
            
            // Ensure we have stroke lists for both workspaces
            lineStrokesByImage[currentImageLabel] = lineStrokesByImage[currentImageLabel] || [];
            lineStrokesByImage[label] = lineStrokesByImage[label] || [];
            
            // Ensure we have stroke visibility for both workspaces
            strokeVisibilityByImage[currentImageLabel] = strokeVisibilityByImage[currentImageLabel] || {};
            strokeVisibilityByImage[label] = strokeVisibilityByImage[label] || {};
            
            // Save current state before switching
            saveState(true, false);
            
            // Switch to the new image
            switchToImage(label);
        };
        
        // *** ADDED LOGS ***
        const imageListElement = document.getElementById('imageList');
        if (!imageListElement) {
            console.error('[addImageToSidebar] Cannot find #imageList element!');
            return; // Stop if the target doesn't exist
        }
        console.log(`[addImageToSidebar] About to append container for ${label} to #imageList.`);
        imageListElement.appendChild(container);
        console.log(`[addImageToSidebar] Successfully appended container for ${label}. #imageList children: ${imageListElement.childElementCount}`);
    }
    

    // Store the original images for each view
    window.originalImages = window.originalImages || {};
    
    // --- MODIFIED Function Signature and Logic --- 
    function pasteImageFromUrl(url, label) {
        // Wrap in a Promise
        return new Promise((resolve, reject) => {
            console.log(`[pasteImageFromUrl] Pasting image for ${label}: ${url.substring(0, 30)}...`);
        
        const img = new Image();
        img.onload = () => {
            // Store the original image for this view
                window.originalImages[label] = url;
                
                // Ensure the object exists before setting properties
                if (!window.originalImageDimensions) {
                    window.originalImageDimensions = {};
                }
            
            // Store original dimensions for scaling
                window.originalImageDimensions[label] = {
                width: img.width,
                height: img.height
            };
                
                // Log dimensions for debugging
                console.log(`[pasteImageFromUrl] Stored dimensions for ${label}: ${img.width}x${img.height}`);
            
            // Clear the canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply current scale factor
                const scale = imageScaleByLabel[label] || 1.0; // Use passed-in label
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of the canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
                const position = imagePositionByLabel[label] || { x: 0, y: 0 }; // Use passed-in label
                const offsetX = position.x;
                const offsetY = position.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;
            
            // Draw the image with scaling and positioning
                console.log(`[pasteImageFromUrl] Drawing image for ${label} at Canvas(${x.toFixed(1)}, ${y.toFixed(1)}) Scale: ${scale * 100}%`);
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Update the scale display in the sidebar
                const scaleElement = document.getElementById(`scale-${label}`);
            if (scaleElement) {
                scaleElement.textContent = `Scale: ${Math.round(scale * 100)}%`;
            }
            
            // Save this as the base state for this image
            const newState = getCanvasState();
                imageStates[label] = cloneImageData(newState); // Use passed-in label
                console.log(`[pasteImageFromUrl] State saved into imageStates[${label}]`);
                
                // If this is the currently active label, update currentStroke
                if (label === currentImageLabel) {
            currentStroke = cloneImageData(newState);
                }
            
                // Initialize the undo stack if needed
                if (!undoStackByImage[label] || undoStackByImage[label].length === 0) {
                    undoStackByImage[label] = [{
                state: cloneImageData(newState),
                type: 'initial',
                label: null
            }];
                    console.log(`[pasteImageFromUrl] Initialized undo stack for ${label}`);
                }
            
                // Update the scale buttons to show active state if this is the current view
                if (label === currentImageLabel) {
            updateScaleButtonsActiveState();
                }
                
                console.log(`[pasteImageFromUrl] Image loaded and state saved for ${label}`);
                resolve(); // Resolve the promise
            };
            
            img.onerror = (err) => {
                console.error(`[pasteImageFromUrl] Error loading image for ${label}:`, err);
                reject(err); // Reject the promise on error
            };
            
        img.src = url;
        });
    }
    // --- END MODIFIED Function ---

    function getNextLabel(imageLabel) {
        const currentLabel = labelsByImage[imageLabel];
        const letter = currentLabel[0];
        const number = parseInt(currentLabel.slice(1)) + 1;
        if (number > 9) {
            return String.fromCharCode(letter.charCodeAt(0) + 1) + '0';
        }
        return letter + number;
    }

    // Make updateStrokeCounter available globally
    window.updateStrokeCounter = updateStrokeCounter;
    function updateStrokeCounter() {
        const strokeCount = lineStrokesByImage[currentImageLabel]?.length || 0;
        strokeCounter.textContent = `Lines: ${strokeCount}`;
        
        // Update visibility controls
        updateStrokeVisibilityControls();
    }
    
    function updateSidebarStrokeCounts() {
        // Update stroke counts in the sidebar
        const imageContainers = document.querySelectorAll('.image-container');
        imageContainers.forEach(container => {
            const label = container.dataset.label;
            if (label) {
                const strokesElement = container.querySelector('.image-strokes');
                if (strokesElement) {
                    const strokes = lineStrokesByImage[label] || [];
                    strokesElement.textContent = `Strokes: ${strokes.length}`;
                }
            }
        });
        
        // Also update visibility controls when sidebar is updated
        updateStrokeVisibilityControls();
    }

    function getCanvasState() {
        return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    function restoreCanvasState(state) {
        if (!state) return;
        ctx.putImageData(state, 0, 0);
    }
    
    // Measurement data for strokes
    let strokeMeasurements = {};
    
    // Initialize measurement data store
    IMAGE_LABELS.forEach(label => {
        strokeMeasurements[label] = {};
    });
    
    // Function to get formatted measurement string
    function getMeasurementString(strokeLabel) {
        const measurement = strokeMeasurements[currentImageLabel]?.[strokeLabel];
        if (!measurement) return '';
        
        const unit = document.getElementById('unitSelector').value;
        
        if (unit === 'inch') {
            const whole = measurement.inchWhole || 0;
            const fraction = measurement.inchFraction || 0;
            
            // Format as 1 1/4" etc.
            let fractionStr = '';
            if (fraction > 0) {
                const fractionMap = {
                    0.125: '1/8',
                    0.25: '1/4',
                    0.375: '3/8',
                    0.5: '1/2',
                    0.625: '5/8',
                    0.75: '3/4',
                    0.875: '7/8'
                };
                fractionStr = ' ' + fractionMap[fraction];
            }
            
            return `${whole}${fractionStr}"`;
        } else {
            // CM with one decimal
            return `${measurement.cm.toFixed(1)} cm`;
        }
    }
    
    // Function to convert between units
    function convertUnits(from, value) {
        if (from === 'inch') {
            // Convert inch to cm
            return value * 2.54;
        } else {
            // Convert cm to inch
            return value / 2.54;
        }
    }
    
    // Function to update all measurements when unit changes
    function updateMeasurementDisplay() {
        const unit = document.getElementById('unitSelector').value;
        const inchWhole = document.getElementById('inchWhole');
        const inchFraction = document.getElementById('inchFraction');
        const cmValue = document.getElementById('cmValue');
        
        // Convert values when switching between units
        if (unit === 'inch') {
            // Converting from cm to inches
            const cm = parseFloat(cmValue.value) || 0;
            const inches = cm / 2.54;
            
            // Update inch values
            inchWhole.value = Math.floor(inches);
            
            // Find closest fraction
            const fractionPart = inches - Math.floor(inches);
            const fractions = [
                {value: '0', text: '0'},
                {value: '0.125', text: '1/8'},
                {value: '0.25', text: '1/4'},
                {value: '0.375', text: '3/8'},
                {value: '0.5', text: '1/2'},
                {value: '0.625', text: '5/8'},
                {value: '0.75', text: '3/4'},
                {value: '0.875', text: '7/8'}
            ];
            
            fractions.forEach(f => {
                const option = document.createElement('option');
                option.value = f.value;
                option.textContent = f.text;
                if (parseFloat(f.value) === fractionPart) {
                    option.selected = true;
                }
                inchFraction.appendChild(option);
            });
            
            // Show inch inputs, hide cm inputs
            document.getElementById('inchInputs').style.display = 'flex';
            document.getElementById('cmInputs').style.display = 'none';
        } else {
            // Converting from inches to cm
            const whole = parseInt(inchWhole.value) || 0;
            const fraction = parseFloat(inchFraction.value) || 0;
            const totalInches = whole + fraction;
            
            // Update cm value with one decimal point
            cmValue.value = (totalInches * 2.54).toFixed(1);
            
            // Show cm inputs, hide inch inputs
            document.getElementById('inchInputs').style.display = 'none';
            document.getElementById('cmInputs').style.display = 'flex';
        }
        
        // Update the stroke visibility display to show new units
        updateStrokeVisibilityControls();
        
        // Redraw the canvas with updated measurement format in labels
        redrawCanvasWithVisibility();
    }

    // Function to update stroke visibility controls
    // Make updateStrokeVisibilityControls available globally
    window.updateStrokeVisibilityControls = updateStrokeVisibilityControls;
    function updateStrokeVisibilityControls() {
        const controlsContainer = document.getElementById('strokeVisibilityControls');
        controlsContainer.innerHTML = ''; // Clear existing controls
        
        // Add a separator at the top
        const topSeparator = document.createElement('hr');
        controlsContainer.appendChild(topSeparator);
        
        // Display current unit
        const unitDisplay = document.createElement('div');
        unitDisplay.className = 'current-unit-display';
        unitDisplay.textContent = `Current Unit: ${document.getElementById('unitSelector').value === 'inch' ? 'Inches' : 'Centimeters'}`;
        controlsContainer.appendChild(unitDisplay);
        
        // Add another separator
        const separator = document.createElement('hr');
        controlsContainer.appendChild(separator);
        
        // Create strokes list
        const strokesList = document.createElement('div');
        strokesList.id = 'strokesList';
        controlsContainer.appendChild(strokesList);
        
        // Get strokes for current image
        const strokes = lineStrokesByImage[currentImageLabel] || [];
        
        if (strokes.length === 0) {
            strokesList.innerHTML = '<p>No strokes to display</p>';
            return;
        }
        
        // Current unit
        const unit = document.getElementById('unitSelector').value;
        
        // Create visibility toggle for each stroke
        strokes.forEach(strokeLabel => {
            // Initialize visibility if not set
            if (strokeVisibilityByImage[currentImageLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel] = {};
            }
            if (strokeVisibilityByImage[currentImageLabel][strokeLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            }
            
            // Initialize label visibility if not set
            if (strokeLabelVisibility[currentImageLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel] = {};
            }
            if (strokeLabelVisibility[currentImageLabel][strokeLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel][strokeLabel] = true; // Labels visible by default
            }
            
            // Initialize measurement if not set
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            if (strokeMeasurements[currentImageLabel][strokeLabel] === undefined) {
                strokeMeasurements[currentImageLabel][strokeLabel] = {
                    inchWhole: 0,
                    inchFraction: 0,
                    cm: 0.0
                };
            }
            
            const isVisible = strokeVisibilityByImage[currentImageLabel][strokeLabel];
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            const measurement = getMeasurementString(strokeLabel);
            const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
            
            const item = document.createElement('div');
            item.className = 'stroke-visibility-item';
            item.dataset.stroke = strokeLabel;
            item.dataset.selected = isSelected ? 'true' : 'false';
            
            // Make all parts of the item selectable (except checkbox and buttons)
            item.addEventListener('click', (e) => {
                // Don't trigger selection if clicking a button or checkbox
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
                    return;
                }
                
                // Toggle selection (if already selected, deselect it)
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                
                // Update the measurement input with the selected stroke's measurement
                    if (typeof updateMeasurementInputWithStroke === 'function') {
                    updateMeasurementInputWithStroke(strokeLabel);
                }
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `visibility-${strokeLabel}`;
            checkbox.checked = isVisible;
            checkbox.addEventListener('change', () => toggleStrokeVisibility(strokeLabel, checkbox.checked));
            
            const labelContainer = document.createElement('div');
            labelContainer.className = 'stroke-label-container';
            
            // Find the stroke color from the undo stack or vector data
            let strokeColor = '#000';
            let strokeType = 'freehand'; // Default type
            
            if (vectorStrokesByImage[currentImageLabel] && 
                vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                const vectorData = vectorStrokesByImage[currentImageLabel][strokeLabel];
                strokeColor = vectorData.color || '#000';
                strokeType = vectorData.type || 'freehand';
            } else {
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel && action.color) {
                        strokeColor = action.color;
                        // Try to determine stroke type from action
                        if (action.type === 'line') {
                            strokeType = 'straight';
                        }
                        break;
                    }
                }
            }
            
            // Create the stroke name element with color matching the stroke
            const strokeName = document.createElement('span');
            strokeName.className = 'stroke-name';
            strokeName.textContent = strokeLabel;
            strokeName.style.borderColor = strokeColor;
            strokeName.style.color = strokeColor;
            
            // Add a small icon to indicate stroke type (optional)
            if (strokeType === 'straight') {
                strokeName.title = 'Straight Line';
            } else {
                strokeName.title = 'Freehand Stroke';
            }
            
            // Make stroke name label clickable for selection as well
            strokeName.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent double handling with the item click
                
                // Toggle selection 
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            // Create measurement text
            const measureText = document.createElement('span');
            measureText.className = 'stroke-measurement';
            measureText.textContent = measurement ? `= ${measurement}` : '';
            
            // Create edit button
            const editBtn = document.createElement('button');
            editBtn.className = 'stroke-edit-btn';
            editBtn.innerHTML = '✏️';
            editBtn.title = 'Edit Stroke';
            editBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                showEditDialog(strokeLabel);
            };
            
            // Create label toggle button
            const labelToggleBtn = document.createElement('button');
            labelToggleBtn.className = 'stroke-label-toggle';
            labelToggleBtn.classList.toggle('active', isLabelVisible);
            labelToggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            labelToggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            labelToggleBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                toggleLabelVisibility(strokeLabel);
            };
            
            // Add elements to container
            labelContainer.appendChild(strokeName);
            labelContainer.appendChild(measureText);
            labelContainer.appendChild(labelToggleBtn);
            labelContainer.appendChild(editBtn);
            
            // Build the complete item
            item.appendChild(checkbox);
            item.appendChild(labelContainer);
            
            // Add to stroke list
            strokesList.appendChild(item);
        });
    }
    
    // Function to toggle label visibility on canvas
    function toggleLabelVisibility(strokeLabel) {
        // Only toggle the label visibility, not the stroke visibility
        strokeLabelVisibility[currentImageLabel][strokeLabel] = !strokeLabelVisibility[currentImageLabel][strokeLabel];
        
        // Update the UI button appearance
        const toggleBtn = document.querySelector(`.stroke-visibility-item[data-stroke="${strokeLabel}"] .stroke-label-toggle`);
        if (toggleBtn) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            toggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            toggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            toggleBtn.classList.toggle('active', isLabelVisible);
        }
        
        // Redraw the canvas with updated label visibility
        // This should not affect the stroke visibility
        redrawCanvasWithVisibility();
    }
    
    // Function to update measurement input with selected stroke's value
    // Function to display a measurement edit dialog
    function showMeasurementDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurement
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Measurement for ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values from inputs
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Determine which unit was changed last and use that value
            const currentUnit = document.getElementById('unitSelector').value;
            let finalCmValue, finalInchWhole, finalInchFraction;
            
            if (currentUnit === 'inch') {
                finalInchWhole = wholeValue;
                finalInchFraction = fractionValue;
                finalCmValue = convertUnits('inch', wholeValue + fractionValue);
            } else {
                finalCmValue = cmValue;
                // Calculate inch equivalent
                const inches = convertUnits('cm', cmValue);
                finalInchWhole = Math.floor(inches);
                finalInchFraction = findClosestFraction(inches - finalInchWhole);
            }
            
            // Update the measurement
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            
            strokeMeasurements[currentImageLabel][strokeLabel] = {
                inchWhole: finalInchWhole,
                inchFraction: finalInchFraction,
                cm: finalCmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update the UI
            updateStrokeVisibilityControls();
            
            // Redraw with the new measurement
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Helper function to find the closest fraction
    function findClosestFraction(fractionPart) {
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        return closestFraction;
    }
    
    // Function to show edit dialog for a stroke
    function showEditDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurements
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Stroke ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Create name edit field
        const nameContainer = document.createElement('div');
        nameContainer.className = 'name-container';
        
        const nameLabel = document.createElement('div');
        nameLabel.textContent = 'Label:';
        nameContainer.appendChild(nameLabel);
        
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = strokeLabel;
        nameInput.placeholder = 'Label';
        nameContainer.appendChild(nameInput);
        
        dialog.appendChild(nameContainer);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Sync between inch and cm inputs
        wholeInput.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        fractionSelect.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        cmInput.addEventListener('change', () => {
            const cmValue = parseFloat(cmInput.value) || 0;
            const inches = convertUnits('cm', cmValue);
            const wholeValue = Math.floor(inches);
            const fractionValue = findClosestFraction(inches - wholeValue);
            
            wholeInput.value = wholeValue;
            fractionSelect.value = fractionValue.toString();
        });
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values
            const newName = nameInput.value.trim();
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Update name if changed
            let finalName = strokeLabel;
            if (newName !== strokeLabel && newName !== '') {
                // The unique name generation is handled inside renameStroke
                finalName = renameStroke(strokeLabel, newName);
                
                // Show feedback if name was modified to make it unique
                if (finalName !== newName) {
                    console.log(`Stroke name automatically adjusted to ${finalName} to avoid duplicates`);
                    
                    // Create and show a temporary notification
                    const notification = document.createElement('div');
                    notification.style.position = 'fixed';
                    notification.style.bottom = '20px';
                    notification.style.left = '50%';
                    notification.style.transform = 'translateX(-50%)';
                    notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                    notification.style.color = 'white';
                    notification.style.padding = '10px 20px';
                    notification.style.borderRadius = '4px';
                    notification.style.zIndex = '10000';
                    notification.textContent = `Renamed to ${finalName} to avoid duplicates`;
                    
                    document.body.appendChild(notification);
                    
                    // Remove after 3 seconds
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 3000);
                }
            }
            
            // Always save both units
            strokeMeasurements[currentImageLabel][finalName] = {
                inchWhole: wholeValue,
                inchFraction: fractionValue,
                cm: cmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update UI
            updateStrokeVisibilityControls();
            
            // Redraw to show updated measurements
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Function to generate a unique stroke name
    function generateUniqueStrokeName(baseName) {
        // If the name is empty or undefined, use a default name
        if (!baseName || baseName.trim() === '') {
            baseName = 'A1';
        }
        
        // If the base name doesn't already exist, we can use it as is
        if (!lineStrokesByImage[currentImageLabel] || 
            !lineStrokesByImage[currentImageLabel].includes(baseName)) {
            return baseName;
        }
        
        // Name already exists, so we need to add a number
        // Extract the base part and any existing numbering
        const match = baseName.match(/^(.+?)(?:\((\d+)\))?$/);
        if (!match) {
            // If the regex didn't match for some reason, append (1) to the name
            return `${baseName}(1)`;
        }
        
        const base = match[1];
        let counter = 1;
        
        // If there was already a number, start from the next one
        if (match[2]) {
            counter = parseInt(match[2]) + 1;
        }
        
        // Keep incrementing until we find a unique name
        let newName;
        do {
            newName = `${base}(${counter})`;
            counter++;
        } while (lineStrokesByImage[currentImageLabel].includes(newName));
        
        return newName;
    }
    
    // Function to rename a stroke
    function renameStroke(oldName, newName) {
        if (oldName === newName) return;
        
        // Generate a unique name if needed - this ensures the new name won't conflict
        // with any existing stroke names, including itself
        const uniqueNewName = generateUniqueStrokeName(newName);
        
        // Find the stroke color from the undo stack or vector data to maintain color after rename
        let strokeColor = '#000';
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            strokeColor = vectorStrokesByImage[currentImageLabel][oldName].color || '#000';
        } else {
            for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                const action = undoStackByImage[currentImageLabel][i];
                if (action.label === oldName && action.color) {
                    strokeColor = action.color;
                    // Try to determine stroke type from action
                    if (action.type === 'line') {
                        strokeType = 'straight';
                    }
                    break;
                }
            }
        }
        
        // Update all relevant data structures
        if (lineStrokesByImage[currentImageLabel]) {
            const index = lineStrokesByImage[currentImageLabel].indexOf(oldName);
            if (index !== -1) {
                lineStrokesByImage[currentImageLabel][index] = uniqueNewName;
            }
        }
        
        // Update visibility
        if (strokeVisibilityByImage[currentImageLabel] && 
            strokeVisibilityByImage[currentImageLabel][oldName] !== undefined) {
            const isVisible = strokeVisibilityByImage[currentImageLabel][oldName];
            strokeVisibilityByImage[currentImageLabel][uniqueNewName] = isVisible;
            delete strokeVisibilityByImage[currentImageLabel][oldName];
        }
        
        // Update label visibility
        if (strokeLabelVisibility[currentImageLabel] && 
            strokeLabelVisibility[currentImageLabel][oldName] !== undefined) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][oldName];
            strokeLabelVisibility[currentImageLabel][uniqueNewName] = isLabelVisible;
            delete strokeLabelVisibility[currentImageLabel][oldName];
        }
        
        // Update stroke data
        if (strokeDataByImage[currentImageLabel] && 
            strokeDataByImage[currentImageLabel][oldName]) {
            strokeDataByImage[currentImageLabel][uniqueNewName] = 
                strokeDataByImage[currentImageLabel][oldName];
            delete strokeDataByImage[currentImageLabel][oldName];
        }
        
        // Update vector data
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            vectorStrokesByImage[currentImageLabel][uniqueNewName] = 
                vectorStrokesByImage[currentImageLabel][oldName];
            delete vectorStrokesByImage[currentImageLabel][oldName];
        }
        
        // Update measurements
        if (strokeMeasurements[currentImageLabel] && 
            strokeMeasurements[currentImageLabel][oldName]) {
            strokeMeasurements[currentImageLabel][uniqueNewName] = 
                strokeMeasurements[currentImageLabel][oldName];
            delete strokeMeasurements[currentImageLabel][oldName];
        }
        
        // Update next label if needed
        if (labelsByImage[currentImageLabel] === oldName) {
            labelsByImage[currentImageLabel] = uniqueNewName;
        }
        
        // Update any references in the undo/redo stacks
        if (undoStackByImage[currentImageLabel]) {
            undoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        if (redoStackByImage[currentImageLabel]) {
            redoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        // Return the actual name used for the stroke (either the original or the uniquified version)
        return uniqueNewName;
    }
    
    // Function to toggle stroke visibility
    function toggleStrokeVisibility(strokeLabel, isVisible) {
        console.log(`Toggling visibility of stroke ${strokeLabel} to ${isVisible}`);
        
        // Update visibility state
        strokeVisibilityByImage[currentImageLabel][strokeLabel] = isVisible;
        
        // Make sure the stroke data is still available and not accidentally cleared
        if (isVisible) {
            // Initialize vectorStrokesByImage for this image if it doesn't exist
            if (!vectorStrokesByImage[currentImageLabel]) {
                vectorStrokesByImage[currentImageLabel] = {};
            }
            
            // If we're making a stroke visible, ensure we still have vector data
            if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                console.log(`Vector data missing for ${strokeLabel}, attempting recovery`);
                
                // Try to recover vector data from the undo stack
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel) {
                        if (action.vectorData) {
                            vectorStrokesByImage[currentImageLabel][strokeLabel] = action.vectorData;
                            console.log(`Recovered vector data for ${strokeLabel}`);
                            break;
                        }
                    }
                }
                
                // If we still couldn't recover the vector data, create a basic one
                // This is especially important for straight lines
                if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                    console.log(`Creating default vector data for ${strokeLabel}`);
                    
                    // Look for color and properties in the undo stack
                    let strokeColor = "#000000";
                    let strokeWidth = 5;
                    let isLine = false;
                    
                    for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                        const action = undoStackByImage[currentImageLabel][i];
                        if (action.label === strokeLabel) {
                            if (action.color) strokeColor = action.color;
                            if (action.width) strokeWidth = action.width;
                            if (action.type === 'line' || action.type === 'straight') isLine = true;
                            break;
                        }
                    }
                    
                    // Create a simple vector representation (placeholder)
                    vectorStrokesByImage[currentImageLabel][strokeLabel] = {
                        points: isLine ? [{x: 0, y: 0}, {x: 1, y: 1}] : [{x: 0, y: 0}],
                        color: strokeColor,
                        width: strokeWidth,
                        type: isLine ? 'straight' : 'freehand'
                    };
                }
            }
        };

        // *** Add redraw call here ***
        redrawCanvasWithVisibility();
    }
    
    // Store for currently selected stroke in each image
    let selectedStrokeByImage = {};
    
    // Initialize stroke label visibility for each image (default to visible)
    IMAGE_LABELS.forEach(label => {
        strokeLabelVisibility[label] = {};
        selectedStrokeByImage[label] = null; // Initialize with no selection
    });
    
    // Store for label custom positions (user-dragged positions)
    let customLabelPositions = {};
    
    // Flag to track if we're dragging a label
    let isDraggingLabel = false;
    let draggedLabelStroke = null;
    let dragStartX = 0;
    let dragStartY = 0;
    
    // Initialize custom label positions for each image
    IMAGE_LABELS.forEach(label => {
        customLabelPositions[label] = {};
    });
    
    // Cache for loaded images to prevent flickering
    const imageCache = {};
    
    // Store for label positions to prevent overlapping
    let currentLabelPositions = [];
    
    // Store for stroke paths to avoid overlapping with lines
    let currentStrokePaths = [];
    
    // Function to redraw canvas respecting stroke visibility
    // Make redrawCanvasWithVisibility available globally
    window.redrawCanvasWithVisibility = redrawCanvasWithVisibility;
    function redrawCanvasWithVisibility() {
        console.log(`--- redrawCanvasWithVisibility called for: ${currentImageLabel} ---`);
        
        // *** Save context and reset transform before drawing anything ***
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset to identity matrix
        console.log("Redraw Start Transform:", ctx.getTransform());
        
        // ADDED: Ensure originalImageDimensions exists and has an entry for this label
        if (!window.originalImageDimensions) {
            window.originalImageDimensions = {};
        }
        
        // ADDED: If we don't have dimensions for this label but we're trying to draw strokes,
        // create default dimensions based on the canvas size to prevent coordinates from being lost
        if (!window.originalImageDimensions[currentImageLabel] && 
            window.vectorStrokesByImage[currentImageLabel] && 
            Object.keys(window.vectorStrokesByImage[currentImageLabel]).length > 0) {
            
            console.log(`Creating default dimensions for ${currentImageLabel} to preserve strokes`);
            window.originalImageDimensions[currentImageLabel] = {
                width: canvas.width,
                height: canvas.height
            };
            console.log(`Set dimensions to match canvas: ${canvas.width}x${canvas.height}`);
        }
        
        // Reset label positions and stroke paths for this redraw
        currentLabelPositions = [];
        currentStrokePaths = [];
        
        // Create a copy of custom label positions for tracking which ones were actually used
        const usedCustomPositions = {};
        
        // We need to rebuild the canvas from scratch using individual stroke data
        const strokes = window.lineStrokesByImage[currentImageLabel] || [];
        
        // Start with a blank canvas or the original image if available
        if (window.originalImages && window.originalImages[currentImageLabel]) {
            // Check if we already have this image in the cache
            const imageUrl = window.originalImages[currentImageLabel];
            
            if (imageCache[imageUrl]) {
                // Use cached image immediately
                drawImageAndStrokes(imageCache[imageUrl]);
            } else {
                // Load the image and cache it
                const img = new Image();
                img.onload = () => {
                    // Add to cache
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                };
                img.src = imageUrl;
                
                // If the image is already cached in the browser, it might be immediately available
                if (img.complete) {
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                } else {
                    // If the image isn't immediately available,
                    // still draw the strokes on a blank canvas so they don't disappear
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the current scale and position
                    const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
                    
                    // For blank canvas mode, we apply the position directly when drawing points
                    // We pass 0,0 for position here since we'll apply it inside applyVisibleStrokes
                    applyVisibleStrokes(scale, 0, 0);
                }
            }
        } else {
            // Otherwise start with a blank canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white'; // Add white background fill
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Get the current scale for the blank canvas state
            const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
            
            // Apply visible strokes - for blank canvas mode, we don't need to apply position offset here
            // since we'll apply it to each point when drawing
            applyVisibleStrokes(scale, 0, 0);
        }
        
        function drawImageAndStrokes(img) {
            // Clear only once within the reset transform state
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply scale
            const scale = window.imageScaleByLabel[currentImageLabel];
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
            const positionOffset = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 }; // Ensure offset exists
            const offsetX = positionOffset.x;
            const offsetY = positionOffset.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;

            // *** ADDED LOGGING ***
            // console.log(`drawImageAndStrokes Calculation:
            //   canvas.width=${canvas.width}, img.width=${img.width}, scaledWidth=${scaledWidth}
            //   scale=${scale}, centerX=${centerX}, offsetX=${offsetX}, final imageX (passed to applyVisibleStrokes)=${x}`);
            // *** END LOGGING ***
            
            // Draw the image with scaling and positioning
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Then apply visible strokes
            applyVisibleStrokes(scale, x, y);
        }
        
        function applyVisibleStrokes(scale, imageX, imageY) {
            console.log("ApplyStrokes Start Transform:", ctx.getTransform()); // Log transform at start
// Define global variables for use by project-manager.js
window.IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
window.currentImageLabel = 'front';
window.vectorStrokesByImage = {};
window.strokeVisibilityByImage = {};
window.strokeLabelVisibility = {};
window.strokeMeasurements = {};
window.imageScaleByLabel = {};
window.imagePositionByLabel = {};
window.lineStrokesByImage = {}; // Make sure it's exposed globally
window.labelsByImage = {};      // Make sure it's exposed globally
window.originalImages = {};
window.isLoadingProject = false; // <-- Re-adding this line

// At the top of the file, near other global variables
window.debugCoordinates = false; // Global flag to control coordinate debugging

document.addEventListener('DOMContentLoaded', () => {
    // Initialize unit selectors
    const unitSelector = document.getElementById('unitSelector');
    unitSelector.addEventListener('change', updateMeasurementDisplay);
    
    // Add debug toggle button to the controls
    const controlsContainer = document.querySelector('.controls-container');
    const debugToggle = document.createElement('button');
    debugToggle.textContent = '🐞 Debug';
    debugToggle.classList.add('debug-toggle');
    debugToggle.addEventListener('click', () => {
        window.debugCoordinates = !window.debugCoordinates;
        debugToggle.classList.toggle('active', window.debugCoordinates);
        console.log(`Coordinate debugging ${window.debugCoordinates ? 'enabled' : 'disabled'}`);
    });
    controlsContainer.appendChild(debugToggle);
    
    // Initialize the measurement inputs
    const inchWhole = document.getElementById('inchWhole');
    const inchFraction = document.getElementById('inchFraction');
    const cmValue = document.getElementById('cmValue');
    
    // Handle unit conversion when changing values
    inchWhole.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    inchFraction.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    cmValue.addEventListener('change', () => {
        const cm = parseFloat(cmValue.value) || 0;
        const inches = cm / 2.54;
        
        // Update inch values
        inchWhole.value = Math.floor(inches);
        
        // Find closest fraction
        const fractionPart = inches - Math.floor(inches);
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        inchFraction.value = closestFraction;
        
        // Show inch inputs, hide cm inputs
        document.getElementById('inchInputs').style.display = 'flex';
        document.getElementById('cmInputs').style.display = 'none';
    });
    
    const canvas = document.getElementById('canvas');
    // Expose canvas globally for project management
    window.canvas = canvas;
    const ctx = canvas.getContext('2d', { willReadFrequently: true }); // Add willReadFrequently hint
    const colorPicker = document.getElementById('colorPicker');
    const brushSize = document.getElementById('brushSize');
    const clearButton = document.getElementById('clear');
    const saveButton = document.getElementById('save');
    const pasteButton = document.getElementById('paste');
    const strokeCounter = document.getElementById('strokeCounter');
    const imageList = document.getElementById('imageList');
    const drawingModeToggle = document.getElementById('drawingModeToggle');
    
    // Draggable sidebars
    const strokeSidebar = document.getElementById('strokeSidebar');
    const imageSidebar = document.getElementById('imageSidebar');
    const strokeSidebarHeader = document.getElementById('strokeSidebarHeader');
    const imageSidebarHeader = document.getElementById('imageSidebarHeader');

    // Undo/Redo functionality
    const MAX_HISTORY = 50;  // Maximum number of states to store
    const IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
    let currentImageIndex = 0;
    let imageStates = {}; // Store states for each image
    
    // Use the global variables instead of creating new ones
    let strokeDataByImage = {}; // Store additional data for each stroke
    let undoStackByImage = {}; // Separate undo stack for each image
    let redoStackByImage = {}; // Separate redo stack for each image
    let pastedImages = [];  // Store all pasted images
    let isDrawingOrPasting = false;  // Flag to prevent saving states while drawing
    let strokeInProgress = false;  // Track if we're in the middle of a stroke
    let currentStroke = null;  // Store the state before current stroke
    let originalImageDimensions = {}; // Store original image dimensions for scaling
    let isShiftPressed = false; // Track if Shift key is pressed for image movement
    let calculatedLabelOffsets = {}; // Store automatically calculated label offsets

    // Initialize states for default images
    IMAGE_LABELS.forEach(label => {
        // Ensure we initialize global arrays properly
        window.lineStrokesByImage[label] = [];
        window.strokeVisibilityByImage[label] = {}; // Initialize stroke visibility
        window.vectorStrokesByImage[label] = {}; // Initialize vector stroke data
        window.labelsByImage[label] = 'A1';  // Start from A1 instead of A0
        
        strokeDataByImage[label] = {}; // Initialize stroke data
        undoStackByImage[label] = [];
        redoStackByImage[label] = [];  // Initialize redo stack
        imageStates[label] = null;
        // Initialize scale to 100% (1.0)
        window.imageScaleByLabel[label] = 1.0;
        originalImageDimensions[label] = { width: 0, height: 0 };
        // Initialize position offset to center (0, 0)
        window.imagePositionByLabel[label] = { x: 0, y: 0 };
        // Initialize with a blank state when the image is first created
        const blankState = ctx.createImageData(canvas.width, canvas.height);
        imageStates[label] = blankState;
        undoStackByImage[label].push({
            state: cloneImageData(blankState),
            type: 'initial',
            label: null
        });
    });

    let currentImageLabel = IMAGE_LABELS[0]; // Start with 'front'

    // Make addImageToSidebar available globally for the project manager
    window.addImageToSidebar = addImageToSidebar;
    function addImageToSidebar(imageUrl, label) {
        // *** ADDED LOG ***
        console.log(`[addImageToSidebar] Called for label: ${label}, imageUrl: ${imageUrl ? imageUrl.substring(0,30) + '...' : 'null'}`);

        const container = document.createElement('div');
        container.className = 'image-container';
        container.dataset.label = label;
        container.dataset.originalImageUrl = imageUrl; // Store the original image URL for later restoration
        
        const labelElement = document.createElement('div');
        labelElement.className = 'image-label';
        labelElement.textContent = label.charAt(0).toUpperCase() + label.slice(1);
        
        const strokesElement = document.createElement('div');
        strokesElement.className = 'image-strokes';
        strokesElement.textContent = 'Strokes: 0';
        
        const scaleElement = document.createElement('div');
        scaleElement.className = 'image-scale';
        scaleElement.textContent = `Scale: ${Math.round(imageScaleByLabel[label] * 100)}%`;
        scaleElement.id = `scale-${label}`;
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.className = 'pasted-image';
        img.alt = `${label} view`;
        
        container.appendChild(img);
        container.appendChild(labelElement);
        container.appendChild(strokesElement);
        container.appendChild(scaleElement);
        
        container.onclick = () => {
            // ... rest of the handler
            
            console.log(`Switching from ${currentImageLabel} to ${label}`);
            
            // Ensure we have undo stacks for both workspaces
            undoStackByImage[currentImageLabel] = undoStackByImage[currentImageLabel] || [];
            undoStackByImage[label] = undoStackByImage[label] || [];
            
            // Ensure we have redo stacks for both workspaces
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[label] = redoStackByImage[label] || [];
            
            // Ensure we have stroke lists for both workspaces
            lineStrokesByImage[currentImageLabel] = lineStrokesByImage[currentImageLabel] || [];
            lineStrokesByImage[label] = lineStrokesByImage[label] || [];
            
            // Ensure we have stroke visibility for both workspaces
            strokeVisibilityByImage[currentImageLabel] = strokeVisibilityByImage[currentImageLabel] || {};
            strokeVisibilityByImage[label] = strokeVisibilityByImage[label] || {};
            
            // Save current state before switching
            saveState(true, false);
            
            // Switch to the new image
            switchToImage(label);
        };
        
        // *** ADDED LOGS ***
        const imageListElement = document.getElementById('imageList');
        if (!imageListElement) {
            console.error('[addImageToSidebar] Cannot find #imageList element!');
            return; // Stop if the target doesn't exist
        }
        console.log(`[addImageToSidebar] About to append container for ${label} to #imageList.`);
        imageListElement.appendChild(container);
        console.log(`[addImageToSidebar] Successfully appended container for ${label}. #imageList children: ${imageListElement.childElementCount}`);
    }
    

    // Store the original images for each view
    window.originalImages = window.originalImages || {};
    
    // --- MODIFIED Function Signature and Logic --- 
    function pasteImageFromUrl(url, label) {
        // Wrap in a Promise
        return new Promise((resolve, reject) => {
            console.log(`[pasteImageFromUrl] Pasting image for ${label}: ${url.substring(0, 30)}...`);
        
        const img = new Image();
        img.onload = () => {
            // Store the original image for this view
                window.originalImages[label] = url;
                
                // Ensure the object exists before setting properties
                if (!window.originalImageDimensions) {
                    window.originalImageDimensions = {};
                }
            
            // Store original dimensions for scaling
                window.originalImageDimensions[label] = {
                width: img.width,
                height: img.height
            };
                
                // Log dimensions for debugging
                console.log(`[pasteImageFromUrl] Stored dimensions for ${label}: ${img.width}x${img.height}`);
            
            // Clear the canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply current scale factor
                const scale = imageScaleByLabel[label] || 1.0; // Use passed-in label
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of the canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
                const position = imagePositionByLabel[label] || { x: 0, y: 0 }; // Use passed-in label
                const offsetX = position.x;
                const offsetY = position.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;
            
            // Draw the image with scaling and positioning
                console.log(`[pasteImageFromUrl] Drawing image for ${label} at Canvas(${x.toFixed(1)}, ${y.toFixed(1)}) Scale: ${scale * 100}%`);
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Update the scale display in the sidebar
                const scaleElement = document.getElementById(`scale-${label}`);
            if (scaleElement) {
                scaleElement.textContent = `Scale: ${Math.round(scale * 100)}%`;
            }
            
            // Save this as the base state for this image
            const newState = getCanvasState();
                imageStates[label] = cloneImageData(newState); // Use passed-in label
                console.log(`[pasteImageFromUrl] State saved into imageStates[${label}]`);
                
                // If this is the currently active label, update currentStroke
                if (label === currentImageLabel) {
            currentStroke = cloneImageData(newState);
                }
            
                // Initialize the undo stack if needed
                if (!undoStackByImage[label] || undoStackByImage[label].length === 0) {
                    undoStackByImage[label] = [{
                state: cloneImageData(newState),
                type: 'initial',
                label: null
            }];
                    console.log(`[pasteImageFromUrl] Initialized undo stack for ${label}`);
                }
            
                // Update the scale buttons to show active state if this is the current view
                if (label === currentImageLabel) {
            updateScaleButtonsActiveState();
                }
                
                console.log(`[pasteImageFromUrl] Image loaded and state saved for ${label}`);
                resolve(); // Resolve the promise
            };
            
            img.onerror = (err) => {
                console.error(`[pasteImageFromUrl] Error loading image for ${label}:`, err);
                reject(err); // Reject the promise on error
            };
            
        img.src = url;
        });
    }
    // --- END MODIFIED Function ---

    function getNextLabel(imageLabel) {
        const currentLabel = labelsByImage[imageLabel];
        const letter = currentLabel[0];
        const number = parseInt(currentLabel.slice(1)) + 1;
        if (number > 9) {
            return String.fromCharCode(letter.charCodeAt(0) + 1) + '0';
        }
        return letter + number;
    }

    // Make updateStrokeCounter available globally
    window.updateStrokeCounter = updateStrokeCounter;
    function updateStrokeCounter() {
        const strokeCount = lineStrokesByImage[currentImageLabel]?.length || 0;
        strokeCounter.textContent = `Lines: ${strokeCount}`;
        
        // Update visibility controls
        updateStrokeVisibilityControls();
    }
    
    function updateSidebarStrokeCounts() {
        // Update stroke counts in the sidebar
        const imageContainers = document.querySelectorAll('.image-container');
        imageContainers.forEach(container => {
            const label = container.dataset.label;
            if (label) {
                const strokesElement = container.querySelector('.image-strokes');
                if (strokesElement) {
                    const strokes = lineStrokesByImage[label] || [];
                    strokesElement.textContent = `Strokes: ${strokes.length}`;
                }
            }
        });
        
        // Also update visibility controls when sidebar is updated
        updateStrokeVisibilityControls();
    }

    function getCanvasState() {
        return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    function restoreCanvasState(state) {
        if (!state) return;
        ctx.putImageData(state, 0, 0);
    }
    
    // Measurement data for strokes
    let strokeMeasurements = {};
    
    // Initialize measurement data store
    IMAGE_LABELS.forEach(label => {
        strokeMeasurements[label] = {};
    });
    
    // Function to get formatted measurement string
    function getMeasurementString(strokeLabel) {
        const measurement = strokeMeasurements[currentImageLabel]?.[strokeLabel];
        if (!measurement) return '';
        
        const unit = document.getElementById('unitSelector').value;
        
        if (unit === 'inch') {
            const whole = measurement.inchWhole || 0;
            const fraction = measurement.inchFraction || 0;
            
            // Format as 1 1/4" etc.
            let fractionStr = '';
            if (fraction > 0) {
                const fractionMap = {
                    0.125: '1/8',
                    0.25: '1/4',
                    0.375: '3/8',
                    0.5: '1/2',
                    0.625: '5/8',
                    0.75: '3/4',
                    0.875: '7/8'
                };
                fractionStr = ' ' + fractionMap[fraction];
            }
            
            return `${whole}${fractionStr}"`;
        } else {
            // CM with one decimal
            return `${measurement.cm.toFixed(1)} cm`;
        }
    }
    
    // Function to convert between units
    function convertUnits(from, value) {
        if (from === 'inch') {
            // Convert inch to cm
            return value * 2.54;
        } else {
            // Convert cm to inch
            return value / 2.54;
        }
    }
    
    // Function to update all measurements when unit changes
    function updateMeasurementDisplay() {
        const unit = document.getElementById('unitSelector').value;
        const inchWhole = document.getElementById('inchWhole');
        const inchFraction = document.getElementById('inchFraction');
        const cmValue = document.getElementById('cmValue');
        
        // Convert values when switching between units
        if (unit === 'inch') {
            // Converting from cm to inches
            const cm = parseFloat(cmValue.value) || 0;
            const inches = cm / 2.54;
            
            // Update inch values
            inchWhole.value = Math.floor(inches);
            
            // Find closest fraction
            const fractionPart = inches - Math.floor(inches);
            const fractions = [
                {value: '0', text: '0'},
                {value: '0.125', text: '1/8'},
                {value: '0.25', text: '1/4'},
                {value: '0.375', text: '3/8'},
                {value: '0.5', text: '1/2'},
                {value: '0.625', text: '5/8'},
                {value: '0.75', text: '3/4'},
                {value: '0.875', text: '7/8'}
            ];
            
            fractions.forEach(f => {
                const option = document.createElement('option');
                option.value = f.value;
                option.textContent = f.text;
                if (parseFloat(f.value) === fractionPart) {
                    option.selected = true;
                }
                inchFraction.appendChild(option);
            });
            
            // Show inch inputs, hide cm inputs
            document.getElementById('inchInputs').style.display = 'flex';
            document.getElementById('cmInputs').style.display = 'none';
        } else {
            // Converting from inches to cm
            const whole = parseInt(inchWhole.value) || 0;
            const fraction = parseFloat(inchFraction.value) || 0;
            const totalInches = whole + fraction;
            
            // Update cm value with one decimal point
            cmValue.value = (totalInches * 2.54).toFixed(1);
            
            // Show cm inputs, hide inch inputs
            document.getElementById('inchInputs').style.display = 'none';
            document.getElementById('cmInputs').style.display = 'flex';
        }
        
        // Update the stroke visibility display to show new units
        updateStrokeVisibilityControls();
        
        // Redraw the canvas with updated measurement format in labels
        redrawCanvasWithVisibility();
    }

    // Function to update stroke visibility controls
    // Make updateStrokeVisibilityControls available globally
    window.updateStrokeVisibilityControls = updateStrokeVisibilityControls;
    function updateStrokeVisibilityControls() {
        const controlsContainer = document.getElementById('strokeVisibilityControls');
        controlsContainer.innerHTML = ''; // Clear existing controls
        
        // Add a separator at the top
        const topSeparator = document.createElement('hr');
        controlsContainer.appendChild(topSeparator);
        
        // Display current unit
        const unitDisplay = document.createElement('div');
        unitDisplay.className = 'current-unit-display';
        unitDisplay.textContent = `Current Unit: ${document.getElementById('unitSelector').value === 'inch' ? 'Inches' : 'Centimeters'}`;
        controlsContainer.appendChild(unitDisplay);
        
        // Add another separator
        const separator = document.createElement('hr');
        controlsContainer.appendChild(separator);
        
        // Create strokes list
        const strokesList = document.createElement('div');
        strokesList.id = 'strokesList';
        controlsContainer.appendChild(strokesList);
        
        // Get strokes for current image
        const strokes = lineStrokesByImage[currentImageLabel] || [];
        
        if (strokes.length === 0) {
            strokesList.innerHTML = '<p>No strokes to display</p>';
            return;
        }
        
        // Current unit
        const unit = document.getElementById('unitSelector').value;
        
        // Create visibility toggle for each stroke
        strokes.forEach(strokeLabel => {
            // Initialize visibility if not set
            if (strokeVisibilityByImage[currentImageLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel] = {};
            }
            if (strokeVisibilityByImage[currentImageLabel][strokeLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            }
            
            // Initialize label visibility if not set
            if (strokeLabelVisibility[currentImageLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel] = {};
            }
            if (strokeLabelVisibility[currentImageLabel][strokeLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel][strokeLabel] = true; // Labels visible by default
            }
            
            // Initialize measurement if not set
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            if (strokeMeasurements[currentImageLabel][strokeLabel] === undefined) {
                strokeMeasurements[currentImageLabel][strokeLabel] = {
                    inchWhole: 0,
                    inchFraction: 0,
                    cm: 0.0
                };
            }
            
            const isVisible = strokeVisibilityByImage[currentImageLabel][strokeLabel];
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            const measurement = getMeasurementString(strokeLabel);
            const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
            
            const item = document.createElement('div');
            item.className = 'stroke-visibility-item';
            item.dataset.stroke = strokeLabel;
            item.dataset.selected = isSelected ? 'true' : 'false';
            
            // Make all parts of the item selectable (except checkbox and buttons)
            item.addEventListener('click', (e) => {
                // Don't trigger selection if clicking a button or checkbox
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
                    return;
                }
                
                // Toggle selection (if already selected, deselect it)
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                
                // Update the measurement input with the selected stroke's measurement
                    if (typeof updateMeasurementInputWithStroke === 'function') {
                    updateMeasurementInputWithStroke(strokeLabel);
                }
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `visibility-${strokeLabel}`;
            checkbox.checked = isVisible;
            checkbox.addEventListener('change', () => toggleStrokeVisibility(strokeLabel, checkbox.checked));
            
            const labelContainer = document.createElement('div');
            labelContainer.className = 'stroke-label-container';
            
            // Find the stroke color from the undo stack or vector data
            let strokeColor = '#000';
            let strokeType = 'freehand'; // Default type
            
            if (vectorStrokesByImage[currentImageLabel] && 
                vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                const vectorData = vectorStrokesByImage[currentImageLabel][strokeLabel];
                strokeColor = vectorData.color || '#000';
                strokeType = vectorData.type || 'freehand';
            } else {
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel && action.color) {
                        strokeColor = action.color;
                        // Try to determine stroke type from action
                        if (action.type === 'line') {
                            strokeType = 'straight';
                        }
                        break;
                    }
                }
            }
            
            // Create the stroke name element with color matching the stroke
            const strokeName = document.createElement('span');
            strokeName.className = 'stroke-name';
            strokeName.textContent = strokeLabel;
            strokeName.style.borderColor = strokeColor;
            strokeName.style.color = strokeColor;
            
            // Add a small icon to indicate stroke type (optional)
            if (strokeType === 'straight') {
                strokeName.title = 'Straight Line';
            } else {
                strokeName.title = 'Freehand Stroke';
            }
            
            // Make stroke name label clickable for selection as well
            strokeName.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent double handling with the item click
                
                // Toggle selection 
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            // Create measurement text
            const measureText = document.createElement('span');
            measureText.className = 'stroke-measurement';
            measureText.textContent = measurement ? `= ${measurement}` : '';
            
            // Create edit button
            const editBtn = document.createElement('button');
            editBtn.className = 'stroke-edit-btn';
            editBtn.innerHTML = '✏️';
            editBtn.title = 'Edit Stroke';
            editBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                showEditDialog(strokeLabel);
            };
            
            // Create label toggle button
            const labelToggleBtn = document.createElement('button');
            labelToggleBtn.className = 'stroke-label-toggle';
            labelToggleBtn.classList.toggle('active', isLabelVisible);
            labelToggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            labelToggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            labelToggleBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                toggleLabelVisibility(strokeLabel);
            };
            
            // Add elements to container
            labelContainer.appendChild(strokeName);
            labelContainer.appendChild(measureText);
            labelContainer.appendChild(labelToggleBtn);
            labelContainer.appendChild(editBtn);
            
            // Build the complete item
            item.appendChild(checkbox);
            item.appendChild(labelContainer);
            
            // Add to stroke list
            strokesList.appendChild(item);
        });
    }
    
    // Function to toggle label visibility on canvas
    function toggleLabelVisibility(strokeLabel) {
        // Only toggle the label visibility, not the stroke visibility
        strokeLabelVisibility[currentImageLabel][strokeLabel] = !strokeLabelVisibility[currentImageLabel][strokeLabel];
        
        // Update the UI button appearance
        const toggleBtn = document.querySelector(`.stroke-visibility-item[data-stroke="${strokeLabel}"] .stroke-label-toggle`);
        if (toggleBtn) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            toggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            toggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            toggleBtn.classList.toggle('active', isLabelVisible);
        }
        
        // Redraw the canvas with updated label visibility
        // This should not affect the stroke visibility
        redrawCanvasWithVisibility();
    }
    
    // Function to update measurement input with selected stroke's value
    // Function to display a measurement edit dialog
    function showMeasurementDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurement
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Measurement for ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values from inputs
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Determine which unit was changed last and use that value
            const currentUnit = document.getElementById('unitSelector').value;
            let finalCmValue, finalInchWhole, finalInchFraction;
            
            if (currentUnit === 'inch') {
                finalInchWhole = wholeValue;
                finalInchFraction = fractionValue;
                finalCmValue = convertUnits('inch', wholeValue + fractionValue);
            } else {
                finalCmValue = cmValue;
                // Calculate inch equivalent
                const inches = convertUnits('cm', cmValue);
                finalInchWhole = Math.floor(inches);
                finalInchFraction = findClosestFraction(inches - finalInchWhole);
            }
            
            // Update the measurement
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            
            strokeMeasurements[currentImageLabel][strokeLabel] = {
                inchWhole: finalInchWhole,
                inchFraction: finalInchFraction,
                cm: finalCmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update the UI
            updateStrokeVisibilityControls();
            
            // Redraw with the new measurement
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Helper function to find the closest fraction
    function findClosestFraction(fractionPart) {
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        return closestFraction;
    }
    
    // Function to show edit dialog for a stroke
    function showEditDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurements
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Stroke ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Create name edit field
        const nameContainer = document.createElement('div');
        nameContainer.className = 'name-container';
        
        const nameLabel = document.createElement('div');
        nameLabel.textContent = 'Label:';
        nameContainer.appendChild(nameLabel);
        
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = strokeLabel;
        nameInput.placeholder = 'Label';
        nameContainer.appendChild(nameInput);
        
        dialog.appendChild(nameContainer);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Sync between inch and cm inputs
        wholeInput.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        fractionSelect.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        cmInput.addEventListener('change', () => {
            const cmValue = parseFloat(cmInput.value) || 0;
            const inches = convertUnits('cm', cmValue);
            const wholeValue = Math.floor(inches);
            const fractionValue = findClosestFraction(inches - wholeValue);
            
            wholeInput.value = wholeValue;
            fractionSelect.value = fractionValue.toString();
        });
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values
            const newName = nameInput.value.trim();
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Update name if changed
            let finalName = strokeLabel;
            if (newName !== strokeLabel && newName !== '') {
                // The unique name generation is handled inside renameStroke
                finalName = renameStroke(strokeLabel, newName);
                
                // Show feedback if name was modified to make it unique
                if (finalName !== newName) {
                    console.log(`Stroke name automatically adjusted to ${finalName} to avoid duplicates`);
                    
                    // Create and show a temporary notification
                    const notification = document.createElement('div');
                    notification.style.position = 'fixed';
                    notification.style.bottom = '20px';
                    notification.style.left = '50%';
                    notification.style.transform = 'translateX(-50%)';
                    notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                    notification.style.color = 'white';
                    notification.style.padding = '10px 20px';
                    notification.style.borderRadius = '4px';
                    notification.style.zIndex = '10000';
                    notification.textContent = `Renamed to ${finalName} to avoid duplicates`;
                    
                    document.body.appendChild(notification);
                    
                    // Remove after 3 seconds
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 3000);
                }
            }
            
            // Always save both units
            strokeMeasurements[currentImageLabel][finalName] = {
                inchWhole: wholeValue,
                inchFraction: fractionValue,
                cm: cmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update UI
            updateStrokeVisibilityControls();
            
            // Redraw to show updated measurements
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Function to generate a unique stroke name
    function generateUniqueStrokeName(baseName) {
        // If the name is empty or undefined, use a default name
        if (!baseName || baseName.trim() === '') {
            baseName = 'A1';
        }
        
        // If the base name doesn't already exist, we can use it as is
        if (!lineStrokesByImage[currentImageLabel] || 
            !lineStrokesByImage[currentImageLabel].includes(baseName)) {
            return baseName;
        }
        
        // Name already exists, so we need to add a number
        // Extract the base part and any existing numbering
        const match = baseName.match(/^(.+?)(?:\((\d+)\))?$/);
        if (!match) {
            // If the regex didn't match for some reason, append (1) to the name
            return `${baseName}(1)`;
        }
        
        const base = match[1];
        let counter = 1;
        
        // If there was already a number, start from the next one
        if (match[2]) {
            counter = parseInt(match[2]) + 1;
        }
        
        // Keep incrementing until we find a unique name
        let newName;
        do {
            newName = `${base}(${counter})`;
            counter++;
        } while (lineStrokesByImage[currentImageLabel].includes(newName));
        
        return newName;
    }
    
    // Function to rename a stroke
    function renameStroke(oldName, newName) {
        if (oldName === newName) return;
        
        // Generate a unique name if needed - this ensures the new name won't conflict
        // with any existing stroke names, including itself
        const uniqueNewName = generateUniqueStrokeName(newName);
        
        // Find the stroke color from the undo stack or vector data to maintain color after rename
        let strokeColor = '#000';
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            strokeColor = vectorStrokesByImage[currentImageLabel][oldName].color || '#000';
        } else {
            for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                const action = undoStackByImage[currentImageLabel][i];
                if (action.label === oldName && action.color) {
                    strokeColor = action.color;
                    // Try to determine stroke type from action
                    if (action.type === 'line') {
                        strokeType = 'straight';
                    }
                    break;
                }
            }
        }
        
        // Update all relevant data structures
        if (lineStrokesByImage[currentImageLabel]) {
            const index = lineStrokesByImage[currentImageLabel].indexOf(oldName);
            if (index !== -1) {
                lineStrokesByImage[currentImageLabel][index] = uniqueNewName;
            }
        }
        
        // Update visibility
        if (strokeVisibilityByImage[currentImageLabel] && 
            strokeVisibilityByImage[currentImageLabel][oldName] !== undefined) {
            const isVisible = strokeVisibilityByImage[currentImageLabel][oldName];
            strokeVisibilityByImage[currentImageLabel][uniqueNewName] = isVisible;
            delete strokeVisibilityByImage[currentImageLabel][oldName];
        }
        
        // Update label visibility
        if (strokeLabelVisibility[currentImageLabel] && 
            strokeLabelVisibility[currentImageLabel][oldName] !== undefined) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][oldName];
            strokeLabelVisibility[currentImageLabel][uniqueNewName] = isLabelVisible;
            delete strokeLabelVisibility[currentImageLabel][oldName];
        }
        
        // Update stroke data
        if (strokeDataByImage[currentImageLabel] && 
            strokeDataByImage[currentImageLabel][oldName]) {
            strokeDataByImage[currentImageLabel][uniqueNewName] = 
                strokeDataByImage[currentImageLabel][oldName];
            delete strokeDataByImage[currentImageLabel][oldName];
        }
        
        // Update vector data
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            vectorStrokesByImage[currentImageLabel][uniqueNewName] = 
                vectorStrokesByImage[currentImageLabel][oldName];
            delete vectorStrokesByImage[currentImageLabel][oldName];
        }
        
        // Update measurements
        if (strokeMeasurements[currentImageLabel] && 
            strokeMeasurements[currentImageLabel][oldName]) {
            strokeMeasurements[currentImageLabel][uniqueNewName] = 
                strokeMeasurements[currentImageLabel][oldName];
            delete strokeMeasurements[currentImageLabel][oldName];
        }
        
        // Update next label if needed
        if (labelsByImage[currentImageLabel] === oldName) {
            labelsByImage[currentImageLabel] = uniqueNewName;
        }
        
        // Update any references in the undo/redo stacks
        if (undoStackByImage[currentImageLabel]) {
            undoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        if (redoStackByImage[currentImageLabel]) {
            redoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        // Return the actual name used for the stroke (either the original or the uniquified version)
        return uniqueNewName;
    }
    
    // Function to toggle stroke visibility
    function toggleStrokeVisibility(strokeLabel, isVisible) {
        console.log(`Toggling visibility of stroke ${strokeLabel} to ${isVisible}`);
        
        // Update visibility state
        strokeVisibilityByImage[currentImageLabel][strokeLabel] = isVisible;
        
        // Make sure the stroke data is still available and not accidentally cleared
        if (isVisible) {
            // Initialize vectorStrokesByImage for this image if it doesn't exist
            if (!vectorStrokesByImage[currentImageLabel]) {
                vectorStrokesByImage[currentImageLabel] = {};
            }
            
            // If we're making a stroke visible, ensure we still have vector data
            if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                console.log(`Vector data missing for ${strokeLabel}, attempting recovery`);
                
                // Try to recover vector data from the undo stack
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel) {
                        if (action.vectorData) {
                            vectorStrokesByImage[currentImageLabel][strokeLabel] = action.vectorData;
                            console.log(`Recovered vector data for ${strokeLabel}`);
                            break;
                        }
                    }
                }
                
                // If we still couldn't recover the vector data, create a basic one
                // This is especially important for straight lines
                if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                    console.log(`Creating default vector data for ${strokeLabel}`);
                    
                    // Look for color and properties in the undo stack
                    let strokeColor = "#000000";
                    let strokeWidth = 5;
                    let isLine = false;
                    
                    for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                        const action = undoStackByImage[currentImageLabel][i];
                        if (action.label === strokeLabel) {
                            if (action.color) strokeColor = action.color;
                            if (action.width) strokeWidth = action.width;
                            if (action.type === 'line' || action.type === 'straight') isLine = true;
                            break;
                        }
                    }
                    
                    // Create a simple vector representation (placeholder)
                    vectorStrokesByImage[currentImageLabel][strokeLabel] = {
                        points: isLine ? [{x: 0, y: 0}, {x: 1, y: 1}] : [{x: 0, y: 0}],
                        color: strokeColor,
                        width: strokeWidth,
                        type: isLine ? 'straight' : 'freehand'
                    };
                }
            }
        };

        // *** Add redraw call here ***
        redrawCanvasWithVisibility();
    }
    
    // Store for currently selected stroke in each image
    let selectedStrokeByImage = {};
    
    // Initialize stroke label visibility for each image (default to visible)
    IMAGE_LABELS.forEach(label => {
        strokeLabelVisibility[label] = {};
        selectedStrokeByImage[label] = null; // Initialize with no selection
    });
    
    // Store for label custom positions (user-dragged positions)
    let customLabelPositions = {};
    
    // Flag to track if we're dragging a label
    let isDraggingLabel = false;
    let draggedLabelStroke = null;
    let dragStartX = 0;
    let dragStartY = 0;
    
    // Initialize custom label positions for each image
    IMAGE_LABELS.forEach(label => {
        customLabelPositions[label] = {};
    });
    
    // Cache for loaded images to prevent flickering
    const imageCache = {};
    
    // Store for label positions to prevent overlapping
    let currentLabelPositions = [];
    
    // Store for stroke paths to avoid overlapping with lines
    let currentStrokePaths = [];
    
    // Function to redraw canvas respecting stroke visibility
    // Make redrawCanvasWithVisibility available globally
    window.redrawCanvasWithVisibility = redrawCanvasWithVisibility;
    function redrawCanvasWithVisibility() {
        console.log(`--- redrawCanvasWithVisibility called for: ${currentImageLabel} ---`);
        
        // *** Save context and reset transform before drawing anything ***
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset to identity matrix
        console.log("Redraw Start Transform:", ctx.getTransform());
        
        // ADDED: Ensure originalImageDimensions exists and has an entry for this label
        if (!window.originalImageDimensions) {
            window.originalImageDimensions = {};
        }
        
        // ADDED: If we don't have dimensions for this label but we're trying to draw strokes,
        // create default dimensions based on the canvas size to prevent coordinates from being lost
        if (!window.originalImageDimensions[currentImageLabel] && 
            window.vectorStrokesByImage[currentImageLabel] && 
            Object.keys(window.vectorStrokesByImage[currentImageLabel]).length > 0) {
            
            console.log(`Creating default dimensions for ${currentImageLabel} to preserve strokes`);
            window.originalImageDimensions[currentImageLabel] = {
                width: canvas.width,
                height: canvas.height
            };
            console.log(`Set dimensions to match canvas: ${canvas.width}x${canvas.height}`);
        }
        
        // Reset label positions and stroke paths for this redraw
        currentLabelPositions = [];
        currentStrokePaths = [];
        
        // Create a copy of custom label positions for tracking which ones were actually used
        const usedCustomPositions = {};
        
        // We need to rebuild the canvas from scratch using individual stroke data
        const strokes = window.lineStrokesByImage[currentImageLabel] || [];
        
        // Start with a blank canvas or the original image if available
        if (window.originalImages && window.originalImages[currentImageLabel]) {
            // Check if we already have this image in the cache
            const imageUrl = window.originalImages[currentImageLabel];
            
            if (imageCache[imageUrl]) {
                // Use cached image immediately
                drawImageAndStrokes(imageCache[imageUrl]);
            } else {
                // Load the image and cache it
                const img = new Image();
                img.onload = () => {
                    // Add to cache
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                };
                img.src = imageUrl;
                
                // If the image is already cached in the browser, it might be immediately available
                if (img.complete) {
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                } else {
                    // If the image isn't immediately available,
                    // still draw the strokes on a blank canvas so they don't disappear
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the current scale and position
                    const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
                    
                    // For blank canvas mode, we apply the position directly when drawing points
                    // We pass 0,0 for position here since we'll apply it inside applyVisibleStrokes
                    applyVisibleStrokes(scale, 0, 0);
                }
            }
        } else {
            // Otherwise start with a blank canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white'; // Add white background fill
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Get the current scale for the blank canvas state
            const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
            
            // Apply visible strokes - for blank canvas mode, we don't need to apply position offset here
            // since we'll apply it to each point when drawing
            applyVisibleStrokes(scale, 0, 0);
        }
        
        function drawImageAndStrokes(img) {
            // Clear only once within the reset transform state
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply scale
            const scale = window.imageScaleByLabel[currentImageLabel];
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
            const positionOffset = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 }; // Ensure offset exists
            const offsetX = positionOffset.x;
            const offsetY = positionOffset.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;

            // *** ADDED LOGGING ***
            // console.log(`drawImageAndStrokes Calculation:
            //   canvas.width=${canvas.width}, img.width=${img.width}, scaledWidth=${scaledWidth}
            //   scale=${scale}, centerX=${centerX}, offsetX=${offsetX}, final imageX (passed to applyVisibleStrokes)=${x}`);
            // *** END LOGGING ***
            
            // Draw the image with scaling and positioning
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Then apply visible strokes
            applyVisibleStrokes(scale, x, y);
        }
        
        function applyVisibleStrokes(scale, imageX, imageY) {
            console.log("ApplyStrokes Start Transform:", ctx.getTransform()); // Log transform at start
            // console.log(`\nApplying strokes with scale=${scale}, imageX=${imageX}, imageY=${imageY}`); // Keep this commented unless debugging scale/position
            const strokes = window.vectorStrokesByImage[currentImageLabel] || {};
            const strokeOrder = window.lineStrokesByImage[currentImageLabel] || [];
            const visibility = window.strokeVisibilityByImage[currentImageLabel] || {};

            // Loop through strokes in their drawing order
            strokeOrder.forEach((strokeLabel) => {
                const isVisible = visibility[strokeLabel];
                if (!isVisible) return; // Skip invisible strokes

                const vectorData = strokes[strokeLabel];
                // Ensure vectorData and points exist
                if (!vectorData || !vectorData.points || vectorData.points.length === 0) {
                     console.warn(`Skipping stroke ${strokeLabel} in redraw: Missing vector data or points.`);
                     return;
                }

                // Set stroke style based on stored data, scaled by CURRENT scale
                ctx.strokeStyle = vectorData.color || '#000000';
                // *** FIX: Ensure lineWidth uses original stored width * current scale ***
                const scaledLineWidth = (vectorData.width || 5) * scale;
                ctx.lineWidth = scaledLineWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Start drawing the path
                ctx.beginPath();

                // Transform the first point from relative to canvas coordinates
                const firstPointRelative = vectorData.points[0];
                const firstPointCanvas = getCanvasCoords(firstPointRelative.x, firstPointRelative.y);
                ctx.moveTo(firstPointCanvas.x, firstPointCanvas.y);

                // Store canvas path for label collision detection
                const strokePath = [{ x: firstPointCanvas.x, y: firstPointCanvas.y }];

                // Check if this is a straight line (only two points)
                const isStraightLine = vectorData.type === 'straight' || (vectorData.points.length === 2 && !vectorData.type);

                if (isStraightLine && vectorData.points.length >= 2) {
                    // Straight Line: Transform only the last point
                    const lastPointRelative = vectorData.points[vectorData.points.length - 1];
                    const lastPointCanvas = getCanvasCoords(lastPointRelative.x, lastPointRelative.y);
                    ctx.lineTo(lastPointCanvas.x, lastPointCanvas.y);
                    strokePath.push({ x: lastPointCanvas.x, y: lastPointCanvas.y });
                } else {
                    // Freehand: Transform ALL subsequent points
                    for (let i = 1; i < vectorData.points.length; i++) {
                        const pointRelative = vectorData.points[i];
                        // *** FIX: Apply getCanvasCoords to EACH subsequent point ***
                        const pointCanvas = getCanvasCoords(pointRelative.x, pointRelative.y);
                        ctx.lineTo(pointCanvas.x, pointCanvas.y);
                        strokePath.push({ x: pointCanvas.x, y: pointCanvas.y });
                         // Optional logging for debugging coordinate drift:
                         // if (i < 3 || i % 20 === 0) { // Log first few and then every 20th
                         //     console.log(`  Redraw Pt ${i} Rel:(${pointRelative.x.toFixed(1)}, ${pointRelative.y.toFixed(1)}) -> Canv:(${pointCanvas.x.toFixed(1)}, ${pointCanvas.y.toFixed(1)})`);
                         // }
                    }
                }

                // Apply selection highlighting if needed (before stroking)
                const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                if (isSelected) {
                    ctx.save();
                    ctx.shadowColor = '#ffffff'; // White glow
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                }

                // Stroke the path
                ctx.stroke();

                // Restore context if selection highlighting was applied
                if (isSelected) {
                    ctx.restore();
                }

                // Store the calculated canvas path and scaled width for label positioning
                currentStrokePaths.push({
                    label: strokeLabel,
                    path: strokePath, // Store canvas coordinates path
                     // *** FIX: Store correctly scaled width ***
                    width: scaledLineWidth,
                    color: vectorData.color
                });
            }); // End of strokeOrder.forEach

            // --- Label Drawing Logic ---
            // console.log(`--- Redraw: Drawing Labels for ${currentImageLabel} ---`);
            currentLabelPositions = [];
            const usedCustomPositions = {};

            strokeOrder.forEach((strokeLabel) => {
                const isStrokeVisible = visibility[strokeLabel];
                if (!strokeLabelVisibility[currentImageLabel]) strokeLabelVisibility[currentImageLabel] = {};
                const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel] !== false; // Default true
                const vectorData = strokes[strokeLabel];

                if (isStrokeVisible && isLabelVisible && vectorData && vectorData.points.length > 0) {
                    const measurement = getMeasurementString(strokeLabel);
                    const labelText = measurement ? `${strokeLabel}=${measurement}` : strokeLabel;

                    // Determine anchor point (middle of the stroke) using RELATIVE coordinates
                    let anchorPointRelative = { x: 0, y: 0 };
                    const midIndex = Math.floor(vectorData.points.length / 2);
                    anchorPointRelative = vectorData.points[midIndex];

                    // Convert anchor point to CURRENT canvas coordinates
                    const anchorPointCanvas = getCanvasCoords(anchorPointRelative.x, anchorPointRelative.y);

                    if (isNaN(anchorPointCanvas.x) || isNaN(anchorPointCanvas.y)) {
                         console.error(`      Error getting canvas coords for label anchor for ${strokeLabel}. Relative point:`, anchorPointRelative);
                         return; // Skip label if anchor is invalid
                    }

                    // Set label style
                    // Increase font size for better visibility, especially when scaled
                    const baseFontSize = 14;
                    const scaledFontSize = Math.max(10, Math.min(28, baseFontSize / scale)); // Adjust font size based on zoom, within limits
                    ctx.font = `${scaledFontSize}px Arial`;
                    const labelColor = vectorData.color || '#000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';

                    // Calculate label dimensions based on current font size
                    const metrics = ctx.measureText(labelText);
                    const padding = 6 / scale; // Scale padding inversely
                    const labelWidth = metrics.width + padding * 2;
                    const labelHeight = scaledFontSize + padding * 2; // Adjust height based on font size

                    // Initial label rectangle guess (used for optimal position calculation)
                     const initialLabelRect = {
                        width: labelWidth,
                        height: labelHeight,
                        x: anchorPointCanvas.x - labelWidth / 2,
                        y: anchorPointCanvas.y - labelHeight - (15 / scale), // Scale vertical offset
                        strokeLabel: strokeLabel
                    };

                    // Determine final label position
                    let finalPosition; // This will be canvas coordinates {x, y} for the top-left of the label
                    let offset = null; // Relative offset {x, y} from anchorPointCanvas

                    // 1. Check for user-dragged position (stored as relative offset)
                    if (customLabelPositions[currentImageLabel]?.[strokeLabel]) {
                        offset = customLabelPositions[currentImageLabel][strokeLabel];
                        // Apply the stored relative offset to the *current* canvas anchor point
                        finalPosition = { x: anchorPointCanvas.x + offset.x, y: anchorPointCanvas.y + offset.y };
                        usedCustomPositions[strokeLabel] = true; // Mark as used
                         // console.log(`    Using custom offset for ${strokeLabel}. Anchor: (${anchorPointCanvas.x.toFixed(1)}, ${anchorPointCanvas.y.toFixed(1)}), Offset: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)}) -> Final: (${finalPosition.x.toFixed(1)}, ${finalPosition.y.toFixed(1)})`);
                    }
                    // 2. Check for previously calculated offset (stored as relative offset)
                    else if (calculatedLabelOffsets[currentImageLabel]?.[strokeLabel]) {
                        offset = calculatedLabelOffsets[currentImageLabel][strokeLabel];
                        // Apply the stored relative offset to the *current* canvas anchor point
                        finalPosition = { x: anchorPointCanvas.x + offset.x, y: anchorPointCanvas.y + offset.y };
                         // console.log(`    Using calculated offset for ${strokeLabel}. Anchor: (${anchorPointCanvas.x.toFixed(1)}, ${anchorPointCanvas.y.toFixed(1)}), Offset: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)}) -> Final: (${finalPosition.x.toFixed(1)}, ${finalPosition.y.toFixed(1)})`);
                    }
                    // 3. Calculate optimal position and offset for the first time
                    else {
                        if (typeof findOptimalLabelPosition !== 'function') {
                            console.error("     findOptimalLabelPosition function is not defined! Using default position.");
                            finalPosition = { x: initialLabelRect.x, y: initialLabelRect.y }; // Fallback
                        } else {
                            try {
                                const strokePathInfo = currentStrokePaths.find(p => p.label === strokeLabel);
                                const optimalRect = findOptimalLabelPosition(
                                    initialLabelRect, // Initial guess uses current canvas coords & dimensions
                                    anchorPointCanvas, // Anchor is current canvas coords
                                    strokePathInfo // Pass current canvas path info
                                );
                                finalPosition = { x: optimalRect.x, y: optimalRect.y };
                            } catch(err) {
                                console.error(`      Error in findOptimalLabelPosition for ${strokeLabel}:`, err);
                                finalPosition = { x: initialLabelRect.x, y: initialLabelRect.y }; // Fallback
                            }
                        }
                        // Calculate and store the RELATIVE offset based on the calculated position
                        offset = {
                            x: finalPosition.x - anchorPointCanvas.x,
                            y: finalPosition.y - anchorPointCanvas.y
                        };
                        if (!calculatedLabelOffsets[currentImageLabel]) calculatedLabelOffsets[currentImageLabel] = {};
                        calculatedLabelOffsets[currentImageLabel][strokeLabel] = offset; // Store relative offset
                        // console.log(`    Calculated and stored offset for ${strokeLabel}:`, offset);
                    }

                    // Store the final calculated position rect for overlap checks in *this* redraw cycle
                    const finalLabelRect = { ...initialLabelRect, x: finalPosition.x, y: finalPosition.y };
                    currentLabelPositions.push(finalLabelRect);

                    // Draw label background
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(finalLabelRect.x, finalLabelRect.y, finalLabelRect.width, finalLabelRect.height);

                    // Draw label border
                    ctx.strokeStyle = labelColor;
                    ctx.lineWidth = 1; // Keep border thin
                    ctx.strokeRect(finalLabelRect.x, finalLabelRect.y, finalLabelRect.width, finalLabelRect.height);

                    // Draw label text
                    ctx.fillStyle = labelColor;
                    const textX = finalLabelRect.x + finalLabelRect.width / 2;
                    const textY = finalLabelRect.y + finalLabelRect.height - padding; // Adjust baseline using scaled padding
                    ctx.fillText(labelText, textX, textY);

                    // Optionally draw connector line (from label edge to anchor point)
                    if (typeof drawLabelConnector === 'function') {
                        try {
                            drawLabelConnector(finalLabelRect, anchorPointCanvas, labelColor);
                        } catch(err) {
                            console.error(`      Error in drawLabelConnector for ${strokeLabel}:`, err);
                        }
                    }
                }
            }); // End of label drawing loop
            // --- End of Label Drawing Logic ---

            // Save the now-combined state (only if not loading, to prevent infinite loops)
            if (!window.isLoadingProject) {
                const newState = getCanvasState();
                imageStates[currentImageLabel] = cloneImageData(newState);
                 // console.log(`[Redraw] Saved final canvas state for ${currentImageLabel}`); // Optional: Debug state saving
            } else {
                 // console.log("[Redraw] Skipping final state save because isLoadingProject is true.");
            }
            ctx.restore(); // *** Restore the original context state (including transform) ***
            console.log("Redraw End Transform:", ctx.getTransform());
        }
    }

    function cloneImageData(imageData) {
        return new ImageData(
            new Uint8ClampedArray(imageData.data),
            imageData.width,
            imageData.height
        );
    }

    function saveState(force = false, incrementLabel = true, updateStrokeList = true) {
        // *** ADDED LOG ***
        console.log(`[Save State Called] force=${force}, incrementLabel=${incrementLabel}, updateStrokeList=${updateStrokeList}, isDrawingOrPasting=${isDrawingOrPasting}, strokeInProgress=${strokeInProgress}`);

        // Get current state
        const currentState = getCanvasState();

        // Initialize if first save for this image
        if (!imageStates[currentImageLabel]) {
            imageStates[currentImageLabel] = cloneImageData(currentState);
            undoStackByImage[currentImageLabel].push({
                state: cloneImageData(currentState),
                type: 'initial',
                label: null
            });
            updateStrokeCounter();
            return;
        }

        // Only save if we're not in the middle of a stroke or if forced
        if (!force && strokeInProgress) return;

        // Don't save if it's identical to the last state
        const lastState = imageStates[currentImageLabel];
        if (lastState && !force) {
            const currentData = currentState.data;
            const lastData = lastState.data;
            let identical = true;
            for (let i = 0; i < currentData.length; i += 4) {
                if (currentData[i] !== lastData[i] ||
                    currentData[i + 1] !== lastData[i + 1] ||
                    currentData[i + 2] !== lastData[i + 2] ||
                    currentData[i + 3] !== lastData[i + 3]) {
                    identical = false;
                    break;
                }
            }
            if (identical) return;
        }

        // For line strokes, assign the next label before saving
        let strokeLabel = null;
        if (!isDrawingOrPasting && !strokeInProgress && incrementLabel && updateStrokeList) {
            // *** ADDED DETAILED LOGS ***
            console.log(`[Save State] Entering stroke update block.`);
            
            // Get the suggested next label
            const suggestedLabel = window.labelsByImage[currentImageLabel];
            console.log(`[Save State] Suggested next label = "${suggestedLabel}" from labelsByImage[${currentImageLabel}]`);
            
            // *** FIX: Ensure the new stroke gets a UNIQUE label ***
            strokeLabel = generateUniqueStrokeName(suggestedLabel);
            console.log(`[Save State] Assigned UNIQUE strokeLabel = "${strokeLabel}"`);
            
            // Always increment the label counter based on the original suggested label for the next stroke
            const nextLabel = getNextLabel(currentImageLabel); // Uses the value in labelsByImage
            window.labelsByImage[currentImageLabel] = nextLabel;
            console.log(`[Save State] Incremented labelsByImage[${currentImageLabel}] to "${nextLabel}"`);
            
            // Only add the *unique* stroke label to the strokes list
            if (!window.lineStrokesByImage[currentImageLabel]) {
                console.log(`[Save State] Initializing lineStrokesByImage[${currentImageLabel}] as []`);
                window.lineStrokesByImage[currentImageLabel] = []; // Initialize if it doesn't exist
            }
            
            // Check if unique stroke label already exists before pushing (shouldn't happen with generateUniqueStrokeName)
            const labelAlreadyExists = window.lineStrokesByImage[currentImageLabel].includes(strokeLabel);
            
            console.log(`[Save State] BEFORE push: lineStrokesByImage[${currentImageLabel}] =`, JSON.parse(JSON.stringify(window.lineStrokesByImage[currentImageLabel])));
            
            if (!labelAlreadyExists && updateStrokeList) {
                window.lineStrokesByImage[currentImageLabel].push(strokeLabel); // Push the unique label
                console.log(`[Save State] AFTER push: lineStrokesByImage[${currentImageLabel}] =`, JSON.parse(JSON.stringify(window.lineStrokesByImage[currentImageLabel])));
            } else {
                // This case should ideally not be reached if generateUniqueStrokeName works correctly
                console.warn(`[Save State] Generated unique stroke label "${strokeLabel}" already exists? Not pushing again.`);
            }
            
            // Initialize visibility, data etc. using the unique strokeLabel
            window.strokeVisibilityByImage[currentImageLabel] = window.strokeVisibilityByImage[currentImageLabel] || {};
            window.strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            
            window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
            window.strokeLabelVisibility[currentImageLabel][strokeLabel] = true;
            
            strokeDataByImage[currentImageLabel] = strokeDataByImage[currentImageLabel] || {};
            strokeDataByImage[currentImageLabel][strokeLabel] = {
                preState: currentStroke ? cloneImageData(currentStroke) : null,
                postState: cloneImageData(currentState)
            };
        }

        // --- FIX: Handle temporary vector data --- 
        const tempStrokeKey = '_drawingStroke';
        let drawnVectorData = null;
        
        // Debug the state of vectorStrokesByImage before handling temporary data
        console.log(`[Save State] Vector strokes for ${currentImageLabel} before processing:`, 
            window.vectorStrokesByImage[currentImageLabel] ? 
            Object.keys(window.vectorStrokesByImage[currentImageLabel]) : "none");
            
        // Detailed check for _drawingStroke
        if (window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
            console.log(`[Save State] Found _drawingStroke data with ${window.vectorStrokesByImage[currentImageLabel][tempStrokeKey].points.length} points`);
        } else {
            console.log(`[Save State] No _drawingStroke data found:`, 
                window.vectorStrokesByImage[currentImageLabel] ? 
                "vectorStrokesByImage exists for label but no _drawingStroke key" : 
                "vectorStrokesByImage doesn't exist for this label");
        }
        
        if (strokeLabel && window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
            drawnVectorData = JSON.parse(JSON.stringify(window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]));
            // Assign the drawn data to the final unique stroke label
            window.vectorStrokesByImage[currentImageLabel][strokeLabel] = drawnVectorData;
            // Remove the temporary data
            delete window.vectorStrokesByImage[currentImageLabel][tempStrokeKey];
            console.log(`[Save State] Moved vector data from ${tempStrokeKey} to ${strokeLabel}`);
        } else if (strokeLabel) {
            console.warn(`[Save State] No temporary vector data found at ${tempStrokeKey} for stroke ${strokeLabel}`);
            // Attempt to find vector data if it somehow got assigned to the suggested label during draw (fallback)
            const suggestedLabel = window.labelsByImage[currentImageLabel]; // Get the label *before* incrementing
             if (window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][suggestedLabel]) {
                console.log(`[Save State] Fallback: Found data under suggested label ${suggestedLabel}`);
                drawnVectorData = JSON.parse(JSON.stringify(window.vectorStrokesByImage[currentImageLabel][suggestedLabel]));
                window.vectorStrokesByImage[currentImageLabel][strokeLabel] = drawnVectorData;
                // Optionally delete the data under suggestedLabel if it shouldn't be there
                // delete window.vectorStrokesByImage[currentImageLabel][suggestedLabel]; 
            }
        }
        // --- END FIX ---

        // Save new state and add to undo stack
        imageStates[currentImageLabel] = cloneImageData(currentState);
        
        // Determine the type of stroke
        let strokeType = 'other';
        if (force && strokeLabel) {
            strokeType = 'stroke';
            
            // Check for vector data to determine if it's a freehand or straight line
            // Use the vector data we just potentially moved
            if (drawnVectorData) { 
                if (drawnVectorData.type === 'straight') {
                    strokeType = 'line';
                } else if (drawnVectorData.type === 'freehand') {
                    strokeType = 'stroke';
                }
            }
        }
        
        // Add to undo stack with stroke info
        const undoAction = {
            state: cloneImageData(currentState),
            type: strokeType,
            label: strokeLabel, // Use the unique label
            color: colorPicker.value, 
            width: parseInt(brushSize.value) 
        };
        
        // Store vector data with the undo action if available
        // Use the data retrieved from the temporary key
        if (drawnVectorData) {
            undoAction.vectorData = drawnVectorData; 
        }
        
        undoStackByImage[currentImageLabel].push(undoAction);
        
        // Remove oldest state if we've reached max history
        if (undoStackByImage[currentImageLabel].length >= MAX_HISTORY) {
            undoStackByImage[currentImageLabel].shift();
        }

        // Clear redo stack when a new action is performed
        redoStackByImage[currentImageLabel] = [];

        updateStrokeCounter();
        updateSidebarStrokeCounts();
    }

    function undo() {
        console.log(`Attempting to undo in ${currentImageLabel} workspace`);
        console.log(`Current undo stack: ${undoStackByImage[currentImageLabel]?.length || 0} items`);
        console.log(`Current strokes: ${lineStrokesByImage[currentImageLabel]?.join(', ') || 'none'}`);
        
        const currentStack = undoStackByImage[currentImageLabel];
        if (currentStack && currentStack.length > 1) { // Keep at least one state (initial)
            // Get the state we're undoing from
            const lastAction = currentStack.pop();
            console.log(`Undoing action of type: ${lastAction.type}, label: ${lastAction.label || 'none'}`);
            
            // Add to redo stack
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[currentImageLabel].push(lastAction);
            console.log(`Added to redo stack, now has ${redoStackByImage[currentImageLabel].length} items`);
            
            // Skip certain state types when undoing
            if (lastAction.type === 'pre-stroke') {
                console.log('Skipping pre-stroke state');
                // If we encounter a pre-stroke state, undo again to get to the previous complete state
                if (currentStack.length > 1) {
                    return undo();
                }
            }
            
            // Handle snapshot type (created when switching views)
            if (lastAction.type === 'snapshot') {
                console.log('Restoring from snapshot state');
                // If we have stored strokes in the snapshot, restore them
                if (lastAction.strokes) {
                    lineStrokesByImage[currentImageLabel] = [...(lastAction.strokes || [])];
                    console.log(`Restored strokes: ${lineStrokesByImage[currentImageLabel].join(', ')}`);
                }
                
                // Continue to next undo action if possible
                if (currentStack.length > 1) {
                    return undo();
                }
            }
            
            // Get the state we're going back to
            const previousState = currentStack[currentStack.length - 1];
            
            if (lastAction.type === 'line' || lastAction.type === 'stroke') {
                // Remove the last stroke and its label
                if (lineStrokesByImage[currentImageLabel] && lineStrokesByImage[currentImageLabel].length > 0) {
                    const removedStroke = lineStrokesByImage[currentImageLabel].pop();
                    console.log(`Removed stroke: ${removedStroke}`);
                    
                    // Also remove from visibility tracking
                    if (strokeVisibilityByImage[currentImageLabel] && strokeVisibilityByImage[currentImageLabel][removedStroke]) {
                        delete strokeVisibilityByImage[currentImageLabel][removedStroke];
                    }
                    
                    // Also remove from label visibility tracking
                    if (strokeLabelVisibility[currentImageLabel] && strokeLabelVisibility[currentImageLabel][removedStroke]) {
                        // Save label visibility in lastAction for possible redo
                        lastAction.labelVisible = strokeLabelVisibility[currentImageLabel][removedStroke];
                        delete strokeLabelVisibility[currentImageLabel][removedStroke];
                    }
                    
                    // Also remove from stroke data tracking
                    if (strokeDataByImage[currentImageLabel] && strokeDataByImage[currentImageLabel][removedStroke]) {
                        delete strokeDataByImage[currentImageLabel][removedStroke];
                    }
                    
                    // Remove vector stroke data
                    if (vectorStrokesByImage[currentImageLabel] && vectorStrokesByImage[currentImageLabel][removedStroke]) {
                        // Save vector data in lastAction for possible redo
                        lastAction.vectorData = vectorStrokesByImage[currentImageLabel][removedStroke];
                        delete vectorStrokesByImage[currentImageLabel][removedStroke];
                }
                
                    // If this was the last stroke, reset to A1
                    if (lineStrokesByImage[currentImageLabel].length === 0) {
                        labelsByImage[currentImageLabel] = 'A1';
                        console.log(`All strokes undone, reset label counter to A1`);
                    } else {
                // Set the next label to be the one we just removed
                if (lastAction.label) {
                    labelsByImage[currentImageLabel] = lastAction.label;
                    console.log(`Reset label counter to: ${lastAction.label}`);
                        }
                    }
                }
            }
            
            // Ensure we have a valid previous state
            if (previousState && previousState.state) {
                // Restore the canvas state
                const stateToRestore = cloneImageData(previousState.state);
                imageStates[currentImageLabel] = stateToRestore;
                restoreCanvasState(stateToRestore);
                currentStroke = cloneImageData(stateToRestore);
                console.log('Canvas state restored');
            } else {
                console.log('Warning: No valid previous state found');
                // Create a blank state if needed
                const blankState = ctx.createImageData(canvas.width, canvas.height);
                imageStates[currentImageLabel] = blankState;
                restoreCanvasState(blankState);
                currentStroke = cloneImageData(blankState);
            }
            
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
        } else if (currentStack && currentStack.length === 1) {
            // We're at the initial state
            console.log('At initial state, resetting workspace');
            const initialState = currentStack[0];
            
            // Clear all stroke data
            lineStrokesByImage[currentImageLabel] = [];
            strokeVisibilityByImage[currentImageLabel] = {};
            strokeLabelVisibility[currentImageLabel] = {};
            vectorStrokesByImage[currentImageLabel] = {};
            strokeDataByImage[currentImageLabel] = {};
            
            // Reset label counter
            labelsByImage[currentImageLabel] = 'A1';  // Reset to A1
            
            if (initialState && initialState.state) {
                imageStates[currentImageLabel] = cloneImageData(initialState.state);
                restoreCanvasState(initialState.state);
                currentStroke = cloneImageData(initialState.state);
            } else if (window.originalImages[currentImageLabel]) {
                // If we have the original image, redraw it
                console.log('Redrawing from original image');
                const img = new Image();
                img.onload = () => {
                    // Clear the canvas first
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the current scale
                    const scale = window.imageScaleByLabel[currentImageLabel];
                    const scaledWidth = img.width * scale;
                    const scaledHeight = img.height * scale;
                    
                    // Calculate base position (center of canvas)
                    const centerX = (canvas.width - scaledWidth) / 2;
                    const centerY = (canvas.height - scaledHeight) / 2;
                    
                    // Apply position offset
                    const offsetX = window.imagePositionByLabel[currentImageLabel].x;
                    const offsetY = window.imagePositionByLabel[currentImageLabel].y;
                    
                    // Calculate final position
                    const x = centerX + offsetX;
                    const y = centerY + offsetY;
                    
                    // Draw the original image with scale and position
                    ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                    
                    // Save this as the new state
                    const newState = getCanvasState();
                    imageStates[currentImageLabel] = cloneImageData(newState);
                    currentStroke = cloneImageData(newState);
                };
                img.src = window.originalImages[currentImageLabel];
            }
            
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
        } else {
            console.log('No undo history available for this workspace');
        }
    }
    
    function redo() {
        console.log(`Attempting to redo in ${currentImageLabel} workspace`);
        console.log(`Current redo stack: ${redoStackByImage[currentImageLabel]?.length || 0} items`);
        
        const redoStack = redoStackByImage[currentImageLabel];
        if (redoStack && redoStack.length > 0) {
            // Get the action to redo
            const actionToRedo = redoStack.pop();
            console.log(`Redoing action of type: ${actionToRedo.type}, label: ${actionToRedo.label || 'none'}`);
            
            // Add back to undo stack
            undoStackByImage[currentImageLabel].push(actionToRedo);
            
            // Handle stroke type actions (both freehand strokes and straight lines)
            if ((actionToRedo.type === 'line' || actionToRedo.type === 'stroke') && actionToRedo.label) {
                // Add the stroke back to the list
                window.lineStrokesByImage[currentImageLabel] = window.lineStrokesByImage[currentImageLabel] || [];
                window.lineStrokesByImage[currentImageLabel].push(actionToRedo.label);
                console.log(`Added stroke back: ${actionToRedo.label}`);
                
                // Restore stroke visibility
                window.strokeVisibilityByImage[currentImageLabel] = window.strokeVisibilityByImage[currentImageLabel] || {};
                window.strokeVisibilityByImage[currentImageLabel][actionToRedo.label] = true;
                
                // Restore stroke data if we have it
                if (actionToRedo.strokeData) {
                    strokeDataByImage[currentImageLabel] = strokeDataByImage[currentImageLabel] || {};
                    strokeDataByImage[currentImageLabel][actionToRedo.label] = actionToRedo.strokeData;
                }
                
                // Restore vector data if we have it
                if (actionToRedo.vectorData) {
                    window.vectorStrokesByImage[currentImageLabel] = window.vectorStrokesByImage[currentImageLabel] || {};
                    window.vectorStrokesByImage[currentImageLabel][actionToRedo.label] = actionToRedo.vectorData;
                    
                    // If no vector data saved in the action, but we're redoing a line/stroke,
                    // try to recreate basic vector data to ensure label display
                    if (!actionToRedo.vectorData && 
                        (actionToRedo.type === 'line' || actionToRedo.type === 'stroke')) {
                        // Create minimal vector data to ensure label display
                        window.vectorStrokesByImage[currentImageLabel][actionToRedo.label] = {
                            points: [
                                { x: canvas.width/2 - 50, y: canvas.height/2 }, // Dummy points
                                { x: canvas.width/2 + 50, y: canvas.height/2 }
                            ],
                            color: actionToRedo.color || "#000000",
                            width: 5,
                            type: actionToRedo.type === 'line' ? 'straight' : 'freehand'
                        };
                    }
                }
                
                // Restore label visibility if we have it
                if (actionToRedo.labelVisible !== undefined) {
                    window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
                    window.strokeLabelVisibility[currentImageLabel][actionToRedo.label] = actionToRedo.labelVisible;
                } else {
                    // Default to visible for new strokes and redone strokes without saved value
                    window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
                    window.strokeLabelVisibility[currentImageLabel][actionToRedo.label] = true;
                }
                
                // Update the next label - make sure it's one higher than the redone label
                const numPart = parseInt(actionToRedo.label.slice(1));
                if (!isNaN(numPart)) {
                    const letterPart = actionToRedo.label[0];
                    const nextNum = numPart + 1;
                    const nextLabel = nextNum > 9 
                        ? String.fromCharCode(letterPart.charCodeAt(0) + 1) + '0' 
                        : letterPart + nextNum;
                    window.labelsByImage[currentImageLabel] = nextLabel;
                    console.log(`Set next label to: ${nextLabel}`);
                } else {
                    // Fallback to the standard next label function
                window.labelsByImage[currentImageLabel] = getNextLabel(currentImageLabel);
                console.log(`Set next label to: ${window.labelsByImage[currentImageLabel]}`);
                }
            }
            
            // Restore the state
            if (actionToRedo.state) {
                const stateToRestore = cloneImageData(actionToRedo.state);
                imageStates[currentImageLabel] = stateToRestore;
                restoreCanvasState(stateToRestore);
                currentStroke = cloneImageData(stateToRestore);
                console.log('Canvas state restored for redo');
            }
            
            // Update all UI elements
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
            
            // Force redraw with visibility to ensure labels appear immediately
            redrawCanvasWithVisibility();
        } else {
            console.log('No redo actions available for this workspace');
        }
    }

    // Save initial blank state
//    saveState();

    // Set canvas size
    function resizeCanvas() {
        // Account for the sidebars and gaps in our calculation (approximately 420px for sidebars + gaps)
        const sidebarSpace = 440;
        const maxWidth = Math.min(window.innerWidth - sidebarSpace, 1000);  // Cap at 1000px width
        const maxHeight = Math.min(window.innerHeight - 100, 800);  // Cap at 800px height
        
        // Save current state before resizing
        const oldState = imageStates[currentImageLabel];
        
        // Resize the canvas
        canvas.width = maxWidth;
        canvas.height = maxHeight;
        
        // Set default canvas styles
        canvas.style.cursor = 'crosshair';
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Restore the image after resize
        if (oldState) {
            // Try to restore from saved state first
            try {
                restoreCanvasState(oldState);
                currentStroke = cloneImageData(oldState);
            } catch (e) {
                // If that fails, redraw from original image
                if (window.originalImages[currentImageLabel]) {
                    const img = new Image();
                    img.onload = () => {
                        // Clear the canvas first
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Get the current scale
                        const scale = imageScaleByLabel[currentImageLabel];
                        const scaledWidth = img.width * scale;
                        const scaledHeight = img.height * scale;
                        
                        // Calculate base position (center of canvas)
                        const centerX = (canvas.width - scaledWidth) / 2;
                        const centerY = (canvas.height - scaledHeight) / 2;
                        
                        // Apply position offset
                        const offsetX = window.imagePositionByLabel[currentImageLabel].x;
                        const offsetY = window.imagePositionByLabel[currentImageLabel].y;
                        
                        // Calculate final position
                        const x = centerX + offsetX;
                        const y = centerY + offsetY;
                        
                        // Draw the original image with scale and position
                        ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                        
                        // Save this as the new state
                        const newState = getCanvasState();
                        imageStates[currentImageLabel] = cloneImageData(newState);
                        currentStroke = cloneImageData(newState);
                    };
                    img.src = window.originalImages[currentImageLabel];
                } else if (!currentStroke) {
                    // Initialize blank state if needed
                    currentStroke = getCanvasState();
                }
            }
        }
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Drawing state
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let points = [];
    let lastVelocity = 0;
    // --- ADD: Track last RAW coordinates ---
    let lastRawX = 0;
    let lastRawY = 0;
    // --- END ADD ---

    // Drawing mode state
    let drawingMode = 'freehand'; // Options: 'freehand', 'straight'
    let straightLineStart = null; // For straight line mode - start point
    let lastDrawnPoint = null;

    /**
     * Transforms raw canvas coordinates to account for image scaling and positioning
     * @param {number} x - Raw x-coordinate from mouse event
     * @param {number} y - Raw y-coordinate from mouse event
     * @returns {Object} Object with transformed x and y coordinates
     */
    function getTransformedCoords(x, y) {
        // Debug logging
        if (window.debugCoordinates) {
            console.log(`[getTransformedCoords] INPUT: Raw canvas coords (${x.toFixed(1)}, ${y.toFixed(1)})`);
        }
        
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
        const position = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 };
        
        // If we have no image dimensions yet (blank canvas), return raw coordinates
        if (!window.originalImageDimensions[currentImageLabel]) {
            if (window.debugCoordinates) {
                console.log(`[getTransformedCoords] No image dimensions - returning raw coords as relative`);
            }
            return { x, y };
        }
        
        // We do have an image, so need to calculate relative coordinates
        const origDims = window.originalImageDimensions[currentImageLabel];
        const scaledWidth = origDims.width * scale;
        const scaledHeight = origDims.height * scale;
        
        // Base position is canvas center minus half the scaled image size
        const imageBaseX = (canvas.width - scaledWidth) / 2;
        const imageBaseY = (canvas.height - scaledHeight) / 2;
        
        // Final image position includes any panning offset
        const finalImageX = imageBaseX + position.x;
        const finalImageY = imageBaseY + position.y;
        
        // Convert the raw canvas coordinates to coordinates relative to the image
        const relativeX = (x - finalImageX) / scale;
        const relativeY = (y - finalImageY) / scale;
        
        if (window.debugCoordinates) {
            console.log(`[getTransformedCoords] Canvas size: ${canvas.width} × ${canvas.height}`);
            console.log(`[getTransformedCoords] Image scale: ${scale}, position: ${JSON.stringify(position)}`);
            console.log(`[getTransformedCoords] Original dimensions: ${JSON.stringify(origDims)}`);
            console.log(`[getTransformedCoords] Scaled dimensions: ${scaledWidth} × ${scaledHeight}`);
            console.log(`[getTransformedCoords] Image position: base(${imageBaseX.toFixed(1)}, ${imageBaseY.toFixed(1)}) + offset => final(${finalImageX.toFixed(1)}, ${finalImageY.toFixed(1)})`);
            console.log(`[getTransformedCoords] OUTPUT: Relative coords (${relativeX.toFixed(1)}, ${relativeY.toFixed(1)})`);
        }
        
        return { x: relativeX, y: relativeY };
    }

    /**
     * Converts relative image coordinates back to canvas coordinates
     * (Inverse of getTransformedCoords)
     * @param {number} imageX_relative - x-coordinate relative to the image
     * @param {number} imageY_relative - y-coordinate relative to the image
     * @returns {Object} Object with canvas x and y coordinates
     */
    function getCanvasCoords(imageX_relative, imageY_relative) {
        // Debug logging
        if (window.debugCoordinates) {
            console.log(`[getCanvasCoords] INPUT: Relative coords (${imageX_relative.toFixed(1)}, ${imageY_relative.toFixed(1)})`);
        }
        
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
        const position = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 };
        
        // If we have no image dimensions yet (blank canvas), return relative coords as-is
        if (!window.originalImageDimensions[currentImageLabel]) {
            if (window.debugCoordinates) {
                console.log(`[getCanvasCoords] No image dimensions - returning relative coords as canvas coords`);
            }
            return { x: imageX_relative, y: imageY_relative };
        }
        
        // We do have an image, calculate canvas coordinates from relative coords
        const origDims = window.originalImageDimensions[currentImageLabel];
        const scaledWidth = origDims.width * scale;
        const scaledHeight = origDims.height * scale;
        
        // Base position is canvas center minus half the scaled image size
        const imageBaseX = (canvas.width - scaledWidth) / 2;
        const imageBaseY = (canvas.height - scaledHeight) / 2;
        
        // Final image position includes any panning offset
        const finalImageX = imageBaseX + position.x;
        const finalImageY = imageBaseY + position.y;
        
        // Calculate final canvas coordinates from image-relative coordinates
        const canvasX = finalImageX + (imageX_relative * scale);
        const canvasY = finalImageY + (imageY_relative * scale);
        
        if (window.debugCoordinates) {
            console.log(`[getCanvasCoords] Canvas size: ${canvas.width} × ${canvas.height}`);
            console.log(`[getCanvasCoords] Image scale: ${scale}, position: ${JSON.stringify(position)}`);
            console.log(`[getCanvasCoords] Original dimensions: ${JSON.stringify(origDims)}`);
            console.log(`[getCanvasCoords] Scaled dimensions: ${scaledWidth} × ${scaledHeight}`);
            console.log(`[getCanvasCoords] Image position: base(${imageBaseX.toFixed(1)}, ${imageBaseY.toFixed(1)}) + offset => final(${finalImageX.toFixed(1)}, ${finalImageY.toFixed(1)})`);
            console.log(`[getCanvasCoords] OUTPUT: Canvas coords (${canvasX.toFixed(1)}, ${canvasY.toFixed(1)})`);
        }
        
        return { x: canvasX, y: canvasY };
    }

    function draw(e) {
        if (!isDrawing) return;

        if (window.debugCoordinates) {
            console.log("--- Draw Event Start ---");
            console.log("[draw] Transform:", ctx.getTransform());
        }

        // Get precise coordinates relative to the canvas
        const rect = canvas.getBoundingClientRect();
        const rawX = e.clientX - rect.left;
        const rawY = e.clientY - rect.top;
        
        if (window.debugCoordinates) {
            console.log(`[draw] Raw mouse coords: (${rawX.toFixed(1)}, ${rawY.toFixed(1)})`);
        }

        // Get current scale for potential use
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;

        // Test round-trip coordinate conversion accuracy
        if (window.debugCoordinates) {
            const roundTrip = getCanvasCoords(getTransformedCoords(rawX, rawY).x, getTransformedCoords(rawX, rawY).y);
            const roundTripError = Math.sqrt(Math.pow(roundTrip.x - rawX, 2) + Math.pow(roundTrip.y - rawY, 2));
            console.log(`[draw] Round-trip coordinate error: ${roundTripError.toFixed(2)} pixels`);
            console.log("--- Draw Event End ---");
        }
    }

// Define global variables for use by project-manager.js
window.IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
window.currentImageLabel = 'front';
window.vectorStrokesByImage = {};
window.strokeVisibilityByImage = {};
window.strokeLabelVisibility = {};
window.strokeMeasurements = {};
window.imageScaleByLabel = {};
window.imagePositionByLabel = {};
window.lineStrokesByImage = {}; // Make sure it's exposed globally
window.labelsByImage = {};      // Make sure it's exposed globally
window.originalImages = {};
window.isLoadingProject = false; // <-- Re-adding this line

// At the top of the file, near other global variables
window.debugCoordinates = false; // Global flag to control coordinate debugging

document.addEventListener('DOMContentLoaded', () => {
    // Initialize unit selectors
    const unitSelector = document.getElementById('unitSelector');
    unitSelector.addEventListener('change', updateMeasurementDisplay);
    
    // Add debug toggle button to the controls
    const controlsContainer = document.querySelector('.controls-container');
    const debugToggle = document.createElement('button');
    debugToggle.textContent = '🐞 Debug';
    debugToggle.classList.add('debug-toggle');
    debugToggle.addEventListener('click', () => {
        window.debugCoordinates = !window.debugCoordinates;
        debugToggle.classList.toggle('active', window.debugCoordinates);
        console.log(`Coordinate debugging ${window.debugCoordinates ? 'enabled' : 'disabled'}`);
    });
    controlsContainer.appendChild(debugToggle);
    
    // Initialize the measurement inputs
    const inchWhole = document.getElementById('inchWhole');
    const inchFraction = document.getElementById('inchFraction');
    const cmValue = document.getElementById('cmValue');
    
    // Handle unit conversion when changing values
    inchWhole.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    inchFraction.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    cmValue.addEventListener('change', () => {
        const cm = parseFloat(cmValue.value) || 0;
        const inches = cm / 2.54;
        
        // Update inch values
        inchWhole.value = Math.floor(inches);
        
        // Find closest fraction
        const fractionPart = inches - Math.floor(inches);
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        inchFraction.value = closestFraction;
        
        // Show inch inputs, hide cm inputs
        document.getElementById('inchInputs').style.display = 'flex';
        document.getElementById('cmInputs').style.display = 'none';
    });
    
    const canvas = document.getElementById('canvas');
    // Expose canvas globally for project management
    window.canvas = canvas;
    const ctx = canvas.getContext('2d', { willReadFrequently: true }); // Add willReadFrequently hint
    const colorPicker = document.getElementById('colorPicker');
    const brushSize = document.getElementById('brushSize');
    const clearButton = document.getElementById('clear');
    const saveButton = document.getElementById('save');
    const pasteButton = document.getElementById('paste');
    const strokeCounter = document.getElementById('strokeCounter');
    const imageList = document.getElementById('imageList');
    const drawingModeToggle = document.getElementById('drawingModeToggle');
    
    // Draggable sidebars
    const strokeSidebar = document.getElementById('strokeSidebar');
    const imageSidebar = document.getElementById('imageSidebar');
    const strokeSidebarHeader = document.getElementById('strokeSidebarHeader');
    const imageSidebarHeader = document.getElementById('imageSidebarHeader');

    // Undo/Redo functionality
    const MAX_HISTORY = 50;  // Maximum number of states to store
    const IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
    let currentImageIndex = 0;
    let imageStates = {}; // Store states for each image
    
    // Use the global variables instead of creating new ones
    let strokeDataByImage = {}; // Store additional data for each stroke
    let undoStackByImage = {}; // Separate undo stack for each image
    let redoStackByImage = {}; // Separate redo stack for each image
    let pastedImages = [];  // Store all pasted images
    let isDrawingOrPasting = false;  // Flag to prevent saving states while drawing
    let strokeInProgress = false;  // Track if we're in the middle of a stroke
    let currentStroke = null;  // Store the state before current stroke
    let originalImageDimensions = {}; // Store original image dimensions for scaling
    let isShiftPressed = false; // Track if Shift key is pressed for image movement
    let calculatedLabelOffsets = {}; // Store automatically calculated label offsets

    // Initialize states for default images
    IMAGE_LABELS.forEach(label => {
        // Ensure we initialize global arrays properly
        window.lineStrokesByImage[label] = [];
        window.strokeVisibilityByImage[label] = {}; // Initialize stroke visibility
        window.vectorStrokesByImage[label] = {}; // Initialize vector stroke data
        window.labelsByImage[label] = 'A1';  // Start from A1 instead of A0
        
        strokeDataByImage[label] = {}; // Initialize stroke data
        undoStackByImage[label] = [];
        redoStackByImage[label] = [];  // Initialize redo stack
        imageStates[label] = null;
        // Initialize scale to 100% (1.0)
        window.imageScaleByLabel[label] = 1.0;
        originalImageDimensions[label] = { width: 0, height: 0 };
        // Initialize position offset to center (0, 0)
        window.imagePositionByLabel[label] = { x: 0, y: 0 };
        // Initialize with a blank state when the image is first created
        const blankState = ctx.createImageData(canvas.width, canvas.height);
        imageStates[label] = blankState;
        undoStackByImage[label].push({
            state: cloneImageData(blankState),
            type: 'initial',
            label: null
        });
    });

    let currentImageLabel = IMAGE_LABELS[0]; // Start with 'front'

    // Make addImageToSidebar available globally for the project manager
    window.addImageToSidebar = addImageToSidebar;
    function addImageToSidebar(imageUrl, label) {
        // *** ADDED LOG ***
        console.log(`[addImageToSidebar] Called for label: ${label}, imageUrl: ${imageUrl ? imageUrl.substring(0,30) + '...' : 'null'}`);

        const container = document.createElement('div');
        container.className = 'image-container';
        container.dataset.label = label;
        container.dataset.originalImageUrl = imageUrl; // Store the original image URL for later restoration
        
        const labelElement = document.createElement('div');
        labelElement.className = 'image-label';
        labelElement.textContent = label.charAt(0).toUpperCase() + label.slice(1);
        
        const strokesElement = document.createElement('div');
        strokesElement.className = 'image-strokes';
        strokesElement.textContent = 'Strokes: 0';
        
        const scaleElement = document.createElement('div');
        scaleElement.className = 'image-scale';
        scaleElement.textContent = `Scale: ${Math.round(imageScaleByLabel[label] * 100)}%`;
        scaleElement.id = `scale-${label}`;
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.className = 'pasted-image';
        img.alt = `${label} view`;
        
        container.appendChild(img);
        container.appendChild(labelElement);
        container.appendChild(strokesElement);
        container.appendChild(scaleElement);
        
        container.onclick = () => {
            // ... rest of the handler
            
            console.log(`Switching from ${currentImageLabel} to ${label}`);
            
            // Ensure we have undo stacks for both workspaces
            undoStackByImage[currentImageLabel] = undoStackByImage[currentImageLabel] || [];
            undoStackByImage[label] = undoStackByImage[label] || [];
            
            // Ensure we have redo stacks for both workspaces
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[label] = redoStackByImage[label] || [];
            
            // Ensure we have stroke lists for both workspaces
            lineStrokesByImage[currentImageLabel] = lineStrokesByImage[currentImageLabel] || [];
            lineStrokesByImage[label] = lineStrokesByImage[label] || [];
            
            // Ensure we have stroke visibility for both workspaces
            strokeVisibilityByImage[currentImageLabel] = strokeVisibilityByImage[currentImageLabel] || {};
            strokeVisibilityByImage[label] = strokeVisibilityByImage[label] || {};
            
            // Save current state before switching
            saveState(true, false);
            
            // Switch to the new image
            switchToImage(label);
        };
        
        // *** ADDED LOGS ***
        const imageListElement = document.getElementById('imageList');
        if (!imageListElement) {
            console.error('[addImageToSidebar] Cannot find #imageList element!');
            return; // Stop if the target doesn't exist
        }
        console.log(`[addImageToSidebar] About to append container for ${label} to #imageList.`);
        imageListElement.appendChild(container);
        console.log(`[addImageToSidebar] Successfully appended container for ${label}. #imageList children: ${imageListElement.childElementCount}`);
    }
    

    // Store the original images for each view
    window.originalImages = window.originalImages || {};
    
    // --- MODIFIED Function Signature and Logic --- 
    function pasteImageFromUrl(url, label) {
        // Wrap in a Promise
        return new Promise((resolve, reject) => {
            console.log(`[pasteImageFromUrl] Pasting image for ${label}: ${url.substring(0, 30)}...`);
        
        const img = new Image();
        img.onload = () => {
            // Store the original image for this view
                window.originalImages[label] = url;
                
                // Ensure the object exists before setting properties
                if (!window.originalImageDimensions) {
                    window.originalImageDimensions = {};
                }
            
            // Store original dimensions for scaling
                window.originalImageDimensions[label] = {
                width: img.width,
                height: img.height
            };
                
                // Log dimensions for debugging
                console.log(`[pasteImageFromUrl] Stored dimensions for ${label}: ${img.width}x${img.height}`);
            
            // Clear the canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply current scale factor
                const scale = imageScaleByLabel[label] || 1.0; // Use passed-in label
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of the canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
                const position = imagePositionByLabel[label] || { x: 0, y: 0 }; // Use passed-in label
                const offsetX = position.x;
                const offsetY = position.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;
            
            // Draw the image with scaling and positioning
                console.log(`[pasteImageFromUrl] Drawing image for ${label} at Canvas(${x.toFixed(1)}, ${y.toFixed(1)}) Scale: ${scale * 100}%`);
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Update the scale display in the sidebar
                const scaleElement = document.getElementById(`scale-${label}`);
            if (scaleElement) {
                scaleElement.textContent = `Scale: ${Math.round(scale * 100)}%`;
            }
            
            // Save this as the base state for this image
            const newState = getCanvasState();
                imageStates[label] = cloneImageData(newState); // Use passed-in label
                console.log(`[pasteImageFromUrl] State saved into imageStates[${label}]`);
                
                // If this is the currently active label, update currentStroke
                if (label === currentImageLabel) {
            currentStroke = cloneImageData(newState);
                }
            
                // Initialize the undo stack if needed
                if (!undoStackByImage[label] || undoStackByImage[label].length === 0) {
                    undoStackByImage[label] = [{
                state: cloneImageData(newState),
                type: 'initial',
                label: null
            }];
                    console.log(`[pasteImageFromUrl] Initialized undo stack for ${label}`);
                }
            
                // Update the scale buttons to show active state if this is the current view
                if (label === currentImageLabel) {
            updateScaleButtonsActiveState();
                }
                
                console.log(`[pasteImageFromUrl] Image loaded and state saved for ${label}`);
                resolve(); // Resolve the promise
            };
            
            img.onerror = (err) => {
                console.error(`[pasteImageFromUrl] Error loading image for ${label}:`, err);
                reject(err); // Reject the promise on error
            };
            
        img.src = url;
        });
    }
    // --- END MODIFIED Function ---

    function getNextLabel(imageLabel) {
        const currentLabel = labelsByImage[imageLabel];
        const letter = currentLabel[0];
        const number = parseInt(currentLabel.slice(1)) + 1;
        if (number > 9) {
            return String.fromCharCode(letter.charCodeAt(0) + 1) + '0';
        }
        return letter + number;
    }

    // Make updateStrokeCounter available globally
    window.updateStrokeCounter = updateStrokeCounter;
    function updateStrokeCounter() {
        const strokeCount = lineStrokesByImage[currentImageLabel]?.length || 0;
        strokeCounter.textContent = `Lines: ${strokeCount}`;
        
        // Update visibility controls
        updateStrokeVisibilityControls();
    }
    
    function updateSidebarStrokeCounts() {
        // Update stroke counts in the sidebar
        const imageContainers = document.querySelectorAll('.image-container');
        imageContainers.forEach(container => {
            const label = container.dataset.label;
            if (label) {
                const strokesElement = container.querySelector('.image-strokes');
                if (strokesElement) {
                    const strokes = lineStrokesByImage[label] || [];
                    strokesElement.textContent = `Strokes: ${strokes.length}`;
                }
            }
        });
        
        // Also update visibility controls when sidebar is updated
        updateStrokeVisibilityControls();
    }

    function getCanvasState() {
        return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    function restoreCanvasState(state) {
        if (!state) return;
        ctx.putImageData(state, 0, 0);
    }
    
    // Measurement data for strokes
    let strokeMeasurements = {};
    
    // Initialize measurement data store
    IMAGE_LABELS.forEach(label => {
        strokeMeasurements[label] = {};
    });
    
    // Function to get formatted measurement string
    function getMeasurementString(strokeLabel) {
        const measurement = strokeMeasurements[currentImageLabel]?.[strokeLabel];
        if (!measurement) return '';
        
        const unit = document.getElementById('unitSelector').value;
        
        if (unit === 'inch') {
            const whole = measurement.inchWhole || 0;
            const fraction = measurement.inchFraction || 0;
            
            // Format as 1 1/4" etc.
            let fractionStr = '';
            if (fraction > 0) {
                const fractionMap = {
                    0.125: '1/8',
                    0.25: '1/4',
                    0.375: '3/8',
                    0.5: '1/2',
                    0.625: '5/8',
                    0.75: '3/4',
                    0.875: '7/8'
                };
                fractionStr = ' ' + fractionMap[fraction];
            }
            
            return `${whole}${fractionStr}"`;
        } else {
            // CM with one decimal
            return `${measurement.cm.toFixed(1)} cm`;
        }
    }
    
    // Function to convert between units
    function convertUnits(from, value) {
        if (from === 'inch') {
            // Convert inch to cm
            return value * 2.54;
        } else {
            // Convert cm to inch
            return value / 2.54;
        }
    }
    
    // Function to update all measurements when unit changes
    function updateMeasurementDisplay() {
        const unit = document.getElementById('unitSelector').value;
        const inchWhole = document.getElementById('inchWhole');
        const inchFraction = document.getElementById('inchFraction');
        const cmValue = document.getElementById('cmValue');
        
        // Convert values when switching between units
        if (unit === 'inch') {
            // Converting from cm to inches
            const cm = parseFloat(cmValue.value) || 0;
            const inches = cm / 2.54;
            
            // Update inch values
            inchWhole.value = Math.floor(inches);
            
            // Find closest fraction
            const fractionPart = inches - Math.floor(inches);
            const fractions = [
                {value: '0', text: '0'},
                {value: '0.125', text: '1/8'},
                {value: '0.25', text: '1/4'},
                {value: '0.375', text: '3/8'},
                {value: '0.5', text: '1/2'},
                {value: '0.625', text: '5/8'},
                {value: '0.75', text: '3/4'},
                {value: '0.875', text: '7/8'}
            ];
            
            fractions.forEach(f => {
                const option = document.createElement('option');
                option.value = f.value;
                option.textContent = f.text;
                if (parseFloat(f.value) === fractionPart) {
                    option.selected = true;
                }
                inchFraction.appendChild(option);
            });
            
            // Show inch inputs, hide cm inputs
            document.getElementById('inchInputs').style.display = 'flex';
            document.getElementById('cmInputs').style.display = 'none';
        } else {
            // Converting from inches to cm
            const whole = parseInt(inchWhole.value) || 0;
            const fraction = parseFloat(inchFraction.value) || 0;
            const totalInches = whole + fraction;
            
            // Update cm value with one decimal point
            cmValue.value = (totalInches * 2.54).toFixed(1);
            
            // Show cm inputs, hide inch inputs
            document.getElementById('inchInputs').style.display = 'none';
            document.getElementById('cmInputs').style.display = 'flex';
        }
        
        // Update the stroke visibility display to show new units
        updateStrokeVisibilityControls();
        
        // Redraw the canvas with updated measurement format in labels
        redrawCanvasWithVisibility();
    }

    // Function to update stroke visibility controls
    // Make updateStrokeVisibilityControls available globally
    window.updateStrokeVisibilityControls = updateStrokeVisibilityControls;
    function updateStrokeVisibilityControls() {
        const controlsContainer = document.getElementById('strokeVisibilityControls');
        controlsContainer.innerHTML = ''; // Clear existing controls
        
        // Add a separator at the top
        const topSeparator = document.createElement('hr');
        controlsContainer.appendChild(topSeparator);
        
        // Display current unit
        const unitDisplay = document.createElement('div');
        unitDisplay.className = 'current-unit-display';
        unitDisplay.textContent = `Current Unit: ${document.getElementById('unitSelector').value === 'inch' ? 'Inches' : 'Centimeters'}`;
        controlsContainer.appendChild(unitDisplay);
        
        // Add another separator
        const separator = document.createElement('hr');
        controlsContainer.appendChild(separator);
        
        // Create strokes list
        const strokesList = document.createElement('div');
        strokesList.id = 'strokesList';
        controlsContainer.appendChild(strokesList);
        
        // Get strokes for current image
        const strokes = lineStrokesByImage[currentImageLabel] || [];
        
        if (strokes.length === 0) {
            strokesList.innerHTML = '<p>No strokes to display</p>';
            return;
        }
        
        // Current unit
        const unit = document.getElementById('unitSelector').value;
        
        // Create visibility toggle for each stroke
        strokes.forEach(strokeLabel => {
            // Initialize visibility if not set
            if (strokeVisibilityByImage[currentImageLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel] = {};
            }
            if (strokeVisibilityByImage[currentImageLabel][strokeLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            }
            
            // Initialize label visibility if not set
            if (strokeLabelVisibility[currentImageLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel] = {};
            }
            if (strokeLabelVisibility[currentImageLabel][strokeLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel][strokeLabel] = true; // Labels visible by default
            }
            
            // Initialize measurement if not set
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            if (strokeMeasurements[currentImageLabel][strokeLabel] === undefined) {
                strokeMeasurements[currentImageLabel][strokeLabel] = {
                    inchWhole: 0,
                    inchFraction: 0,
                    cm: 0.0
                };
            }
            
            const isVisible = strokeVisibilityByImage[currentImageLabel][strokeLabel];
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            const measurement = getMeasurementString(strokeLabel);
            const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
            
            const item = document.createElement('div');
            item.className = 'stroke-visibility-item';
            item.dataset.stroke = strokeLabel;
            item.dataset.selected = isSelected ? 'true' : 'false';
            
            // Make all parts of the item selectable (except checkbox and buttons)
            item.addEventListener('click', (e) => {
                // Don't trigger selection if clicking a button or checkbox
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
                    return;
                }
                
                // Toggle selection (if already selected, deselect it)
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                
                // Update the measurement input with the selected stroke's measurement
                    if (typeof updateMeasurementInputWithStroke === 'function') {
                    updateMeasurementInputWithStroke(strokeLabel);
                }
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `visibility-${strokeLabel}`;
            checkbox.checked = isVisible;
            checkbox.addEventListener('change', () => toggleStrokeVisibility(strokeLabel, checkbox.checked));
            
            const labelContainer = document.createElement('div');
            labelContainer.className = 'stroke-label-container';
            
            // Find the stroke color from the undo stack or vector data
            let strokeColor = '#000';
            let strokeType = 'freehand'; // Default type
            
            if (vectorStrokesByImage[currentImageLabel] && 
                vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                const vectorData = vectorStrokesByImage[currentImageLabel][strokeLabel];
                strokeColor = vectorData.color || '#000';
                strokeType = vectorData.type || 'freehand';
            } else {
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel && action.color) {
                        strokeColor = action.color;
                        // Try to determine stroke type from action
                        if (action.type === 'line') {
                            strokeType = 'straight';
                        }
                        break;
                    }
                }
            }
            
            // Create the stroke name element with color matching the stroke
            const strokeName = document.createElement('span');
            strokeName.className = 'stroke-name';
            strokeName.textContent = strokeLabel;
            strokeName.style.borderColor = strokeColor;
            strokeName.style.color = strokeColor;
            
            // Add a small icon to indicate stroke type (optional)
            if (strokeType === 'straight') {
                strokeName.title = 'Straight Line';
            } else {
                strokeName.title = 'Freehand Stroke';
            }
            
            // Make stroke name label clickable for selection as well
            strokeName.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                
                // Toggle selection 
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            // Create measurement text
            const measureText = document.createElement('span');
            measureText.className = 'stroke-measurement';
            measureText.textContent = measurement ? `= ${measurement}` : '';
            
            // Create edit button
            const editBtn = document.createElement('button');
            editBtn.className = 'stroke-edit-btn';
            editBtn.innerHTML = '✏️';
            editBtn.title = 'Edit Stroke';
            editBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                showEditDialog(strokeLabel);
            };
            
            // Create label toggle button
            const labelToggleBtn = document.createElement('button');
            labelToggleBtn.className = 'stroke-label-toggle';
            labelToggleBtn.classList.toggle('active', isLabelVisible);
            labelToggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            labelToggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            labelToggleBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                toggleLabelVisibility(strokeLabel);
            };
            
            // Add elements to container
            labelContainer.appendChild(strokeName);
            labelContainer.appendChild(measureText);
            labelContainer.appendChild(labelToggleBtn);
            labelContainer.appendChild(editBtn);
            
            // Build the complete item
            item.appendChild(checkbox);
            item.appendChild(labelContainer);
            
            // Add to stroke list
            strokesList.appendChild(item);
        });
    }
    
    // Function to toggle label visibility on canvas
    function toggleLabelVisibility(strokeLabel) {
        // Only toggle the label visibility, not the stroke visibility
        strokeLabelVisibility[currentImageLabel][strokeLabel] = !strokeLabelVisibility[currentImageLabel][strokeLabel];
        
        // Update the UI button appearance
        const toggleBtn = document.querySelector(`.stroke-visibility-item[data-stroke="${strokeLabel}"] .stroke-label-toggle`);
        if (toggleBtn) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            toggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            toggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            toggleBtn.classList.toggle('active', isLabelVisible);
        }
        
        // Redraw the canvas with updated label visibility
        // This should not affect the stroke visibility
        redrawCanvasWithVisibility();
    }
    
    // Function to update measurement input with selected stroke's value
    // Function to display a measurement edit dialog
    function showMeasurementDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurement
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Measurement for ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values from inputs
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Determine which unit was changed last and use that value
            const currentUnit = document.getElementById('unitSelector').value;
            let finalCmValue, finalInchWhole, finalInchFraction;
            
            if (currentUnit === 'inch') {
                finalInchWhole = wholeValue;
                finalInchFraction = fractionValue;
                finalCmValue = convertUnits('inch', wholeValue + fractionValue);
            } else {
                finalCmValue = cmValue;
                // Calculate inch equivalent
                const inches = convertUnits('cm', cmValue);
                finalInchWhole = Math.floor(inches);
                finalInchFraction = findClosestFraction(inches - finalInchWhole);
            }
            
            // Update the measurement
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            
            strokeMeasurements[currentImageLabel][strokeLabel] = {
                inchWhole: finalInchWhole,
                inchFraction: finalInchFraction,
                cm: finalCmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update the UI
            updateStrokeVisibilityControls();
            
            // Redraw with the new measurement
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Helper function to find the closest fraction
    function findClosestFraction(fractionPart) {
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        return closestFraction;
    }
    
    // Function to show edit dialog for a stroke
    function showEditDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurements
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Stroke ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Create name edit field
        const nameContainer = document.createElement('div');
        nameContainer.className = 'name-container';
        
        const nameLabel = document.createElement('div');
        nameLabel.textContent = 'Label:';
        nameContainer.appendChild(nameLabel);
        
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = strokeLabel;
        nameInput.placeholder = 'Label';
        nameContainer.appendChild(nameInput);
        
        dialog.appendChild(nameContainer);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Sync between inch and cm inputs
        wholeInput.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        fractionSelect.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        cmInput.addEventListener('change', () => {
            const cmValue = parseFloat(cmInput.value) || 0;
            const inches = convertUnits('cm', cmValue);
            const wholeValue = Math.floor(inches);
            const fractionValue = findClosestFraction(inches - wholeValue);
            
            wholeInput.value = wholeValue;
            fractionSelect.value = fractionValue.toString();
        });
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values
            const newName = nameInput.value.trim();
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Update name if changed
            let finalName = strokeLabel;
            if (newName !== strokeLabel && newName !== '') {
                // The unique name generation is handled inside renameStroke
                finalName = renameStroke(strokeLabel, newName);
                
                // Show feedback if name was modified to make it unique
                if (finalName !== newName) {
                    console.log(`Stroke name automatically adjusted to ${finalName} to avoid duplicates`);
                    
                    // Create and show a temporary notification
                    const notification = document.createElement('div');
                    notification.style.position = 'fixed';
                    notification.style.bottom = '20px';
                    notification.style.left = '50%';
                    notification.style.transform = 'translateX(-50%)';
                    notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                    notification.style.color = 'white';
                    notification.style.padding = '10px 20px';
                    notification.style.borderRadius = '4px';
                    notification.style.zIndex = '10000';
                    notification.textContent = `Renamed to ${finalName} to avoid duplicates`;
                    
                    document.body.appendChild(notification);
                    
                    // Remove after 3 seconds
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 3000);
                }
            }
            
            // Always save both units
            strokeMeasurements[currentImageLabel][finalName] = {
                inchWhole: wholeValue,
                inchFraction: fractionValue,
                cm: cmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update UI
            updateStrokeVisibilityControls();
            
            // Redraw to show updated measurements
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Function to generate a unique stroke name
    function generateUniqueStrokeName(baseName) {
        // If the name is empty or undefined, use a default name
        if (!baseName || baseName.trim() === '') {
            baseName = 'A1';
        }
        
        // If the base name doesn't already exist, we can use it as is
        if (!lineStrokesByImage[currentImageLabel] || 
            !lineStrokesByImage[currentImageLabel].includes(baseName)) {
            return baseName;
        }
        
        // Name already exists, so we need to add a number
        // Extract the base part and any existing numbering
        const match = baseName.match(/^(.+?)(?:\((\d+)\))?$/);
        if (!match) {
            // If the regex didn't match for some reason, append (1) to the name
            return `${baseName}(1)`;
        }
        
        const base = match[1];
        let counter = 1;
        
        // If there was already a number, start from the next one
        if (match[2]) {
            counter = parseInt(match[2]) + 1;
        }
        
        // Keep incrementing until we find a unique name
        let newName;
        do {
            newName = `${base}(${counter})`;
            counter++;
        } while (lineStrokesByImage[currentImageLabel].includes(newName));
        
        return newName;
    }
    
    // Function to rename a stroke
    function renameStroke(oldName, newName) {
        if (oldName === newName) return;
        
        // Generate a unique name if needed - this ensures the new name won't conflict
        // with any existing stroke names, including itself
        const uniqueNewName = generateUniqueStrokeName(newName);
        
        // Find the stroke color from the undo stack or vector data to maintain color after rename
        let strokeColor = '#000';
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            strokeColor = vectorStrokesByImage[currentImageLabel][oldName].color || '#000';
        } else {
            for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                const action = undoStackByImage[currentImageLabel][i];
                if (action.label === oldName && action.color) {
                    strokeColor = action.color;
                    // Try to determine stroke type from action
                    if (action.type === 'line') {
                        strokeType = 'straight';
                    }
                    break;
                }
            }
        }
        
        // Update all relevant data structures
        if (lineStrokesByImage[currentImageLabel]) {
            const index = lineStrokesByImage[currentImageLabel].indexOf(oldName);
            if (index !== -1) {
                lineStrokesByImage[currentImageLabel][index] = uniqueNewName;
            }
        }
        
        // Update visibility
        if (strokeVisibilityByImage[currentImageLabel] && 
            strokeVisibilityByImage[currentImageLabel][oldName] !== undefined) {
            const isVisible = strokeVisibilityByImage[currentImageLabel][oldName];
            strokeVisibilityByImage[currentImageLabel][uniqueNewName] = isVisible;
            delete strokeVisibilityByImage[currentImageLabel][oldName];
        }
        
        // Update label visibility
        if (strokeLabelVisibility[currentImageLabel] && 
            strokeLabelVisibility[currentImageLabel][oldName] !== undefined) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][oldName];
            strokeLabelVisibility[currentImageLabel][uniqueNewName] = isLabelVisible;
            delete strokeLabelVisibility[currentImageLabel][oldName];
        }
        
        // Update stroke data
        if (strokeDataByImage[currentImageLabel] && 
            strokeDataByImage[currentImageLabel][oldName]) {
            strokeDataByImage[currentImageLabel][uniqueNewName] = 
                strokeDataByImage[currentImageLabel][oldName];
            delete strokeDataByImage[currentImageLabel][oldName];
        }
        
        // Update vector data
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            vectorStrokesByImage[currentImageLabel][uniqueNewName] = 
                vectorStrokesByImage[currentImageLabel][oldName];
            delete vectorStrokesByImage[currentImageLabel][oldName];
        }
        
        // Update measurements
        if (strokeMeasurements[currentImageLabel] && 
            strokeMeasurements[currentImageLabel][oldName]) {
            strokeMeasurements[currentImageLabel][uniqueNewName] = 
                strokeMeasurements[currentImageLabel][oldName];
            delete strokeMeasurements[currentImageLabel][oldName];
        }
        
        // Update next label if needed
        if (labelsByImage[currentImageLabel] === oldName) {
            labelsByImage[currentImageLabel] = uniqueNewName;
        }
        
        // Update any references in the undo/redo stacks
        if (undoStackByImage[currentImageLabel]) {
            undoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        if (redoStackByImage[currentImageLabel]) {
            redoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        // Return the actual name used for the stroke (either the original or the uniquified version)
        return uniqueNewName;
    }
    
    // Function to toggle stroke visibility
    function toggleStrokeVisibility(strokeLabel, isVisible) {
        console.log(`Toggling visibility of stroke ${strokeLabel} to ${isVisible}`);
        
        // Update visibility state
        strokeVisibilityByImage[currentImageLabel][strokeLabel] = isVisible;
        
        // Make sure the stroke data is still available and not accidentally cleared
        if (isVisible) {
            // Initialize vectorStrokesByImage for this image if it doesn't exist
            if (!vectorStrokesByImage[currentImageLabel]) {
                vectorStrokesByImage[currentImageLabel] = {};
            }
            
            // If we're making a stroke visible, ensure we still have vector data
            if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                console.log(`Vector data missing for ${strokeLabel}, attempting recovery`);
                
                // Try to recover vector data from the undo stack
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel) {
                        if (action.vectorData) {
                            vectorStrokesByImage[currentImageLabel][strokeLabel] = action.vectorData;
                            console.log(`Recovered vector data for ${strokeLabel}`);
                            break;
                        }
                    }
                }
                
                // If we still couldn't recover the vector data, create a basic one
                // This is especially important for straight lines
                if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                    console.log(`Creating default vector data for ${strokeLabel}`);
                    
                    // Look for color and properties in the undo stack
                    let strokeColor = "#000000";
                    let strokeWidth = 5;
                    let isLine = false;
                    
                    for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                        const action = undoStackByImage[currentImageLabel][i];
                        if (action.label === strokeLabel) {
                            if (action.color) strokeColor = action.color;
                            if (action.width) strokeWidth = action.width;
                            if (action.type === 'line' || action.type === 'straight') isLine = true;
                            break;
                        }
                    }
                    
                    // Create a simple vector representation (placeholder)
                    vectorStrokesByImage[currentImageLabel][strokeLabel] = {
                        points: isLine ? [{x: 0, y: 0}, {x: 1, y: 1}] : [{x: 0, y: 0}],
                        color: strokeColor,
                        width: strokeWidth,
                        type: isLine ? 'straight' : 'freehand'
                    };
                }
            }
        };

        // *** Add redraw call here ***
        redrawCanvasWithVisibility();
    }
    
    // Store for currently selected stroke in each image
    let selectedStrokeByImage = {};
    
    // Initialize stroke label visibility for each image (default to visible)
    IMAGE_LABELS.forEach(label => {
        strokeLabelVisibility[label] = {};
        selectedStrokeByImage[label] = null; // Initialize with no selection
    });
    
    // Store for label custom positions (user-dragged positions)
    let customLabelPositions = {};
    
    // Flag to track if we're dragging a label
    let isDraggingLabel = false;
    let draggedLabelStroke = null;
    let dragStartX = 0;
    let dragStartY = 0;
    
    // Initialize custom label positions for each image
    IMAGE_LABELS.forEach(label => {
        customLabelPositions[label] = {};
    });
    
    // Cache for loaded images to prevent flickering
    const imageCache = {};
    
    // Store for label positions to prevent overlapping
    let currentLabelPositions = [];
    
    // Store for stroke paths to avoid overlapping with lines
    let currentStrokePaths = [];
    
    // Function to redraw canvas respecting stroke visibility
    // Make redrawCanvasWithVisibility available globally
    window.redrawCanvasWithVisibility = redrawCanvasWithVisibility;
    function redrawCanvasWithVisibility() {
        console.log(`--- redrawCanvasWithVisibility called for: ${currentImageLabel} ---`);
        
        // *** Save context and reset transform before drawing anything ***
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset to identity matrix
        console.log("Redraw Start Transform:", ctx.getTransform());
        
        // ADDED: Ensure originalImageDimensions exists and has an entry for this label
        if (!window.originalImageDimensions) {
            window.originalImageDimensions = {};
        }
        
        // ADDED: If we don't have dimensions for this label but we're trying to draw strokes,
        // create default dimensions based on the canvas size to prevent coordinates from being lost
        if (!window.originalImageDimensions[currentImageLabel] && 
            window.vectorStrokesByImage[currentImageLabel] && 
            Object.keys(window.vectorStrokesByImage[currentImageLabel]).length > 0) {
            
            console.log(`Creating default dimensions for ${currentImageLabel} to preserve strokes`);
            window.originalImageDimensions[currentImageLabel] = {
                width: canvas.width,
                height: canvas.height
            };
            console.log(`Set dimensions to match canvas: ${canvas.width}x${canvas.height}`);
        }
        
        // Reset label positions and stroke paths for this redraw
        currentLabelPositions = [];
        currentStrokePaths = [];
        
        // Create a copy of custom label positions for tracking which ones were actually used
        const usedCustomPositions = {};
        
        // We need to rebuild the canvas from scratch using individual stroke data
        const strokes = window.lineStrokesByImage[currentImageLabel] || [];
        
        // Start with a blank canvas or the original image if available
        if (window.originalImages && window.originalImages[currentImageLabel]) {
            // Check if we already have this image in the cache
            const imageUrl = window.originalImages[currentImageLabel];
            
            if (imageCache[imageUrl]) {
                // Use cached image immediately
                drawImageAndStrokes(imageCache[imageUrl]);
            } else {
                // Load the image and cache it
                const img = new Image();
                img.onload = () => {
                    // Add to cache
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                };
                img.src = imageUrl;
                
                // If the image is already cached in the browser, it might be immediately available
                if (img.complete) {
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                } else {
                    // If the image isn't immediately available,
                    // still draw the strokes on a blank canvas so they don't disappear
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the current scale and position
                    const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
                    
                    // For blank canvas mode, we apply the position directly when drawing points
                    // We pass 0,0 for position here since we'll apply it inside applyVisibleStrokes
                    applyVisibleStrokes(scale, 0, 0);
                }
            }
        } else {
            // Otherwise start with a blank canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white'; // Add white background fill
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Get the current scale for the blank canvas state
            const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
            
            // Apply visible strokes - for blank canvas mode, we don't need to apply position offset here
            // since we'll apply it to each point when drawing
            applyVisibleStrokes(scale, 0, 0);
        }
        
        function drawImageAndStrokes(img) {
            // Clear only once within the reset transform state
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply scale
            const scale = window.imageScaleByLabel[currentImageLabel];
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
            const positionOffset = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 }; // Ensure offset exists
            const offsetX = positionOffset.x;
            const offsetY = positionOffset.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;

            // *** ADDED LOGGING ***
            // console.log(`drawImageAndStrokes Calculation:
            //   canvas.width=${canvas.width}, img.width=${img.width}, scaledWidth=${scaledWidth}
            //   scale=${scale}, centerX=${centerX}, offsetX=${offsetX}, final imageX (passed to applyVisibleStrokes)=${x}`);
            // *** END LOGGING ***
            
            // Draw the image with scaling and positioning
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Then apply visible strokes
            applyVisibleStrokes(scale, x, y);
        }
        
        function applyVisibleStrokes(scale, imageX, imageY) {
+           console.log("ApplyStrokes Start Transform:", ctx.getTransform()); // Log transform at start
            // console.log(`\nApplying strokes with scale=${scale}, imageX=${imageX}, imageY=${imageY}`); // Keep this commented unless debugging scale/position
            const strokes = window.vectorStrokesByImage[currentImageLabel] || {};
            const strokeOrder = window.lineStrokesByImage[currentImageLabel] || [];
            const visibility = window.strokeVisibilityByImage[currentImageLabel] || {};

            // Loop through strokes in their drawing order
            strokeOrder.forEach((strokeLabel) => {
                const isVisible = visibility[strokeLabel];
                if (!isVisible) return; // Skip invisible strokes

                const vectorData = strokes[strokeLabel];
                // Ensure vectorData and points exist
                if (!vectorData || !vectorData.points || vectorData.points.length === 0) {
                     console.warn(`Skipping stroke ${strokeLabel} in redraw: Missing vector data or points.`);
                     return;
                }

                // Set stroke style based on stored data, scaled by CURRENT scale
                ctx.strokeStyle = vectorData.color || '#000000';
                // *** FIX: Ensure lineWidth uses original stored width * current scale ***
                const scaledLineWidth = (vectorData.width || 5) * scale;
                ctx.lineWidth = scaledLineWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Start drawing the path
                ctx.beginPath();

                // Transform the first point from relative to canvas coordinates
                const firstPointRelative = vectorData.points[0];
                const firstPointCanvas = getCanvasCoords(firstPointRelative.x, firstPointRelative.y);
                ctx.moveTo(firstPointCanvas.x, firstPointCanvas.y);

                // Store canvas path for label collision detection
                const strokePath = [{ x: firstPointCanvas.x, y: firstPointCanvas.y }];

                // Check if this is a straight line (only two points)
                const isStraightLine = vectorData.type === 'straight' || (vectorData.points.length === 2 && !vectorData.type);

                if (isStraightLine && vectorData.points.length >= 2) {
                    // Straight Line: Transform only the last point
                    const lastPointRelative = vectorData.points[vectorData.points.length - 1];
                    const lastPointCanvas = getCanvasCoords(lastPointRelative.x, lastPointRelative.y);
                    ctx.lineTo(lastPointCanvas.x, lastPointCanvas.y);
                    strokePath.push({ x: lastPointCanvas.x, y: lastPointCanvas.y });
                } else {
                    // Freehand: Transform ALL subsequent points
                    for (let i = 1; i < vectorData.points.length; i++) {
                        const pointRelative = vectorData.points[i];
                        // *** FIX: Apply getCanvasCoords to EACH subsequent point ***
                        const pointCanvas = getCanvasCoords(pointRelative.x, pointRelative.y);
                        ctx.lineTo(pointCanvas.x, pointCanvas.y);
                        strokePath.push({ x: pointCanvas.x, y: pointCanvas.y });
                         // Optional logging for debugging coordinate drift:
                         // if (i < 3 || i % 20 === 0) { // Log first few and then every 20th
                         //     console.log(`  Redraw Pt ${i} Rel:(${pointRelative.x.toFixed(1)}, ${pointRelative.y.toFixed(1)}) -> Canv:(${pointCanvas.x.toFixed(1)}, ${pointCanvas.y.toFixed(1)})`);
                         // }
                    }
                }

                // Apply selection highlighting if needed (before stroking)
                const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                if (isSelected) {
                    ctx.save();
                    ctx.shadowColor = '#ffffff'; // White glow
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                }

                // Stroke the path
                ctx.stroke();

                // Restore context if selection highlighting was applied
                if (isSelected) {
                    ctx.restore();
                }

                // Store the calculated canvas path and scaled width for label positioning
                currentStrokePaths.push({
                    label: strokeLabel,
                    path: strokePath, // Store canvas coordinates path
                     // *** FIX: Store correctly scaled width ***
                    width: scaledLineWidth,
                    color: vectorData.color
                });
            }); // End of strokeOrder.forEach

            // --- Label Drawing Logic ---
            // console.log(`--- Redraw: Drawing Labels for ${currentImageLabel} ---`);
            currentLabelPositions = [];
            const usedCustomPositions = {};

            strokeOrder.forEach((strokeLabel) => {
                const isStrokeVisible = visibility[strokeLabel];
                if (!strokeLabelVisibility[currentImageLabel]) strokeLabelVisibility[currentImageLabel] = {};
                const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel] !== false; // Default true
                const vectorData = strokes[strokeLabel];

                if (isStrokeVisible && isLabelVisible && vectorData && vectorData.points.length > 0) {
                    const measurement = getMeasurementString(strokeLabel);
                    const labelText = measurement ? `${strokeLabel}=${measurement}` : strokeLabel;

                    // Determine anchor point (middle of the stroke) using RELATIVE coordinates
                    let anchorPointRelative = { x: 0, y: 0 };
                    const midIndex = Math.floor(vectorData.points.length / 2);
                    anchorPointRelative = vectorData.points[midIndex];

                    // Convert anchor point to CURRENT canvas coordinates
                    const anchorPointCanvas = getCanvasCoords(anchorPointRelative.x, anchorPointRelative.y);

                    if (isNaN(anchorPointCanvas.x) || isNaN(anchorPointCanvas.y)) {
                         console.error(`      Error getting canvas coords for label anchor for ${strokeLabel}. Relative point:`, anchorPointRelative);
                         return; // Skip label if anchor is invalid
                    }

                    // Set label style
                    // Increase font size for better visibility, especially when scaled
                    const baseFontSize = 14;
                    const scaledFontSize = Math.max(10, Math.min(28, baseFontSize / scale)); // Adjust font size based on zoom, within limits
                    ctx.font = `${scaledFontSize}px Arial`;
                    const labelColor = vectorData.color || '#000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';

                    // Calculate label dimensions based on current font size
                    const metrics = ctx.measureText(labelText);
                    const padding = 6 / scale; // Scale padding inversely
                    const labelWidth = metrics.width + padding * 2;
                    const labelHeight = scaledFontSize + padding * 2; // Adjust height based on font size

                    // Initial label rectangle guess (used for optimal position calculation)
                     const initialLabelRect = {
                        width: labelWidth,
                        height: labelHeight,
                        x: anchorPointCanvas.x - labelWidth / 2,
                        y: anchorPointCanvas.y - labelHeight - (15 / scale), // Scale vertical offset
                        strokeLabel: strokeLabel
                    };

                    // Determine final label position
                    let finalPosition; // This will be canvas coordinates {x, y} for the top-left of the label
                    let offset = null; // Relative offset {x, y} from anchorPointCanvas

                    // 1. Check for user-dragged position (stored as relative offset)
                    if (customLabelPositions[currentImageLabel]?.[strokeLabel]) {
                        offset = customLabelPositions[currentImageLabel][strokeLabel];
                        // Apply the stored relative offset to the *current* canvas anchor point
                        finalPosition = { x: anchorPointCanvas.x + offset.x, y: anchorPointCanvas.y + offset.y };
                        usedCustomPositions[strokeLabel] = true; // Mark as used
                         // console.log(`    Using custom offset for ${strokeLabel}. Anchor: (${anchorPointCanvas.x.toFixed(1)}, ${anchorPointCanvas.y.toFixed(1)}), Offset: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)}) -> Final: (${finalPosition.x.toFixed(1)}, ${finalPosition.y.toFixed(1)})`);
                    }
                    // 2. Check for previously calculated offset (stored as relative offset)
                    else if (calculatedLabelOffsets[currentImageLabel]?.[strokeLabel]) {
                        offset = calculatedLabelOffsets[currentImageLabel][strokeLabel];
                        // Apply the stored relative offset to the *current* canvas anchor point
                        finalPosition = { x: anchorPointCanvas.x + offset.x, y: anchorPointCanvas.y + offset.y };
                         // console.log(`    Using calculated offset for ${strokeLabel}. Anchor: (${anchorPointCanvas.x.toFixed(1)}, ${anchorPointCanvas.y.toFixed(1)}), Offset: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)}) -> Final: (${finalPosition.x.toFixed(1)}, ${finalPosition.y.toFixed(1)})`);
                    }
                    // 3. Calculate optimal position and offset for the first time
                    else {
                        if (typeof findOptimalLabelPosition !== 'function') {
                            console.error("     findOptimalLabelPosition function is not defined! Using default position.");
                            finalPosition = { x: initialLabelRect.x, y: initialLabelRect.y }; // Fallback
                        } else {
                            try {
                                const strokePathInfo = currentStrokePaths.find(p => p.label === strokeLabel);
                                const optimalRect = findOptimalLabelPosition(
                                    initialLabelRect, // Initial guess uses current canvas coords & dimensions
                                    anchorPointCanvas, // Anchor is current canvas coords
                                    strokePathInfo // Pass current canvas path info
                                );
                                finalPosition = { x: optimalRect.x, y: optimalRect.y };
                            } catch(err) {
                                console.error(`      Error in findOptimalLabelPosition for ${strokeLabel}:`, err);
                                finalPosition = { x: initialLabelRect.x, y: initialLabelRect.y }; // Fallback
                            }
                        }
                        // Calculate and store the RELATIVE offset based on the calculated position
                        offset = {
                            x: finalPosition.x - anchorPointCanvas.x,
                            y: finalPosition.y - anchorPointCanvas.y
                        };
                        if (!calculatedLabelOffsets[currentImageLabel]) calculatedLabelOffsets[currentImageLabel] = {};
                        calculatedLabelOffsets[currentImageLabel][strokeLabel] = offset; // Store relative offset
                        // console.log(`    Calculated and stored offset for ${strokeLabel}:`, offset);
                    }

                    // Store the final calculated position rect for overlap checks in *this* redraw cycle
                    const finalLabelRect = { ...initialLabelRect, x: finalPosition.x, y: finalPosition.y };
                    currentLabelPositions.push(finalLabelRect);

                    // Draw label background
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(finalLabelRect.x, finalLabelRect.y, finalLabelRect.width, finalLabelRect.height);

                    // Draw label border
                    ctx.strokeStyle = labelColor;
                    ctx.lineWidth = 1; // Keep border thin
                    ctx.strokeRect(finalLabelRect.x, finalLabelRect.y, finalLabelRect.width, finalLabelRect.height);

                    // Draw label text
                    ctx.fillStyle = labelColor;
                    const textX = finalLabelRect.x + finalLabelRect.width / 2;
                    const textY = finalLabelRect.y + finalLabelRect.height - padding; // Adjust baseline using scaled padding
                    ctx.fillText(labelText, textX, textY);

                    // Optionally draw connector line (from label edge to anchor point)
                    if (typeof drawLabelConnector === 'function') {
                        try {
                            drawLabelConnector(finalLabelRect, anchorPointCanvas, labelColor);
                        } catch(err) {
                            console.error(`      Error in drawLabelConnector for ${strokeLabel}:`, err);
                        }
                    }
                }
            }); // End of label drawing loop
            // --- End of Label Drawing Logic ---

            // Save the now-combined state (only if not loading, to prevent infinite loops)
            if (!window.isLoadingProject) {
                const newState = getCanvasState();
                imageStates[currentImageLabel] = cloneImageData(newState);
                 // console.log(`[Redraw] Saved final canvas state for ${currentImageLabel}`); // Optional: Debug state saving
            } else {
                 // console.log("[Redraw] Skipping final state save because isLoadingProject is true.");
            }
            ctx.restore(); // *** Restore the original context state (including transform) ***
            console.log("Redraw End Transform:", ctx.getTransform());
        }
    }

    function cloneImageData(imageData) {
        return new ImageData(
            new Uint8ClampedArray(imageData.data),
            imageData.width,
            imageData.height
        );
    }

    function saveState(force = false, incrementLabel = true, updateStrokeList = true) {
        // *** ADDED LOG ***
        console.log(`[Save State Called] force=${force}, incrementLabel=${incrementLabel}, updateStrokeList=${updateStrokeList}, isDrawingOrPasting=${isDrawingOrPasting}, strokeInProgress=${strokeInProgress}`);

        // Get current state
        const currentState = getCanvasState();

        // Initialize if first save for this image
        if (!imageStates[currentImageLabel]) {
            imageStates[currentImageLabel] = cloneImageData(currentState);
            undoStackByImage[currentImageLabel].push({
                state: cloneImageData(currentState),
                type: 'initial',
                label: null
            });
            updateStrokeCounter();
            return;
        }

        // Only save if we're not in the middle of a stroke or if forced
        if (!force && strokeInProgress) return;

        // Don't save if it's identical to the last state
        const lastState = imageStates[currentImageLabel];
        if (lastState && !force) {
            const currentData = currentState.data;
            const lastData = lastState.data;
            let identical = true;
            for (let i = 0; i < currentData.length; i += 4) {
                if (currentData[i] !== lastData[i] ||
                    currentData[i + 1] !== lastData[i + 1] ||
                    currentData[i + 2] !== lastData[i + 2] ||
                    currentData[i + 3] !== lastData[i + 3]) {
                    identical = false;
                    break;
                }
            }
            if (identical) return;
        }

        // For line strokes, assign the next label before saving
        let strokeLabel = null;
        if (!isDrawingOrPasting && !strokeInProgress && incrementLabel && updateStrokeList) {
            // *** ADDED DETAILED LOGS ***
            console.log(`[Save State] Entering stroke update block.`);
            
            // Get the suggested next label
            const suggestedLabel = window.labelsByImage[currentImageLabel];
            console.log(`[Save State] Suggested next label = "${suggestedLabel}" from labelsByImage[${currentImageLabel}]`);
            
            // *** FIX: Ensure the new stroke gets a UNIQUE label ***
            strokeLabel = generateUniqueStrokeName(suggestedLabel);
            console.log(`[Save State] Assigned UNIQUE strokeLabel = "${strokeLabel}"`);
            
            // Always increment the label counter based on the original suggested label for the next stroke
            const nextLabel = getNextLabel(currentImageLabel); // Uses the value in labelsByImage
            window.labelsByImage[currentImageLabel] = nextLabel;
            console.log(`[Save State] Incremented labelsByImage[${currentImageLabel}] to "${nextLabel}"`);
            
            // Only add the *unique* stroke label to the strokes list
            if (!window.lineStrokesByImage[currentImageLabel]) {
                console.log(`[Save State] Initializing lineStrokesByImage[${currentImageLabel}] as []`);
                window.lineStrokesByImage[currentImageLabel] = []; // Initialize if it doesn't exist
            }
            
            // Check if unique stroke label already exists before pushing (shouldn't happen with generateUniqueStrokeName)
            const labelAlreadyExists = window.lineStrokesByImage[currentImageLabel].includes(strokeLabel);
            
            console.log(`[Save State] BEFORE push: lineStrokesByImage[${currentImageLabel}] =`, JSON.parse(JSON.stringify(window.lineStrokesByImage[currentImageLabel])));
            
            if (!labelAlreadyExists && updateStrokeList) {
                window.lineStrokesByImage[currentImageLabel].push(strokeLabel); // Push the unique label
                console.log(`[Save State] AFTER push: lineStrokesByImage[${currentImageLabel}] =`, JSON.parse(JSON.stringify(window.lineStrokesByImage[currentImageLabel])));
            } else {
                // This case should ideally not be reached if generateUniqueStrokeName works correctly
                console.warn(`[Save State] Generated unique stroke label "${strokeLabel}" already exists? Not pushing again.`);
            }
            
            // Initialize visibility, data etc. using the unique strokeLabel
            window.strokeVisibilityByImage[currentImageLabel] = window.strokeVisibilityByImage[currentImageLabel] || {};
            window.strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            
            window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
            window.strokeLabelVisibility[currentImageLabel][strokeLabel] = true;
            
            strokeDataByImage[currentImageLabel] = strokeDataByImage[currentImageLabel] || {};
            strokeDataByImage[currentImageLabel][strokeLabel] = {
                preState: currentStroke ? cloneImageData(currentStroke) : null,
                postState: cloneImageData(currentState)
            };
        }

        // --- FIX: Handle temporary vector data --- 
        const tempStrokeKey = '_drawingStroke';
        let drawnVectorData = null;
        
        // Debug the state of vectorStrokesByImage before handling temporary data
        console.log(`[Save State] Vector strokes for ${currentImageLabel} before processing:`, 
            window.vectorStrokesByImage[currentImageLabel] ? 
            Object.keys(window.vectorStrokesByImage[currentImageLabel]) : "none");
            
        // Detailed check for _drawingStroke
        if (window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
            console.log(`[Save State] Found _drawingStroke data with ${window.vectorStrokesByImage[currentImageLabel][tempStrokeKey].points.length} points`);
        } else {
            console.log(`[Save State] No _drawingStroke data found:`, 
                window.vectorStrokesByImage[currentImageLabel] ? 
                "vectorStrokesByImage exists for label but no _drawingStroke key" : 
                "vectorStrokesByImage doesn't exist for this label");
        }
        
        if (strokeLabel && window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
            drawnVectorData = JSON.parse(JSON.stringify(window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]));
            // Assign the drawn data to the final unique stroke label
            window.vectorStrokesByImage[currentImageLabel][strokeLabel] = drawnVectorData;
            // Remove the temporary data
            delete window.vectorStrokesByImage[currentImageLabel][tempStrokeKey];
            console.log(`[Save State] Moved vector data from ${tempStrokeKey} to ${strokeLabel}`);
        } else if (strokeLabel) {
            console.warn(`[Save State] No temporary vector data found at ${tempStrokeKey} for stroke ${strokeLabel}`);
            // Attempt to find vector data if it somehow got assigned to the suggested label during draw (fallback)
            const suggestedLabel = window.labelsByImage[currentImageLabel]; // Get the label *before* incrementing
             if (window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][suggestedLabel]) {
                console.log(`[Save State] Fallback: Found data under suggested label ${suggestedLabel}`);
                drawnVectorData = JSON.parse(JSON.stringify(window.vectorStrokesByImage[currentImageLabel][suggestedLabel]));
                window.vectorStrokesByImage[currentImageLabel][strokeLabel] = drawnVectorData;
                // Optionally delete the data under suggestedLabel if it shouldn't be there
                // delete window.vectorStrokesByImage[currentImageLabel][suggestedLabel]; 
            }
        }
        // --- END FIX ---

        // Save new state and add to undo stack
        imageStates[currentImageLabel] = cloneImageData(currentState);
        
        // Determine the type of stroke
        let strokeType = 'other';
        if (force && strokeLabel) {
            strokeType = 'stroke';
            
            // Check for vector data to determine if it's a freehand or straight line
            // Use the vector data we just potentially moved
            if (drawnVectorData) { 
                if (drawnVectorData.type === 'straight') {
                    strokeType = 'line';
                } else if (drawnVectorData.type === 'freehand') {
                    strokeType = 'stroke';
                }
            }
        }
        
        // Add to undo stack with stroke info
        const undoAction = {
            state: cloneImageData(currentState),
            type: strokeType,
            label: strokeLabel, // Use the unique label
            color: colorPicker.value, 
            width: parseInt(brushSize.value) 
        };
        
        // Store vector data with the undo action if available
        // Use the data retrieved from the temporary key
        if (drawnVectorData) {
            undoAction.vectorData = drawnVectorData; 
        }
        
        undoStackByImage[currentImageLabel].push(undoAction);
        
        // Remove oldest state if we've reached max history
        if (undoStackByImage[currentImageLabel].length >= MAX_HISTORY) {
            undoStackByImage[currentImageLabel].shift();
        }

        // Clear redo stack when a new action is performed
        redoStackByImage[currentImageLabel] = [];

        updateStrokeCounter();
        updateSidebarStrokeCounts();
    }

    function undo() {
        console.log(`Attempting to undo in ${currentImageLabel} workspace`);
        console.log(`Current undo stack: ${undoStackByImage[currentImageLabel]?.length || 0} items`);
        console.log(`Current strokes: ${lineStrokesByImage[currentImageLabel]?.join(', ') || 'none'}`);
        
        const currentStack = undoStackByImage[currentImageLabel];
        if (currentStack && currentStack.length > 1) { // Keep at least one state (initial)
            // Get the state we're undoing from
            const lastAction = currentStack.pop();
            console.log(`Undoing action of type: ${lastAction.type}, label: ${lastAction.label || 'none'}`);
            
            // Add to redo stack
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[currentImageLabel].push(lastAction);
            console.log(`Added to redo stack, now has ${redoStackByImage[currentImageLabel].length} items`);
            
            // Skip certain state types when undoing
            if (lastAction.type === 'pre-stroke') {
                console.log('Skipping pre-stroke state');
                // If we encounter a pre-stroke state, undo again to get to the previous complete state
                if (currentStack.length > 1) {
                    return undo();
                }
            }
            
            // Handle snapshot type (created when switching views)
            if (lastAction.type === 'snapshot') {
                console.log('Restoring from snapshot state');
                // If we have stored strokes in the snapshot, restore them
                if (lastAction.strokes) {
                    lineStrokesByImage[currentImageLabel] = [...(lastAction.strokes || [])];
                    console.log(`Restored strokes: ${lineStrokesByImage[currentImageLabel].join(', ')}`);
                }
                
                // Continue to next undo action if possible
                if (currentStack.length > 1) {
                    return undo();
                }
            }
            
            // Get the state we're going back to
            const previousState = currentStack[currentStack.length - 1];
            
            if (lastAction.type === 'line' || lastAction.type === 'stroke') {
                // Remove the last stroke and its label
                if (lineStrokesByImage[currentImageLabel] && lineStrokesByImage[currentImageLabel].length > 0) {
                    const removedStroke = lineStrokesByImage[currentImageLabel].pop();
                    console.log(`Removed stroke: ${removedStroke}`);
                    
                    // Also remove from visibility tracking
                    if (strokeVisibilityByImage[currentImageLabel] && strokeVisibilityByImage[currentImageLabel][removedStroke]) {
                        delete strokeVisibilityByImage[currentImageLabel][removedStroke];
                    }
                    
                    // Also remove from label visibility tracking
                    if (strokeLabelVisibility[currentImageLabel] && strokeLabelVisibility[currentImageLabel][removedStroke]) {
                        // Save label visibility in lastAction for possible redo
                        lastAction.labelVisible = strokeLabelVisibility[currentImageLabel][removedStroke];
                        delete strokeLabelVisibility[currentImageLabel][removedStroke];
                    }
                    
                    // Also remove from stroke data tracking
                    if (strokeDataByImage[currentImageLabel] && strokeDataByImage[currentImageLabel][removedStroke]) {
                        delete strokeDataByImage[currentImageLabel][removedStroke];
                    }
                    
                    // Remove vector stroke data
                    if (vectorStrokesByImage[currentImageLabel] && vectorStrokesByImage[currentImageLabel][removedStroke]) {
                        // Save vector data in lastAction for possible redo
                        lastAction.vectorData = vectorStrokesByImage[currentImageLabel][removedStroke];
                        delete vectorStrokesByImage[currentImageLabel][removedStroke];
                }
                
                    // If this was the last stroke, reset to A1
                    if (lineStrokesByImage[currentImageLabel].length === 0) {
                        labelsByImage[currentImageLabel] = 'A1';
                        console.log(`All strokes undone, reset label counter to A1`);
                    } else {
                // Set the next label to be the one we just removed
                if (lastAction.label) {
                    labelsByImage[currentImageLabel] = lastAction.label;
                    console.log(`Reset label counter to: ${lastAction.label}`);
                        }
                    }
                }
            }
            
            // Ensure we have a valid previous state
            if (previousState && previousState.state) {
                // Restore the canvas state
                const stateToRestore = cloneImageData(previousState.state);
                imageStates[currentImageLabel] = stateToRestore;
                restoreCanvasState(stateToRestore);
                currentStroke = cloneImageData(stateToRestore);
                console.log('Canvas state restored');
            } else {
                console.log('Warning: No valid previous state found');
                // Create a blank state if needed
                const blankState = ctx.createImageData(canvas.width, canvas.height);
                imageStates[currentImageLabel] = blankState;
                restoreCanvasState(blankState);
                currentStroke = cloneImageData(blankState);
            }
            
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
        } else if (currentStack && currentStack.length === 1) {
            // We're at the initial state
            console.log('At initial state, resetting workspace');
            const initialState = currentStack[0];
            
            // Clear all stroke data
            lineStrokesByImage[currentImageLabel] = [];
            strokeVisibilityByImage[currentImageLabel] = {};
            strokeLabelVisibility[currentImageLabel] = {};
            vectorStrokesByImage[currentImageLabel] = {};
            strokeDataByImage[currentImageLabel] = {};
            
            // Reset label counter
            labelsByImage[currentImageLabel] = 'A1';  // Reset to A1
            
            if (initialState && initialState.state) {
                imageStates[currentImageLabel] = cloneImageData(initialState.state);
                restoreCanvasState(initialState.state);
                currentStroke = cloneImageData(initialState.state);
            } else if (window.originalImages[currentImageLabel]) {
                // If we have the original image, redraw it
                console.log('Redrawing from original image');
                const img = new Image();
                img.onload = () => {
                    // Clear the canvas first
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the current scale
                    const scale = window.imageScaleByLabel[currentImageLabel];
                    const scaledWidth = img.width * scale;
                    const scaledHeight = img.height * scale;
                    
                    // Calculate base position (center of canvas)
                    const centerX = (canvas.width - scaledWidth) / 2;
                    const centerY = (canvas.height - scaledHeight) / 2;
                    
                    // Apply position offset
                    const offsetX = window.imagePositionByLabel[currentImageLabel].x;
                    const offsetY = window.imagePositionByLabel[currentImageLabel].y;
                    
                    // Calculate final position
                    const x = centerX + offsetX;
                    const y = centerY + offsetY;
                    
                    // Draw the original image with scale and position
                    ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                    
                    // Save this as the new state
                    const newState = getCanvasState();
                    imageStates[currentImageLabel] = cloneImageData(newState);
                    currentStroke = cloneImageData(newState);
                };
                img.src = window.originalImages[currentImageLabel];
            }
            
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
        } else {
            console.log('No undo history available for this workspace');
        }
    }
    
    function redo() {
        console.log(`Attempting to redo in ${currentImageLabel} workspace`);
        console.log(`Current redo stack: ${redoStackByImage[currentImageLabel]?.length || 0} items`);
        
        const redoStack = redoStackByImage[currentImageLabel];
        if (redoStack && redoStack.length > 0) {
            // Get the action to redo
            const actionToRedo = redoStack.pop();
            console.log(`Redoing action of type: ${actionToRedo.type}, label: ${actionToRedo.label || 'none'}`);
            
            // Add back to undo stack
            undoStackByImage[currentImageLabel].push(actionToRedo);
            
            // Handle stroke type actions (both freehand strokes and straight lines)
            if ((actionToRedo.type === 'line' || actionToRedo.type === 'stroke') && actionToRedo.label) {
                // Add the stroke back to the list
                window.lineStrokesByImage[currentImageLabel] = window.lineStrokesByImage[currentImageLabel] || [];
                window.lineStrokesByImage[currentImageLabel].push(actionToRedo.label);
                console.log(`Added stroke back: ${actionToRedo.label}`);
                
                // Restore stroke visibility
                window.strokeVisibilityByImage[currentImageLabel] = window.strokeVisibilityByImage[currentImageLabel] || {};
                window.strokeVisibilityByImage[currentImageLabel][actionToRedo.label] = true;
                
                // Restore stroke data if we have it
                if (actionToRedo.strokeData) {
                    strokeDataByImage[currentImageLabel] = strokeDataByImage[currentImageLabel] || {};
                    strokeDataByImage[currentImageLabel][actionToRedo.label] = actionToRedo.strokeData;
                }
                
                // Restore vector data if we have it
                if (actionToRedo.vectorData) {
                    window.vectorStrokesByImage[currentImageLabel] = window.vectorStrokesByImage[currentImageLabel] || {};
                    window.vectorStrokesByImage[currentImageLabel][actionToRedo.label] = actionToRedo.vectorData;
                    
                    // If no vector data saved in the action, but we're redoing a line/stroke,
                    // try to recreate basic vector data to ensure label display
                    if (!actionToRedo.vectorData && 
                        (actionToRedo.type === 'line' || actionToRedo.type === 'stroke')) {
                        // Create minimal vector data to ensure label display
                        window.vectorStrokesByImage[currentImageLabel][actionToRedo.label] = {
                            points: [
                                { x: canvas.width/2 - 50, y: canvas.height/2 }, // Dummy points
                                { x: canvas.width/2 + 50, y: canvas.height/2 }
                            ],
                            color: actionToRedo.color || "#000000",
                            width: 5,
                            type: actionToRedo.type === 'line' ? 'straight' : 'freehand'
                        };
                    }
                }
                
                // Restore label visibility if we have it
                if (actionToRedo.labelVisible !== undefined) {
                    window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
                    window.strokeLabelVisibility[currentImageLabel][actionToRedo.label] = actionToRedo.labelVisible;
                } else {
                    // Default to visible for new strokes and redone strokes without saved value
                    window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
                    window.strokeLabelVisibility[currentImageLabel][actionToRedo.label] = true;
                }
                
                // Update the next label - make sure it's one higher than the redone label
                const numPart = parseInt(actionToRedo.label.slice(1));
                if (!isNaN(numPart)) {
                    const letterPart = actionToRedo.label[0];
                    const nextNum = numPart + 1;
                    const nextLabel = nextNum > 9 
                        ? String.fromCharCode(letterPart.charCodeAt(0) + 1) + '0' 
                        : letterPart + nextNum;
                    window.labelsByImage[currentImageLabel] = nextLabel;
                    console.log(`Set next label to: ${nextLabel}`);
                } else {
                    // Fallback to the standard next label function
                window.labelsByImage[currentImageLabel] = getNextLabel(currentImageLabel);
                console.log(`Set next label to: ${window.labelsByImage[currentImageLabel]}`);
                }
            }
            
            // Restore the state
            if (actionToRedo.state) {
                const stateToRestore = cloneImageData(actionToRedo.state);
                imageStates[currentImageLabel] = stateToRestore;
                restoreCanvasState(stateToRestore);
                currentStroke = cloneImageData(stateToRestore);
                console.log('Canvas state restored for redo');
            }
            
            // Update all UI elements
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
            
            // Force redraw with visibility to ensure labels appear immediately
            redrawCanvasWithVisibility();
        } else {
            console.log('No redo actions available for this workspace');
        }
    }

    // Save initial blank state
//    saveState();

    // Set canvas size
    function resizeCanvas() {
        // Account for the sidebars and gaps in our calculation (approximately 420px for sidebars + gaps)
        const sidebarSpace = 440;
        const maxWidth = Math.min(window.innerWidth - sidebarSpace, 1000);  // Cap at 1000px width
        const maxHeight = Math.min(window.innerHeight - 100, 800);  // Cap at 800px height
        
        // Save current state before resizing
        const oldState = imageStates[currentImageLabel];
        
        // Resize the canvas
        canvas.width = maxWidth;
        canvas.height = maxHeight;
        
        // Set default canvas styles
        canvas.style.cursor = 'crosshair';
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Restore the image after resize
        if (oldState) {
            // Try to restore from saved state first
            try {
                restoreCanvasState(oldState);
                currentStroke = cloneImageData(oldState);
            } catch (e) {
                // If that fails, redraw from original image
                if (window.originalImages[currentImageLabel]) {
                    const img = new Image();
                    img.onload = () => {
                        // Clear the canvas first
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Get the current scale
                        const scale = imageScaleByLabel[currentImageLabel];
                        const scaledWidth = img.width * scale;
                        const scaledHeight = img.height * scale;
                        
                        // Calculate base position (center of canvas)
                        const centerX = (canvas.width - scaledWidth) / 2;
                        const centerY = (canvas.height - scaledHeight) / 2;
                        
                        // Apply position offset
                        const offsetX = window.imagePositionByLabel[currentImageLabel].x;
                        const offsetY = window.imagePositionByLabel[currentImageLabel].y;
                        
                        // Calculate final position
                        const x = centerX + offsetX;
                        const y = centerY + offsetY;
                        
                        // Draw the original image with scale and position
                        ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                        
                        // Save this as the new state
                        const newState = getCanvasState();
                        imageStates[currentImageLabel] = cloneImageData(newState);
                        currentStroke = cloneImageData(newState);
                    };
                    img.src = window.originalImages[currentImageLabel];
                } else if (!currentStroke) {
                    // Initialize blank state if needed
                    currentStroke = getCanvasState();
                }
            }
        }
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Drawing state
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let points = [];
    let lastVelocity = 0;
    // --- ADD: Track last RAW coordinates ---
    let lastRawX = 0;
    let lastRawY = 0;
    // --- END ADD ---

    // Drawing mode state
    let drawingMode = 'freehand'; // Options: 'freehand', 'straight'
    let straightLineStart = null; // For straight line mode - start point
    let lastDrawnPoint = null;

    /**
     * Transforms raw canvas coordinates to account for image scaling and positioning
     * @param {number} x - Raw x-coordinate from mouse event
     * @param {number} y - Raw y-coordinate from mouse event
     * @returns {Object} Object with transformed x and y coordinates
     */
    function getTransformedCoords(x, y) {
        // Debug logging
        if (window.debugCoordinates) {
            console.log(`[getTransformedCoords] INPUT: Raw canvas coords (${x.toFixed(1)}, ${y.toFixed(1)})`);
        }
        
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
        const position = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 };
        
        // If we have no image dimensions yet (blank canvas), return raw coordinates
        if (!window.originalImageDimensions[currentImageLabel]) {
            if (window.debugCoordinates) {
                console.log(`[getTransformedCoords] No image dimensions - returning raw coords as relative`);
            }
            return { x, y };
        }
        
        // We do have an image, so need to calculate relative coordinates
        const origDims = window.originalImageDimensions[currentImageLabel];
        const scaledWidth = origDims.width * scale;
        const scaledHeight = origDims.height * scale;
        
        // Base position is canvas center minus half the scaled image size
        const imageBaseX = (canvas.width - scaledWidth) / 2;
        const imageBaseY = (canvas.height - scaledHeight) / 2;
        
        // Final image position includes any panning offset
        const finalImageX = imageBaseX + position.x;
        const finalImageY = imageBaseY + position.y;
        
        // Convert the raw canvas coordinates to coordinates relative to the image
        const relativeX = (x - finalImageX) / scale;
        const relativeY = (y - finalImageY) / scale;
        
        if (window.debugCoordinates) {
            console.log(`[getTransformedCoords] Canvas size: ${canvas.width} × ${canvas.height}`);
            console.log(`[getTransformedCoords] Image scale: ${scale}, position: ${JSON.stringify(position)}`);
            console.log(`[getTransformedCoords] Original dimensions: ${JSON.stringify(origDims)}`);
            console.log(`[getTransformedCoords] Scaled dimensions: ${scaledWidth} × ${scaledHeight}`);
            console.log(`[getTransformedCoords] Image position: base(${imageBaseX.toFixed(1)}, ${imageBaseY.toFixed(1)}) + offset => final(${finalImageX.toFixed(1)}, ${finalImageY.toFixed(1)})`);
            console.log(`[getTransformedCoords] OUTPUT: Relative coords (${relativeX.toFixed(1)}, ${relativeY.toFixed(1)})`);
        }
        
        return { x: relativeX, y: relativeY };
    }

    /**
     * Converts relative image coordinates back to canvas coordinates
     * (Inverse of getTransformedCoords)
     * @param {number} imageX_relative - x-coordinate relative to the image
     * @param {number} imageY_relative - y-coordinate relative to the image
     * @returns {Object} Object with canvas x and y coordinates
     */
    function getCanvasCoords(imageX_relative, imageY_relative) {
        // Debug logging
        if (window.debugCoordinates) {
            console.log(`[getCanvasCoords] INPUT: Relative coords (${imageX_relative.toFixed(1)}, ${imageY_relative.toFixed(1)})`);
        }
        
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
        const position = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 };
        
        // If we have no image dimensions yet (blank canvas), return relative coords as-is
        if (!window.originalImageDimensions[currentImageLabel]) {
            if (window.debugCoordinates) {
                console.log(`[getCanvasCoords] No image dimensions - returning relative coords as canvas coords`);
            }
            return { x: imageX_relative, y: imageY_relative };
        }
        
        // We do have an image, calculate canvas coordinates from relative coords
        const origDims = window.originalImageDimensions[currentImageLabel];
        const scaledWidth = origDims.width * scale;
        const scaledHeight = origDims.height * scale;
        
        // Base position is canvas center minus half the scaled image size
        const imageBaseX = (canvas.width - scaledWidth) / 2;
        const imageBaseY = (canvas.height - scaledHeight) / 2;
        
        // Final image position includes any panning offset
        const finalImageX = imageBaseX + position.x;
        const finalImageY = imageBaseY + position.y;
        
        // Calculate final canvas coordinates from image-relative coordinates
        const canvasX = finalImageX + (imageX_relative * scale);
        const canvasY = finalImageY + (imageY_relative * scale);
        
        if (window.debugCoordinates) {
            console.log(`[getCanvasCoords] Canvas size: ${canvas.width} × ${canvas.height}`);
            console.log(`[getCanvasCoords] Image scale: ${scale}, position: ${JSON.stringify(position)}`);
            console.log(`[getCanvasCoords] Original dimensions: ${JSON.stringify(origDims)}`);
            console.log(`[getCanvasCoords] Scaled dimensions: ${scaledWidth} × ${scaledHeight}`);
            console.log(`[getCanvasCoords] Image position: base(${imageBaseX.toFixed(1)}, ${imageBaseY.toFixed(1)}) + offset => final(${finalImageX.toFixed(1)}, ${finalImageY.toFixed(1)})`);
            console.log(`[getCanvasCoords] OUTPUT: Canvas coords (${canvasX.toFixed(1)}, ${canvasY.toFixed(1)})`);
        }
        
        return { x: canvasX, y: canvasY };
    }

    function draw(e) {
        if (!isDrawing) return;

        if (window.debugCoordinates) {
            console.log("--- Draw Event Start ---");
            console.log("[draw] Transform:", ctx.getTransform());
        }

        // Get precise coordinates relative to the canvas
        const rect = canvas.getBoundingClientRect();
        const rawX = e.clientX - rect.left;
        const rawY = e.clientY - rect.top;
        
        if (window.debugCoordinates) {
            console.log(`[draw] Raw mouse coords: (${rawX.toFixed(1)}, ${rawY.toFixed(1)})`);
        }

        // Get current scale for potential use
// Define global variables for use by project-manager.js
window.IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
window.currentImageLabel = 'front';
window.vectorStrokesByImage = {};
window.strokeVisibilityByImage = {};
window.strokeLabelVisibility = {};
window.strokeMeasurements = {};
window.imageScaleByLabel = {};
window.imagePositionByLabel = {};
window.lineStrokesByImage = {}; // Make sure it's exposed globally
window.labelsByImage = {};      // Make sure it's exposed globally
window.originalImages = {};
window.isLoadingProject = false; // <-- Re-adding this line

// At the top of the file, near other global variables
window.debugCoordinates = false; // Global flag to control coordinate debugging

document.addEventListener('DOMContentLoaded', () => {
    // Initialize unit selectors
    const unitSelector = document.getElementById('unitSelector');
    unitSelector.addEventListener('change', updateMeasurementDisplay);
    
    // Add debug toggle button to the controls
    const controlsContainer = document.querySelector('.controls-container');
    const debugToggle = document.createElement('button');
    debugToggle.textContent = '🐞 Debug';
    debugToggle.classList.add('debug-toggle');
    debugToggle.addEventListener('click', () => {
        window.debugCoordinates = !window.debugCoordinates;
        debugToggle.classList.toggle('active', window.debugCoordinates);
        console.log(`Coordinate debugging ${window.debugCoordinates ? 'enabled' : 'disabled'}`);
    });
    controlsContainer.appendChild(debugToggle);
    
    // Initialize the measurement inputs
    const inchWhole = document.getElementById('inchWhole');
    const inchFraction = document.getElementById('inchFraction');
    const cmValue = document.getElementById('cmValue');
    
    // Handle unit conversion when changing values
    inchWhole.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    inchFraction.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * 2.54).toFixed(1);
    });
    
    cmValue.addEventListener('change', () => {
        const cm = parseFloat(cmValue.value) || 0;
        const inches = cm / 2.54;
        
        // Update inch values
        inchWhole.value = Math.floor(inches);
        
        // Find closest fraction
        const fractionPart = inches - Math.floor(inches);
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        inchFraction.value = closestFraction;
        
        // Show inch inputs, hide cm inputs
        document.getElementById('inchInputs').style.display = 'flex';
        document.getElementById('cmInputs').style.display = 'none';
    });
    
    const canvas = document.getElementById('canvas');
    // Expose canvas globally for project management
    window.canvas = canvas;
    const ctx = canvas.getContext('2d', { willReadFrequently: true }); // Add willReadFrequently hint
    const colorPicker = document.getElementById('colorPicker');
    const brushSize = document.getElementById('brushSize');
    const clearButton = document.getElementById('clear');
    const saveButton = document.getElementById('save');
    const pasteButton = document.getElementById('paste');
    const strokeCounter = document.getElementById('strokeCounter');
    const imageList = document.getElementById('imageList');
    const drawingModeToggle = document.getElementById('drawingModeToggle');
    
    // Draggable sidebars
    const strokeSidebar = document.getElementById('strokeSidebar');
    const imageSidebar = document.getElementById('imageSidebar');
    const strokeSidebarHeader = document.getElementById('strokeSidebarHeader');
    const imageSidebarHeader = document.getElementById('imageSidebarHeader');

    // Undo/Redo functionality
    const MAX_HISTORY = 50;  // Maximum number of states to store
    const IMAGE_LABELS = ['front', 'side', 'back', 'cushion'];
    let currentImageIndex = 0;
    let imageStates = {}; // Store states for each image
    
    // Use the global variables instead of creating new ones
    let strokeDataByImage = {}; // Store additional data for each stroke
    let undoStackByImage = {}; // Separate undo stack for each image
    let redoStackByImage = {}; // Separate redo stack for each image
    let pastedImages = [];  // Store all pasted images
    let isDrawingOrPasting = false;  // Flag to prevent saving states while drawing
    let strokeInProgress = false;  // Track if we're in the middle of a stroke
    let currentStroke = null;  // Store the state before current stroke
    let originalImageDimensions = {}; // Store original image dimensions for scaling
    let isShiftPressed = false; // Track if Shift key is pressed for image movement
    let calculatedLabelOffsets = {}; // Store automatically calculated label offsets

    // Initialize states for default images
    IMAGE_LABELS.forEach(label => {
        // Ensure we initialize global arrays properly
        window.lineStrokesByImage[label] = [];
        window.strokeVisibilityByImage[label] = {}; // Initialize stroke visibility
        window.vectorStrokesByImage[label] = {}; // Initialize vector stroke data
        window.labelsByImage[label] = 'A1';  // Start from A1 instead of A0
        
        strokeDataByImage[label] = {}; // Initialize stroke data
        undoStackByImage[label] = [];
        redoStackByImage[label] = [];  // Initialize redo stack
        imageStates[label] = null;
        // Initialize scale to 100% (1.0)
        window.imageScaleByLabel[label] = 1.0;
        originalImageDimensions[label] = { width: 0, height: 0 };
        // Initialize position offset to center (0, 0)
        window.imagePositionByLabel[label] = { x: 0, y: 0 };
        // Initialize with a blank state when the image is first created
        const blankState = ctx.createImageData(canvas.width, canvas.height);
        imageStates[label] = blankState;
        undoStackByImage[label].push({
            state: cloneImageData(blankState),
            type: 'initial',
            label: null
        });
    });

    let currentImageLabel = IMAGE_LABELS[0]; // Start with 'front'

    // Make addImageToSidebar available globally for the project manager
    window.addImageToSidebar = addImageToSidebar;
    function addImageToSidebar(imageUrl, label) {
        // *** ADDED LOG ***
        console.log(`[addImageToSidebar] Called for label: ${label}, imageUrl: ${imageUrl ? imageUrl.substring(0,30) + '...' : 'null'}`);

        const container = document.createElement('div');
        container.className = 'image-container';
        container.dataset.label = label;
        container.dataset.originalImageUrl = imageUrl; // Store the original image URL for later restoration
        
        const labelElement = document.createElement('div');
        labelElement.className = 'image-label';
        labelElement.textContent = label.charAt(0).toUpperCase() + label.slice(1);
        
        const strokesElement = document.createElement('div');
        strokesElement.className = 'image-strokes';
        strokesElement.textContent = 'Strokes: 0';
        
        const scaleElement = document.createElement('div');
        scaleElement.className = 'image-scale';
        scaleElement.textContent = `Scale: ${Math.round(imageScaleByLabel[label] * 100)}%`;
        scaleElement.id = `scale-${label}`;
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.className = 'pasted-image';
        img.alt = `${label} view`;
        
        container.appendChild(img);
        container.appendChild(labelElement);
        container.appendChild(strokesElement);
        container.appendChild(scaleElement);
        
        container.onclick = () => {
            // ... rest of the handler
            
            console.log(`Switching from ${currentImageLabel} to ${label}`);
            
            // Ensure we have undo stacks for both workspaces
            undoStackByImage[currentImageLabel] = undoStackByImage[currentImageLabel] || [];
            undoStackByImage[label] = undoStackByImage[label] || [];
            
            // Ensure we have redo stacks for both workspaces
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[label] = redoStackByImage[label] || [];
            
            // Ensure we have stroke lists for both workspaces
            lineStrokesByImage[currentImageLabel] = lineStrokesByImage[currentImageLabel] || [];
            lineStrokesByImage[label] = lineStrokesByImage[label] || [];
            
            // Ensure we have stroke visibility for both workspaces
            strokeVisibilityByImage[currentImageLabel] = strokeVisibilityByImage[currentImageLabel] || {};
            strokeVisibilityByImage[label] = strokeVisibilityByImage[label] || {};
            
            // Save current state before switching
            saveState(true, false);
            
            // Switch to the new image
            switchToImage(label);
        };
        
        // *** ADDED LOGS ***
        const imageListElement = document.getElementById('imageList');
        if (!imageListElement) {
            console.error('[addImageToSidebar] Cannot find #imageList element!');
            return; // Stop if the target doesn't exist
        }
        console.log(`[addImageToSidebar] About to append container for ${label} to #imageList.`);
        imageListElement.appendChild(container);
        console.log(`[addImageToSidebar] Successfully appended container for ${label}. #imageList children: ${imageListElement.childElementCount}`);
    }
    

    // Store the original images for each view
    window.originalImages = window.originalImages || {};
    
    // --- MODIFIED Function Signature and Logic --- 
    function pasteImageFromUrl(url, label) {
        // Wrap in a Promise
        return new Promise((resolve, reject) => {
            console.log(`[pasteImageFromUrl] Pasting image for ${label}: ${url.substring(0, 30)}...`);
        
        const img = new Image();
        img.onload = () => {
            // Store the original image for this view
                window.originalImages[label] = url;
                
                // Ensure the object exists before setting properties
                if (!window.originalImageDimensions) {
                    window.originalImageDimensions = {};
                }
            
            // Store original dimensions for scaling
                window.originalImageDimensions[label] = {
                width: img.width,
                height: img.height
            };
                
                // Log dimensions for debugging
                console.log(`[pasteImageFromUrl] Stored dimensions for ${label}: ${img.width}x${img.height}`);
            
            // Clear the canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply current scale factor
                const scale = imageScaleByLabel[label] || 1.0; // Use passed-in label
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of the canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
                const position = imagePositionByLabel[label] || { x: 0, y: 0 }; // Use passed-in label
                const offsetX = position.x;
                const offsetY = position.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;
            
            // Draw the image with scaling and positioning
                console.log(`[pasteImageFromUrl] Drawing image for ${label} at Canvas(${x.toFixed(1)}, ${y.toFixed(1)}) Scale: ${scale * 100}%`);
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Update the scale display in the sidebar
                const scaleElement = document.getElementById(`scale-${label}`);
            if (scaleElement) {
                scaleElement.textContent = `Scale: ${Math.round(scale * 100)}%`;
            }
            
            // Save this as the base state for this image
            const newState = getCanvasState();
                imageStates[label] = cloneImageData(newState); // Use passed-in label
                console.log(`[pasteImageFromUrl] State saved into imageStates[${label}]`);
                
                // If this is the currently active label, update currentStroke
                if (label === currentImageLabel) {
            currentStroke = cloneImageData(newState);
                }
            
                // Initialize the undo stack if needed
                if (!undoStackByImage[label] || undoStackByImage[label].length === 0) {
                    undoStackByImage[label] = [{
                state: cloneImageData(newState),
                type: 'initial',
                label: null
            }];
                    console.log(`[pasteImageFromUrl] Initialized undo stack for ${label}`);
                }
            
                // Update the scale buttons to show active state if this is the current view
                if (label === currentImageLabel) {
            updateScaleButtonsActiveState();
                }
                
                console.log(`[pasteImageFromUrl] Image loaded and state saved for ${label}`);
                resolve(); // Resolve the promise
            };
            
            img.onerror = (err) => {
                console.error(`[pasteImageFromUrl] Error loading image for ${label}:`, err);
                reject(err); // Reject the promise on error
            };
            
        img.src = url;
        });
    }
    // --- END MODIFIED Function ---

    function getNextLabel(imageLabel) {
        const currentLabel = labelsByImage[imageLabel];
        const letter = currentLabel[0];
        const number = parseInt(currentLabel.slice(1)) + 1;
        if (number > 9) {
            return String.fromCharCode(letter.charCodeAt(0) + 1) + '0';
        }
        return letter + number;
    }

    // Make updateStrokeCounter available globally
    window.updateStrokeCounter = updateStrokeCounter;
    function updateStrokeCounter() {
        const strokeCount = lineStrokesByImage[currentImageLabel]?.length || 0;
        strokeCounter.textContent = `Lines: ${strokeCount}`;
        
        // Update visibility controls
        updateStrokeVisibilityControls();
    }
    
    function updateSidebarStrokeCounts() {
        // Update stroke counts in the sidebar
        const imageContainers = document.querySelectorAll('.image-container');
        imageContainers.forEach(container => {
            const label = container.dataset.label;
            if (label) {
                const strokesElement = container.querySelector('.image-strokes');
                if (strokesElement) {
                    const strokes = lineStrokesByImage[label] || [];
                    strokesElement.textContent = `Strokes: ${strokes.length}`;
                }
            }
        });
        
        // Also update visibility controls when sidebar is updated
        updateStrokeVisibilityControls();
    }

    function getCanvasState() {
        return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    function restoreCanvasState(state) {
        if (!state) return;
        ctx.putImageData(state, 0, 0);
    }
    
    // Measurement data for strokes
    let strokeMeasurements = {};
    
    // Initialize measurement data store
    IMAGE_LABELS.forEach(label => {
        strokeMeasurements[label] = {};
    });
    
    // Function to get formatted measurement string
    function getMeasurementString(strokeLabel) {
        const measurement = strokeMeasurements[currentImageLabel]?.[strokeLabel];
        if (!measurement) return '';
        
        const unit = document.getElementById('unitSelector').value;
        
        if (unit === 'inch') {
            const whole = measurement.inchWhole || 0;
            const fraction = measurement.inchFraction || 0;
            
            // Format as 1 1/4" etc.
            let fractionStr = '';
            if (fraction > 0) {
                const fractionMap = {
                    0.125: '1/8',
                    0.25: '1/4',
                    0.375: '3/8',
                    0.5: '1/2',
                    0.625: '5/8',
                    0.75: '3/4',
                    0.875: '7/8'
                };
                fractionStr = ' ' + fractionMap[fraction];
            }
            
            return `${whole}${fractionStr}"`;
        } else {
            // CM with one decimal
            return `${measurement.cm.toFixed(1)} cm`;
        }
    }
    
    // Function to convert between units
    function convertUnits(from, value) {
        if (from === 'inch') {
            // Convert inch to cm
            return value * 2.54;
        } else {
            // Convert cm to inch
            return value / 2.54;
        }
    }
    
    // Function to update all measurements when unit changes
    function updateMeasurementDisplay() {
        const unit = document.getElementById('unitSelector').value;
        const inchWhole = document.getElementById('inchWhole');
        const inchFraction = document.getElementById('inchFraction');
        const cmValue = document.getElementById('cmValue');
        
        // Convert values when switching between units
        if (unit === 'inch') {
            // Converting from cm to inches
            const cm = parseFloat(cmValue.value) || 0;
            const inches = cm / 2.54;
            
            // Update inch values
            inchWhole.value = Math.floor(inches);
            
            // Find closest fraction
            const fractionPart = inches - Math.floor(inches);
            const fractions = [
                {value: '0', text: '0'},
                {value: '0.125', text: '1/8'},
                {value: '0.25', text: '1/4'},
                {value: '0.375', text: '3/8'},
                {value: '0.5', text: '1/2'},
                {value: '0.625', text: '5/8'},
                {value: '0.75', text: '3/4'},
                {value: '0.875', text: '7/8'}
            ];
            
            fractions.forEach(f => {
                const option = document.createElement('option');
                option.value = f.value;
                option.textContent = f.text;
                if (parseFloat(f.value) === fractionPart) {
                    option.selected = true;
                }
                inchFraction.appendChild(option);
            });
            
            // Show inch inputs, hide cm inputs
            document.getElementById('inchInputs').style.display = 'flex';
            document.getElementById('cmInputs').style.display = 'none';
        } else {
            // Converting from inches to cm
            const whole = parseInt(inchWhole.value) || 0;
            const fraction = parseFloat(inchFraction.value) || 0;
            const totalInches = whole + fraction;
            
            // Update cm value with one decimal point
            cmValue.value = (totalInches * 2.54).toFixed(1);
            
            // Show cm inputs, hide inch inputs
            document.getElementById('inchInputs').style.display = 'none';
            document.getElementById('cmInputs').style.display = 'flex';
        }
        
        // Update the stroke visibility display to show new units
        updateStrokeVisibilityControls();
        
        // Redraw the canvas with updated measurement format in labels
        redrawCanvasWithVisibility();
    }

    // Function to update stroke visibility controls
    // Make updateStrokeVisibilityControls available globally
    window.updateStrokeVisibilityControls = updateStrokeVisibilityControls;
    function updateStrokeVisibilityControls() {
        const controlsContainer = document.getElementById('strokeVisibilityControls');
        controlsContainer.innerHTML = ''; // Clear existing controls
        
        // Add a separator at the top
        const topSeparator = document.createElement('hr');
        controlsContainer.appendChild(topSeparator);
        
        // Display current unit
        const unitDisplay = document.createElement('div');
        unitDisplay.className = 'current-unit-display';
        unitDisplay.textContent = `Current Unit: ${document.getElementById('unitSelector').value === 'inch' ? 'Inches' : 'Centimeters'}`;
        controlsContainer.appendChild(unitDisplay);
        
        // Add another separator
        const separator = document.createElement('hr');
        controlsContainer.appendChild(separator);
        
        // Create strokes list
        const strokesList = document.createElement('div');
        strokesList.id = 'strokesList';
        controlsContainer.appendChild(strokesList);
        
        // Get strokes for current image
        const strokes = lineStrokesByImage[currentImageLabel] || [];
        
        if (strokes.length === 0) {
            strokesList.innerHTML = '<p>No strokes to display</p>';
            return;
        }
        
        // Current unit
        const unit = document.getElementById('unitSelector').value;
        
        // Create visibility toggle for each stroke
        strokes.forEach(strokeLabel => {
            // Initialize visibility if not set
            if (strokeVisibilityByImage[currentImageLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel] = {};
            }
            if (strokeVisibilityByImage[currentImageLabel][strokeLabel] === undefined) {
                strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            }
            
            // Initialize label visibility if not set
            if (strokeLabelVisibility[currentImageLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel] = {};
            }
            if (strokeLabelVisibility[currentImageLabel][strokeLabel] === undefined) {
                strokeLabelVisibility[currentImageLabel][strokeLabel] = true; // Labels visible by default
            }
            
            // Initialize measurement if not set
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            if (strokeMeasurements[currentImageLabel][strokeLabel] === undefined) {
                strokeMeasurements[currentImageLabel][strokeLabel] = {
                    inchWhole: 0,
                    inchFraction: 0,
                    cm: 0.0
                };
            }
            
            const isVisible = strokeVisibilityByImage[currentImageLabel][strokeLabel];
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            const measurement = getMeasurementString(strokeLabel);
            const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
            
            const item = document.createElement('div');
            item.className = 'stroke-visibility-item';
            item.dataset.stroke = strokeLabel;
            item.dataset.selected = isSelected ? 'true' : 'false';
            
            // Make all parts of the item selectable (except checkbox and buttons)
            item.addEventListener('click', (e) => {
                // Don't trigger selection if clicking a button or checkbox
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
                    return;
                }
                
                // Toggle selection (if already selected, deselect it)
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                
                // Update the measurement input with the selected stroke's measurement
                    if (typeof updateMeasurementInputWithStroke === 'function') {
                    updateMeasurementInputWithStroke(strokeLabel);
                }
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `visibility-${strokeLabel}`;
            checkbox.checked = isVisible;
            checkbox.addEventListener('change', () => toggleStrokeVisibility(strokeLabel, checkbox.checked));
            
            const labelContainer = document.createElement('div');
            labelContainer.className = 'stroke-label-container';
            
            // Find the stroke color from the undo stack or vector data
            let strokeColor = '#000';
            let strokeType = 'freehand'; // Default type
            
            if (vectorStrokesByImage[currentImageLabel] && 
                vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                const vectorData = vectorStrokesByImage[currentImageLabel][strokeLabel];
                strokeColor = vectorData.color || '#000';
                strokeType = vectorData.type || 'freehand';
            } else {
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel && action.color) {
                        strokeColor = action.color;
                        // Try to determine stroke type from action
                        if (action.type === 'line') {
                            strokeType = 'straight';
                        }
                        break;
                    }
                }
            }
            
            // Create the stroke name element with color matching the stroke
            const strokeName = document.createElement('span');
            strokeName.className = 'stroke-name';
            strokeName.textContent = strokeLabel;
            strokeName.style.borderColor = strokeColor;
            strokeName.style.color = strokeColor;
            
            // Add a small icon to indicate stroke type (optional)
            if (strokeType === 'straight') {
                strokeName.title = 'Straight Line';
            } else {
                strokeName.title = 'Freehand Stroke';
            }
            
            // Make stroke name label clickable for selection as well
            strokeName.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent double handling with the item click
                
                // Toggle selection 
                const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                
                // Clear previous selection from UI
                document.querySelectorAll('.stroke-visibility-item').forEach(el => {
                    el.dataset.selected = 'false';
                });
                
                if (isCurrentlySelected) {
                    // Deselect if already selected
                    selectedStrokeByImage[currentImageLabel] = null;
                    item.dataset.selected = 'false';
                } else {
                    // Select if not already selected
                    selectedStrokeByImage[currentImageLabel] = strokeLabel;
                    item.dataset.selected = 'true';
                }
                
                // Make sure stroke is visible when selected
                if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                    // Ensure the stroke is visible when selected
                    strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
                    checkbox.checked = true;
                }
                
                // Redraw the canvas to show the selected stroke with glow effect
                redrawCanvasWithVisibility();
            });
            
            // Create measurement text
            const measureText = document.createElement('span');
            measureText.className = 'stroke-measurement';
            measureText.textContent = measurement ? `= ${measurement}` : '';
            
            // Create edit button
            const editBtn = document.createElement('button');
            editBtn.className = 'stroke-edit-btn';
            editBtn.innerHTML = '✏️';
            editBtn.title = 'Edit Stroke';
            editBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                showEditDialog(strokeLabel);
            };
            
            // Create label toggle button
            const labelToggleBtn = document.createElement('button');
            labelToggleBtn.className = 'stroke-label-toggle';
            labelToggleBtn.classList.toggle('active', isLabelVisible);
            labelToggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            labelToggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            labelToggleBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering the item's click event
                toggleLabelVisibility(strokeLabel);
            };
            
            // Add elements to container
            labelContainer.appendChild(strokeName);
            labelContainer.appendChild(measureText);
            labelContainer.appendChild(labelToggleBtn);
            labelContainer.appendChild(editBtn);
            
            // Build the complete item
            item.appendChild(checkbox);
            item.appendChild(labelContainer);
            
            // Add to stroke list
            strokesList.appendChild(item);
        });
    }
    
    // Function to toggle label visibility on canvas
    function toggleLabelVisibility(strokeLabel) {
        // Only toggle the label visibility, not the stroke visibility
        strokeLabelVisibility[currentImageLabel][strokeLabel] = !strokeLabelVisibility[currentImageLabel][strokeLabel];
        
        // Update the UI button appearance
        const toggleBtn = document.querySelector(`.stroke-visibility-item[data-stroke="${strokeLabel}"] .stroke-label-toggle`);
        if (toggleBtn) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel];
            toggleBtn.innerHTML = isLabelVisible ? '👁️' : '👁️‍🗨️';
            toggleBtn.title = isLabelVisible ? 'Hide Label on Canvas' : 'Show Label on Canvas';
            toggleBtn.classList.toggle('active', isLabelVisible);
        }
        
        // Redraw the canvas with updated label visibility
        // This should not affect the stroke visibility
        redrawCanvasWithVisibility();
    }
    
    // Function to update measurement input with selected stroke's value
    // Function to display a measurement edit dialog
    function showMeasurementDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurement
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Measurement for ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values from inputs
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Determine which unit was changed last and use that value
            const currentUnit = document.getElementById('unitSelector').value;
            let finalCmValue, finalInchWhole, finalInchFraction;
            
            if (currentUnit === 'inch') {
                finalInchWhole = wholeValue;
                finalInchFraction = fractionValue;
                finalCmValue = convertUnits('inch', wholeValue + fractionValue);
            } else {
                finalCmValue = cmValue;
                // Calculate inch equivalent
                const inches = convertUnits('cm', cmValue);
                finalInchWhole = Math.floor(inches);
                finalInchFraction = findClosestFraction(inches - finalInchWhole);
            }
            
            // Update the measurement
            if (strokeMeasurements[currentImageLabel] === undefined) {
                strokeMeasurements[currentImageLabel] = {};
            }
            
            strokeMeasurements[currentImageLabel][strokeLabel] = {
                inchWhole: finalInchWhole,
                inchFraction: finalInchFraction,
                cm: finalCmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update the UI
            updateStrokeVisibilityControls();
            
            // Redraw with the new measurement
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Helper function to find the closest fraction
    function findClosestFraction(fractionPart) {
        const fractions = [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875];
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        return closestFraction;
    }
    
    // Function to show edit dialog for a stroke
    function showEditDialog(strokeLabel) {
        // Create a modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'measurement-overlay';
        document.body.appendChild(overlay);
        
        // Create a modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'measurement-dialog';
        
        // Get current measurements
        const measurement = strokeMeasurements[currentImageLabel][strokeLabel] || {
            inchWhole: 0,
            inchFraction: 0,
            cm: 0.0
        };
        
        // Title
        const title = document.createElement('h3');
        title.textContent = `Edit Stroke ${strokeLabel}`;
        dialog.appendChild(title);
        
        // Create name edit field
        const nameContainer = document.createElement('div');
        nameContainer.className = 'name-container';
        
        const nameLabel = document.createElement('div');
        nameLabel.textContent = 'Label:';
        nameContainer.appendChild(nameLabel);
        
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = strokeLabel;
        nameInput.placeholder = 'Label';
        nameContainer.appendChild(nameInput);
        
        dialog.appendChild(nameContainer);
        
        // Measurement inputs
        const inputsContainer = document.createElement('div');
        inputsContainer.className = 'measurement-dialog-inputs';
        
        // Inch inputs
        const inchContainer = document.createElement('div');
        inchContainer.className = 'inch-container';
        
        const inchLabel = document.createElement('div');
        inchLabel.textContent = 'Inches:';
        inchContainer.appendChild(inchLabel);
        
        const inchInputs = document.createElement('div');
        inchInputs.className = 'inch-inputs';
        
        const wholeInput = document.createElement('input');
        wholeInput.type = 'number';
        wholeInput.min = '0';
        wholeInput.value = measurement.inchWhole || 0;
        wholeInput.id = 'dialog-inch-whole';
        
        const fractionSelect = document.createElement('select');
        fractionSelect.id = 'dialog-inch-fraction';
        const fractions = [
            {value: '0', text: '0'},
            {value: '0.125', text: '1/8'},
            {value: '0.25', text: '1/4'},
            {value: '0.375', text: '3/8'},
            {value: '0.5', text: '1/2'},
            {value: '0.625', text: '5/8'},
            {value: '0.75', text: '3/4'},
            {value: '0.875', text: '7/8'}
        ];
        
        fractions.forEach(f => {
            const option = document.createElement('option');
            option.value = f.value;
            option.textContent = f.text;
            if (parseFloat(f.value) === measurement.inchFraction) {
                option.selected = true;
            }
            fractionSelect.appendChild(option);
        });
        
        inchInputs.appendChild(wholeInput);
        inchInputs.appendChild(fractionSelect);
        inchContainer.appendChild(inchInputs);
        
        // CM inputs
        const cmContainer = document.createElement('div');
        cmContainer.className = 'cm-container';
        
        const cmLabel = document.createElement('div');
        cmLabel.textContent = 'Centimeters:';
        cmContainer.appendChild(cmLabel);
        
        const cmInput = document.createElement('input');
        cmInput.type = 'number';
        cmInput.min = '0';
        cmInput.step = '0.1';
        cmInput.value = measurement.cm ? measurement.cm.toFixed(1) : '0.0';
        cmInput.id = 'dialog-cm';
        cmContainer.appendChild(cmInput);
        
        // Sync between inch and cm inputs
        wholeInput.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        fractionSelect.addEventListener('change', () => {
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = convertUnits('inch', wholeValue + fractionValue);
            cmInput.value = cmValue.toFixed(1);
        });
        
        cmInput.addEventListener('change', () => {
            const cmValue = parseFloat(cmInput.value) || 0;
            const inches = convertUnits('cm', cmValue);
            const wholeValue = Math.floor(inches);
            const fractionValue = findClosestFraction(inches - wholeValue);
            
            wholeInput.value = wholeValue;
            fractionSelect.value = fractionValue.toString();
        });
        
        // Add inputs to container
        inputsContainer.appendChild(inchContainer);
        inputsContainer.appendChild(cmContainer);
        dialog.appendChild(inputsContainer);
        
        // Add buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'button-container';
        
        const saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.onclick = () => {
            // Get values
            const newName = nameInput.value.trim();
            const wholeValue = parseInt(wholeInput.value) || 0;
            const fractionValue = parseFloat(fractionSelect.value) || 0;
            const cmValue = parseFloat(cmInput.value) || 0;
            
            // Update name if changed
            let finalName = strokeLabel;
            if (newName !== strokeLabel && newName !== '') {
                // The unique name generation is handled inside renameStroke
                finalName = renameStroke(strokeLabel, newName);
                
                // Show feedback if name was modified to make it unique
                if (finalName !== newName) {
                    console.log(`Stroke name automatically adjusted to ${finalName} to avoid duplicates`);
                    
                    // Create and show a temporary notification
                    const notification = document.createElement('div');
                    notification.style.position = 'fixed';
                    notification.style.bottom = '20px';
                    notification.style.left = '50%';
                    notification.style.transform = 'translateX(-50%)';
                    notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                    notification.style.color = 'white';
                    notification.style.padding = '10px 20px';
                    notification.style.borderRadius = '4px';
                    notification.style.zIndex = '10000';
                    notification.textContent = `Renamed to ${finalName} to avoid duplicates`;
                    
                    document.body.appendChild(notification);
                    
                    // Remove after 3 seconds
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 3000);
                }
            }
            
            // Always save both units
            strokeMeasurements[currentImageLabel][finalName] = {
                inchWhole: wholeValue,
                inchFraction: fractionValue,
                cm: cmValue
            };
            
            // Close dialog
            document.body.removeChild(overlay);
            
            // Update UI
            updateStrokeVisibilityControls();
            
            // Redraw to show updated measurements
            redrawCanvasWithVisibility();
        };
        
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.onclick = () => {
            document.body.removeChild(overlay);
        };
        
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        dialog.appendChild(buttonContainer);
        
        overlay.appendChild(dialog);
    }
    
    // Function to generate a unique stroke name
    function generateUniqueStrokeName(baseName) {
        // If the name is empty or undefined, use a default name
        if (!baseName || baseName.trim() === '') {
            baseName = 'A1';
        }
        
        // If the base name doesn't already exist, we can use it as is
        if (!lineStrokesByImage[currentImageLabel] || 
            !lineStrokesByImage[currentImageLabel].includes(baseName)) {
            return baseName;
        }
        
        // Name already exists, so we need to add a number
        // Extract the base part and any existing numbering
        const match = baseName.match(/^(.+?)(?:\((\d+)\))?$/);
        if (!match) {
            // If the regex didn't match for some reason, append (1) to the name
            return `${baseName}(1)`;
        }
        
        const base = match[1];
        let counter = 1;
        
        // If there was already a number, start from the next one
        if (match[2]) {
            counter = parseInt(match[2]) + 1;
        }
        
        // Keep incrementing until we find a unique name
        let newName;
        do {
            newName = `${base}(${counter})`;
            counter++;
        } while (lineStrokesByImage[currentImageLabel].includes(newName));
        
        return newName;
    }
    
    // Function to rename a stroke
    function renameStroke(oldName, newName) {
        if (oldName === newName) return;
        
        // Generate a unique name if needed - this ensures the new name won't conflict
        // with any existing stroke names, including itself
        const uniqueNewName = generateUniqueStrokeName(newName);
        
        // Find the stroke color from the undo stack or vector data to maintain color after rename
        let strokeColor = '#000';
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            strokeColor = vectorStrokesByImage[currentImageLabel][oldName].color || '#000';
        } else {
            for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                const action = undoStackByImage[currentImageLabel][i];
                if (action.label === oldName && action.color) {
                    strokeColor = action.color;
                    // Try to determine stroke type from action
                    if (action.type === 'line') {
                        strokeType = 'straight';
                    }
                    break;
                }
            }
        }
        
        // Update all relevant data structures
        if (lineStrokesByImage[currentImageLabel]) {
            const index = lineStrokesByImage[currentImageLabel].indexOf(oldName);
            if (index !== -1) {
                lineStrokesByImage[currentImageLabel][index] = uniqueNewName;
            }
        }
        
        // Update visibility
        if (strokeVisibilityByImage[currentImageLabel] && 
            strokeVisibilityByImage[currentImageLabel][oldName] !== undefined) {
            const isVisible = strokeVisibilityByImage[currentImageLabel][oldName];
            strokeVisibilityByImage[currentImageLabel][uniqueNewName] = isVisible;
            delete strokeVisibilityByImage[currentImageLabel][oldName];
        }
        
        // Update label visibility
        if (strokeLabelVisibility[currentImageLabel] && 
            strokeLabelVisibility[currentImageLabel][oldName] !== undefined) {
            const isLabelVisible = strokeLabelVisibility[currentImageLabel][oldName];
            strokeLabelVisibility[currentImageLabel][uniqueNewName] = isLabelVisible;
            delete strokeLabelVisibility[currentImageLabel][oldName];
        }
        
        // Update stroke data
        if (strokeDataByImage[currentImageLabel] && 
            strokeDataByImage[currentImageLabel][oldName]) {
            strokeDataByImage[currentImageLabel][uniqueNewName] = 
                strokeDataByImage[currentImageLabel][oldName];
            delete strokeDataByImage[currentImageLabel][oldName];
        }
        
        // Update vector data
        if (vectorStrokesByImage[currentImageLabel] && 
            vectorStrokesByImage[currentImageLabel][oldName]) {
            vectorStrokesByImage[currentImageLabel][uniqueNewName] = 
                vectorStrokesByImage[currentImageLabel][oldName];
            delete vectorStrokesByImage[currentImageLabel][oldName];
        }
        
        // Update measurements
        if (strokeMeasurements[currentImageLabel] && 
            strokeMeasurements[currentImageLabel][oldName]) {
            strokeMeasurements[currentImageLabel][uniqueNewName] = 
                strokeMeasurements[currentImageLabel][oldName];
            delete strokeMeasurements[currentImageLabel][oldName];
        }
        
        // Update next label if needed
        if (labelsByImage[currentImageLabel] === oldName) {
            labelsByImage[currentImageLabel] = uniqueNewName;
        }
        
        // Update any references in the undo/redo stacks
        if (undoStackByImage[currentImageLabel]) {
            undoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        if (redoStackByImage[currentImageLabel]) {
            redoStackByImage[currentImageLabel].forEach(action => {
                if (action.label === oldName) {
                    action.label = uniqueNewName;
                }
            });
        }
        
        // Return the actual name used for the stroke (either the original or the uniquified version)
        return uniqueNewName;
    }
    
    // Function to toggle stroke visibility
    function toggleStrokeVisibility(strokeLabel, isVisible) {
        console.log(`Toggling visibility of stroke ${strokeLabel} to ${isVisible}`);
        
        // Update visibility state
        strokeVisibilityByImage[currentImageLabel][strokeLabel] = isVisible;
        
        // Make sure the stroke data is still available and not accidentally cleared
        if (isVisible) {
            // Initialize vectorStrokesByImage for this image if it doesn't exist
            if (!vectorStrokesByImage[currentImageLabel]) {
                vectorStrokesByImage[currentImageLabel] = {};
            }
            
            // If we're making a stroke visible, ensure we still have vector data
            if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                console.log(`Vector data missing for ${strokeLabel}, attempting recovery`);
                
                // Try to recover vector data from the undo stack
                for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                    const action = undoStackByImage[currentImageLabel][i];
                    if (action.label === strokeLabel) {
                        if (action.vectorData) {
                            vectorStrokesByImage[currentImageLabel][strokeLabel] = action.vectorData;
                            console.log(`Recovered vector data for ${strokeLabel}`);
                            break;
                        }
                    }
                }
                
                // If we still couldn't recover the vector data, create a basic one
                // This is especially important for straight lines
                if (!vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                    console.log(`Creating default vector data for ${strokeLabel}`);
                    
                    // Look for color and properties in the undo stack
                    let strokeColor = "#000000";
                    let strokeWidth = 5;
                    let isLine = false;
                    
                    for (let i = undoStackByImage[currentImageLabel].length - 1; i >= 0; i--) {
                        const action = undoStackByImage[currentImageLabel][i];
                        if (action.label === strokeLabel) {
                            if (action.color) strokeColor = action.color;
                            if (action.width) strokeWidth = action.width;
                            if (action.type === 'line' || action.type === 'straight') isLine = true;
                            break;
                        }
                    }
                    
                    // Create a simple vector representation (placeholder)
                    vectorStrokesByImage[currentImageLabel][strokeLabel] = {
                        points: isLine ? [{x: 0, y: 0}, {x: 1, y: 1}] : [{x: 0, y: 0}],
                        color: strokeColor,
                        width: strokeWidth,
                        type: isLine ? 'straight' : 'freehand'
                    };
                }
            }
        };

        // *** Add redraw call here ***
        redrawCanvasWithVisibility();
    }
    
    // Store for currently selected stroke in each image
    let selectedStrokeByImage = {};
    
    // Initialize stroke label visibility for each image (default to visible)
    IMAGE_LABELS.forEach(label => {
        strokeLabelVisibility[label] = {};
        selectedStrokeByImage[label] = null; // Initialize with no selection
    });
    
    // Store for label custom positions (user-dragged positions)
    let customLabelPositions = {};
    
    // Flag to track if we're dragging a label
    let isDraggingLabel = false;
    let draggedLabelStroke = null;
    let dragStartX = 0;
    let dragStartY = 0;
    
    // Initialize custom label positions for each image
    IMAGE_LABELS.forEach(label => {
        customLabelPositions[label] = {};
    });
    
    // Cache for loaded images to prevent flickering
    const imageCache = {};
    
    // Store for label positions to prevent overlapping
    let currentLabelPositions = [];
    
    // Store for stroke paths to avoid overlapping with lines
    let currentStrokePaths = [];
    
    // Function to redraw canvas respecting stroke visibility
    // Make redrawCanvasWithVisibility available globally
    window.redrawCanvasWithVisibility = redrawCanvasWithVisibility;
    function redrawCanvasWithVisibility() {
        console.log(`--- redrawCanvasWithVisibility called for: ${currentImageLabel} ---`);
        
        // *** Save context and reset transform before drawing anything ***
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset to identity matrix
        console.log("Redraw Start Transform:", ctx.getTransform());
        
        // ADDED: Ensure originalImageDimensions exists and has an entry for this label
        if (!window.originalImageDimensions) {
            window.originalImageDimensions = {};
        }
        
        // ADDED: If we don't have dimensions for this label but we're trying to draw strokes,
        // create default dimensions based on the canvas size to prevent coordinates from being lost
        if (!window.originalImageDimensions[currentImageLabel] && 
            window.vectorStrokesByImage[currentImageLabel] && 
            Object.keys(window.vectorStrokesByImage[currentImageLabel]).length > 0) {
            
            console.log(`Creating default dimensions for ${currentImageLabel} to preserve strokes`);
            window.originalImageDimensions[currentImageLabel] = {
                width: canvas.width,
                height: canvas.height
            };
            console.log(`Set dimensions to match canvas: ${canvas.width}x${canvas.height}`);
        }
        
        // Reset label positions and stroke paths for this redraw
        currentLabelPositions = [];
        currentStrokePaths = [];
        
        // Create a copy of custom label positions for tracking which ones were actually used
        const usedCustomPositions = {};
        
        // We need to rebuild the canvas from scratch using individual stroke data
        const strokes = window.lineStrokesByImage[currentImageLabel] || [];
        
        // Start with a blank canvas or the original image if available
        if (window.originalImages && window.originalImages[currentImageLabel]) {
            // Check if we already have this image in the cache
            const imageUrl = window.originalImages[currentImageLabel];
            
            if (imageCache[imageUrl]) {
                // Use cached image immediately
                drawImageAndStrokes(imageCache[imageUrl]);
            } else {
                // Load the image and cache it
                const img = new Image();
                img.onload = () => {
                    // Add to cache
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                };
                img.src = imageUrl;
                
                // If the image is already cached in the browser, it might be immediately available
                if (img.complete) {
                    imageCache[imageUrl] = img;
                    drawImageAndStrokes(img);
                } else {
                    // If the image isn't immediately available,
                    // still draw the strokes on a blank canvas so they don't disappear
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the current scale and position
                    const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
                    
                    // For blank canvas mode, we apply the position directly when drawing points
                    // We pass 0,0 for position here since we'll apply it inside applyVisibleStrokes
                    applyVisibleStrokes(scale, 0, 0);
                }
            }
        } else {
            // Otherwise start with a blank canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white'; // Add white background fill
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Get the current scale for the blank canvas state
            const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
            
            // Apply visible strokes - for blank canvas mode, we don't need to apply position offset here
            // since we'll apply it to each point when drawing
            applyVisibleStrokes(scale, 0, 0);
        }
        
        function drawImageAndStrokes(img) {
            // Clear only once within the reset transform state
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply scale
            const scale = window.imageScaleByLabel[currentImageLabel];
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            
            // Calculate base position (center of canvas)
            const centerX = (canvas.width - scaledWidth) / 2;
            const centerY = (canvas.height - scaledHeight) / 2;
            
            // Apply position offset
            const positionOffset = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 }; // Ensure offset exists
            const offsetX = positionOffset.x;
            const offsetY = positionOffset.y;
            
            // Calculate final position
            const x = centerX + offsetX;
            const y = centerY + offsetY;

            // *** ADDED LOGGING ***
            // console.log(`drawImageAndStrokes Calculation:
            //   canvas.width=${canvas.width}, img.width=${img.width}, scaledWidth=${scaledWidth}
            //   scale=${scale}, centerX=${centerX}, offsetX=${offsetX}, final imageX (passed to applyVisibleStrokes)=${x}`);
            // *** END LOGGING ***
            
            // Draw the image with scaling and positioning
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Then apply visible strokes
            applyVisibleStrokes(scale, x, y);
        }
        
        function applyVisibleStrokes(scale, imageX, imageY) {
            console.log("ApplyStrokes Start Transform:", ctx.getTransform()); // Log transform at start
            // console.log(`\nApplying strokes with scale=${scale}, imageX=${imageX}, imageY=${imageY}`); // Keep this commented unless debugging scale/position
            const strokes = window.vectorStrokesByImage[currentImageLabel] || {};
            const strokeOrder = window.lineStrokesByImage[currentImageLabel] || [];
            const visibility = window.strokeVisibilityByImage[currentImageLabel] || {};

            // Loop through strokes in their drawing order
            strokeOrder.forEach((strokeLabel) => {
                const isVisible = visibility[strokeLabel];
                if (!isVisible) return; // Skip invisible strokes

                const vectorData = strokes[strokeLabel];
                // Ensure vectorData and points exist
                if (!vectorData || !vectorData.points || vectorData.points.length === 0) {
                     console.warn(`Skipping stroke ${strokeLabel} in redraw: Missing vector data or points.`);
                     return;
                }

                // Set stroke style based on stored data, scaled by CURRENT scale
                ctx.strokeStyle = vectorData.color || '#000000';
                // *** FIX: Ensure lineWidth uses original stored width * current scale ***
                const scaledLineWidth = (vectorData.width || 5) * scale;
                ctx.lineWidth = scaledLineWidth;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        
                // Start drawing the path
                ctx.beginPath();

                // Transform the first point from relative to canvas coordinates
                const firstPointRelative = vectorData.points[0];
                const firstPointCanvas = getCanvasCoords(firstPointRelative.x, firstPointRelative.y);
                ctx.moveTo(firstPointCanvas.x, firstPointCanvas.y);

                // Store canvas path for label collision detection
                const strokePath = [{ x: firstPointCanvas.x, y: firstPointCanvas.y }];

                // Check if this is a straight line (only two points)
                const isStraightLine = vectorData.type === 'straight' || (vectorData.points.length === 2 && !vectorData.type);

                if (isStraightLine && vectorData.points.length >= 2) {
                    // Straight Line: Transform only the last point
                    const lastPointRelative = vectorData.points[vectorData.points.length - 1];
                    const lastPointCanvas = getCanvasCoords(lastPointRelative.x, lastPointRelative.y);
                    ctx.lineTo(lastPointCanvas.x, lastPointCanvas.y);
                    strokePath.push({ x: lastPointCanvas.x, y: lastPointCanvas.y });
                } else {
                    // Freehand: Transform ALL subsequent points
                    for (let i = 1; i < vectorData.points.length; i++) {
                        const pointRelative = vectorData.points[i];
                        // *** FIX: Apply getCanvasCoords to EACH subsequent point ***
                        const pointCanvas = getCanvasCoords(pointRelative.x, pointRelative.y);
                        ctx.lineTo(pointCanvas.x, pointCanvas.y);
                        strokePath.push({ x: pointCanvas.x, y: pointCanvas.y });
                         // Optional logging for debugging coordinate drift:
                         // if (i < 3 || i % 20 === 0) { // Log first few and then every 20th
                         //     console.log(`  Redraw Pt ${i} Rel:(${pointRelative.x.toFixed(1)}, ${pointRelative.y.toFixed(1)}) -> Canv:(${pointCanvas.x.toFixed(1)}, ${pointCanvas.y.toFixed(1)})`);
                         // }
                    }
                }

                // Apply selection highlighting if needed (before stroking)
                const isSelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
                if (isSelected) {
                    ctx.save();
                    ctx.shadowColor = '#ffffff'; // White glow
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                }

                // Stroke the path
                        ctx.stroke();
                        
                // Restore context if selection highlighting was applied
                if (isSelected) {
                    ctx.restore();
                }

                // Store the calculated canvas path and scaled width for label positioning
                currentStrokePaths.push({
                    label: strokeLabel,
                    path: strokePath, // Store canvas coordinates path
                     // *** FIX: Store correctly scaled width ***
                    width: scaledLineWidth,
                    color: vectorData.color
                });
            }); // End of strokeOrder.forEach

            // --- Label Drawing Logic ---
            // console.log(`--- Redraw: Drawing Labels for ${currentImageLabel} ---`);
            currentLabelPositions = [];
            const usedCustomPositions = {};

            strokeOrder.forEach((strokeLabel) => {
                const isStrokeVisible = visibility[strokeLabel];
                if (!strokeLabelVisibility[currentImageLabel]) strokeLabelVisibility[currentImageLabel] = {};
                const isLabelVisible = strokeLabelVisibility[currentImageLabel][strokeLabel] !== false; // Default true
                const vectorData = strokes[strokeLabel];

                if (isStrokeVisible && isLabelVisible && vectorData && vectorData.points.length > 0) {
                    const measurement = getMeasurementString(strokeLabel);
                    const labelText = measurement ? `${strokeLabel}=${measurement}` : strokeLabel;

                    // Determine anchor point (middle of the stroke) using RELATIVE coordinates
                    let anchorPointRelative = { x: 0, y: 0 };
                    const midIndex = Math.floor(vectorData.points.length / 2);
                    anchorPointRelative = vectorData.points[midIndex];

                    // Convert anchor point to CURRENT canvas coordinates
                    const anchorPointCanvas = getCanvasCoords(anchorPointRelative.x, anchorPointRelative.y);

                    if (isNaN(anchorPointCanvas.x) || isNaN(anchorPointCanvas.y)) {
                         console.error(`      Error getting canvas coords for label anchor for ${strokeLabel}. Relative point:`, anchorPointRelative);
                         return; // Skip label if anchor is invalid
                    }

                    // Set label style
                    // Increase font size for better visibility, especially when scaled
                    const baseFontSize = 14;
                    const scaledFontSize = Math.max(10, Math.min(28, baseFontSize / scale)); // Adjust font size based on zoom, within limits
                    ctx.font = `${scaledFontSize}px Arial`;
                    const labelColor = vectorData.color || '#000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';

                    // Calculate label dimensions based on current font size
                    const metrics = ctx.measureText(labelText);
                    const padding = 6 / scale; // Scale padding inversely
                    const labelWidth = metrics.width + padding * 2;
                    const labelHeight = scaledFontSize + padding * 2; // Adjust height based on font size

                    // Initial label rectangle guess (used for optimal position calculation)
                     const initialLabelRect = {
                        width: labelWidth,
                        height: labelHeight,
                        x: anchorPointCanvas.x - labelWidth / 2,
                        y: anchorPointCanvas.y - labelHeight - (15 / scale), // Scale vertical offset
                        strokeLabel: strokeLabel
                    };

                    // Determine final label position
                    let finalPosition; // This will be canvas coordinates {x, y} for the top-left of the label
                    let offset = null; // Relative offset {x, y} from anchorPointCanvas

                    // 1. Check for user-dragged position (stored as relative offset)
                    if (customLabelPositions[currentImageLabel]?.[strokeLabel]) {
                        offset = customLabelPositions[currentImageLabel][strokeLabel];
                        // Apply the stored relative offset to the *current* canvas anchor point
                        finalPosition = { x: anchorPointCanvas.x + offset.x, y: anchorPointCanvas.y + offset.y };
                        usedCustomPositions[strokeLabel] = true; // Mark as used
                         // console.log(`    Using custom offset for ${strokeLabel}. Anchor: (${anchorPointCanvas.x.toFixed(1)}, ${anchorPointCanvas.y.toFixed(1)}), Offset: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)}) -> Final: (${finalPosition.x.toFixed(1)}, ${finalPosition.y.toFixed(1)})`);
                    }
                    // 2. Check for previously calculated offset (stored as relative offset)
                    else if (calculatedLabelOffsets[currentImageLabel]?.[strokeLabel]) {
                        offset = calculatedLabelOffsets[currentImageLabel][strokeLabel];
                        // Apply the stored relative offset to the *current* canvas anchor point
                        finalPosition = { x: anchorPointCanvas.x + offset.x, y: anchorPointCanvas.y + offset.y };
                         // console.log(`    Using calculated offset for ${strokeLabel}. Anchor: (${anchorPointCanvas.x.toFixed(1)}, ${anchorPointCanvas.y.toFixed(1)}), Offset: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)}) -> Final: (${finalPosition.x.toFixed(1)}, ${finalPosition.y.toFixed(1)})`);
                    }
                    // 3. Calculate optimal position and offset for the first time
                    else {
                        if (typeof findOptimalLabelPosition !== 'function') {
                            console.error("     findOptimalLabelPosition function is not defined! Using default position.");
                            finalPosition = { x: initialLabelRect.x, y: initialLabelRect.y }; // Fallback
                        } else {
                            try {
                                const strokePathInfo = currentStrokePaths.find(p => p.label === strokeLabel);
                                const optimalRect = findOptimalLabelPosition(
                                    initialLabelRect, // Initial guess uses current canvas coords & dimensions
                                    anchorPointCanvas, // Anchor is current canvas coords
                                    strokePathInfo // Pass current canvas path info
                                );
                                finalPosition = { x: optimalRect.x, y: optimalRect.y };
                            } catch(err) {
                                console.error(`      Error in findOptimalLabelPosition for ${strokeLabel}:`, err);
                                finalPosition = { x: initialLabelRect.x, y: initialLabelRect.y }; // Fallback
                            }
                        }
                        // Calculate and store the RELATIVE offset based on the calculated position
                        offset = {
                            x: finalPosition.x - anchorPointCanvas.x,
                            y: finalPosition.y - anchorPointCanvas.y
                        };
                        if (!calculatedLabelOffsets[currentImageLabel]) calculatedLabelOffsets[currentImageLabel] = {};
                        calculatedLabelOffsets[currentImageLabel][strokeLabel] = offset; // Store relative offset
                        // console.log(`    Calculated and stored offset for ${strokeLabel}:`, offset);
                    }

                    // Store the final calculated position rect for overlap checks in *this* redraw cycle
                    const finalLabelRect = { ...initialLabelRect, x: finalPosition.x, y: finalPosition.y };
                    currentLabelPositions.push(finalLabelRect);

                    // Draw label background
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(finalLabelRect.x, finalLabelRect.y, finalLabelRect.width, finalLabelRect.height);

                    // Draw label border
                    ctx.strokeStyle = labelColor;
                    ctx.lineWidth = 1; // Keep border thin
                    ctx.strokeRect(finalLabelRect.x, finalLabelRect.y, finalLabelRect.width, finalLabelRect.height);

                    // Draw label text
                    ctx.fillStyle = labelColor;
                    const textX = finalLabelRect.x + finalLabelRect.width / 2;
                    const textY = finalLabelRect.y + finalLabelRect.height - padding; // Adjust baseline using scaled padding
                    ctx.fillText(labelText, textX, textY);

                    // Optionally draw connector line (from label edge to anchor point)
                    if (typeof drawLabelConnector === 'function') {
                        try {
                            drawLabelConnector(finalLabelRect, anchorPointCanvas, labelColor);
                        } catch(err) {
                            console.error(`      Error in drawLabelConnector for ${strokeLabel}:`, err);
                        }
                    }
                }
            }); // End of label drawing loop
            // --- End of Label Drawing Logic ---

            // Save the now-combined state (only if not loading, to prevent infinite loops)
            if (!window.isLoadingProject) {
                const newState = getCanvasState();
                imageStates[currentImageLabel] = cloneImageData(newState);
                 // console.log(`[Redraw] Saved final canvas state for ${currentImageLabel}`); // Optional: Debug state saving
            } else {
                 // console.log("[Redraw] Skipping final state save because isLoadingProject is true.");
            }
            ctx.restore(); // *** Restore the original context state (including transform) ***
            console.log("Redraw End Transform:", ctx.getTransform());
        }
    }

    function cloneImageData(imageData) {
        return new ImageData(
            new Uint8ClampedArray(imageData.data),
            imageData.width,
            imageData.height
        );
    }

    function saveState(force = false, incrementLabel = true, updateStrokeList = true) {
        // *** ADDED LOG ***
        console.log(`[Save State Called] force=${force}, incrementLabel=${incrementLabel}, updateStrokeList=${updateStrokeList}, isDrawingOrPasting=${isDrawingOrPasting}, strokeInProgress=${strokeInProgress}`);

        // Get current state
        const currentState = getCanvasState();

        // Initialize if first save for this image
        if (!imageStates[currentImageLabel]) {
            imageStates[currentImageLabel] = cloneImageData(currentState);
            undoStackByImage[currentImageLabel].push({
                state: cloneImageData(currentState),
                type: 'initial',
                label: null
            });
            updateStrokeCounter();
            return;
        }

        // Only save if we're not in the middle of a stroke or if forced
        if (!force && strokeInProgress) return;

        // Don't save if it's identical to the last state
        const lastState = imageStates[currentImageLabel];
        if (lastState && !force) {
            const currentData = currentState.data;
            const lastData = lastState.data;
            let identical = true;
            for (let i = 0; i < currentData.length; i += 4) {
                if (currentData[i] !== lastData[i] ||
                    currentData[i + 1] !== lastData[i + 1] ||
                    currentData[i + 2] !== lastData[i + 2] ||
                    currentData[i + 3] !== lastData[i + 3]) {
                    identical = false;
                    break;
                }
            }
            if (identical) return;
        }

        // For line strokes, assign the next label before saving
        let strokeLabel = null;
        if (!isDrawingOrPasting && !strokeInProgress && incrementLabel && updateStrokeList) {
            // *** ADDED DETAILED LOGS ***
            console.log(`[Save State] Entering stroke update block.`);
            
            // Get the suggested next label
            const suggestedLabel = window.labelsByImage[currentImageLabel];
            console.log(`[Save State] Suggested next label = "${suggestedLabel}" from labelsByImage[${currentImageLabel}]`);
            
            // *** FIX: Ensure the new stroke gets a UNIQUE label ***
            strokeLabel = generateUniqueStrokeName(suggestedLabel);
            console.log(`[Save State] Assigned UNIQUE strokeLabel = "${strokeLabel}"`);
            
            // Always increment the label counter based on the original suggested label for the next stroke
            const nextLabel = getNextLabel(currentImageLabel); // Uses the value in labelsByImage
            window.labelsByImage[currentImageLabel] = nextLabel;
            console.log(`[Save State] Incremented labelsByImage[${currentImageLabel}] to "${nextLabel}"`);
            
            // Only add the *unique* stroke label to the strokes list
            if (!window.lineStrokesByImage[currentImageLabel]) {
                console.log(`[Save State] Initializing lineStrokesByImage[${currentImageLabel}] as []`);
                window.lineStrokesByImage[currentImageLabel] = []; // Initialize if it doesn't exist
            }
            
            // Check if unique stroke label already exists before pushing (shouldn't happen with generateUniqueStrokeName)
            const labelAlreadyExists = window.lineStrokesByImage[currentImageLabel].includes(strokeLabel);
            
            console.log(`[Save State] BEFORE push: lineStrokesByImage[${currentImageLabel}] =`, JSON.parse(JSON.stringify(window.lineStrokesByImage[currentImageLabel])));
            
            if (!labelAlreadyExists && updateStrokeList) {
                window.lineStrokesByImage[currentImageLabel].push(strokeLabel); // Push the unique label
                console.log(`[Save State] AFTER push: lineStrokesByImage[${currentImageLabel}] =`, JSON.parse(JSON.stringify(window.lineStrokesByImage[currentImageLabel])));
            } else {
                // This case should ideally not be reached if generateUniqueStrokeName works correctly
                console.warn(`[Save State] Generated unique stroke label "${strokeLabel}" already exists? Not pushing again.`);
            }
            
            // Initialize visibility, data etc. using the unique strokeLabel
            window.strokeVisibilityByImage[currentImageLabel] = window.strokeVisibilityByImage[currentImageLabel] || {};
            window.strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            
            window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
            window.strokeLabelVisibility[currentImageLabel][strokeLabel] = true;
            
            strokeDataByImage[currentImageLabel] = strokeDataByImage[currentImageLabel] || {};
            strokeDataByImage[currentImageLabel][strokeLabel] = {
                preState: currentStroke ? cloneImageData(currentStroke) : null,
                postState: cloneImageData(currentState)
            };
        }

        // --- FIX: Handle temporary vector data --- 
        const tempStrokeKey = '_drawingStroke';
        let drawnVectorData = null;
        
        // Debug the state of vectorStrokesByImage before handling temporary data
        console.log(`[Save State] Vector strokes for ${currentImageLabel} before processing:`, 
            window.vectorStrokesByImage[currentImageLabel] ? 
            Object.keys(window.vectorStrokesByImage[currentImageLabel]) : "none");
            
        // Detailed check for _drawingStroke
        if (window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
            console.log(`[Save State] Found _drawingStroke data with ${window.vectorStrokesByImage[currentImageLabel][tempStrokeKey].points.length} points`);
        } else {
            console.log(`[Save State] No _drawingStroke data found:`, 
                window.vectorStrokesByImage[currentImageLabel] ? 
                "vectorStrokesByImage exists for label but no _drawingStroke key" : 
                "vectorStrokesByImage doesn't exist for this label");
        }
        
        if (strokeLabel && window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
            drawnVectorData = JSON.parse(JSON.stringify(window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]));
            // Assign the drawn data to the final unique stroke label
            window.vectorStrokesByImage[currentImageLabel][strokeLabel] = drawnVectorData;
            // Remove the temporary data
            delete window.vectorStrokesByImage[currentImageLabel][tempStrokeKey];
            console.log(`[Save State] Moved vector data from ${tempStrokeKey} to ${strokeLabel}`);
        } else if (strokeLabel) {
            console.warn(`[Save State] No temporary vector data found at ${tempStrokeKey} for stroke ${strokeLabel}`);
            // Attempt to find vector data if it somehow got assigned to the suggested label during draw (fallback)
            const suggestedLabel = window.labelsByImage[currentImageLabel]; // Get the label *before* incrementing
             if (window.vectorStrokesByImage[currentImageLabel] && window.vectorStrokesByImage[currentImageLabel][suggestedLabel]) {
                console.log(`[Save State] Fallback: Found data under suggested label ${suggestedLabel}`);
                drawnVectorData = JSON.parse(JSON.stringify(window.vectorStrokesByImage[currentImageLabel][suggestedLabel]));
                window.vectorStrokesByImage[currentImageLabel][strokeLabel] = drawnVectorData;
                // Optionally delete the data under suggestedLabel if it shouldn't be there
                // delete window.vectorStrokesByImage[currentImageLabel][suggestedLabel]; 
            }
        }
        // --- END FIX ---

        // Save new state and add to undo stack
        imageStates[currentImageLabel] = cloneImageData(currentState);
        
        // Determine the type of stroke
        let strokeType = 'other';
        if (force && strokeLabel) {
            strokeType = 'stroke';
            
            // Check for vector data to determine if it's a freehand or straight line
            // Use the vector data we just potentially moved
            if (drawnVectorData) { 
                if (drawnVectorData.type === 'straight') {
                    strokeType = 'line';
                } else if (drawnVectorData.type === 'freehand') {
                    strokeType = 'stroke';
                }
            }
        }
        
        // Add to undo stack with stroke info
        const undoAction = {
            state: cloneImageData(currentState),
            type: strokeType,
            label: strokeLabel, // Use the unique label
            color: colorPicker.value, 
            width: parseInt(brushSize.value) 
        };
        
        // Store vector data with the undo action if available
        // Use the data retrieved from the temporary key
        if (drawnVectorData) {
            undoAction.vectorData = drawnVectorData; 
        }
        
        undoStackByImage[currentImageLabel].push(undoAction);
        
        // Remove oldest state if we've reached max history
        if (undoStackByImage[currentImageLabel].length >= MAX_HISTORY) {
            undoStackByImage[currentImageLabel].shift();
        }

        // Clear redo stack when a new action is performed
        redoStackByImage[currentImageLabel] = [];

        updateStrokeCounter();
        updateSidebarStrokeCounts();
    }

    function undo() {
        console.log(`Attempting to undo in ${currentImageLabel} workspace`);
        console.log(`Current undo stack: ${undoStackByImage[currentImageLabel]?.length || 0} items`);
        console.log(`Current strokes: ${lineStrokesByImage[currentImageLabel]?.join(', ') || 'none'}`);
        
        const currentStack = undoStackByImage[currentImageLabel];
        if (currentStack && currentStack.length > 1) { // Keep at least one state (initial)
            // Get the state we're undoing from
            const lastAction = currentStack.pop();
            console.log(`Undoing action of type: ${lastAction.type}, label: ${lastAction.label || 'none'}`);
            
            // Add to redo stack
            redoStackByImage[currentImageLabel] = redoStackByImage[currentImageLabel] || [];
            redoStackByImage[currentImageLabel].push(lastAction);
            console.log(`Added to redo stack, now has ${redoStackByImage[currentImageLabel].length} items`);
            
            // Skip certain state types when undoing
            if (lastAction.type === 'pre-stroke') {
                console.log('Skipping pre-stroke state');
                // If we encounter a pre-stroke state, undo again to get to the previous complete state
                if (currentStack.length > 1) {
                    return undo();
                }
            }
            
            // Handle snapshot type (created when switching views)
            if (lastAction.type === 'snapshot') {
                console.log('Restoring from snapshot state');
                // If we have stored strokes in the snapshot, restore them
                if (lastAction.strokes) {
                    lineStrokesByImage[currentImageLabel] = [...(lastAction.strokes || [])];
                    console.log(`Restored strokes: ${lineStrokesByImage[currentImageLabel].join(', ')}`);
                }
                
                // Continue to next undo action if possible
                if (currentStack.length > 1) {
                    return undo();
                }
            }
            
            // Get the state we're going back to
            const previousState = currentStack[currentStack.length - 1];
            
            if (lastAction.type === 'line' || lastAction.type === 'stroke') {
                // Remove the last stroke and its label
                if (lineStrokesByImage[currentImageLabel] && lineStrokesByImage[currentImageLabel].length > 0) {
                    const removedStroke = lineStrokesByImage[currentImageLabel].pop();
                    console.log(`Removed stroke: ${removedStroke}`);
                    
                    // Also remove from visibility tracking
                    if (strokeVisibilityByImage[currentImageLabel] && strokeVisibilityByImage[currentImageLabel][removedStroke]) {
                        delete strokeVisibilityByImage[currentImageLabel][removedStroke];
                    }
                    
                    // Also remove from label visibility tracking
                    if (strokeLabelVisibility[currentImageLabel] && strokeLabelVisibility[currentImageLabel][removedStroke]) {
                        // Save label visibility in lastAction for possible redo
                        lastAction.labelVisible = strokeLabelVisibility[currentImageLabel][removedStroke];
                        delete strokeLabelVisibility[currentImageLabel][removedStroke];
                    }
                    
                    // Also remove from stroke data tracking
                    if (strokeDataByImage[currentImageLabel] && strokeDataByImage[currentImageLabel][removedStroke]) {
                        delete strokeDataByImage[currentImageLabel][removedStroke];
                    }
                    
                    // Remove vector stroke data
                    if (vectorStrokesByImage[currentImageLabel] && vectorStrokesByImage[currentImageLabel][removedStroke]) {
                        // Save vector data in lastAction for possible redo
                        lastAction.vectorData = vectorStrokesByImage[currentImageLabel][removedStroke];
                        delete vectorStrokesByImage[currentImageLabel][removedStroke];
                }
                
                    // If this was the last stroke, reset to A1
                    if (lineStrokesByImage[currentImageLabel].length === 0) {
                        labelsByImage[currentImageLabel] = 'A1';
                        console.log(`All strokes undone, reset label counter to A1`);
                    } else {
                // Set the next label to be the one we just removed
                if (lastAction.label) {
                    labelsByImage[currentImageLabel] = lastAction.label;
                    console.log(`Reset label counter to: ${lastAction.label}`);
                        }
                    }
                }
            }
            
            // Ensure we have a valid previous state
            if (previousState && previousState.state) {
                // Restore the canvas state
                const stateToRestore = cloneImageData(previousState.state);
                imageStates[currentImageLabel] = stateToRestore;
                restoreCanvasState(stateToRestore);
                currentStroke = cloneImageData(stateToRestore);
                console.log('Canvas state restored');
            } else {
                console.log('Warning: No valid previous state found');
                // Create a blank state if needed
                const blankState = ctx.createImageData(canvas.width, canvas.height);
                imageStates[currentImageLabel] = blankState;
                restoreCanvasState(blankState);
                currentStroke = cloneImageData(blankState);
            }
            
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
        } else if (currentStack && currentStack.length === 1) {
            // We're at the initial state
            console.log('At initial state, resetting workspace');
            const initialState = currentStack[0];
            
            // Clear all stroke data
            lineStrokesByImage[currentImageLabel] = [];
            strokeVisibilityByImage[currentImageLabel] = {};
            strokeLabelVisibility[currentImageLabel] = {};
            vectorStrokesByImage[currentImageLabel] = {};
            strokeDataByImage[currentImageLabel] = {};
            
            // Reset label counter
            labelsByImage[currentImageLabel] = 'A1';  // Reset to A1
            
            if (initialState && initialState.state) {
                imageStates[currentImageLabel] = cloneImageData(initialState.state);
                restoreCanvasState(initialState.state);
                currentStroke = cloneImageData(initialState.state);
            } else if (window.originalImages[currentImageLabel]) {
                // If we have the original image, redraw it
                console.log('Redrawing from original image');
                const img = new Image();
                img.onload = () => {
                    // Clear the canvas first
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the current scale
                    const scale = window.imageScaleByLabel[currentImageLabel];
                    const scaledWidth = img.width * scale;
                    const scaledHeight = img.height * scale;
                    
                    // Calculate base position (center of canvas)
                    const centerX = (canvas.width - scaledWidth) / 2;
                    const centerY = (canvas.height - scaledHeight) / 2;
                    
                    // Apply position offset
                    const offsetX = window.imagePositionByLabel[currentImageLabel].x;
                    const offsetY = window.imagePositionByLabel[currentImageLabel].y;
                    
                    // Calculate final position
                    const x = centerX + offsetX;
                    const y = centerY + offsetY;
                    
                    // Draw the original image with scale and position
                    ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                    
                    // Save this as the new state
                    const newState = getCanvasState();
                    imageStates[currentImageLabel] = cloneImageData(newState);
                    currentStroke = cloneImageData(newState);
                };
                img.src = window.originalImages[currentImageLabel];
            }
            
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
        } else {
            console.log('No undo history available for this workspace');
        }
    }
    
    function redo() {
        console.log(`Attempting to redo in ${currentImageLabel} workspace`);
        console.log(`Current redo stack: ${redoStackByImage[currentImageLabel]?.length || 0} items`);
        
        const redoStack = redoStackByImage[currentImageLabel];
        if (redoStack && redoStack.length > 0) {
            // Get the action to redo
            const actionToRedo = redoStack.pop();
            console.log(`Redoing action of type: ${actionToRedo.type}, label: ${actionToRedo.label || 'none'}`);
            
            // Add back to undo stack
            undoStackByImage[currentImageLabel].push(actionToRedo);
            
            // Handle stroke type actions (both freehand strokes and straight lines)
            if ((actionToRedo.type === 'line' || actionToRedo.type === 'stroke') && actionToRedo.label) {
                // Add the stroke back to the list
                window.lineStrokesByImage[currentImageLabel] = window.lineStrokesByImage[currentImageLabel] || [];
                window.lineStrokesByImage[currentImageLabel].push(actionToRedo.label);
                console.log(`Added stroke back: ${actionToRedo.label}`);
                
                // Restore stroke visibility
                window.strokeVisibilityByImage[currentImageLabel] = window.strokeVisibilityByImage[currentImageLabel] || {};
                window.strokeVisibilityByImage[currentImageLabel][actionToRedo.label] = true;
                
                // Restore stroke data if we have it
                if (actionToRedo.strokeData) {
                    strokeDataByImage[currentImageLabel] = strokeDataByImage[currentImageLabel] || {};
                    strokeDataByImage[currentImageLabel][actionToRedo.label] = actionToRedo.strokeData;
                }
                
                // Restore vector data if we have it
                if (actionToRedo.vectorData) {
                    window.vectorStrokesByImage[currentImageLabel] = window.vectorStrokesByImage[currentImageLabel] || {};
                    window.vectorStrokesByImage[currentImageLabel][actionToRedo.label] = actionToRedo.vectorData;
                    
                    // If no vector data saved in the action, but we're redoing a line/stroke,
                    // try to recreate basic vector data to ensure label display
                    if (!actionToRedo.vectorData && 
                        (actionToRedo.type === 'line' || actionToRedo.type === 'stroke')) {
                        // Create minimal vector data to ensure label display
                        window.vectorStrokesByImage[currentImageLabel][actionToRedo.label] = {
                            points: [
                                { x: canvas.width/2 - 50, y: canvas.height/2 }, // Dummy points
                                { x: canvas.width/2 + 50, y: canvas.height/2 }
                            ],
                            color: actionToRedo.color || "#000000",
                            width: 5,
                            type: actionToRedo.type === 'line' ? 'straight' : 'freehand'
                        };
                    }
                }
                
                // Restore label visibility if we have it
                if (actionToRedo.labelVisible !== undefined) {
                    window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
                    window.strokeLabelVisibility[currentImageLabel][actionToRedo.label] = actionToRedo.labelVisible;
                } else {
                    // Default to visible for new strokes and redone strokes without saved value
                    window.strokeLabelVisibility[currentImageLabel] = window.strokeLabelVisibility[currentImageLabel] || {};
                    window.strokeLabelVisibility[currentImageLabel][actionToRedo.label] = true;
                }
                
                // Update the next label - make sure it's one higher than the redone label
                const numPart = parseInt(actionToRedo.label.slice(1));
                if (!isNaN(numPart)) {
                    const letterPart = actionToRedo.label[0];
                    const nextNum = numPart + 1;
                    const nextLabel = nextNum > 9 
                        ? String.fromCharCode(letterPart.charCodeAt(0) + 1) + '0' 
                        : letterPart + nextNum;
                    window.labelsByImage[currentImageLabel] = nextLabel;
                    console.log(`Set next label to: ${nextLabel}`);
                } else {
                    // Fallback to the standard next label function
                window.labelsByImage[currentImageLabel] = getNextLabel(currentImageLabel);
                console.log(`Set next label to: ${window.labelsByImage[currentImageLabel]}`);
                }
            }
            
            // Restore the state
            if (actionToRedo.state) {
                const stateToRestore = cloneImageData(actionToRedo.state);
                imageStates[currentImageLabel] = stateToRestore;
                restoreCanvasState(stateToRestore);
                currentStroke = cloneImageData(stateToRestore);
                console.log('Canvas state restored for redo');
            }
            
            // Update all UI elements
            updateStrokeCounter();
            updateStrokeVisibilityControls();
            updateSidebarStrokeCounts();
            
            // Force redraw with visibility to ensure labels appear immediately
            redrawCanvasWithVisibility();
        } else {
            console.log('No redo actions available for this workspace');
        }
    }

    // Save initial blank state
//    saveState();

    // Set canvas size
    function resizeCanvas() {
        // Account for the sidebars and gaps in our calculation (approximately 420px for sidebars + gaps)
        const sidebarSpace = 440;
        const maxWidth = Math.min(window.innerWidth - sidebarSpace, 1000);  // Cap at 1000px width
        const maxHeight = Math.min(window.innerHeight - 100, 800);  // Cap at 800px height
        
        // Save current state before resizing
        const oldState = imageStates[currentImageLabel];
        
        // Resize the canvas
        canvas.width = maxWidth;
        canvas.height = maxHeight;
        
        // Set default canvas styles
        canvas.style.cursor = 'crosshair';
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Restore the image after resize
        if (oldState) {
            // Try to restore from saved state first
            try {
                restoreCanvasState(oldState);
                currentStroke = cloneImageData(oldState);
            } catch (e) {
                // If that fails, redraw from original image
                if (window.originalImages[currentImageLabel]) {
                    const img = new Image();
                    img.onload = () => {
                        // Clear the canvas first
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Get the current scale
                        const scale = imageScaleByLabel[currentImageLabel];
                        const scaledWidth = img.width * scale;
                        const scaledHeight = img.height * scale;
                        
                        // Calculate base position (center of canvas)
                        const centerX = (canvas.width - scaledWidth) / 2;
                        const centerY = (canvas.height - scaledHeight) / 2;
                        
                        // Apply position offset
                        const offsetX = window.imagePositionByLabel[currentImageLabel].x;
                        const offsetY = window.imagePositionByLabel[currentImageLabel].y;
                        
                        // Calculate final position
                        const x = centerX + offsetX;
                        const y = centerY + offsetY;
                        
                        // Draw the original image with scale and position
                        ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                        
                        // Save this as the new state
                        const newState = getCanvasState();
                        imageStates[currentImageLabel] = cloneImageData(newState);
                        currentStroke = cloneImageData(newState);
                    };
                    img.src = window.originalImages[currentImageLabel];
                } else if (!currentStroke) {
                    // Initialize blank state if needed
                    currentStroke = getCanvasState();
                }
            }
        }
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Drawing state
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let points = [];
    let lastVelocity = 0;
    // --- ADD: Track last RAW coordinates ---
    let lastRawX = 0;
    let lastRawY = 0;
    // --- END ADD ---

    // Drawing mode state
    let drawingMode = 'freehand'; // Options: 'freehand', 'straight'
    let straightLineStart = null; // For straight line mode - start point
    let lastDrawnPoint = null;

    /**
     * Transforms raw canvas coordinates to account for image scaling and positioning
     * @param {number} x - Raw x-coordinate from mouse event
     * @param {number} y - Raw y-coordinate from mouse event
     * @returns {Object} Object with transformed x and y coordinates
     */
    function getTransformedCoords(x, y) {
        // Debug logging
        if (window.debugCoordinates) {
            console.log(`[getTransformedCoords] INPUT: Raw canvas coords (${x.toFixed(1)}, ${y.toFixed(1)})`);
        }
        
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
        const position = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 };
        
        // If we have no image dimensions yet (blank canvas), return raw coordinates
        if (!window.originalImageDimensions[currentImageLabel]) {
            if (window.debugCoordinates) {
                console.log(`[getTransformedCoords] No image dimensions - returning raw coords as relative`);
            }
            return { x, y };
        }
        
        // We do have an image, so need to calculate relative coordinates
        const origDims = window.originalImageDimensions[currentImageLabel];
        const scaledWidth = origDims.width * scale;
        const scaledHeight = origDims.height * scale;
        
        // Base position is canvas center minus half the scaled image size
        const imageBaseX = (canvas.width - scaledWidth) / 2;
        const imageBaseY = (canvas.height - scaledHeight) / 2;
        
        // Final image position includes any panning offset
        const finalImageX = imageBaseX + position.x;
        const finalImageY = imageBaseY + position.y;
        
        // Convert the raw canvas coordinates to coordinates relative to the image
        const relativeX = (x - finalImageX) / scale;
        const relativeY = (y - finalImageY) / scale;
        
        if (window.debugCoordinates) {
            console.log(`[getTransformedCoords] Canvas size: ${canvas.width} × ${canvas.height}`);
            console.log(`[getTransformedCoords] Image scale: ${scale}, position: ${JSON.stringify(position)}`);
            console.log(`[getTransformedCoords] Original dimensions: ${JSON.stringify(origDims)}`);
            console.log(`[getTransformedCoords] Scaled dimensions: ${scaledWidth} × ${scaledHeight}`);
            console.log(`[getTransformedCoords] Image position: base(${imageBaseX.toFixed(1)}, ${imageBaseY.toFixed(1)}) + offset => final(${finalImageX.toFixed(1)}, ${finalImageY.toFixed(1)})`);
            console.log(`[getTransformedCoords] OUTPUT: Relative coords (${relativeX.toFixed(1)}, ${relativeY.toFixed(1)})`);
        }
        
        return { x: relativeX, y: relativeY };
    }

    /**
     * Converts relative image coordinates back to canvas coordinates
     * (Inverse of getTransformedCoords)
     * @param {number} imageX_relative - x-coordinate relative to the image
     * @param {number} imageY_relative - y-coordinate relative to the image
     * @returns {Object} Object with canvas x and y coordinates
     */
    function getCanvasCoords(imageX_relative, imageY_relative) {
        // Debug logging
        if (window.debugCoordinates) {
            console.log(`[getCanvasCoords] INPUT: Relative coords (${imageX_relative.toFixed(1)}, ${imageY_relative.toFixed(1)})`);
        }
        
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
        const position = window.imagePositionByLabel[currentImageLabel] || { x: 0, y: 0 };
        
        // If we have no image dimensions yet (blank canvas), return relative coords as-is
        if (!window.originalImageDimensions[currentImageLabel]) {
            if (window.debugCoordinates) {
                console.log(`[getCanvasCoords] No image dimensions - returning relative coords as canvas coords`);
            }
            return { x: imageX_relative, y: imageY_relative };
        }
        
        // We do have an image, calculate canvas coordinates from relative coords
        const origDims = window.originalImageDimensions[currentImageLabel];
        const scaledWidth = origDims.width * scale;
        const scaledHeight = origDims.height * scale;
        
        // Base position is canvas center minus half the scaled image size
        const imageBaseX = (canvas.width - scaledWidth) / 2;
        const imageBaseY = (canvas.height - scaledHeight) / 2;
        
        // Final image position includes any panning offset
        const finalImageX = imageBaseX + position.x;
        const finalImageY = imageBaseY + position.y;
        
        // Calculate final canvas coordinates from image-relative coordinates
        const canvasX = finalImageX + (imageX_relative * scale);
        const canvasY = finalImageY + (imageY_relative * scale);
        
        if (window.debugCoordinates) {
            console.log(`[getCanvasCoords] Canvas size: ${canvas.width} × ${canvas.height}`);
            console.log(`[getCanvasCoords] Image scale: ${scale}, position: ${JSON.stringify(position)}`);
            console.log(`[getCanvasCoords] Original dimensions: ${JSON.stringify(origDims)}`);
            console.log(`[getCanvasCoords] Scaled dimensions: ${scaledWidth} × ${scaledHeight}`);
            console.log(`[getCanvasCoords] Image position: base(${imageBaseX.toFixed(1)}, ${imageBaseY.toFixed(1)}) + offset => final(${finalImageX.toFixed(1)}, ${finalImageY.toFixed(1)})`);
            console.log(`[getCanvasCoords] OUTPUT: Canvas coords (${canvasX.toFixed(1)}, ${canvasY.toFixed(1)})`);
        }
        
        return { x: canvasX, y: canvasY };
    }

    function draw(e) {
        if (!isDrawing) return;

        console.log("--- Draw Event Start ---");
        console.log("[draw] Transform:", ctx.getTransform()); 

        // Get precise coordinates relative to the canvas
        const rect = canvas.getBoundingClientRect();
        const rawX = e.clientX - rect.left;
        const rawY = e.clientY - rect.top;
        console.log(`[draw] Raw mouse coords: (${rawX.toFixed(1)}, ${rawY.toFixed(1)})`);

        // Get current scale for potential use
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;

        if (drawingMode === 'straight' && straightLineStart) {
            // For straight line mode, just update the preview using raw coordinates
            const endPoint = { x: rawX, y: rawY };
            // Preview function handles restoring canvas and drawing temp line
            drawStraightLinePreview(straightLineStart, endPoint);
        } else {
            // For freehand drawing

            // --- STORE Image-Relative Coordinates ---
            const transformedCoords = getTransformedCoords(rawX, rawY);
            const relativeX = transformedCoords.x;
            const relativeY = transformedCoords.y;
            console.log(`[draw] Transformed to relative coords: (${relativeX.toFixed(1)}, ${relativeY.toFixed(1)})`);

            // Add the point to our current stroke data (vector) using RELATIVE coords
            const tempStrokeKey = '_drawingStroke';
            // Create the storage if not exists for the current image
            if (!window.vectorStrokesByImage[currentImageLabel]) {
                window.vectorStrokesByImage[currentImageLabel] = {};
            }
            // Create the array of vector points if not exists for this stroke
            if (!window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
                window.vectorStrokesByImage[currentImageLabel][tempStrokeKey] = [];
            }
            
            // Velocity-based width calculation for dynamic/pressure effect
            const now = performance.now();
            let dynamicWidth = parseInt(brushSize.value);
            
            if (lastDrawTime && !straightLineMode) {
                const velocity = calculateVelocity(lastX, lastY, rawX, rawY, now);
                const velocityFactor = Math.max(0.5, Math.min(1, 1 - velocity * velocitySensitivity.value));
                dynamicWidth = Math.max(1, Math.round(dynamicWidth * velocityFactor * scale));
                console.log(`[draw] Velocity: ${velocity.toFixed(2)}, Width: ${dynamicWidth}`);
            } else {
                dynamicWidth = Math.max(1, Math.round(dynamicWidth * scale));
                console.log(`[draw] Initial width: ${dynamicWidth}`);
            }

            // Add the point to our vector data for this stroke
            window.vectorStrokesByImage[currentImageLabel][tempStrokeKey].push({
                x: relativeX,
                y: relativeY,
                width: dynamicWidth,
                pressure: e.pressure || 1.0
            });

            // --- DRAW using Canvas Coordinates ---
            // For drawing, we convert the current AND previous relative coords back to canvas
            const currentPoint = window.vectorStrokesByImage[currentImageLabel][tempStrokeKey].length - 1;
            const currentRelative = window.vectorStrokesByImage[currentImageLabel][tempStrokeKey][currentPoint];
            const currentCanvasCoords = getCanvasCoords(currentRelative.x, currentRelative.y);
            
            console.log(`[draw] Current canvas coords for drawing: (${currentCanvasCoords.x.toFixed(1)}, ${currentCanvasCoords.y.toFixed(1)})`);

            if (currentPoint > 0) {
                const previousRelative = window.vectorStrokesByImage[currentImageLabel][tempStrokeKey][currentPoint-1];
                const previousCanvasCoords = getCanvasCoords(previousRelative.x, previousRelative.y);
                
                console.log(`[draw] Previous canvas coords for drawing: (${previousCanvasCoords.x.toFixed(1)}, ${previousCanvasCoords.y.toFixed(1)})`);
                console.log(`[draw] Drawing line segment from previous to current canvas coords`);

                // Now draw a line segment between the previous and current canvas coordinates
                ctx.lineWidth = currentRelative.width;
                ctx.strokeStyle = brushColor.value;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(previousCanvasCoords.x, previousCanvasCoords.y);
                ctx.lineTo(currentCanvasCoords.x, currentCanvasCoords.y);
                ctx.stroke();
            } else {
                // For the very first point, just draw a dot
                console.log(`[draw] Drawing initial dot at canvas coords`);
                
                ctx.fillStyle = brushColor.value;
                ctx.beginPath();
                ctx.arc(currentCanvasCoords.x, currentCanvasCoords.y, currentRelative.width / 2, 0, Math.PI * 2);
                ctx.fill();
            }

            lastX = rawX;
            lastY = rawY;
            lastDrawTime = now;
        }
        
        // Test round-trip coordinate conversion accuracy
        const roundTrip = getCanvasCoords(getTransformedCoords(rawX, rawY).x, getTransformedCoords(rawX, rawY).y);
        const roundTripError = Math.sqrt(Math.pow(roundTrip.x - rawX, 2) + Math.pow(roundTrip.y - rawY, 2));
        console.log(`[draw] Round-trip coordinate error: ${roundTripError.toFixed(2)} pixels`);
        console.log("--- Draw Event End ---");
    }
    
    // Function to draw straight line preview
    function drawStraightLinePreview(startPoint, endPoint) {
        console.log("--- Straight Line Preview Start ---");
        console.log(`[drawStraightLinePreview] Raw start: (${startPoint.x.toFixed(1)}, ${startPoint.y.toFixed(1)}), Raw end: (${endPoint.x.toFixed(1)}, ${endPoint.y.toFixed(1)})`);
        
        // Convert raw canvas points to image-relative coordinates
        const startRelative = getTransformedCoords(startPoint.x, startPoint.y);
        const endRelative = getTransformedCoords(endPoint.x, endPoint.y);
        
        console.log(`[drawStraightLinePreview] Relative start: (${startRelative.x.toFixed(1)}, ${startRelative.y.toFixed(1)}), Relative end: (${endRelative.x.toFixed(1)}, ${endRelative.y.toFixed(1)})`);
        
        // Convert back to canvas coordinates for drawing
        const drawStart = getCanvasCoords(startRelative.x, startRelative.y);
        const drawEnd = getCanvasCoords(endRelative.x, endRelative.y);
        
        console.log(`[drawStraightLinePreview] Canvas draw start: (${drawStart.x.toFixed(1)}, ${drawStart.y.toFixed(1)}), Canvas draw end: (${drawEnd.x.toFixed(1)}, ${drawEnd.y.toFixed(1)})`);
        
        // Get current scale for line width
        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
        const lineWidth = parseInt(brushSize.value) * scale;
        
        // Restore canvas to the state before our preview
        if (straightLinePreviewState) {
            ctx.putImageData(straightLinePreviewState, 0, 0);
        } else {
            // If no previous state, save the current one
            straightLinePreviewState = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
        
        // Draw the preview line
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = brushColor.value;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        ctx.beginPath();
        ctx.moveTo(drawStart.x, drawStart.y);
        ctx.lineTo(drawEnd.x, drawEnd.y);
        ctx.stroke();
        
        // Draw end cap circles for a smoother look
        ctx.fillStyle = brushColor.value;
        ctx.beginPath();
        ctx.arc(drawStart.x, drawStart.y, lineWidth / 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(drawEnd.x, drawEnd.y, lineWidth / 2, 0, Math.PI * 2);
        ctx.fill();
        
        console.log("--- Straight Line Preview End ---");
    }
    
    // Drawing mode toggle event listener
    drawingModeToggle.addEventListener('click', () => {
        if (drawingMode === 'freehand') {
            drawingMode = 'straight';
            drawingModeToggle.textContent = 'Straight Line';
            drawingModeToggle.classList.add('straight-mode');
        } else {
            drawingMode = 'freehand';
            drawingModeToggle.textContent = 'Freehand';
            drawingModeToggle.classList.remove('straight-mode');
        }
    });

    // Mouse drag variables for image movement
    let isDraggingImage = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    
    // Helper function to find if a point is inside a label
    function findLabelAtPoint(x, y) {
        for (const label of currentLabelPositions) {
            if (x >= label.x && x <= label.x + label.width &&
                y >= label.y && y <= label.y + label.height) {
                return label;
            }
        }
        return null;
    };
    
    // Mouse event listeners
    canvas.addEventListener('mousedown', (e) => {
        // Get correct mouse coordinates relative to canvas with Tailwind styling
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Check if clicked on a label
        const clickedLabel = findLabelAtPoint(x, y);
        if (clickedLabel) {
            // Toggle selection of the corresponding stroke
            const strokeLabel = clickedLabel.strokeLabel;
            const isCurrentlySelected = selectedStrokeByImage[currentImageLabel] === strokeLabel;
            
            // Update selection state
            if (isCurrentlySelected) {
                // Deselect if already selected
                selectedStrokeByImage[currentImageLabel] = null;
            } else {
                // Select if not already selected
                selectedStrokeByImage[currentImageLabel] = strokeLabel;
                
                // When selecting a stroke, ensure it's visible
                if (strokeVisibilityByImage[currentImageLabel] === undefined) {
                    strokeVisibilityByImage[currentImageLabel] = {};
                }
                strokeVisibilityByImage[currentImageLabel][strokeLabel] = true;
            }
            
            // Start dragging the label if it's selected
            if (selectedStrokeByImage[currentImageLabel] === strokeLabel) {
                isDraggingLabel = true;
                draggedLabelStroke = strokeLabel;
                dragStartX = x; // Store initial canvas click coords
                dragStartY = y;
                
                // We will calculate/update the offset in mousemove
                canvas.style.cursor = 'grabbing';
            }
            
            // Update the sidebar to show selection
            updateStrokeVisibilityControls();
            
            // Redraw canvas to reflect selection
            redrawCanvasWithVisibility();
            return;
        }
        
        // Try to detect if user clicked on a stroke directly, rather than its label
        const strokeData = checkForStrokeAtPoint(x, y);
        if (strokeData) {
            // Draw a white connector circle to anchor the start point instead of selecting the line
            // Save the state before starting a new stroke
            if (!strokeInProgress) {
                const currentState = getCanvasState();
                currentStroke = cloneImageData(currentState);
                // Save the state before we start drawing
                undoStackByImage[currentImageLabel].push({
                    state: cloneImageData(currentState),
                    type: 'pre-stroke',
                    label: null
                });
            }
            
            // Start drawing
            isDrawing = true;
            isDrawingOrPasting = true;
            strokeInProgress = true;
            points = [];
            lastVelocity = 0;
            lastDrawnPoint = null;
            [lastX, lastY] = [x, y]; // Store raw coordinates for potential future use if needed

            // Draw a glowing white connector circle at the start point
            const scale = imageScaleByLabel[currentImageLabel] || 1.0; // Get scale
            const baseRadius = parseInt(brushSize.value) / 2;
            const scaledRadius = baseRadius * scale;
            const glowPadding = 5; // Keep glow padding fixed for now

            ctx.beginPath();
            // Use scaled radius + fixed padding for glow circle
            ctx.arc(x, y, scaledRadius + glowPadding, 0, Math.PI * 2);

            // Create a white glow effect with a radial gradient using scaled radii
            const gradient = ctx.createRadialGradient(
                x, y, scaledRadius / 2, // Inner radius of gradient (scaled)
                x, y, scaledRadius + glowPadding // Outer radius of gradient (scaled + fixed padding)
            );
            gradient.addColorStop(0, 'white');
            gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = gradient;
            ctx.fill();

            // Then draw the colored dot for the actual start point
            ctx.beginPath();
            ctx.arc(x, y, scaledRadius, 0, Math.PI * 2); // Use scaled radius
            ctx.fillStyle = colorPicker.value;
            ctx.fill();

            if (drawingMode === 'straight') {
                // For straight line, store the start point
                straightLineStart = { x: x, y: y };

                // Also store the transformed coordinates for later consistency checks
                const transformed = getTransformedCoords(x, y);
                console.log(`Straight line start at canvas (${x}, ${y}) -> image (${transformed.x}, ${transformed.y})`);
            } else {
                // For freehand, add the first point using image-relative coordinates
                const { x: imgX, y: imgY } = getTransformedCoords(x, y);
                const firstPoint = {
                    x: imgX,             // Image space X
                    y: imgY,             // Image space Y
                    canvasX: x,          // Canvas space X
                    canvasY: y,          // Canvas space Y
                    time: Date.now()
                };
                points.push(firstPoint); // Keep raw coords here if needed for other logic?
                console.log("Mousedown: Added first point:", JSON.stringify(firstPoint));

                // Store the very first point in vector data immediately
                const tempStrokeKey = '_drawingStroke'; // Use temp key
                if (!vectorStrokesByImage[currentImageLabel]) {
                    vectorStrokesByImage[currentImageLabel] = {};
                }
                // Initialize the temporary stroke data
                vectorStrokesByImage[currentImageLabel][tempStrokeKey] = {
                    points: [{ x: imgX, y: imgY }], // Store only relative coords
                    color: colorPicker.value,
                    width: parseInt(brushSize.value), // Store base width without scaling
                    type: 'freehand'
                };
                console.log(`Mousedown: Initial vector data for ${tempStrokeKey}:`, JSON.stringify(vectorStrokesByImage[currentImageLabel][tempStrokeKey]));

                // *** Draw initial dot using calculated canvas coords ***
                const startCanvasCoords = getCanvasCoords(imgX, imgY);
                ctx.beginPath();
                const dotRadius = parseInt(brushSize.value) * scale / 2;
                ctx.arc(startCanvasCoords.x, startCanvasCoords.y, dotRadius, 0, Math.PI * 2);
                ctx.fillStyle = colorPicker.value;
                ctx.fill();
            }
            return; // Return early as we started drawing from the connector
        }

        // Handle image dragging with Shift key
        if (isShiftPressed) {
            isDraggingImage = true;
            lastMouseX = x;
            lastMouseY = y;
            canvas.style.cursor = 'grabbing';
            return;
        }

        // Handle drawing (default when Shift is not pressed)
        // Save the state before starting a new stroke
        if (!strokeInProgress) {
            // --- FIX: Save the state BEFORE setting drawing styles ---
            const currentState = getCanvasState();
            currentStroke = cloneImageData(currentState);
            undoStackByImage[currentImageLabel].push({
                state: cloneImageData(currentState),
                type: 'pre-stroke',
                label: null
            });
            // --- END FIX ---
        }

        // Start drawing
        isDrawing = true;
        isDrawingOrPasting = true;
        strokeInProgress = true;
        points = []; // Clear points array

        // *** Initialize last RAW coordinates ***
        lastRawX = x;
        lastRawY = y;

        // *** Calculate initial RELATIVE coordinates for storage ***
        const transformedCoords = getTransformedCoords(x, y);
        const startRelativeX = transformedCoords.x;
        const startRelativeY = transformedCoords.y;

        // *** DEBUG: Check coordinate round-trip ***
        const roundTripCanvasCoordsStart = getCanvasCoords(startRelativeX, startRelativeY);
        if (Math.abs(x - roundTripCanvasCoordsStart.x) > 0.1 || Math.abs(y - roundTripCanvasCoordsStart.y) > 0.1) {
            console.warn(`MOUSEDOWN ROUND TRIP MISMATCH! Raw: (${x.toFixed(2)}, ${y.toFixed(2)}), Relative: (${startRelativeX.toFixed(2)}, ${startRelativeY.toFixed(2)}), RoundTrip: (${roundTripCanvasCoordsStart.x.toFixed(2)}, ${roundTripCanvasCoordsStart.y.toFixed(2)})`);
        }

        // Clear temporary drawing data
        const tempStrokeKey = '_drawingStroke';
        if (window.vectorStrokesByImage[currentImageLabel]) {
             delete window.vectorStrokesByImage[currentImageLabel][tempStrokeKey];
        } else {
             window.vectorStrokesByImage[currentImageLabel] = {};
        }
        console.log("Cleared/Ensured temporary drawing data for key:", tempStrokeKey);

        // Set drawing styles AFTER saving state
        ctx.strokeStyle = colorPicker.value;
        ctx.fillStyle = colorPicker.value;
        const scale = imageScaleByLabel[currentImageLabel] || 1.0;
        ctx.lineWidth = parseInt(brushSize.value) * scale;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        if (drawingMode === 'straight') {
            // For straight line, store the RAW start point for the preview
            straightLineStart = { x: x, y: y };
            // Store the starting RELATIVE coordinate for the final vector data
            window.vectorStrokesByImage[currentImageLabel][tempStrokeKey] = {
                points: [{ x: startRelativeX, y: startRelativeY }],
                color: colorPicker.value,
                width: parseInt(brushSize.value), // Store base width
                type: 'straight'
            };
        } else {
            // For freehand, add first RELATIVE point to vector data
            window.vectorStrokesByImage[currentImageLabel][tempStrokeKey] = {
                points: [{ x: startRelativeX, y: startRelativeY }],
                color: colorPicker.value,
                width: parseInt(brushSize.value), // Store base width
                type: 'freehand'
            };

            // *** Draw a dot at the start point using CALCULATED canvas coordinates ***
            const startCanvasCoords = getCanvasCoords(startRelativeX, startRelativeY); // Already calculated above
            ctx.beginPath();
            const dotRadius = parseInt(brushSize.value) * scale / 2;
            ctx.arc(startCanvasCoords.x, startCanvasCoords.y, dotRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    });
    
    canvas.addEventListener('mousemove', function(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // Update debug cursor to match canvas-relative position
        const debugCursor = document.getElementById('debug-cursor');
        if (debugCursor) {
            // Use pageX/pageY for correct positioning with scroll
            debugCursor.style.left = `${e.pageX}px`;
            debugCursor.style.top = `${e.pageY}px`;
        }
        
        // Change cursor when hovering over labels
        if (!isDraggingLabel && !isDraggingImage && !isDrawing) {
            const hoveredLabel = findLabelAtPoint(x, y);
            canvas.style.cursor = hoveredLabel ? 'grab' : (isShiftPressed ? 'grab' : 'crosshair');
        }
        
        // Handle label dragging
        if (isDraggingLabel) {
            const currentX = x;
            const currentY = y;

            // Calculate canvas delta from the last position
            const deltaX = currentX - dragStartX;
            const deltaY = currentY - dragStartY;
            
            // Update start position for next move event
            dragStartX = currentX;
            dragStartY = currentY;
            
            // Ensure customLabelPositions structure exists
            if (!customLabelPositions[currentImageLabel]) customLabelPositions[currentImageLabel] = {};
            
            // Get the anchor point for the dragged label's stroke (current canvas coords)
            const vectorData = vectorStrokesByImage[currentImageLabel]?.[draggedLabelStroke];
            if (vectorData && vectorData.points.length > 0) {
                const midIndex = Math.floor(vectorData.points.length / 2);
                const midPointRelative = vectorData.points[midIndex];
                const anchorPoint = getCanvasCoords(midPointRelative.x, midPointRelative.y);

                // Get the current offset (custom or calculated) or calculate if first time dragging
                let currentOffset = customLabelPositions[currentImageLabel][draggedLabelStroke] || 
                                    calculatedLabelOffsets[currentImageLabel]?.[draggedLabelStroke];

                if (!currentOffset) {
                    // Calculate initial offset based on current drawn position if neither exists
                    const currentLabelRect = currentLabelPositions.find(l => l.strokeLabel === draggedLabelStroke);
                    if (currentLabelRect) {
                        currentOffset = {
                            x: currentLabelRect.x - anchorPoint.x,
                            y: currentLabelRect.y - anchorPoint.y
                        };
                         console.log(`Initialized drag offset from current rect for ${draggedLabelStroke}:`, currentOffset);
                    } else {
                        // Fallback if label wasn't found in current positions (shouldn't happen)
                        currentOffset = { x: 0, y: 0 }; 
                        console.warn(`Could not find current rect for ${draggedLabelStroke} during drag start.`);
                    }
                } else {
                    // Clone the offset object if it came from calculatedLabelOffsets 
                    // to avoid modifying the original calculated offset
                    currentOffset = { ...currentOffset };
                }

                // Update the relative offset by the canvas delta
                currentOffset.x += deltaX;
                currentOffset.y += deltaY;
                
                // Store the updated offset in customLabelPositions (always overwrites calculated)
                customLabelPositions[currentImageLabel][draggedLabelStroke] = currentOffset;
                 console.log(`Storing updated custom offset for ${draggedLabelStroke}:`, currentOffset);

                // Remove canvas boundary clamping
                // pos.x = Math.max(10, Math.min(canvas.width - labelToMove.width - 10, pos.x));
                // pos.y = Math.max(10, Math.min(canvas.height - labelToMove.height - 10, pos.y));
                
                // Redraw with the new position
                redrawCanvasWithVisibility();
            }
            return; // Return early as we handled label dragging
        }
        
        if (isDraggingImage) {
            const deltaX = x - lastMouseX;
            const deltaY = y - lastMouseY;
            lastMouseX = x;
            lastMouseY = y;
            
            moveImage(deltaX, deltaY);
            return;
        }
        
        if (!isDrawing) return;
        
        if (drawingMode === 'straight' && straightLineStart) {
            // Handle straight line preview
            // restore the original state
            if (currentStroke) {
                restoreCanvasState(currentStroke);
            }
            // draw the preview line
            drawStraightLinePreview(straightLineStart, { x: x, y: y });
        } else if (drawingMode === 'freehand') {
            // Handle freehand drawing
            draw(e, x, y);
        }
    });

    canvas.addEventListener('mouseup', function(e) {
        if (isDraggingLabel) {
            isDraggingLabel = false;
            draggedLabelStroke = null;
            canvas.style.cursor = 'grab';
            return;
        }

        if (isDraggingImage) {
            isDraggingImage = false;
            canvas.style.cursor = isShiftPressed ? 'grab' : 'crosshair';
            return;
        }

        if (isDrawing) {
            // For straight line, finalize the line
            if (drawingMode === 'straight' && straightLineStart) {
                // *** Standardize coordinate calculation ***
                const rect = canvas.getBoundingClientRect();
                const endPoint = { x: e.clientX - rect.left, y: e.clientY - rect.top };

                // Only save the line if the start and end points are different
                if (Math.abs(straightLineStart.x - endPoint.x) > 2 ||
                    Math.abs(straightLineStart.y - endPoint.y) > 2) {

                    // Check if end point is on another stroke
                    const endPointStrokeData = checkForStrokeAtPoint(endPoint.x, endPoint.y);

                    // --- MODIFIED: Store vector data temporarily ---
                    const tempStrokeKey = '_drawingStroke';
                    const strokeColor = colorPicker.value;
                    const strokeWidth = parseInt(brushSize.value);

                    // Initialize if needed
                    if (!window.vectorStrokesByImage[currentImageLabel]) {
                        window.vectorStrokesByImage[currentImageLabel] = {};
                    }

                    // Get transformed coordinates
                    const startTransformed = getTransformedCoords(straightLineStart.x, straightLineStart.y);
                    const endTransformed = getTransformedCoords(endPoint.x, endPoint.y);

                    console.log(`Straight line from canvas (${straightLineStart.x}, ${straightLineStart.y}) -> image (${startTransformed.x}, ${startTransformed.y})`);
                    console.log(`Straight line to canvas (${endPoint.x}, ${endPoint.y}) -> image (${endTransformed.x}, ${endTransformed.y})`);

                    // *** DEBUG: Check coordinate round-trip ***
                    const roundTripCanvasStart = getCanvasCoords(startTransformed.x, startTransformed.y);
                    const roundTripCanvasEnd = getCanvasCoords(endTransformed.x, endTransformed.y);
                    if (Math.abs(straightLineStart.x - roundTripCanvasStart.x) > 0.1 || Math.abs(straightLineStart.y - roundTripCanvasStart.y) > 0.1) {
                         console.warn(`MOUSEUP (Straight Start) ROUND TRIP MISMATCH! Raw: (${straightLineStart.x.toFixed(2)}, ${straightLineStart.y.toFixed(2)}), Relative: (${startTransformed.x.toFixed(2)}, ${startTransformed.y.toFixed(2)}), RoundTrip: (${roundTripCanvasStart.x.toFixed(2)}, ${roundTripCanvasStart.y.toFixed(2)})`);
                    }
                    if (Math.abs(endPoint.x - roundTripCanvasEnd.x) > 0.1 || Math.abs(endPoint.y - roundTripCanvasEnd.y) > 0.1) {
                        console.warn(`MOUSEUP (Straight End) ROUND TRIP MISMATCH! Raw: (${endPoint.x.toFixed(2)}, ${endPoint.y.toFixed(2)}), Relative: (${endTransformed.x.toFixed(2)}, ${endTransformed.y.toFixed(2)}), RoundTrip: (${roundTripCanvasEnd.x.toFixed(2)}, ${roundTripCanvasEnd.y.toFixed(2)})`);
                    }

                    // Create a vector representation under the temporary key
                    // Ensure points array exists if overwriting
                    if (!window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
                         window.vectorStrokesByImage[currentImageLabel][tempStrokeKey] = { points: [] };
                    }
                    window.vectorStrokesByImage[currentImageLabel][tempStrokeKey].points = [
                            { x: startTransformed.x, y: startTransformed.y },
                            { x: endTransformed.x, y: endTransformed.y }
                        ];
                    window.vectorStrokesByImage[currentImageLabel][tempStrokeKey].color = strokeColor;
                    window.vectorStrokesByImage[currentImageLabel][tempStrokeKey].width = strokeWidth;
                    window.vectorStrokesByImage[currentImageLabel][tempStrokeKey].type = 'straight';

                    console.log(`Stored straight line data temporarily under ${tempStrokeKey}`);
                    // --- END MODIFICATION ---

                    // Draw the final line using the raw preview function (which uses raw coords)
                    drawStraightLinePreview(straightLineStart, endPoint);

                    // If end point overlaps with another line, draw a glowing circle
                    if (endPointStrokeData) {
                        const scale = imageScaleByLabel[currentImageLabel] || 1.0;
                        const baseRadius = parseInt(brushSize.value) / 2;
                        const scaledRadius = baseRadius * scale;
                        const glowPadding = 5;
                        // ... (glowing circle drawing code remains the same, uses raw endPoint) ...
                        ctx.beginPath();
                        ctx.arc(endPoint.x, endPoint.y, scaledRadius + glowPadding, 0, Math.PI * 2);
                        const gradient = ctx.createRadialGradient(
                            endPoint.x, endPoint.y, scaledRadius / 2,
                            endPoint.x, endPoint.y, scaledRadius + glowPadding
                        );
                        gradient.addColorStop(0, 'white');
                        gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.8)');
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        ctx.fillStyle = gradient;
                        ctx.fill();

                        ctx.beginPath();
                        ctx.arc(endPoint.x, endPoint.y, scaledRadius, 0, Math.PI * 2);
                        ctx.fillStyle = strokeColor;
                        ctx.fill();
                    }
                }

                // Reset straight line start
                straightLineStart = null;
            } else if (drawingMode === 'freehand' /*&& points.length > 0*/) { // Check if drawing, not points array length
                // Handle freehand drawing completion
                // Vector data is already stored correctly in _drawingStroke by the 'draw' function

                // Check if the last point of the freehand stroke is on another stroke
                const tempStrokeKey = '_drawingStroke';
                const strokeVectorData = window.vectorStrokesByImage[currentImageLabel]?.[tempStrokeKey];
                if (strokeVectorData && strokeVectorData.points.length > 0) {
                    const lastRelativePoint = strokeVectorData.points[strokeVectorData.points.length - 1];
                    // Need canvas coords for check
                    const lastCanvasCoords = getCanvasCoords(lastRelativePoint.x, lastRelativePoint.y);
                    const endPointStrokeData = checkForStrokeAtPoint(lastCanvasCoords.x, lastCanvasCoords.y);

                    // If end point overlaps with another line, draw a glowing circle
                    if (endPointStrokeData) {
                        const scale = imageScaleByLabel[currentImageLabel] || 1.0;
                        const baseRadius = parseInt(brushSize.value) / 2;
                        const scaledRadius = baseRadius * scale;
                        const glowPadding = 5;

                        ctx.beginPath();
                        // Use calculated canvas coords for glow circle
                        ctx.arc(lastCanvasCoords.x, lastCanvasCoords.y, scaledRadius + glowPadding, 0, Math.PI * 2);

                        const gradient = ctx.createRadialGradient(
                            lastCanvasCoords.x, lastCanvasCoords.y, scaledRadius / 2,
                            lastCanvasCoords.x, lastCanvasCoords.y, scaledRadius + glowPadding
                        );
                        gradient.addColorStop(0, 'white');
                        gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.8)');
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        ctx.fillStyle = gradient;
                        ctx.fill();

                        ctx.beginPath();
                        ctx.arc(lastCanvasCoords.x, lastCanvasCoords.y, scaledRadius, 0, Math.PI * 2);
                        ctx.fillStyle = colorPicker.value;
                        ctx.fill();
                    }
                }

                // Reset points array (if used)
                // points = []; // Not strictly necessary now as we draw from vector data
                // lastVelocity = 0;
                // lastDrawnPoint = null;
            }

            isDrawing = false;
            isDrawingOrPasting = false;
            strokeInProgress = false;

            // Make sure the current state is captured before saving
            // const finalState = getCanvasState(); // Let saveState handle getting state

            // Save state immediately after stroke completion and increment label
            // saveState will handle moving data from _drawingStroke to the correct unique label
            saveState(true, true);

            // Update the sidebar visibility controls
            updateStrokeVisibilityControls();

            // Force redraw to show labels immediately
            redrawCanvasWithVisibility();
        }
    });
    
    canvas.addEventListener('mouseout', () => {
        if (isDraggingLabel) {
            isDraggingLabel = false;
            draggedLabelStroke = null;
            canvas.style.cursor = 'grab';
            return;
        }
        
        if (isDraggingImage) {
            isDraggingImage = false;
            canvas.style.cursor = isShiftPressed ? 'grab' : 'crosshair';
            return;
        }
        
        if (isDrawing) {
            isDrawing = false;
            isDrawingOrPasting = false;
            strokeInProgress = false;
            
            // For straight line, cancel the operation if mouse leaves canvas
            if (drawingMode === 'straight') {
                // If we have a valid start point, restore to previous state
                if (straightLineStart && currentStroke) {
                    restoreCanvasState(currentStroke);
                }
                straightLineStart = null;
            }
            
            // Save state immediately after stroke completion and increment label
            saveState(true, true);
            
            // Force redraw to show labels immediately
            redrawCanvasWithVisibility();
        }
    });
    
    // Track shift key for image movement
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Shift') {
            isShiftPressed = true;
            if (!isDrawing && !isDraggingImage) {
                canvas.style.cursor = 'grab';
            }
        }
    });
    
    document.addEventListener('keyup', (e) => {
        if (e.key === 'Shift') {
            isShiftPressed = false;
            if (!isDrawing && !isDraggingImage) {
                canvas.style.cursor = 'crosshair';
            }
        }
    });
    
    // Function to switch to a different image
    // Make switchToImage available globally
    window.switchToImage = switchToImage;
    function switchToImage(label) {
        if (currentImageLabel === label) return;
        
        console.log(`Switching from ${currentImageLabel} to ${label}`);
        
        // Save current state before switching
        const currentStrokes = [...(lineStrokesByImage[currentImageLabel] || [])];
        const currentState = getCanvasState();
        
        // Create a snapshot state that includes the strokes list
        undoStackByImage[currentImageLabel].push({
            state: cloneImageData(currentState),
            type: 'snapshot',
            strokes: currentStrokes
        });
        
        // Update current image label
        currentImageLabel = label;
        
        // Restore state for the new image
        if (imageStates[label]) {
            restoreCanvasState(imageStates[label]);
            console.log(`Restored cached state for ${label}`);
            // Ensure we redraw with visibility to show strokes and labels correctly
            redrawCanvasWithVisibility();
        } else if (window.originalImages[label]) {
            // If no state exists but we have the original image, paste it
            console.log(`No state exists for ${label}, pasting original image: ${window.originalImages[label].substring(0, 30)}...`);
            pasteImageFromUrl(window.originalImages[label], label);
        } else {
            // Clear canvas if no state or original image exists
            console.log(`No state or image found for ${label}, clearing canvas`);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Still do a redraw to ensure any strokes are shown
            redrawCanvasWithVisibility();
        }
        
        // Update UI
        updateActiveImageInSidebar();
        updateStrokeCounter();
        updateStrokeVisibilityControls();
        
        // Update scale UI to reflect the current image's scale
        updateScaleUI();
    }
    
    function updateActiveImageInSidebar() {
        // Update which image is active in the sidebar
        document.querySelectorAll('.image-container').forEach(container => {
            if (container.dataset.label === currentImageLabel) {
                container.classList.add('active');
            } else {
                container.classList.remove('active');
            }
        });
    }
    
    // Handle Ctrl+Z for undo and Ctrl+Y for redo
    document.addEventListener('keydown', (e) => {
        // Handle undo (Ctrl+Z)
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !isDrawingOrPasting) {
            e.preventDefault();
            console.log('Ctrl+Z pressed, executing undo');
            
            // Make sure we have valid undo stacks
            if (!undoStackByImage[currentImageLabel]) {
                undoStackByImage[currentImageLabel] = [];
                console.log(`Created new undo stack for ${currentImageLabel}`);
            }
            
            // Make sure we have valid stroke lists
            if (!lineStrokesByImage[currentImageLabel]) {
                lineStrokesByImage[currentImageLabel] = [];
                console.log(`Created new stroke list for ${currentImageLabel}`);
            }
            
            // Make sure we have valid redo stacks
            if (!redoStackByImage[currentImageLabel]) {
                redoStackByImage[currentImageLabel] = [];
            }
            
            // Force a redraw after undo to ensure visual consistency
            const performUndo = async () => {
                undo();
                // Small delay to ensure state is updated
                await new Promise(resolve => setTimeout(resolve, 10));
                // Force redraw by restoring current state
                if (imageStates[currentImageLabel]) {
                    restoreCanvasState(imageStates[currentImageLabel]);
                }
                // Update visibility controls after undo
                updateStrokeVisibilityControls();
            };
            
            performUndo();
        }
        
        // Handle redo (Ctrl+Y)
        if ((e.ctrlKey || e.metaKey) && e.key === 'y' && !isDrawingOrPasting) {
            e.preventDefault();
            console.log('Ctrl+Y pressed, executing redo');
            
            // Make sure we have valid redo stacks
            if (!redoStackByImage[currentImageLabel]) {
                redoStackByImage[currentImageLabel] = [];
                console.log(`Created new redo stack for ${currentImageLabel}`);
            }
            
            // Force a redraw after redo to ensure visual consistency
            const performRedo = async () => {
                redo();
                // Small delay to ensure state is updated
                await new Promise(resolve => setTimeout(resolve, 10));
                
                // Force redraw with visibility to ensure labels appear immediately
                redrawCanvasWithVisibility();
                
                // Make sure we restore proper label visibility settings for any redone strokes
                if (lineStrokesByImage[currentImageLabel]?.length > 0) {
                    const strokes = lineStrokesByImage[currentImageLabel];
                    for (const strokeLabel of strokes) {
                        // Make sure label visibility is initialized properly
                        if (strokeLabelVisibility[currentImageLabel] === undefined) {
                            strokeLabelVisibility[currentImageLabel] = {};
                        }
                        if (strokeLabelVisibility[currentImageLabel][strokeLabel] === undefined) {
                            strokeLabelVisibility[currentImageLabel][strokeLabel] = true;
                        }
                    }
                }
                
                // Update all UI elements to ensure synchronized state
                updateStrokeCounter();
                updateStrokeVisibilityControls();
                updateSidebarStrokeCounts();
            };
            
            performRedo();
        }
    });
    
    // Clear canvas (but keep the background image)
    clearButton.addEventListener('click', () => {
        // Save the current state before clearing
        const currentState = getCanvasState();
        undoStackByImage[currentImageLabel].push({
            state: cloneImageData(currentState),
            type: 'clear',
            label: null
        });
        
        // Clear the selected stroke
        selectedStrokeByImage[currentImageLabel] = null;
        
        // Instead of just clearing the canvas, redraw the original image if available
        if (window.originalImages[currentImageLabel]) {
            const img = new Image();
            img.onload = () => {
                // Clear the canvas first
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Get the current scale
                const scale = imageScaleByLabel[currentImageLabel];
                const scaledWidth = img.width * scale;
                const scaledHeight = img.height * scale;
                
                // Calculate base position (center of canvas)
                const centerX = (canvas.width - scaledWidth) / 2;
                const centerY = (canvas.height - scaledHeight) / 2;
                
                // Apply position offset
                const offsetX = window.imagePositionByLabel[currentImageLabel].x;
                const offsetY = window.imagePositionByLabel[currentImageLabel].y;
                
                // Calculate final position
                const x = centerX + offsetX;
                const y = centerY + offsetY;
                
                // Draw the original image with scale and position
                ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                
                // Save this as the new state
                const newState = getCanvasState();
                imageStates[currentImageLabel] = cloneImageData(newState);
                currentStroke = cloneImageData(newState);
                
                // Reset other states
                lineStrokesByImage[currentImageLabel] = [];
                labelsByImage[currentImageLabel] = 'A1';  // Reset to A1
                
                // Clear visibility controls
                strokeVisibilityByImage[currentImageLabel] = {};
                strokeDataByImage[currentImageLabel] = {};
                
                // Clear label position offsets
                if (customLabelPositions[currentImageLabel]) {
                    delete customLabelPositions[currentImageLabel];
                }
                if (calculatedLabelOffsets[currentImageLabel]) {
                    delete calculatedLabelOffsets[currentImageLabel];
                }
                
                // Update UI
                updateStrokeCounter();
            };
            img.src = originalImages[currentImageLabel];
        } else {
            // If no original image, just clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Reset state for this image
            const blankState = getCanvasState();
            imageStates[currentImageLabel] = blankState;
            currentStroke = cloneImageData(blankState);
            lineStrokesByImage[currentImageLabel] = [];
            labelsByImage[currentImageLabel] = 'A1';  // Reset to A1
            
            // Clear visibility controls
            strokeVisibilityByImage[currentImageLabel] = {};
            strokeDataByImage[currentImageLabel] = {};
            
            // Clear label position offsets
            if (customLabelPositions[currentImageLabel]) {
                delete customLabelPositions[currentImageLabel];
            }
            if (calculatedLabelOffsets[currentImageLabel]) {
                delete calculatedLabelOffsets[currentImageLabel];
            }
            
            // Update UI
            updateStrokeCounter();
        }
    });
    
    // Save canvas
    saveButton.addEventListener('click', () => {
        const projectName = document.getElementById('projectName').value || 'New Sofa';
        const unit = document.getElementById('unitSelector').value || 'inch';
        
        // Create filename using project name, view, and unit
        // Replace spaces with underscores
        const sanitizedName = projectName.replace(/\s+/g, '_');
        const filename = `${sanitizedName}_${currentImageLabel}_${unit}.png`;
        
        const link = document.createElement('a');
        link.download = filename;
        link.href = canvas.toDataURL();
        link.click();
    });
    
    // Determine the best label for an image based on its filename
    function getLabelFromFilename(filename) {
        filename = filename.toLowerCase();
        
        if (filename.includes('front')) {
            return 'front';
        } else if (filename.includes('side')) {
            return 'side';
        } else if (filename.includes('back')) {
            return 'back';
        } else if (filename.includes('cushion')) {
            return 'cushion';
        } else {
            // If no matching keywords, find next available label
            for (const label of IMAGE_LABELS) {
                if (!window.originalImages[label]) {
                    return label;
                }
            }
            return IMAGE_LABELS[0]; // Default to front if all are taken
        }
    }
    
    // Handle file drop
    const handleFiles = (files) => {
        // Convert FileList to Array for easier manipulation
        const fileArray = Array.from(files);
        
        // Sort files to prioritize ones with matching keywords
        const sortedFiles = fileArray.sort((a, b) => {
            const aName = a.name.toLowerCase();
            const bName = b.name.toLowerCase();
            
            // Define priority order for keywords
            const keywordOrder = ['front', 'side', 'back', 'cushion'];
            
            // Find the first keyword that matches for each file
            const aKeyword = keywordOrder.find(keyword => aName.includes(keyword)) || '';
            const bKeyword = keywordOrder.find(keyword => bName.includes(keyword)) || '';
            
            // Get the index of each keyword
            const aIndex = keywordOrder.indexOf(aKeyword);
            const bIndex = keywordOrder.indexOf(bKeyword);
            
            // Sort by keyword index (if both have matching keywords)
            if (aIndex >= 0 && bIndex >= 0) {
                return aIndex - bIndex;
            }
            
            // Prioritize files with matching keywords
            if (aIndex >= 0) return -1;
            if (bIndex >= 0) return 1;
            
            // Sort alphabetically for files without matching keywords
            return aName.localeCompare(bName);
        });
        
        // Process each file
        sortedFiles.forEach(file => {
            if (file.type.indexOf('image') !== -1) {
                const url = URL.createObjectURL(file);
                const label = getLabelFromFilename(file.name);
                
                console.log(`Processing file ${file.name} as ${label}`);
                
                // Add to sidebar (replace existing if the label is already taken)
                const existingContainer = document.querySelector(`.image-container[data-label="${label}"]`);
                if (existingContainer) {
                    existingContainer.remove();
                }
                
                addImageToSidebar(url, label);
                
                // Store the image URL
                if (!pastedImages.includes(url)) {
                    pastedImages.push(url);
                }
                window.originalImages[label] = url;
                
                // Clear any previous state for this label
                imageStates[label] = null;
                undoStackByImage[label] = [];
                lineStrokesByImage[label] = [];
                labelsByImage[label] = 'A1';
                
                // If this is the first image, switch to it and paste it
                if (pastedImages.length === 1 || label === 'front') {
                    currentImageLabel = label;
                    pasteImageFromUrl(url, label);
                }
            }
        });
        
        // Update UI
        updateStrokeCounter();
        updateSidebarStrokeCounts();
        updateActiveImageInSidebar();
        updateStrokeVisibilityControls();
    };
    
    // Set up drag and drop events
    const setupDragAndDrop = () => {
        const dropZone = canvas;
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('drag-over');
        });
        
        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('drag-over');
            
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                handleFiles(e.dataTransfer.files);
            }
        });
    };
    
    // Initialize drag and drop
    setupDragAndDrop();
    
    // Handle paste from clipboard
    document.addEventListener('paste', (e) => {
        const items = e.clipboardData.items;
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                const blob = item.getAsFile();
                const url = URL.createObjectURL(blob);
                
                // Assign to the first available label
                let label;
                for (const availableLabel of IMAGE_LABELS) {
                    if (!window.originalImages[availableLabel]) {
                        label = availableLabel;
                        break;
                    }
                }
                
                // If all labels are taken, use the current label
                if (!label) {
                    label = currentImageLabel;
                }
                
                // Add to sidebar
                const existingContainer = document.querySelector(`.image-container[data-label="${label}"]`);
                if (existingContainer) {
                    existingContainer.remove();
                }
                
                addImageToSidebar(url, label);
                
                // Store the image URL
                if (!pastedImages.includes(url)) {
                    pastedImages.push(url);
                }
                window.originalImages[label] = url;
                
                // Switch to this image and paste it
                currentImageLabel = label;
                
                // Clear any previous state for this label
                imageStates[label] = null;
                undoStackByImage[label] = [];
                lineStrokesByImage[label] = [];
                labelsByImage[label] = 'A1';
                
                // Paste the image
                pasteImageFromUrl(url, label);
                
                // Update UI
                updateStrokeCounter();
                updateSidebarStrokeCounts();
                updateActiveImageInSidebar();
                updateStrokeVisibilityControls();
            }
        }
    });
    
    // Handle paste button click
    pasteButton.addEventListener('click', () => {
        // Create an input element for file selection
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.multiple = true;
        fileInput.accept = 'image/*';
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files.length > 0) {
                handleFiles(e.target.files);
            }
        });
        
        // Trigger file selection dialog
        fileInput.click();
    });
    
    // Initialize the stroke visibility controls
    updateStrokeVisibilityControls();
    
    // Handle image scaling
    function updateScaleButtonsActiveState() {
        // Remove active class from all scale buttons
        document.querySelectorAll('.scale-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Add active class to the current scale button
        const currentScale = imageScaleByLabel[currentImageLabel];
        const activeButton = document.querySelector(`.scale-btn[data-scale="${currentScale}"]`);
        if (activeButton) {
            activeButton.classList.add('active');
        }
    }
    
    function updateImageScale(newScale) {
        // Update scale for current image
        const oldScale = imageScaleByLabel[currentImageLabel];
        console.log(`[updateImageScale] Changing scale for ${currentImageLabel} from ${oldScale} to ${newScale}`);

        // --- Refinement: Ensure state is saved BEFORE scale change --- 
        // Save current state (using OLD scale) before redrawing
        // const previousState = getCanvasState(); // Don't get state here, rely on redraw
        // undoStackByImage[currentImageLabel].push({ // Don't push state here, let redraw handle it
        //     state: cloneImageData(previousState),
        //     type: 'scale',
        //     label: null
        // });
        // --- End Refinement ---
        
        // *** SET the new scale ***
        imageScaleByLabel[currentImageLabel] = newScale;

        // Redraw the canvas (image and/or strokes) with the NEW scale
        // redrawCanvasWithVisibility will handle saving the final state
        redrawCanvasWithVisibility();

        // Update the scale display in the sidebar (if the element exists)
        const scaleElement = document.getElementById(`scale-${currentImageLabel}`);
        if (scaleElement) {
            scaleElement.textContent = `Scale: ${Math.round(newScale * 100)}%`;
        }
        
        // Update UI
        updateScaleButtonsActiveState();
    }
    
    // Initialize scale option click handlers
    document.querySelectorAll('.scale-option').forEach(option => {
        option.addEventListener('click', () => {
            const scale = parseFloat(option.dataset.scale);
            if (!isNaN(scale)) {
                updateImageScale(scale);
                // Update dropdown button text
                const scaleButton = document.getElementById('scaleButton');
                if (scaleButton) {
                    scaleButton.textContent = `Scale: ${Math.round(scale * 100)}% ▼`;
                }
                // --- FIX: Close the dropdown ---
                const dropdownContent = option.closest('.dropdown-content');
                if (dropdownContent) {
                    // Assuming Tailwind controls visibility, e.g., with 'hidden' class
                    // Or potentially inline style 'display: none'
                    // We need a consistent way to hide it. Let's try adding/removing 'hidden'.
                    // We might need a more robust toggle later.
                    dropdownContent.classList.add('hidden'); 
                }
                // --- END FIX ---
            }
        });
    });

    // --- ADD: Add click listener to the scale button to toggle dropdown visibility ---
    const scaleButton = document.getElementById('scaleButton');
    if (scaleButton) {
        scaleButton.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent closing immediately if clicking button re-triggers document listener
            const dropdownContent = scaleButton.nextElementSibling; // Assumes .dropdown-content is the next sibling
            if (dropdownContent && dropdownContent.classList.contains('dropdown-content')) {
                dropdownContent.classList.toggle('hidden');
            }
        });
    }

    // --- ADD: Close dropdown if clicking outside ---
    document.addEventListener('click', (event) => {
        const scaleDropdown = document.querySelector('.scale-dropdown');
        const dropdownContent = document.querySelector('.scale-dropdown .dropdown-content');
        if (scaleDropdown && dropdownContent && !scaleDropdown.contains(event.target)) {
            dropdownContent.classList.add('hidden');
        }
    });
    // --- END ADD ---

    // Initialize color palette buttons
    const colorButtons = document.querySelectorAll('.color-btn');
    colorButtons.forEach(button => {
        button.addEventListener('click', () => {
            // Remove active class from all buttons
            colorButtons.forEach(btn => btn.classList.remove('active'));
            
            // Add active class to clicked button
            button.classList.add('active');
            
            // Set the drawing color
            const color = button.dataset.color;
            colorPicker.value = color;
        });
    });
    
    // Function to move the image and its strokes
    function moveImage(deltaX, deltaY) {
        // Update position offset
        if (!imagePositionByLabel[currentImageLabel]) {
            imagePositionByLabel[currentImageLabel] = { x: 0, y: 0 };
        }
        imagePositionByLabel[currentImageLabel].x += deltaX;
        imagePositionByLabel[currentImageLabel].y += deltaY;
        
            // Save current state before moving
            const currentState = getCanvasState();
            undoStackByImage[currentImageLabel].push({
                state: cloneImageData(currentState),
                type: 'move',
                label: null
            });
            
        // Redraw the canvas (image and/or strokes) with updated position
            redrawCanvasWithVisibility();
    }
    
    // Handle WASD and zoom keyboard controls
    document.addEventListener('keydown', (e) => {
        // Don't process if user is typing in an input field
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }
        
        // Zoom controls
        if (e.key === 'q' || e.key === 'Q') {
            // Zoom out - find the next smaller scale
            const currentScale = imageScaleByLabel[currentImageLabel];
            const scales = [0.1, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 2];
            let nextScale = 0.1; // Minimum scale
            
            for (let i = scales.length - 1; i >= 0; i--) {
                if (scales[i] < currentScale) {
                    nextScale = scales[i];
                    break;
                }
            }
            
            updateImageScale(nextScale);
            const scaleButton = document.getElementById('scaleButton');
            if (scaleButton) {
                scaleButton.textContent = `Scale: ${Math.round(nextScale * 100)}% ▼`;
            }
        } else if (e.key === 'e' || e.key === 'E') {
            // Zoom in - find the next larger scale
            const currentScale = imageScaleByLabel[currentImageLabel];
            const scales = [0.1, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 2];
            let nextScale = 2; // Maximum scale
            
            for (let i = 0; i < scales.length; i++) {
                if (scales[i] > currentScale) {
                    nextScale = scales[i];
                    break;
                }
            }
            
            updateImageScale(nextScale);
            const scaleButton = document.getElementById('scaleButton');
            if (scaleButton) {
                scaleButton.textContent = `Scale: ${Math.round(nextScale * 100)}% ▼`;
            }
        }
        
        // Movement controls with inverted W/S as requested
        const moveStep = 10; // Pixels to move per keypress
        
        if (e.key === 'w' || e.key === 'W') {
            moveImage(0, moveStep); // Move DOWN (inverted)
        } else if (e.key === 'd' || e.key === 'D') {
            moveImage(-moveStep, 0); // Move left
        } else if (e.key === 's' || e.key === 'S') {
            moveImage(0, -moveStep); // Move UP (inverted)
        } else if (e.key === 'a' || e.key === 'A') {
            moveImage(moveStep, 0); // Move right
        }
    });
    
    // Update active scale option on image change
    function updateScaleUI() {
        updateScaleButtonsActiveState();
        
        // Update dropdown button text
        const scale = imageScaleByLabel[currentImageLabel];
        const scaleButton = document.getElementById('scaleButton');
        if (scaleButton) {
            scaleButton.textContent = `Scale: ${Math.round(scale * 100)}% ▼`;
        }
    }
    
    updateScaleUI();
    
    // Make sidebars draggable
    function makeDraggable(element, handle) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        
        handle.onmousedown = dragMouseDown;
        
        function dragMouseDown(e) {
            e.preventDefault();
            // Get the mouse cursor position at startup
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            // Call a function whenever the cursor moves
            document.onmousemove = elementDrag;
        }
        
        function elementDrag(e) {
            e.preventDefault();
            // Calculate the new cursor position
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            // Set the element's new position
            element.style.top = (element.offsetTop - pos2) + "px";
            element.style.left = (element.offsetLeft - pos1) + "px";
            
            // Remove right position if we're dragging the image sidebar
            if (element === imageSidebar) {
                element.style.right = 'auto';
            }
        }
        
        function closeDragElement() {
            // Stop moving when mouse button is released
            document.onmouseup = null;
            document.onmousemove = null;
        }
    }
    
    // Make both sidebars draggable
    makeDraggable(strokeSidebar, strokeSidebarHeader);
    makeDraggable(imageSidebar, imageSidebarHeader);
    
    // Adjust canvas size when window resizes to account for sidebars
    window.addEventListener('resize', () => {
        resizeCanvas();
        
        // Check if sidebars are overlapping canvas and adjust if needed
        const canvasRect = canvas.getBoundingClientRect();
        const imageSidebarRect = imageSidebar.getBoundingClientRect();
        const strokeSidebarRect = strokeSidebar.getBoundingClientRect();
        
        // If image sidebar is overlapping canvas on the right
        if (imageSidebarRect.left < canvasRect.right) {
            imageSidebar.style.left = 'auto';
            imageSidebar.style.right = '20px';
        }
        
        // If stroke sidebar is overlapping canvas on the left
        if (strokeSidebarRect.right > canvasRect.left) {
            strokeSidebar.style.left = '20px';
        }
    });

    // Function to find an optimal position for a label
    function findOptimalLabelPosition(labelRect, anchorPoint, strokeInfo) {
        // Parameters for positioning
        const MAX_TRIES = 12;
        const MAX_DISTANCE = 150; // Maximum distance from anchor point
        const MIN_DISTANCE = 30;  // Minimum distance from anchor point

        // Create a copy of the initial rect
        let bestRect = { ...labelRect };
        let bestScore = -Infinity;
        
        // Keep track of how many other labels each position would impact
        let bestImpactCount = Infinity;
        
        // Try different positions in a radial pattern
        for (let angle = 0; angle < 360; angle += 30) {
            for (let distance = MIN_DISTANCE; distance <= MAX_DISTANCE; distance += 20) {
                const radians = angle * (Math.PI / 180);
                const offsetX = Math.cos(radians) * distance;
                const offsetY = Math.sin(radians) * distance;
                
                const candidateRect = {
                    ...labelRect,
                    x: anchorPoint.x + offsetX,
                    y: anchorPoint.y + offsetY - labelRect.height,
                };
                
                // Ensure the label stays within canvas bounds
                // candidateRect.x = Math.max(10, Math.min(canvas.width - labelRect.width - 10, candidateRect.x));
                // candidateRect.y = Math.max(10, Math.min(canvas.height - labelRect.height - 10, candidateRect.y));
                
                // Count how many existing labels this position would overlap with
                let impactCount = 0;
                for (const existingLabel of currentLabelPositions) {
                    if (rectsOverlap(candidateRect, existingLabel)) {
                        impactCount++;
                    }
                }
                
                // Score this position
                const score = evaluateLabelPosition(candidateRect, anchorPoint, strokeInfo);
                
                // Prioritize positions with minimal impact on other labels
                if (impactCount < bestImpactCount || 
                    (impactCount === bestImpactCount && score > bestScore)) {
                    bestImpactCount = impactCount;
                    bestScore = score;
                    bestRect = { ...candidateRect };
                }
                
                // If we found a position that affects no other labels and has a good score, prioritize it
                if (impactCount === 0 && score > 0.6) {
                    return bestRect;
                }
            }
        }
        
        return bestRect;
    }
    
    // Function to evaluate how good a label position is (0-1, higher is better)
    function evaluateLabelPosition(rect, anchorPoint, strokeInfo) {
        let score = 1.0; // Start with perfect score
        
        // Distance from anchor point (penalize being too far away)
        const centerX = rect.x + rect.width / 2;
        const centerY = rect.y + rect.height / 2;
        const distance = Math.sqrt(
            Math.pow(centerX - anchorPoint.x, 2) + 
            Math.pow(centerY - anchorPoint.y, 2)
        );
        
        // Normalize distance penalty (0-0.4) - further means bigger penalty
        const distancePenalty = Math.min(0.4, (distance / 300) * 0.4);
        score -= distancePenalty;
        
        // Prefer positions to the right or above (slight preference)
        if (rect.x + rect.width < anchorPoint.x || rect.y > anchorPoint.y) {
            score -= 0.1; // Small penalty for less preferred positions
        }
        
        // Severe penalty for overlapping with any other label
        for (const otherRect of currentLabelPositions) {
            if (rectsOverlap(rect, otherRect)) {
                // Apply even higher penalty for overlapping with user-positioned labels
                const isUserPositioned = customLabelPositions[currentImageLabel] && 
                                         customLabelPositions[currentImageLabel][otherRect.strokeLabel];
                
                score -= isUserPositioned ? 0.7 : 0.5; // Higher penalty for user-positioned labels
            }
        }
        
        // Severe penalty for overlapping with lines
        for (const path of currentStrokePaths) {
            if (path.label !== strokeInfo.label) { // Don't check against our own path
                for (let i = 1; i < path.path.length; i++) {
                    const p1 = path.path[i-1];
                    const p2 = path.path[i];
                    if (rectIntersectsLine(rect, p1, p2, path.width)) {
                        score -= 0.6; // Major penalty for overlapping lines
                        break;
                    }
                }
            }
        }
        
        // Penalty for being too close to edge of canvas
        const edgeMargin = 20;
        if (rect.x < edgeMargin || rect.y < edgeMargin || 
            rect.x + rect.width > canvas.width - edgeMargin || 
            rect.y + rect.height > canvas.height - edgeMargin) {
            score -= 0.2; // Minor penalty for being too close to edge
        }
        
        return Math.max(0, score); // Ensure score is not negative
    }
    
    // Function to check if a rectangle intersects with a line segment
    function rectIntersectsLine(rect, p1, p2, lineWidth = 1) {
        // Expand rectangle slightly to account for line width
        const expandedRect = {
            x: rect.x - lineWidth/2,
            y: rect.y - lineWidth/2,
            width: rect.width + lineWidth,
            height: rect.height + lineWidth
        };
        
        // Check if either endpoint is inside the rectangle
        if (pointInRect(p1, expandedRect) || pointInRect(p2, expandedRect)) {
            return true;
        }
        
        // Check if the line intersects any of the rectangle's edges
        const rectLines = [
            {p1: {x: expandedRect.x, y: expandedRect.y}, p2: {x: expandedRect.x + expandedRect.width, y: expandedRect.y}},
            {p1: {x: expandedRect.x + expandedRect.width, y: expandedRect.y}, p2: {x: expandedRect.x + expandedRect.width, y: expandedRect.y + expandedRect.height}},
            {p1: {x: expandedRect.x + expandedRect.width, y: expandedRect.y + expandedRect.height}, p2: {x: expandedRect.x, y: expandedRect.y + expandedRect.height}},
            {p1: {x: expandedRect.x, y: expandedRect.y + expandedRect.height}, p2: {x: expandedRect.x, y: expandedRect.y}}
        ];
        
        for (const rectLine of rectLines) {
            if (lineIntersectsLine(p1, p2, rectLine.p1, rectLine.p2)) {
                return true;
            }
        }
        
        return false;
    }
    
    // Function to check if a point is inside a rectangle
    function pointInRect(point, rect) {
        return (
            point.x >= rect.x &&
            point.x <= rect.x + rect.width &&
            point.y >= rect.y &&
            point.y <= rect.y + rect.height
        );
    }
    
    // Function to check if two line segments intersect
    function lineIntersectsLine(l1p1, l1p2, l2p1, l2p2) {
        // Calculate direction vectors
        const v1 = {x: l1p2.x - l1p1.x, y: l1p2.y - l1p1.y};
        const v2 = {x: l2p2.x - l2p1.x, y: l2p2.y - l2p1.y};
        
        // Calculate determinant
        const det = v1.x * v2.y - v1.y * v2.x;
        
        // Lines are parallel if determinant is zero
        if (Math.abs(det) < 0.0001) return false;
        
        // Calculate vector from l1p1 to l2p1
        const v3 = {x: l2p1.x - l1p1.x, y: l2p1.y - l1p1.y};
        
        // Calculate intersection parameters
        const t1 = (v3.x * v2.y - v3.y * v2.x) / det;
        const t2 = (v3.x * v1.y - v3.y * v1.x) / det;
        
        // Check if intersection point is within both line segments
        return (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1);
    }
    
    // Function to draw a connector line between the label and the stroke
    function drawLabelConnector(labelRect, anchorPoint, strokeColor) {
        // Find the closest point on the label to connect to
        const labelCenter = {
            x: labelRect.x + labelRect.width / 2,
            y: labelRect.y + labelRect.height / 2
        };
        
        // Determine the exit point from the label (closest edge to the anchor)
        let exitPoint;
        
        // Try to exit from the nearest edge to create a shorter, cleaner line
        if (Math.abs(labelCenter.x - anchorPoint.x) > Math.abs(labelCenter.y - anchorPoint.y)) {
            // Exit from left or right side
            const x = (anchorPoint.x < labelCenter.x) ? labelRect.x : (labelRect.x + labelRect.width);
            const y = labelCenter.y;
            exitPoint = {x, y};
        } else {
            // Exit from top or bottom side
            const x = labelCenter.x;
            const y = (anchorPoint.y < labelCenter.y) ? labelRect.y : (labelRect.y + labelRect.height);
            exitPoint = {x, y};
        }
        
        // Draw the connecting line
        ctx.beginPath();
        ctx.moveTo(exitPoint.x, exitPoint.y);
        ctx.lineTo(anchorPoint.x, anchorPoint.y);
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]); // Dotted line
        ctx.stroke();
        ctx.setLineDash([]); // Reset to solid line
    }
    
    // Helper function to check if two rectangles overlap
    function rectsOverlap(rect1, rect2) {
        return (
            rect1.x < rect2.x + rect2.width &&
            rect1.x + rect1.width > rect2.x &&
            rect1.y < rect2.y + rect2.height &&
            rect1.y + rect1.height > rect2.y
        );
    }
    
    // Helper function to check if a point is on or near a stroke
    function checkForStrokeAtPoint(x, y) {
        // Only check visible strokes
        const strokes = lineStrokesByImage[currentImageLabel] || [];
        
        // Get current image scale and position for coordinate transforms
        const scale = imageScaleByLabel[currentImageLabel] || 1;
        
        // Calculate image position for coordinate transforms
        let imageWidth = canvas.width;
        let imageHeight = canvas.height;
        let imageX, imageY;
        
        // Try to get original image dimensions if available
        if (window.originalImages && window.originalImages[currentImageLabel]) {
            const cachedImg = imageCache[window.originalImages[currentImageLabel]];
            if (cachedImg) {
                imageWidth = cachedImg.width;
                imageHeight = cachedImg.height;
                
                // Calculate position based on image dimensions
                imageX = (canvas.width - imageWidth * scale) / 2 + 
                        (imagePositionByLabel[currentImageLabel]?.x || 0);
                imageY = (canvas.height - imageHeight * scale) / 2 + 
                        (imagePositionByLabel[currentImageLabel]?.y || 0);
            } else {
                // Image not yet loaded, use canvas center as reference
                imageX = canvas.width / 2 + (imagePositionByLabel[currentImageLabel]?.x || 0);
                imageY = canvas.height / 2 + (imagePositionByLabel[currentImageLabel]?.y || 0);
            }
        } else {
            // No image, use canvas center as reference point
            imageX = canvas.width / 2 + (imagePositionByLabel[currentImageLabel]?.x || 0);
            imageY = canvas.height / 2 + (imagePositionByLabel[currentImageLabel]?.y || 0);
        }
        
        // Adjust max distance based on scale
        const baseMaxDistance = 10; // Base distance in pixels for hit detection
        const scaledMaxDistance = baseMaxDistance / scale;
        
        // Special handling for straight lines which are more prone to detection issues
        let closestMatch = null;
        let closestDistance = Number.MAX_VALUE;
        
        // First pass - check all strokes to find the closest one
        for (const strokeLabel of strokes) {
            const isVisible = strokeVisibilityByImage[currentImageLabel] && 
                              strokeVisibilityByImage[currentImageLabel][strokeLabel];
            if (!isVisible) continue;
            
            // Check vector data
            if (vectorStrokesByImage[currentImageLabel] && 
                vectorStrokesByImage[currentImageLabel][strokeLabel]) {
                
                const vectorData = vectorStrokesByImage[currentImageLabel][strokeLabel];
                if (!vectorData.points || vectorData.points.length === 0) continue;
                
                const strokeWidth = (vectorData.width || 5) * scale;
                const maxDistance = Math.max(strokeWidth + 5, baseMaxDistance); // Add padding for easier selection
                
                // For straight lines, check if point is near the line
                if (vectorData.type === 'straight' || vectorData.points.length === 2) {
                    const p1 = vectorData.points[0];
                    const p2 = vectorData.points[vectorData.points.length - 1];
                    
                    // Transform the coordinates based on image scale and position
                    const x1 = imageX + (p1.x * scale);
                    const y1 = imageY + (p1.y * scale);
                    const x2 = imageX + (p2.x * scale);
                    const y2 = imageY + (p2.y * scale);
                    
                    // Calculate distance to this line
                    const distance = pointDistanceToLine(x, y, x1, y1, x2, y2);
                    
                    // If this is closer than our previous closest line, update
                    if (distance <= maxDistance && distance < closestDistance) {
                        closestDistance = distance;
                        closestMatch = { label: strokeLabel, type: 'straight', distance };
                    }
                } else {
                    // For freehand, check each segment
                    for (let i = 1; i < vectorData.points.length; i++) {
                        const p1 = vectorData.points[i-1];
                        const p2 = vectorData.points[i];
                        
                        // Transform the coordinates based on image scale and position
                        const x1 = imageX + (p1.x * scale);
                        const y1 = imageY + (p1.y * scale);
                        const x2 = imageX + (p2.x * scale);
                        const y2 = imageY + (p2.y * scale);
                        
                        // Calculate distance to this segment
                        const distance = pointDistanceToLine(x, y, x1, y1, x2, y2);
                        
                        // If this is closer than our previous closest segment, update
                        if (distance <= maxDistance && distance < closestDistance) {
                            closestDistance = distance;
                            closestMatch = { label: strokeLabel, type: 'freehand', distance };
                        }
                    }
                }
            }
        }
        
        return closestMatch;
    }
    
    // Helper function to calculate the distance from a point to a line
    function pointDistanceToLine(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const len = Math.sqrt(dx * dx + dy * dy);
        
        // If the line is actually a point
        if (len < 0.0001) {
            return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
        }
        
        // Calculate the projection of point onto line
        const projection = ((px - x1) * dx + (py - y1) * dy) / len;
        
        // If the projection is outside the line segment
        if (projection < 0 || projection > len) {
            // Check distance to endpoints
            const d1 = Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
            const d2 = Math.sqrt((px - x2) * (px - x2) + (py - y2) * (py - y2));
            return Math.min(d1, d2);
        }
        
        // Calculate the actual distance to the line
        const projX = x1 + (projection * dx) / len;
        const projY = y1 + (projection * dy) / len;
        const distance = Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
        return distance;
    }
    
    // Expose necessary functions globally for project-manager.js to use
    window.addImageToSidebar = addImageToSidebar;
    window.switchToImage = switchToImage;
    window.updateStrokeCounter = updateStrokeCounter;
    window.updateStrokeVisibilityControls = updateStrokeVisibilityControls;
    window.redrawCanvasWithVisibility = redrawCanvasWithVisibility;
    window.updateScaleUI = updateScaleUI;
    
    // *** ADDED: Expose function globally ***
    window.pasteImageFromUrl = pasteImageFromUrl;
    
    // Initial saveState call that won't increment labels or add to stroke list
    saveState(false, false, false);

    function startDrawing(e) {
        // Only draw with left mouse button
        if (e.buttons !== 1) return;
        
        // Make sure we're drawing on the canvas, not on UI elements
        if (e.target !== canvas) return;
        
        isDrawing = true;
        isDrawingOrPasting = true;
        strokeInProgress = true;
        
        // Reset drawing state
        points = [];
        lastVelocity = 0;
        lastDrawnPoint = null;
        straightLineStart = null;
        
        // Get coordinates relative to the canvas, accounting for any page scrolling
        const rect = canvas.getBoundingClientRect();
        const rawX = e.clientX - rect.left;
        const rawY = e.clientY - rect.top;
        
        console.log(`Starting drawing at raw position: (${rawX}, ${rawY})`);
        
        // Transform the coordinates
        const transformedCoords = getTransformedCoords(rawX, rawY);
        lastX = transformedCoords.x;
        lastY = transformedCoords.y;
        
        console.log(`Transformed to: (${lastX}, ${lastY})`);
        
        // Set drawing style
        ctx.strokeStyle = colorPicker.value;
        ctx.fillStyle = colorPicker.value;
        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Start a new stroke
        currentStroke = {
            color: colorPicker.value,
            size: brushSize,
            opacity: 1.0,
            points: [{ x: lastX, y: lastY }]
        };
        
        // Also store point in the points array for freehand drawing
        const now = Date.now();
        points.push({
            x: lastX,
            y: lastY,
            canvasX: rawX,
            canvasY: rawY,
            time: now,
            velocity: 0
        });
        
        // If in straight line mode, store the start point
        if (drawingMode === 'straight') {
            straightLineStart = { x: rawX, y: rawY };
        } else {
            // For freehand, draw a single dot at the starting point
            ctx.beginPath();
            ctx.arc(lastX, lastY, brushSize / 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Add event listeners to the document for better mouse tracking outside canvas
        document.addEventListener('mousemove', draw);
        document.addEventListener('mouseup', stopDrawing);
        document.addEventListener('mouseleave', stopDrawing);
    }

    function stopDrawing(e) {
        // Remove event listeners
        document.removeEventListener('mousemove', draw);
        document.removeEventListener('mouseup', stopDrawing);
        document.removeEventListener('mouseleave', stopDrawing);
        
        // Debug logs
        console.log(`stopDrawing called, isDrawing=${isDrawing}, drawingMode=${drawingMode}, points.length=${points?.length || 0}`);
        console.log(`currentImageLabel=${currentImageLabel}`);
        
        if (isDrawing) {
            // For straight line, finalize the line
            if (drawingMode === 'straight' && straightLineStart) {
                const rect = canvas.getBoundingClientRect();
                const endPoint = { 
                    x: e.clientX - rect.left, 
                    y: e.clientY - rect.top 
                };
                
                // Only save the line if the start and end points are different
                if (Math.abs(straightLineStart.x - endPoint.x) > 2 || 
                    Math.abs(straightLineStart.y - endPoint.y) > 2) {
                    
                    // Check if end point is on another stroke
                    const endPointStrokeData = checkForStrokeAtPoint(endPoint.x, endPoint.y);
                    
                    // Store vector data temporarily
                    const tempStrokeKey = '_drawingStroke';
                    const strokeColor = colorPicker.value;
                    const strokeWidth = brushSize;
                    
                    // Initialize if needed
                    if (!window.vectorStrokesByImage[currentImageLabel]) {
                        window.vectorStrokesByImage[currentImageLabel] = {};
                    }
                    
                    // Get transformed coordinates
                    const startTransformed = getTransformedCoords(straightLineStart.x, straightLineStart.y);
                    const endTransformed = getTransformedCoords(endPoint.x, endPoint.y);

                    console.log(`Straight line from canvas (${straightLineStart.x}, ${straightLineStart.y}) -> image (${startTransformed.x}, ${startTransformed.y})`);
                    console.log(`Straight line to canvas (${endPoint.x}, ${endPoint.y}) -> image (${endTransformed.x}, ${endTransformed.y})`);

                    // Create a vector representation under the temporary key
                    window.vectorStrokesByImage[currentImageLabel][tempStrokeKey] = {
                        points: [
                            { x: startTransformed.x, y: startTransformed.y },
                            { x: endTransformed.x, y: endTransformed.y }
                        ],
                        color: strokeColor,
                        width: strokeWidth,
                        type: 'straight'
                    };
                    console.log(`Stored straight line data temporarily under ${tempStrokeKey}`);
                    
                    // Draw the final line
                    drawStraightLinePreview(straightLineStart, endPoint);
                    
                    // If end point overlaps with another line, draw a glowing circle
                    if (endPointStrokeData) {
                        const scale = window.imageScaleByLabel[currentImageLabel] || 1.0;
                        const baseRadius = brushSize / 2;
                        const scaledRadius = baseRadius * scale;
                        const glowPadding = 5; // Keep glow padding fixed
                        
                        // Use transformed coordinates for the circle too
                        ctx.beginPath();
                        // Use scaled radius + padding for glow circle
                        ctx.arc(endTransformed.x, endTransformed.y, scaledRadius + glowPadding, 0, Math.PI * 2);
                        
                        // Create a white glow effect with a radial gradient using scaled radii
                        const gradient = ctx.createRadialGradient(
                            endTransformed.x, endTransformed.y, scaledRadius / 2, // Inner radius (scaled)
                            endTransformed.x, endTransformed.y, scaledRadius + glowPadding // Outer radius (scaled + padding)
                        );
                        gradient.addColorStop(0, 'white');
                        gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.8)');
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.fillStyle = gradient;
                        ctx.fill();
                        
                        // Then draw the colored dot for the actual end point
                        ctx.beginPath();
                        ctx.arc(endTransformed.x, endTransformed.y, scaledRadius, 0, Math.PI * 2);
                        ctx.fillStyle = strokeColor;
                        ctx.fill();
                    }
                }
                
                // Reset straight line start
                straightLineStart = null;
            } else if (drawingMode === 'freehand' && points.length > 0) {
                // Handle freehand drawing completion
                console.log("Processing freehand stroke completion");
                
                // Store vector data temporarily for freehand drawing
                const tempStrokeKey = '_drawingStroke';
                const strokeColor = colorPicker.value;
                const strokeWidth = brushSize;
                
                // Initialize if needed
                if (!window.vectorStrokesByImage[currentImageLabel]) {
                    window.vectorStrokesByImage[currentImageLabel] = {};
                }
                
                // Create or update vector data for the freehand stroke if not already done
                if (!window.vectorStrokesByImage[currentImageLabel][tempStrokeKey]) {
                    window.vectorStrokesByImage[currentImageLabel][tempStrokeKey] = {
                        points: points.map(p => ({ x: p.x, y: p.y })),
                        color: strokeColor,
                        width: strokeWidth,
                        type: 'freehand'
                    };
                    console.log(`Created new vector data for freehand stroke with ${points.length} points`);
                }
            }
            
            // Clear drawing state
            isDrawing = false;
            straightLineStart = null;
            
            // Reset the stroke-in-progress flag
            setTimeout(() => {
                if (!isDrawing) {
                    strokeInProgress = false;
                    isDrawingOrPasting = false;
                }
            }, 50);
            
            // Save the state to allow undo
            saveState(true, true, true);
        }
    }

    /**
     * Calculates drawing velocity based on distance between points and time elapsed
     * @param {number} lastX - Previous X coordinate
     * @param {number} lastY - Previous Y coordinate
     * @param {number} x - Current X coordinate
     * @param {number} y - Current Y coordinate
     * @param {number} now - Current timestamp
     * @returns {number} Velocity value
     */
    function calculateVelocity(lastX, lastY, x, y, now) {
        const dx = x - lastX;
        const dy = y - lastY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // If this is the first point or points are very close, return 0
        if (!lastDrawnPoint || distance < 0.1) return 0;
        
        const lastTime = lastDrawnPoint.time || now - 16; // Default to 60fps if no previous time
        const timeDelta = Math.max(1, now - lastTime); // Avoid division by zero
        
        return distance / timeDelta;
    }

    // Add this to paint.js just before the startDrawing function
    function addDebugCursor() {
        // Create debug cursor element if it doesn't exist
        if (!document.getElementById('debug-cursor')) {
            const debugCursor = document.createElement('div');
            debugCursor.id = 'debug-cursor';
            debugCursor.style.cssText = `
                position: absolute;
                width: 10px;
                height: 10px;
                background-color: red;
                border-radius: 50%;
                pointer-events: none;
                z-index: 9999;
                opacity: 0.7;
                transform: translate(-50%, -50%);
            `;
            document.body.appendChild(debugCursor);
            
            // Add transformation info display
            const debugInfo = document.createElement('div');
            debugInfo.id = 'debug-info';
            debugInfo.style.cssText = `
                position: absolute;
                left: 10px;
                top: 10px;
                background-color: rgba(0,0,0,0.7);
                color: white;
                padding: 5px;
                font-size: 12px;
                z-index: 9999;
            `;
            document.body.appendChild(debugInfo);
        }
    }

    // Call this function at the end of document.addEventListener('DOMContentLoaded', ...)
    addDebugCursor();

    // Then add this to the mousemove event handler
    canvas.addEventListener('mousemove', function(e) {
        const rect = canvas.getBoundingClientRect();
        const rawX = e.clientX - rect.left;
        const rawY = e.clientY - rect.top;
        
        const debugCursor = document.getElementById('debug-cursor');
        if (debugCursor) {
            // Position the debug cursor at the raw mouse position
            const rect = canvas.getBoundingClientRect();
            debugCursor.style.left = `${rect.left + (e.clientX - rect.left)}px`; // == e.clientX
            debugCursor.style.top = `${rect.top + (e.clientY - rect.top)}px`;   // == e.clientY
            
            // Update debug info
            const debugInfo = document.getElementById('debug-info');
            if (debugInfo) {
                debugInfo.innerHTML = `
                    Raw: (${Math.round(rawX)}, ${Math.round(rawY)})<br>
                    Client: (${Math.round(e.clientX)}, ${Math.round(e.clientY)})<br>
                    Canvas rect: (${Math.round(rect.left)}, ${Math.round(rect.top)})
                `;
            }
        }
    });

    // Add a test button
    const testButton = document.createElement('button');
    testButton.textContent = 'Draw Test Square';
    testButton.style.cssText = 'position: fixed; bottom: 10px; left: 10px; z-index: 9999;';
    document.body.appendChild(testButton);

    testButton.addEventListener('click', function() {
        // Draw a square at a fixed position
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const size = 50;
        
        ctx.beginPath();
        ctx.rect(centerX - size/2, centerY - size/2, size, size);
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        console.log('Drew test square at center:', { centerX, centerY });
    });

    // Function to restore transform after all drawing is done
    function finalizeRedraw() {
        // Save the now-combined state (only if not loading, to prevent infinite loops)
        if (!window.isLoadingProject) {
            const newState = getCanvasState();
            imageStates[currentImageLabel] = cloneImageData(newState);
            // console.log(`[Redraw] Saved final canvas state for ${currentImageLabel}`); // Optional: Debug state saving
        } else {
            // console.log("[Redraw] Skipping final state save because isLoadingProject is true.");
        }
        ctx.restore(); // *** Restore the original context state (including transform) ***
        console.log("Redraw End Transform:", ctx.getTransform());
    }

    function setupCoordinateDebugTools() {
        // Create debug overlay
        const debugOverlay = document.createElement('div');
        debugOverlay.id = 'debug-overlay';
        debugOverlay.style.cssText = 'position:absolute; top:0; left:0; pointer-events:none; z-index:1000;';
        document.body.appendChild(debugOverlay);
        
        // Add marker and text for mouse position
        const mouseMarker = document.createElement('div');
        mouseMarker.style.cssText = 'position:absolute; width:10px; height:10px; border-radius:50%; background:red; transform:translate(-50%,-50%); opacity:0.7;';
        debugOverlay.appendChild(mouseMarker);
        
        const coordText = document.createElement('div');
        coordText.style.cssText = 'position:absolute; background:rgba(0,0,0,0.7); color:white; padding:5px; border-radius:3px;';
        debugOverlay.appendChild(coordText);
        
        // Add canvas info element
        const canvasInfo = document.createElement('div');
        canvasInfo.style.cssText = 'position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.7); color:white; padding:5px; border-radius:3px; max-width:300px;';
        debugOverlay.appendChild(canvasInfo);
        
        // Update on mouse move with proper null checks
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const rawX = e.clientX - rect.left;
            const rawY = e.clientY - rect.top;
            
            // Update marker position to match raw coordinates
            mouseMarker.style.left = `${e.clientX}px`;
            mouseMarker.style.top = `${e.clientY}px`;
            
            // Calculate transformed and round-trip coordinates
            const transformed = getTransformedCoords(rawX, rawY);
            const roundTrip = getCanvasCoords(transformed.x, transformed.y);
            
            // Update text
            coordText.style.left = `${e.clientX + 15}px`;
            coordText.style.top = `${e.clientY + 15}px`;
            coordText.textContent = `Raw: (${rawX.toFixed(1)}, ${rawY.toFixed(1)})\nRelative: (${transformed.x.toFixed(1)}, ${transformed.y.toFixed(1)})\nRoundTrip: (${roundTrip.x.toFixed(1)}, ${roundTrip.y.toFixed(1)})`;
            
            // Update canvas info with proper null checks
            const scale = window.imageScaleByLabel?.[currentImageLabel] || 1.0;
            const position = window.imagePositionByLabel?.[currentImageLabel] || { x: 0, y: 0 };
            const dimensions = window.originalImageDimensions?.[currentImageLabel] || { width: 0, height: 0 };
            
            canvasInfo.innerHTML = `Canvas: ${canvas.width}x${canvas.height}<br>
                                  Rect: (${rect.left.toFixed(1)}, ${rect.top.toFixed(1)}) ${rect.width.toFixed(1)}x${rect.height.toFixed(1)}<br>
                                  Scale: ${scale}<br>
                                  Position: (${position.x.toFixed(1)}, ${position.y.toFixed(1)})<br>
                                  Image Dims: ${dimensions.width}x${dimensions.height}`;
        });
        
        // Add test buttons 
        const testButton = document.createElement('button');
        testButton.textContent = 'Test Coordinates';
        testButton.style.cssText = 'position:absolute; top:10px; right:10px; z-index:1001;';
        testButton.onclick = testCoordinateMapping;
        document.body.appendChild(testButton);
        
        const gridButton = document.createElement('button');
        gridButton.textContent = 'Draw Test Grid';
        gridButton.style.cssText = 'position:absolute; top:50px; right:10px; z-index:1001;';
        gridButton.onclick = drawTestPattern;
        document.body.appendChild(gridButton);
        
        const directButton = document.createElement('button');
        directButton.textContent = 'Test Direct Drawing';
        directButton.style.cssText = 'position:absolute; top:90px; right:10px; z-index:1001;';
        directButton.onclick = testDirectDrawing;
        document.body.appendChild(directButton);
        
        console.log('Coordinate debug tools initialized');
        
        // Add this inside setupCoordinateDebugTools() after the other buttons
        const trackButton = document.createElement('button');
        trackButton.textContent = 'Track Live Drawing';
        trackButton.style.cssText = 'position:absolute; top:130px; right:10px; z-index:1001;';
        trackButton.onclick = trackLiveDrawing;
        document.body.appendChild(trackButton);
    }

    function testCoordinateMapping() {
        // Draw a red dot at raw (100,100)
        ctx.save();
        ctx.beginPath();
        ctx.arc(100, 100, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'red';
        ctx.fill();
        ctx.fillText('Raw (100,100)', 110, 100);
        
        // Draw a blue dot using transformed->canvas roundtrip
        const transformed = getTransformedCoords(100, 100);
        const roundTrip = getCanvasCoords(transformed.x, transformed.y);
        
        ctx.beginPath();
        ctx.arc(roundTrip.x, roundTrip.y, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'blue';
        ctx.fill();
        ctx.fillText(`Roundtrip (${roundTrip.x.toFixed(1)}, ${roundTrip.y.toFixed(1)})`, roundTrip.x + 10, roundTrip.y);
        
        // Draw a green dot at canvas center
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        ctx.beginPath();
        ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'green';
        ctx.fill();
        ctx.fillText(`Center (${centerX}, ${centerY})`, centerX + 10, centerY);
        
        // Log canvas and viewport details
        console.log('Canvas Element:', canvas);
        console.log('Canvas Size:', {width: canvas.width, height: canvas.height});
        console.log('Canvas Rect:', canvas.getBoundingClientRect());
        console.log('Image Scale:', window.imageScaleByLabel[currentImageLabel]);
        console.log('Image Position:', window.imagePositionByLabel[currentImageLabel]);
        console.log('Image Dimensions:', window.originalImageDimensions[currentImageLabel]);
        
        ctx.restore();
    }

    // Initialize coordinate debug tools
    setupCoordinateDebugTools();

    // Add this function before referencing it
    function drawTestPattern() {
        // Clear any existing content first
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw a test grid with known coordinates
        ctx.lineWidth = 1;
        
        // Draw axis lines in blue
        ctx.strokeStyle = 'blue';
        ctx.beginPath();
        // Horizontal axis
        ctx.moveTo(0, canvas.height/2);
        ctx.lineTo(canvas.width, canvas.height/2);
        // Vertical axis
        ctx.moveTo(canvas.width/2, 0);
        ctx.lineTo(canvas.width/2, canvas.height);
        ctx.stroke();
        
        // Draw a red cross at raw coordinates (100,100)
        ctx.strokeStyle = 'red';
        ctx.beginPath();
        ctx.moveTo(95, 100);
        ctx.lineTo(105, 100);
        ctx.moveTo(100, 95);
        ctx.lineTo(100, 105);
        ctx.stroke();
        ctx.fillText("Raw (100,100)", 105, 100);
        
        // Draw a green cross using the transformed->canvas pipeline
        const transformed = getTransformedCoords(100, 100);
        const roundTrip = getCanvasCoords(transformed.x, transformed.y);
        
        ctx.strokeStyle = 'green';
        ctx.beginPath();
        ctx.moveTo(roundTrip.x-5, roundTrip.y);
        ctx.lineTo(roundTrip.x+5, roundTrip.y);
        ctx.moveTo(roundTrip.x, roundTrip.y-5);
        ctx.lineTo(roundTrip.x, roundTrip.y+5);
        ctx.stroke();
        ctx.fillText(`Roundtrip (${roundTrip.x.toFixed(1)},${roundTrip.y.toFixed(1)})`, roundTrip.x+5, roundTrip.y+15);
        
        // Log the current image position and dimensions
        console.log("Test Pattern Canvas Info:");
        console.log("Canvas Size:", {width: canvas.width, height: canvas.height});
        console.log("Image Scale:", window.imageScaleByLabel?.[currentImageLabel] || 1.0);
        console.log("Image Position:", window.imagePositionByLabel?.[currentImageLabel] || {x:0, y:0});
        console.log("Image Dimensions:", window.originalImageDimensions?.[currentImageLabel] || {width:0, height:0});
        
        ctx.restore();
    }

    // Fix the coordinate debug tools
    function setupCoordinateDebugTools() {
        // Create debug overlay
        const debugOverlay = document.createElement('div');
        debugOverlay.id = 'debug-overlay';
        debugOverlay.style.cssText = 'position:absolute; top:0; left:0; pointer-events:none; z-index:1000;';
        document.body.appendChild(debugOverlay);
        
        // Add marker and text for mouse position
        const mouseMarker = document.createElement('div');
        mouseMarker.style.cssText = 'position:absolute; width:10px; height:10px; border-radius:50%; background:red; transform:translate(-50%,-50%); opacity:0.7;';
        debugOverlay.appendChild(mouseMarker);
        
        const coordText = document.createElement('div');
        coordText.style.cssText = 'position:absolute; background:rgba(0,0,0,0.7); color:white; padding:5px; border-radius:3px;';
        debugOverlay.appendChild(coordText);
        
        // Add canvas info element
        const canvasInfo = document.createElement('div');
        canvasInfo.style.cssText = 'position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.7); color:white; padding:5px; border-radius:3px; max-width:300px;';
        debugOverlay.appendChild(canvasInfo);
        
        // Update on mouse move with proper null checks
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const rawX = e.clientX - rect.left;
            const rawY = e.clientY - rect.top;
            
            // Update marker position to match raw coordinates
            mouseMarker.style.left = `${e.clientX}px`;
            mouseMarker.style.top = `${e.clientY}px`;
            
            // Calculate transformed and round-trip coordinates
            const transformed = getTransformedCoords(rawX, rawY);
            const roundTrip = getCanvasCoords(transformed.x, transformed.y);
            
            // Update text
            coordText.style.left = `${e.clientX + 15}px`;
            coordText.style.top = `${e.clientY + 15}px`;
            coordText.textContent = `Raw: (${rawX.toFixed(1)}, ${rawY.toFixed(1)})\nRelative: (${transformed.x.toFixed(1)}, ${transformed.y.toFixed(1)})\nRoundTrip: (${roundTrip.x.toFixed(1)}, ${roundTrip.y.toFixed(1)})`;
            
            // Update canvas info with proper null checks
            const scale = window.imageScaleByLabel?.[currentImageLabel] || 1.0;
            const position = window.imagePositionByLabel?.[currentImageLabel] || { x: 0, y: 0 };
            const dimensions = window.originalImageDimensions?.[currentImageLabel] || { width: 0, height: 0 };
            
            canvasInfo.innerHTML = `Canvas: ${canvas.width}x${canvas.height}<br>
                                  Rect: (${rect.left.toFixed(1)}, ${rect.top.toFixed(1)}) ${rect.width.toFixed(1)}x${rect.height.toFixed(1)}<br>
                                  Scale: ${scale}<br>
                                  Position: (${position.x.toFixed(1)}, ${position.y.toFixed(1)})<br>
                                  Image Dims: ${dimensions.width}x${dimensions.height}`;
        });
        
        // Add test buttons 
        const testButton = document.createElement('button');
        testButton.textContent = 'Test Coordinates';
        testButton.style.cssText = 'position:absolute; top:10px; right:10px; z-index:1001;';
        testButton.onclick = testCoordinateMapping;
        document.body.appendChild(testButton);
        
        const gridButton = document.createElement('button');
        gridButton.textContent = 'Draw Test Grid';
        gridButton.style.cssText = 'position:absolute; top:50px; right:10px; z-index:1001;';
        gridButton.onclick = drawTestPattern;
        document.body.appendChild(gridButton);
        
        const directButton = document.createElement('button');
        directButton.textContent = 'Test Direct Drawing';
        directButton.style.cssText = 'position:absolute; top:90px; right:10px; z-index:1001;';
        directButton.onclick = testDirectDrawing;
        document.body.appendChild(directButton);
        
        console.log('Coordinate debug tools initialized');
    }

    // Let's also check our getTransformedCoords and getCanvasCoords functions
    function checkCoordinateSystem() {
        // Check if image dimensions are properly set
        const dims = window.originalImageDimensions?.[currentImageLabel];
        if (!dims || dims.width === 0 || dims.height === 0) {
            console.warn("WARNING: originalImageDimensions not properly set for", currentImageLabel);
            console.log("Current value:", dims);
            
            // Initialize dimensions if needed
            if (!window.originalImageDimensions) {
                window.originalImageDimensions = {};
            }
            if (!window.originalImageDimensions[currentImageLabel]) {
                window.originalImageDimensions[currentImageLabel] = {
                    width: canvas.width,
                    height: canvas.height
                };
                console.log("Auto-initialized dimensions to canvas size:", window.originalImageDimensions[currentImageLabel]);
            }
        }
        
        // Add a test function to directly modify getTransformedCoords and getCanvasCoords temporarily
        window.testDirectDrawing = function() {
            // Store original functions
            const originalGetTransformedCoords = window.getTransformedCoords;
            const originalGetCanvasCoords = window.getCanvasCoords;
            
            // Override with direct mapping for testing
            window.getTransformedCoords = function(x, y) {
                console.log("Using direct mapping for transformed coords:", x, y);
                return {x: x, y: y};
            };
            
            window.getCanvasCoords = function(x, y) {
                console.log("Using direct mapping for canvas coords:", x, y);
                return {x: x, y: y};
            };
            
            // Draw something
            alert("Drawing a test line with direct coordinate mapping. Click OK to start.");
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw a diagonal line
            ctx.beginPath();
            ctx.moveTo(100, 100);
            ctx.lineTo(300, 300);
            ctx.strokeStyle = "magenta";
            ctx.lineWidth = 5;
            ctx.stroke();
            ctx.restore();
            
            // Restore original functions after 5 seconds
            setTimeout(() => {
                window.getTransformedCoords = originalGetTransformedCoords;
                window.getCanvasCoords = originalGetCanvasCoords;
                alert("Restored original coordinate functions.");
            }, 5000);
        };
        
        // Add a button for this test
        const directButton = document.createElement('button');
        directButton.textContent = 'Test Direct Drawing';
        directButton.style.cssText = 'position:absolute; top:90px; right:10px; z-index:1001;';
        directButton.onclick = window.testDirectDrawing;
        document.body.appendChild(directButton);
    }

    // Call this during initialization
    document.addEventListener('DOMContentLoaded', () => {
        // Add this after your existing DOMContentLoaded code
        setupCoordinateDebugTools();
        checkCoordinateSystem();
    });

    function testDirectDrawing() {
        // Store original functions
        const originalGetTransformedCoords = window.getTransformedCoords;
        const originalGetCanvasCoords = window.getCanvasCoords;
        
        // Override with direct mapping for testing
        window.getTransformedCoords = function(x, y) {
            console.log("Using direct mapping for transformed coords:", x, y);
            return {x: x, y: y};
        };
        
        window.getCanvasCoords = function(x, y) {
            console.log("Using direct mapping for canvas coords:", x, y);
            return {x: x, y: y};
        };
        
        // Draw something
        alert("Drawing a test line with direct coordinate mapping. Click OK to start.");
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw a diagonal line
        ctx.beginPath();
        ctx.moveTo(100, 100);
        ctx.lineTo(300, 300);
        ctx.strokeStyle = "magenta";
        ctx.lineWidth = 5;
        ctx.stroke();
        ctx.restore();
        
        // Restore original functions after 5 seconds
        setTimeout(() => {
            window.getTransformedCoords = originalGetTransformedCoords;
            window.getCanvasCoords = originalGetCanvasCoords;
            alert("Restored original coordinate functions.");
        }, 5000);
    }

    function trackLiveDrawing() {
        // Create a tracking element
        const tracker = document.createElement('div');
        tracker.id = 'live-draw-tracker';
        tracker.style.cssText = 'position:fixed; bottom:10px; left:10px; background:rgba(0,0,0,0.7); color:white; padding:10px; border-radius:5px; z-index:1001;';
        document.body.appendChild(tracker);
        
        // Save the original draw function
        const originalDraw = window.draw;
        
        // Replace with a tracking version
        window.draw = function(e) {
            // Get the coordinates
            const rect = canvas.getBoundingClientRect();
            const rawX = e.clientX - rect.left;
            const rawY = e.clientY - rect.top;
            
            // Update tracker
            tracker.innerHTML = `Current Draw:<br>
                               Raw: (${rawX.toFixed(1)}, ${rawY.toFixed(1)})<br>
                               Client: (${e.clientX.toFixed(1)}, ${e.clientY.toFixed(1)})<br>
                               Rect: (${rect.left.toFixed(1)}, ${rect.top.toFixed(1)})`;
            
            // Call the original function
            return originalDraw.call(this, e);
        };
        
        // Add button to restore
        const restoreButton = document.createElement('button');
        restoreButton.textContent = 'Restore Draw Function';
        restoreButton.style.cssText = 'position:absolute; top:130px; right:10px; z-index:1001;';
        restoreButton.onclick = function() {
            window.draw = originalDraw;
            document.body.removeChild(tracker);
            document.body.removeChild(restoreButton);
        };
        document.body.appendChild(restoreButton);
    }

    // Add this after your canvas is initialized
    let testDrawing = false;
    let lastTestX = null, lastTestY = null;

    canvas.addEventListener('mousedown', function(e) {
        if (!testDrawing) return;
        const rect = canvas.getBoundingClientRect();
        lastTestX = e.clientX - rect.left;
        lastTestY = e.clientY - rect.top;
        canvas.addEventListener('mousemove', testDrawMove);
    });

    canvas.addEventListener('mouseup', function(e) {
        if (!testDrawing) return;
        canvas.removeEventListener('mousemove', testDrawMove);
        lastTestX = null;
        lastTestY = null;
    });

    function testDrawMove(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        if (lastTestX !== null && lastTestY !== null) {
            ctx.beginPath();
            ctx.moveTo(lastTestX, lastTestY);
            ctx.lineTo(x, y);
            ctx.strokeStyle = 'magenta';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        lastTestX = x;
        lastTestY = y;
    }

    // Add a button to toggle test drawing mode
    const testDrawBtn = document.createElement('button');
    testDrawBtn.textContent = 'Toggle Test Live Drawing';
    testDrawBtn.style.cssText = 'position:fixed;top:170px;right:10px;z-index:1001;';
    testDrawBtn.onclick = () => {
        testDrawing = !testDrawing;
        alert('Test live drawing mode is now ' + (testDrawing ? 'ON' : 'OFF'));
    };
    document.body.appendChild(testDrawBtn);
});

// At the end of the file, before the closing </script> tag

// Enhanced debug overlay for coordinate visualization
function setupEnhancedDebugOverlay() {
    // Create overlay container if it doesn't exist
    let overlay = document.getElementById('debug-coordinate-overlay');
    if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'debug-coordinate-overlay';
        overlay.style.position = 'fixed';
        overlay.style.bottom = '10px';
        overlay.style.right = '10px';
        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        overlay.style.color = 'white';
        overlay.style.padding = '10px';
        overlay.style.borderRadius = '5px';
        overlay.style.fontFamily = 'monospace';
        overlay.style.fontSize = '12px';
        overlay.style.zIndex = '9999';
        overlay.style.maxWidth = '400px';
        overlay.style.maxHeight = '200px';
        overlay.style.overflow = 'auto';
        overlay.style.display = 'none'; // Start hidden
        document.body.appendChild(overlay);
    }

    // Create a toggle button
    let toggleButton = document.getElementById('debug-overlay-toggle');
    if (!toggleButton) {
        toggleButton = document.createElement('button');
        toggleButton.id = 'debug-overlay-toggle';
        toggleButton.textContent = 'Debug Overlay';
        toggleButton.style.position = 'fixed';
        toggleButton.style.bottom = '10px';
        toggleButton.style.left = '10px';
        toggleButton.style.padding = '5px';
        toggleButton.style.backgroundColor = '#007bff';
        toggleButton.style.color = 'white';
        toggleButton.style.border = 'none';
        toggleButton.style.borderRadius = '3px';
        toggleButton.style.zIndex = '9999';
        document.body.appendChild(toggleButton);
        
        toggleButton.addEventListener('click', () => {
            if (overlay.style.display === 'none') {
                overlay.style.display = 'block';
                toggleButton.textContent = 'Hide Debug';
            } else {
                overlay.style.display = 'none';
                toggleButton.textContent = 'Debug Overlay';
            }
        });
    }
    
    // Set up mouse move tracking on canvas
    canvas.addEventListener('mousemove', (e) => {
        // Only update if overlay is visible
        if (overlay.style.display === 'none') return;
        
        const rect = canvas.getBoundingClientRect();
        const rawX = e.clientX - rect.left;
        const rawY = e.clientY - rect.top;
        
        // Get transformed coordinates
        const relativeCoords = getTransformedCoords(rawX, rawY);
        
        // Get round-trip coordinates
        const roundTripCoords = getCanvasCoords(relativeCoords.x, relativeCoords.y);
        
        // Calculate round-trip error
        const errorX = Math.abs(rawX - roundTripCoords.x);
        const errorY = Math.abs(rawY - roundTripCoords.y);
        const totalError = Math.sqrt(errorX * errorX + errorY * errorY);
        
        // Update overlay content
        overlay.innerHTML = `
            <div><strong>Debug Coordinate Info:</strong></div>
            <div>Raw Canvas: (${rawX.toFixed(1)}, ${rawY.toFixed(1)})</div>
            <div>Image Relative: (${relativeCoords.x.toFixed(1)}, ${relativeCoords.y.toFixed(1)})</div>
            <div>Round Trip: (${roundTripCoords.x.toFixed(1)}, ${roundTripCoords.y.toFixed(1)})</div>
            <div>Round Trip Error: ${totalError.toFixed(2)}px</div>
            <div>Canvas Size: ${canvas.width} × ${canvas.height}</div>
            <div>Scale: ${window.imageScaleByLabel[currentImageLabel] || 1}</div>
        `;
    });
    
    console.log('Enhanced debug overlay initialized (hidden by default)');
};
}
// Initialize the debug overlay
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(setupEnhancedDebugOverlay, 1000); // Delay to ensure canvas is ready
});
