<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viewport Controller Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        
        .container {
            width: 800px;
            height: 600px;
            border: 2px solid #333;
            position: relative;
            margin: 20px 0;
            background: #f0f0f0;
        }
        
        #canvas {
            background: white;
            cursor: crosshair;
        }
        
        .controls {
            margin: 20px 0;
        }
        
        .controls button {
            margin: 5px;
            padding: 10px 15px;
            font-size: 14px;
        }
        
        .debug-info {
            background: #f8f8f8;
            border: 1px solid #ddd;
            padding: 15px;
            margin: 20px 0;
            font-family: monospace;
            white-space: pre-line;
        }
        
        .test-results {
            margin: 20px 0;
        }
        
        .test-results .pass {
            color: green;
        }
        
        .test-results .fail {
            color: red;
        }
    </style>
</head>
<body>
    <h1>Viewport Controller Test</h1>
    
    <div class="controls">
        <button onclick="toggleViewport()">Toggle New Viewport</button>
        <button onclick="testPrecision()">Test Coordinate Precision</button>
        <button onclick="simulateResize()">Simulate Resize</button>
        <button onclick="testLockState()">Test Lock State</button>
        <button onclick="resetTest()">Reset</button>
    </div>
    
    <div class="container" id="canvasContainer">
        <canvas id="canvas"></canvas>
    </div>
    
    <div class="debug-info" id="debugInfo">
        Viewport Controller Test - Ready
        Click buttons above to test functionality
    </div>
    
    <div class="test-results" id="testResults"></div>

    <!-- Load our viewport modules -->
    <script src="src/canvas/viewport/featureFlags.js"></script>
    <script src="src/canvas/viewport/canvasViewport.js"></script>
    
    <script>
        let viewportController = null;
        let useNewViewport = true;
        
        function log(message, isError = false) {
            const debugInfo = document.getElementById('debugInfo');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = isError ? '❌' : '✅';
            debugInfo.textContent += `\n${timestamp} ${prefix} ${message}`;
            debugInfo.scrollTop = debugInfo.scrollHeight;
        }
        
        function updateDebugInfo() {
            if (!viewportController) return;
            
            const state = viewportController.getState();
            const canvas = document.getElementById('canvas');
            
            log(`Transform: scale=${state.transform.scale.toFixed(3)}, tx=${state.transform.tx.toFixed(1)}, ty=${state.transform.ty.toFixed(1)}`);
            log(`DPR: ${state.dpr.toFixed(2)}`);
            log(`Canvas size: ${canvas.width}x${canvas.height} (bitmap), ${canvas.style.width} x ${canvas.style.height} (CSS)`);
            log(`Lock state: ${state.lockState.kind}`);
        }
        
        function initViewport() {
            const container = document.getElementById('canvasContainer');
            const canvas = document.getElementById('canvas');
            
            if (viewportController) {
                viewportController.destroy();
                viewportController = null;
            }
            
            if (useNewViewport && window.CanvasViewportController) {
                log('Initializing new viewport controller');
                
                // Create test frame bounds (simulating an image)
                const frameBounds = {
                    x: 0,
                    y: 0,
                    width: 400,
                    height: 300
                };
                
                viewportController = new window.CanvasViewportController(
                    container,
                    canvas,
                    {
                        frameBounds: frameBounds,
                        padding: 20
                    }
                );
                
                // Listen for viewport changes
                container.addEventListener('viewportChanged', (event) => {
                    log(`Viewport changed: ${JSON.stringify(event.detail.transform)}`);
                    drawTestContent();
                });
                
                // Draw some test content
                setTimeout(() => {
                    drawTestContent();
                    updateDebugInfo();
                }, 100);
                
            } else {
                log('Using legacy resize (new viewport disabled)');
                // Simple legacy sizing
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';
                
                drawTestContent();
            }
        }
        
        function drawTestContent() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas (accounting for transform)
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
            
            if (viewportController) {
                // New viewport system - content is drawn in world coordinates
                
                // Draw frame bounds (the "image")
                ctx.strokeStyle = '#0066cc';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, 400, 300);
                
                // Draw some test shapes in world coordinates
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(50, 50, 100, 100);
                
                ctx.fillStyle = '#4ecdc4';
                ctx.fillRect(250, 150, 100, 100);
                
                // Draw coordinate system
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(50, 0);
                ctx.moveTo(0, 0);
                ctx.lineTo(0, 50);
                ctx.stroke();
                
                // Draw origin marker
                ctx.fillStyle = '#333';
                ctx.fillRect(-2, -2, 4, 4);
                
            } else {
                // Legacy system - draw directly in canvas coordinates
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.strokeRect(100, 100, 200, 150);
                
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(120, 120, 50, 50);
                
                ctx.fillStyle = '#4ecdc4';
                ctx.fillRect(230, 180, 50, 50);
            }
        }
        
        function toggleViewport() {
            useNewViewport = !useNewViewport;
            log(`Switching to ${useNewViewport ? 'new' : 'legacy'} viewport system`);
            initViewport();
        }
        
        function testPrecision() {
            if (!viewportController) {
                log('Need viewport controller for precision test', true);
                return;
            }
            
            log('Testing coordinate precision...');
            
            const testPoints = [
                { x: 0, y: 0 },
                { x: 123.456, y: 789.012 },
                { x: -50.5, y: 100.25 }
            ];
            
            let allPassed = true;
            
            testPoints.forEach((point, i) => {
                const screen = viewportController.worldToClient(point.x, point.y);
                const world = viewportController.clientToWorld(screen.x, screen.y);
                
                const errorX = Math.abs(world.x - point.x);
                const errorY = Math.abs(world.y - point.y);
                const maxError = 0.001; // 1 thousandth of a pixel
                
                const passed = errorX < maxError && errorY < maxError;
                allPassed = allPassed && passed;
                
                log(`Point ${i + 1}: error=(${errorX.toFixed(6)}, ${errorY.toFixed(6)}) ${passed ? 'PASS' : 'FAIL'}`, !passed);
            });
            
            log(`Precision test: ${allPassed ? 'ALL PASSED' : 'SOME FAILED'}`, !allPassed);
            
            // Add to test results
            const results = document.getElementById('testResults');
            results.innerHTML += `<div class="${allPassed ? 'pass' : 'fail'}">Coordinate Precision: ${allPassed ? 'PASS' : 'FAIL'}</div>`;
        }
        
        function simulateResize() {
            log('Simulating container resize...');
            
            const container = document.getElementById('canvasContainer');
            const originalWidth = container.style.width || '800px';
            
            // Animate resize
            container.style.width = '600px';
            container.style.height = '400px';
            
            setTimeout(() => {
                container.style.width = '1000px';
                container.style.height = '700px';
                
                setTimeout(() => {
                    container.style.width = originalWidth;
                    container.style.height = '600px';
                    
                    setTimeout(() => {
                        updateDebugInfo();
                        log('Resize simulation complete');
                    }, 200);
                }, 500);
            }, 500);
        }
        
        function testLockState() {
            if (!viewportController) {
                log('Need viewport controller for lock test', true);
                return;
            }
            
            log('Testing lock state...');
            
            // Lock at center of frame
            const lockCenter = { x: 200, y: 150 };
            viewportController.setLock({ kind: 'locked', frameCenter: lockCenter });
            
            log(`Locked at world point (${lockCenter.x}, ${lockCenter.y})`);
            
            // Simulate resize while locked
            setTimeout(() => {
                simulateResize();
                
                setTimeout(() => {
                    // Unlock
                    viewportController.setLock({ kind: 'unlocked' });
                    log('Unlocked - should revert to fit behavior');
                    updateDebugInfo();
                }, 2000);
            }, 500);
        }
        
        function resetTest() {
            document.getElementById('debugInfo').textContent = 'Viewport Controller Test - Reset';
            document.getElementById('testResults').innerHTML = '';
            initViewport();
        }
        
        // Initialize when page loads
        window.addEventListener('load', () => {
            // Initialize feature flags for testing
            if (window.ViewportFeatureFlags) {
                window.ViewportFeatureFlags.initFeatureFlags();
                // Enable debug mode
                window.ViewportFeatureFlags.setFeatureFlag('DEBUG_VIEWPORT', true);
                window.ViewportFeatureFlags.setFeatureFlag('LOG_VIEWPORT_CHANGES', true);
            }
            
            setTimeout(initViewport, 100);
        });
        
        // Handle DPR changes for testing
        window.matchMedia('(resolution: 1dppx)').addEventListener('change', () => {
            log(`DPR changed to ${window.devicePixelRatio}`);
            updateDebugInfo();
        });
    </script>
</body>
</html>
