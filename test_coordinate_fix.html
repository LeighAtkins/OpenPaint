<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coordinate Fix Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        .success { color: green; }
        .error { color: red; }
        .info { color: blue; }
        canvas { border: 1px solid #000; margin: 10px 0; }
        button { margin: 5px; padding: 8px 16px; }
    </style>
</head>
<body>
    <h1>Coordinate Stability Test</h1>

    <div class="test-section">
        <h2>Test Instructions</h2>
        <ol>
            <li>Draw some strokes on the canvas below</li>
            <li>Upload an image and draw some measurement labels</li>
            <li>Use background removal (if available)</li>
            <li>Check that label positions remain stable after background removal</li>
            <li>Verify coordinates don't jump around unexpectedly</li>
        </ol>
    </div>

    <div class="test-section">
        <h2>Test Canvas</h2>
        <canvas id="testCanvas" width="800" height="600"></canvas>
        <br>
        <button onclick="testCoordinateStability()">Test Coordinate Stability</button>
        <button onclick="clearCanvas()">Clear Canvas</button>
        <button onclick="simulateBackgroundRemoval()">Simulate Background Removal</button>
    </div>

    <div class="test-section">
        <h2>Test Results</h2>
        <div id="results"></div>
    </div>

    <script>
        const canvas = document.getElementById('testCanvas');
        const ctx = canvas.getContext('2d');
        const results = document.getElementById('results');

        // Mock label positions for testing
        let labelPositions = [
            { x: 100, y: 100, label: 'A1' },
            { x: 300, y: 200, label: 'A2' },
            { x: 500, y: 150, label: 'A3' }
        ];

        let originalDimensions = { width: 800, height: 600 };
        let newDimensions = { width: 750, height: 580 }; // Simulate background removal dimensions

        function testCoordinateStability() {
            results.innerHTML = '';

            // Test 1: Check that coordinate calculations work
            const testResult1 = testCoordinateCalculation();
            logResult('Coordinate Calculation Test', testResult1.success, testResult1.message);

            // Test 2: Check offset rebasing logic
            const testResult2 = testOffsetRebasing();
            logResult('Offset Rebasing Test', testResult2.success, testResult2.message);

            // Test 3: Check shadow offset integration
            const testResult3 = testShadowOffsetIntegration();
            logResult('Shadow Offset Integration Test', testResult3.success, testResult3.message);
        }

        function testCoordinateCalculation() {
            try {
                // Simulate basic coordinate transformation
                const testPoint = { x: 100, y: 100 };
                const scale = 0.9; // Simulate scale change
                const transformed = {
                    x: testPoint.x * scale,
                    y: testPoint.y * scale
                };

                if (Math.abs(transformed.x - 90) < 0.1 && Math.abs(transformed.y - 90) < 0.1) {
                    return { success: true, message: 'Coordinate transformation works correctly' };
                } else {
                    return { success: false, message: 'Coordinate transformation failed' };
                }
            } catch (e) {
                return { success: false, message: `Error: ${e.message}` };
            }
        }

        function testOffsetRebasing() {
            try {
                // Simulate the rebasing logic from background removal
                const originalOffset = { x: 20, y: -15 };
                const scaleRatio = originalDimensions.width / newDimensions.width;

                const rebasedOffset = {
                    x: originalOffset.x / scaleRatio,
                    y: originalOffset.y / scaleRatio
                };

                // Check if rebasing is reasonable
                const expectedX = originalOffset.x / scaleRatio;
                const expectedY = originalOffset.y / scaleRatio;

                if (Math.abs(rebasedOffset.x - expectedX) < 0.1 && Math.abs(rebasedOffset.y - expectedY) < 0.1) {
                    return { success: true, message: `Offset rebasing works: (${originalOffset.x},${originalOffset.y}) -> (${rebasedOffset.x.toFixed(2)},${rebasedOffset.y.toFixed(2)})` };
                } else {
                    return { success: false, message: 'Offset rebasing calculation failed' };
                }
            } catch (e) {
                return { success: false, message: `Error: ${e.message}` };
            }
        }

        function testShadowOffsetIntegration() {
            try {
                // Test that shadow offsets are properly integrated
                const mockShadowOffsets = {
                    'A1': { x: 15.2, y: -12.3 },
                    'A2': { x: 18.7, y: -8.9 }
                };

                const mockCalculatedOffsets = {
                    'A1': { x: 20.0, y: -15.0 },
                    'A2': { x: 25.0, y: -10.0 }
                };

                // Simulate the priority logic: shadow offsets should take precedence
                const finalOffsets = {};
                ['A1', 'A2'].forEach(label => {
                    finalOffsets[label] = mockShadowOffsets[label] || mockCalculatedOffsets[label];
                });

                const expectedA1 = mockShadowOffsets['A1'];
                const expectedA2 = mockShadowOffsets['A2'];

                if (finalOffsets['A1'].x === expectedA1.x && finalOffsets['A1'].y === expectedA1.y &&
                    finalOffsets['A2'].x === expectedA2.x && finalOffsets['A2'].y === expectedA2.y) {
                    return { success: true, message: 'Shadow offset integration works correctly' };
                } else {
                    return { success: false, message: 'Shadow offset integration failed' };
                }
            } catch (e) {
                return { success: false, message: `Error: ${e.message}` };
            }
        }

        function simulateBackgroundRemoval() {
            // Simulate dimension change (background removal)
            originalDimensions = { ...newDimensions };
            newDimensions = { width: 720, height: 560 };

            results.innerHTML += '<div class="info">Simulated background removal: dimensions changed from ' +
                `${originalDimensions.width}x${originalDimensions.height} to ${newDimensions.width}x${newDimensions.height}</div>`;

            // Test coordinate stability after simulated change
            setTimeout(() => {
                testCoordinateStability();
            }, 100);
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            results.innerHTML = '<div class="info">Canvas cleared</div>';
        }

        function logResult(testName, success, message) {
            const className = success ? 'success' : 'error';
            const status = success ? 'PASS' : 'FAIL';
            results.innerHTML += `<div class="${className}">${status}: ${testName} - ${message}</div>`;
        }

        // Draw initial test labels
        function drawLabels() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = '16px Arial';
            ctx.fillStyle = 'red';

            labelPositions.forEach(pos => {
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 3, 0, 2 * Math.PI);
                ctx.fill();

                ctx.fillText(pos.label, pos.x + 10, pos.y - 10);
            });
        }

        // Initial draw
        drawLabels();
    </script>
</body>
</html>
