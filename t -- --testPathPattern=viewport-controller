// Define core application structure for better state management
console.log('[PAINT.JS] Script loaded successfully');
console.warn('[PAINT.JS] Script loaded (warn)');
// Disable legacy measurement overlay rendering in favor of unified tag renderer
window.disableLegacyMeasurementOverlay = true;
window.paintApp = {
    config: {
        IMAGE_LABELS: ['front', 'side', 'back', 'cushion', 'blank_canvas'],
        MAX_HISTORY: 50,  // Maximum number of states to store
        ANCHOR_SIZE: 4,
        CLICK_AREA: 10,
        clickDelay: 300, // Milliseconds to wait for double-click
        defaultScale: 1.0,
        defaultPosition: { x: 0, y: 0 },
        INCHES_TO_CM: 2.54, // Conversion factor from inches to centimeters
        DEFAULT_LABEL_START: 'A1', // Starting label for strokes
        FRACTION_VALUES: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875], // Common fractions for inch display
        MINIMUM_DRAG_DISTANCE: 3 // pixels - minimum distance to detect drag vs click
    },
    state: {
        currentImageLabel: 'front',
        vectorStrokesByImage: {},
        strokeVisibilityByImage: {},
        strokeLabelVisibility: {},
        strokeMeasurements: {},
        imageScaleByLabel: {},
        imagePositionByLabel: {},
        lineStrokesByImage: {},
        labelsByImage: {},
        originalImages: {},
        originalImageDimensions: {},
        imageTags: {},
        isLoadingProject: false,
        isDefocusingOperationInProgress: false,
        // DOM element references for centralized access
        domElements: {},
        // Event listener management
        listenersBound: false,
        eventListeners: new AbortController(),
        folderStructure: {
    "root": {
        id: "root",
        name: "Root",
        type: "folder",
        parentId: null,
        children: []
    }
        },
        selectedStrokeByImage: {},
        multipleSelectedStrokesByImage: {},
        labelCounters: {
    front: 0,
    side: 0,
    back: 0,
    cushion: 0
        },
        customLabelPositions: {},
        calculatedLabelOffsets: {},
        clearedMassiveOffsets: {}, // Track which labels have had massive offsets cleared to prevent repeated clearing
        selectedStrokeInEditMode: null,
        lastClickTime: 0,
        lastCanvasClickTime: 0,
        orderedImageLabels: []
    },
    uiState: {
        // Control point dragging
        isDraggingControlPoint: false,
        draggedControlPointInfo: null, // { strokeLabel, pointIndex, startPos }
        // Image drag and drop
        draggedImageItem: null,
        // Keyboard state
        isShiftPressed: false,
        // Drawing state variables
        isDrawing: false,
        lastX: 0,
        lastY: 0,
        points: [],
        lastVelocity: 0,
        mouseDownPosition: null,
        curveJustCompleted: false,
        drawingMode: 'straight', // Options: 'freehand', 'straight', 'curved', 'arrow'
        straightLineStart: null,
        curvedLinePoints: [],
        lastDrawnPoint: null,
        // Label dragging state
        isDraggingLabel: false,
        draggedLabelStroke: null, // Store stroke label string
        dragStartX: 0,
        dragStartY: 0
    }
};

// Maintain backward compatibility by keeping global references
// These will be gradually migrated to use the paintApp structure
window.IMAGE_LABELS = window.paintApp.config.IMAGE_LABELS;
window.currentImageLabel = window.paintApp.state.currentImageLabel;
window.vectorStrokesByImage = window.paintApp.state.vectorStrokesByImage;
window.strokeVisibilityByImage = window.paintApp.state.strokeVisibilityByImage;
window.strokeLabelVisibility = window.paintApp.state.strokeLabelVisibility;
window.strokeMeasurements = window.paintApp.state.strokeMeasurements;
window.imageScaleByLabel = window.paintApp.state.imageScaleByLabel;
window.imagePositionByLabel = window.paintApp.state.imagePositionByLabel;
window.lineStrokesByImage = window.paintApp.state.lineStrokesByImage;
window.labelsByImage = window.paintApp.state.labelsByImage;
window.originalImages = window.paintApp.state.originalImages;
window.originalImageDimensions = window.paintApp.state.originalImageDimensions;
window.imageTags = window.paintApp.state.imageTags;
window.isLoadingProject = window.paintApp.state.isLoadingProject;
window.isDefocusingOperationInProgress = window.paintApp.state.isDefocusingOperationInProgress;
window.folderStructure = window.paintApp.state.folderStructure;
window.selectedStrokeByImage = window.paintApp.state.selectedStrokeByImage;
window.multipleSelectedStrokesByImage = window.paintApp.state.multipleSelectedStrokesByImage;
window.labelCounters = window.paintApp.state.labelCounters;

// Control point dragging variables (to be migrated)
let isDraggingControlPoint = window.paintApp.uiState.isDraggingControlPoint;
let draggedControlPointInfo = window.paintApp.uiState.draggedControlPointInfo;

// Label dragging variables (migrated to uiState)
let isDraggingLabel = window.paintApp.uiState.isDraggingLabel;
let draggedLabelStroke = window.paintApp.uiState.draggedLabelStroke;
let dragStartX = window.paintApp.uiState.dragStartX;
let dragStartY = window.paintApp.uiState.dragStartY;

// Additional backward compatibility references
window.customLabelPositions = window.paintApp.state.customLabelPositions;
window.calculatedLabelOffsets = window.paintApp.state.calculatedLabelOffsets;
window.clearedMassiveOffsets = window.paintApp.state.clearedMassiveOffsets;
window.selectedStrokeInEditMode = window.paintApp.state.selectedStrokeInEditMode;
window.lastClickTime = window.paintApp.state.lastClickTime;
window.lastCanvasClickTime = window.paintApp.state.lastCanvasClickTime;
window.clickDelay = window.paintApp.config.clickDelay;
let draggedImageItem = window.paintApp.uiState.draggedImageItem;
window.orderedImageLabels = window.paintApp.state.orderedImageLabels;

// Add arrow settings and curved line state to the UI state structure
window.paintApp.uiState.arrowSettings = {
    startArrow: false,  // Off by default (Priority 1 requirement)
    endArrow: false,    // Off by default (Priority 1 requirement)
    arrowSize: null,    // null means use proportional sizing based on stroke width
    arrowStyle: 'triangular' // Options: 'triangular', 'filled', 'curved'
};

// Add dash offset tracking for continuous freehand patterns
window.paintApp.uiState.dashOffset = 0;

// Add dash settings for dotted/dashed lines
window.paintApp.uiState.dashSettings = {
    enabled: false,     // Solid lines by default
    style: 'solid',     // 'solid', 'small', 'medium', 'large', 'dot-dash', 'custom'
    pattern: [],        // Canvas dash array - empty for solid
    dashLength: 5,      // Base dash length (scales with line width)
    gapLength: 5        // Base gap length (scales with line width)
};

window.paintApp.uiState.draggingAnchor = false;
window.paintApp.uiState.dragCurveStroke = null; // The stroke being modified
window.paintApp.uiState.dragAnchorIndex = -1;   // Which control point is being dragged

// Backward compatibility references
let arrowSettings = window.paintApp.uiState.arrowSettings;
let dashSettings = window.paintApp.uiState.dashSettings;
let dashOffset = window.paintApp.uiState.dashOffset;
let draggingAnchor = window.paintApp.uiState.draggingAnchor;

// PERFORMANCE OPTIMIZATIONS: Cache variables and functions
let mouseMoveThrottled = false;
let cachedControlPoints = new Map(); // Cache for transformed control point coordinates
let cachedLabelPositions = new Map(); // Cache for transformed label positions
let cacheInvalidated = true; // Flag to track when cache needs updating

// PERFORMANCE: Cache invalidation helper - call when view changes (pan/zoom) or strokes change

// JSON validation helper function
function isValidJSON(jsonString) {
    try {
        JSON.parse(jsonString);
        return true;
    } catch (e) {
        return false;
    }
}

// Safe JSON parsing with fallback
function safeJsonParse(jsonString, fallback = null) {
    if (!jsonString || jsonString.trim() === '') {
        return fallback;
    }
    try {
        return JSON.parse(jsonString);
    } catch (e) {
        console.error('JSON parsing error:', e.message, 'Input:', jsonString);
        return fallback;
    }
}

function invalidateInteractiveElementCache() {
    cacheInvalidated = true;
    cachedControlPoints.clear();
    cachedLabelPositions.clear();
//         console.log('[PERF] Interactive element cache invalidated');
}

// Safe number formatter to avoid toFixed on undefined or non-numbers
function fmt(n, p = 1) {
    return (typeof n === 'number' && isFinite(n)) ? n.toFixed(p) : String(n);
}
let dragCurveStroke = window.paintApp.uiState.dragCurveStroke;
let dragAnchorIndex = window.paintApp.uiState.dragAnchorIndex;
const ANCHOR_SIZE = window.paintApp.config.ANCHOR_SIZE;
const CLICK_AREA = window.paintApp.config.CLICK_AREA;

document.addEventListener('DOMContentLoaded', () => {
    // Initialize unit selectors
    const unitSelector = document.getElementById('unitSelector');
    unitSelector.addEventListener('change', updateMeasurementDisplay);
    
    // Initialize show measurements toggle
    const toggleShowMeasurements = document.getElementById('toggleShowMeasurements');
    if (toggleShowMeasurements) {
        toggleShowMeasurements.addEventListener('change', () => {
            // Redraw canvas to update label display
            redrawCanvasWithVisibility();
        });
    }
    
    // Initialize the measurement inputs
    const inchWhole = document.getElementById('inchWhole');
    const inchFraction = document.getElementById('inchFraction');
    const cmValue = document.getElementById('cmValue');
    
    // Handle unit conversion when changing values
    inchWhole.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * window.paintApp.config.INCHES_TO_CM).toFixed(1);
    });
    
    inchFraction.addEventListener('change', () => {
        const whole = parseInt(inchWhole.value) || 0;
        const fraction = parseFloat(inchFraction.value) || 0;
        const totalInches = whole + fraction;
        
        // Update cm value
        cmValue.value = (totalInches * window.paintApp.config.INCHES_TO_CM).toFixed(1);
    });
    
    cmValue.addEventListener('change', () => {
        const cm = parseFloat(cmValue.value) || 0;
        const inches = cm / window.paintApp.config.INCHES_TO_CM;
        
        // Update inch values
        inchWhole.value = Math.floor(inches);
        
        // Find closest fraction
        const fractionPart = inches - Math.floor(inches);
        const fractions = window.paintApp.config.FRACTION_VALUES;
        let closestFraction = 0;
        let minDiff = 1;
        
        for (const fraction of fractions) {
            const diff = Math.abs(fractionPart - fraction);
            if (diff < minDiff) {
                minDiff = diff;
                closestFraction = fraction;
            }
        }
        
        inchFraction.value = closestFraction;
        
        // Show inch inputs, hide cm inputs
        document.getElementById('inchInputs').style.display = 'flex';
        document.getElementById('cmInputs').style.display = 'none';
    });
    
    // Add event listener for standalone Save as PDF button
    const saveAsPdfButton = document.getElementById('saveAsPdf');
    if (saveAsPdfButton) {
        saveAsPdfButton.addEventListener('click', () => {
            const projectName = document.getElementById('projectName').value || 'Untitled Project';
            showPDFExportDialog(projectName);
        });
    }
    // Remove Background (server REMBG) - toolbar button
    const removeBgBtn = document.getElementById('removeBgClientTop');
    if (removeBgBtn) {
        if (!removeBgBtn.__removeBgBound) {
            removeBgBtn.__removeBgBound = true;
            removeBgBtn.addEventListener('click', async () => {
                try {
                    const label = window.paintApp.state.currentImageLabel || 'front';
                    const srcUrl = (window.originalImages && window.originalImages[label]) || null;
                    const canvasEl = window.paintApp.state.domElements.canvas;
                    removeBgBtn.disabled = true;
                    const oldText = removeBgBtn.textContent;
                    removeBgBtn.textContent = 'Processing�';

                    let blob;
                    if (srcUrl) {
                        try {
                            const r = await fetch(srcUrl, { cache: 'no-store' });
                            blob = await r.blob();
                        } catch (_) {}
                    }
                    if (!blob && canvasEl) {
                        blob = await new Promise(resolve => canvasEl.toBlob(resolve, 'image/png'));
                    }
                    if (!blob) throw new Error('No image to process');

                    // Step 1: Get direct upload URL from Cloudflare Worker
                    const uploadResp = await fetch('/api/images/direct-upload', { 
                        method: 'POST',
                        headers: { 'x-api-key': 'dev-secret' }
                    });
                    const uploadData = await uploadResp.json();
                    if (!uploadData.success || !uploadData.result?.uploadURL) {
                        throw new Error('Failed to get upload URL');
                    }

                    // Step 2: Upload image directly to Cloudflare Images
                    const formData = new FormData();
                    formData.append('file', blob, 'image.png');
                    const imageUploadResp = await fetch(uploadData.result.uploadURL, {
                        method: 'POST',
                        body: formData
                    });
                    const imageUploadData = await imageUploadResp.json();
                    if (!imageUploadData.success || !imageUploadData.result?.id) {
                        throw new Error('Failed to upload image');
                    }

                    // Step 3: Remove background using Cloudflare Images (robust parsing)
                    const bgRemoveResp = await fetch('/api/remove-background', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': 'dev-secret'
                        },
                        body: JSON.stringify({
                            imageId: imageUploadData.result.id,
                            return: 'url'
                        })
                    });
                    const ct = (bgRemoveResp.headers.get('content-type') || '').toLowerCase();
                    if (!bgRemoveResp.ok) {
                        if (ct.includes('application/json')) {
                            const errJson = await bgRemoveResp.json().catch(() => ({}));
                            throw new Error(errJson.message || JSON.stringify(errJson));
                        }
                        if (ct.startsWith('text/')) {
                            const text = await bgRemoveResp.text();
                            throw new Error(text.slice(0, 300));
                        }
                        const ab = await bgRemoveResp.arrayBuffer().catch(() => null);
                        throw new Error(`RemoveBG HTTP ${bgRemoveResp.status}: ${ct || 'unknown'} (${ab ? ab.byteLength : 'no'} bytes)`);
                    }
                    let cutoutUrl;
                    if (ct.includes('application/json')) {
                        const bgRemoveData = await bgRemoveResp.json();
                        if (!bgRemoveData.success || !bgRemoveData.cutoutUrl) {
                            throw new Error(bgRemoveData.message || 'Background removal failed');
                        }
                        cutoutUrl = bgRemoveData.cutoutUrl;
                    } else if (ct.startsWith('image/')) {
                        const blobOut = await bgRemoveResp.blob();
                        cutoutUrl = URL.createObjectURL(blobOut);
                    } else if (ct.startsWith('text/')) {
                        const text = await bgRemoveResp.text();
                        throw new Error(`Unexpected text from remove-background: ${text.slice(0, 300)}`);
                    } else {
                        const buf = await bgRemoveResp.arrayBuffer();
                        const blobOut = new Blob([buf]);
                        cutoutUrl = URL.createObjectURL(blobOut);
                    }

                    // Step 4: Apply the processed image
                    // If cutoutUrl is already a URL (from JSON response), fetch it first to avoid CORS/HTTP2 issues
                    // If it's a blob URL (from binary response), we need to fetch it
                    if (cutoutUrl.startsWith('http')) {
                        // cutoutUrl is already a URL from the API response - fetch it first to convert to blob
                        try {
                            console.log('[BG-REMOVE] Fetching processed image from:', cutoutUrl);
                            const response = await fetch(cutoutUrl, { 
                                mode: 'cors',
                                cache: 'no-cache'
                            });
                            
                            if (!response.ok) {
                                throw new Error(`Failed to fetch processed image: ${response.status} ${response.statusText}`);
                            }
                            
                            const blob = await response.blob();
                            console.log('[BG-REMOVE] Successfully fetched processed image blob:', blob.size, 'bytes');
                            
                            // Use centralized background removal handler if available
                            if (typeof window.onBackgroundRemoved === 'function') {
                                await window.onBackgroundRemoved(label, blob);
                            } else {
                                // Fallback to direct paste
                                const dataUrl = await rembg_blobToDataURL(blob);
                                if (typeof pasteImageFromUrl === 'function') {
                                    await pasteImageFromUrl(dataUrl, label, { preserveCanvasScale: true, preserveBasis: 'width' });
                                }
                            }
                        } catch (fetchError) {
                            console.error('[BG-REMOVE] Failed to fetch processed image from URL:', fetchError);
                            // Try direct URL as fallback
                            console.log('[BG-REMOVE] Attempting direct URL fallback...');
                            if (typeof pasteImageFromUrl === 'function') {
                                await pasteImageFromUrl(cutoutUrl, label, { preserveCanvasScale: true, preserveBasis: 'width' });
                            }
                        }
                    } else {
                        // cutoutUrl is a blob URL - fetch it to get the blob
                        try {
                            const response = await fetch(cutoutUrl);
                            const blob = await response.blob();
                            
                            // Use centralized background removal handler if available
                            if (typeof window.onBackgroundRemoved === 'function') {
                                await window.onBackgroundRemoved(label, blob);
                            } else {
                                // Fallback to direct paste
                                const dataUrl = await rembg_blobToDataURL(blob);
                                if (typeof pasteImageFromUrl === 'function') {
                                    await pasteImageFromUrl(dataUrl, label, { preserveCanvasScale: true, preserveBasis: 'width' });
                                }
                            }
                        } catch (fetchErr) {
                            console.error('[RemoveBG] Failed to fetch blob URL:', fetchErr);
                            throw new Error('Failed to process background removal result');
                        }
                    }
                    // Keep UI scale text and canvas in sync after replace
                    try { if (label === window.currentImageLabel && typeof updateScaleUI === 'function') updateScaleUI(); } catch(_) {}
                    try { if (typeof redrawCanvasWithVisibility === 'function') redrawCanvasWithVisibility(); } catch(_) {}
                    if (!window.originalImages) window.originalImages = {};
                    // Only set originalImages if we used the fallback path
                    if (typeof window.onBackgroundRemoved !== 'function') {
                        window.originalImages[label] = cutoutUrl;
                    }
                } catch (e) {
                    console.error('[RemoveBG]', e);
                    alert('Remove background failed: ' + e.message);
                } finally {
                    removeBgBtn.disabled = false;
                    removeBgBtn.textContent = 'Remove BG';
                }
            });
        }
    }
    
    // Initialize DOM elements in state object for centralized access
    window.paintApp.state.domElements.canvas = document.getElementById('canvas');
    window.paintApp.state.domElements.ctx = window.paintApp.state.domElements.canvas.getContext('2d', { willReadFrequently: true });
    window.paintApp.state.domElements.colorPicker = document.getElementById('colorPicker');
    window.paintApp.state.domElements.brushSize = document.getElementById('brushSize');
    window.paintApp.state.domElements.clearButton = document.getElementById('clear');
    window.paintApp.state.domElements.saveButton = document.getElementById('save');
    window.paintApp.state.domElements.copyButton = document.getElementById('copy');
    window.paintApp.state.domElements.copyCanvasBtn = document.getElementById('copyCanvasBtn');
    window.paintApp.state.domElements.pasteButton = document.getElementById('paste');
    
    // Debug DOM element loading
    console.log('[PAINT.JS] DOM elements found:', {
        brushSize: !!window.paintApp.state.domElements.brushSize,
        clearButton: !!window.paintApp.state.domElements.clearButton,
        saveButton: !!window.paintApp.state.domElements.saveButton,
        copyButton: !!window.paintApp.state.domElements.copyButton,
        pasteButton: !!window.paintApp.state.domElements.pasteButton
    });
    window.paintApp.state.domElements.strokeCounter = document.getElementById('strokeCounter');
    window.paintApp.state.domElements.imageList = document.getElementById('imageList');
    window.paintApp.state.domElements.drawingModeToggle = document.getElementById('drawingModeToggle');
    window.paintApp.state.domElements.strokeSidebar = document.getElementById('strokePanel');
    window.paintApp.state.domElements.imageSidebar = document.getElementById('imagePanel');
    window.paintApp.state.domElements.strokeSidebarHeader = document.getElementById('strokePanel');
    window.paintApp.state.domElements.imageSidebarHeader = document.getElementById('imagePanel');
    
    // Create backward compatibility references
    const canvas = window.paintApp.state.domElements.canvas;
    const ctx = window.paintApp.state.domElements.ctx;
    const colorPicker = window.paintApp.state.domElements.colorPicker;
    const brushSize = window.paintApp.state.domElements.brushSize;
    // Enforce consistent slider attributes to match original OpenPaint
    if (brushSize) {
        if (!brushSize.min || Number(brushSize.min) < 1) brushSize.min = '1';
        if (!brushSize.max || Number(brushSize.max) < 50) brushSize.max = '50';
        if (!brushSize.value) brushSize.value = '5';
    }
    const clearButton = window.paintApp.state.domElements.clearButton;
    const saveButton = window.paintApp.state.domElements.saveButton;

    // Sync slider UI with brush size and color
    const updateBrushSliderAccent = () => {
        if (brushSize) {
            const currentColor = (colorPicker && colorPicker.value) ? colorPicker.value : '#3b82f6';
            // Always use the actual color, but add shadow for white
            brushSize.style.setProperty('--accent', currentColor);
            
            // Add drop shadow for white color to make it visible
            if (currentColor === '#ffffff' || currentColor === 'white' || currentColor === 'rgb(255, 255, 255)') {
                brushSize.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.3)';
            } else {
                brushSize.style.boxShadow = 'none';
            }
        }
    };
// cache these unless you dynamically change attributes later
    const MIN = Number.isFinite(+brushSize.min) ? +brushSize.min : 0;
    const MAX = Number.isFinite(+brushSize.max) ? +brushSize.max : 100;

    const updateBrushSliderFill = () => {
    if (!brushSize) return;

    const val = Number(brushSize.value);
    const lo = Math.min(MIN, MAX);
    const hi = Math.max(MIN, MAX);
    const range = Math.max(hi - lo, 1); // avoid /0

    const pRaw = (val - lo) / range;
    // Prevent tiny FP rounding from stopping short of 100%
    const p = (val >= hi) ? 1 : Math.min(1, Math.max(0, pRaw));

    // Keep both variables for compatibility with older CSS
    brushSize.style.setProperty('--p', String(p));
    brushSize.style.setProperty('--filled', (p === 1) ? '100%' : `${(p * 100).toFixed(2)}%`);

    // optional: keep ARIA in sync for screen readers
    brushSize.setAttribute('aria-valuenow', String(val));
    };
        updateBrushSliderAccent();
        updateBrushSliderFill();
        const copyButton = window.paintApp.state.domElements.copyButton;

// Update color of stroke currently in edit mode when the color picker changes
if (colorPicker) {
    const applyEditedStrokeColor = () => {
        const img = window.currentImageLabel;
        const edited = window.selectedStrokeInEditMode;
        if (!img || !edited) return;
        if (!window.vectorStrokesByImage || !window.vectorStrokesByImage[img] || !window.vectorStrokesByImage[img][edited]) return;

        // Apply new color to the vector data of the edited stroke
        const vectorData = window.vectorStrokesByImage[img][edited];
        vectorData.color = colorPicker.value;

        // Persist and refresh UI
        try { saveState(true, false, false); } catch(_) {}
        try { redrawCanvasWithVisibility(); } catch(_) {}
        try { updateStrokeVisibilityControls(); } catch(_) {}
    };

    // Support both direct color input and programmatic swatch changes (which dispatch 'change')
    colorPicker.addEventListener('input', applyEditedStrokeColor);
    colorPicker.addEventListener('change', applyEditedStrokeColor);

    // Keep slider accent in sync with chosen color
    colorPicker.addEventListener('input', () => {
        updateBrushSliderAccent();
    });
    colorPicker.addEventListener('change', () => {
        updateBrushSliderAccent();
    });
}
    const pasteButton = window.paintApp.state.domElements.pasteButton;
    const strokeCounter = window.paintApp.state.domElements.strokeCounter;
    const imageList = window.paintApp.state.domElements.imageList;
    const drawingModeToggle = window.paintApp.state.domElements.drawingModeToggle;
    const strokeSidebar = window.paintApp.state.domElements.strokeSidebar;
    const imageSidebar = window.paintApp.state.domElements.imageSidebar;
    const strokeSidebarHeader = window.paintApp.state.domElements.strokeSidebarHeader;
    const imageSidebarHeader = window.paintApp.state.domElements.imageSidebarHeader;
    
    // Expose canvas globally for project management
    window.canvas = canvas;
    
    // Set up drag-and-drop for the image list container
    imageList.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
    });
    
    imageList.addEventListener('drop', (e) => {
        e.preventDefault();
        
        // If dropped on the imageList itself (not on a specific container), append to end
        if (draggedImageItem && e.target === imageList) {
            imageList.appendChild(draggedImageItem);
        }
    });

    // === REMBG Safety Shim (additive, opt-in, no side effects when disabled) ===
    function rembg_isShimEnabled() {
        try {
            var v = (typeof process !== 'undefined' && process && process.env && process.env.NEXT_PUBLIC_REMBG_SAFESHIM) || globalThis.NEXT_PUBLIC_REMBG_SAFESHIM;
            return String(v) === '1';
        } catch (_) { return false; }
    }

    function rembg_debug() {
        try {
            var dbg = (typeof process !== 'undefined' && process && process.env && process.env.NEXT_PUBLIC_REMBG_SAFESHIM_DEBUG) || globalThis.NEXT_PUBLIC_REMBG_SAFESHIM_DEBUG;
            if (String(dbg) === '1') {
                // eslint-disable-next-line no-console
                console.log.apply(console, arguments);
            }
        } catch (_) {}
    }

    // === LABEL REPROJECTION FEATURE FLAG ===
    function labelReprojectEnabled() {
        try {
            var v = (typeof process !== 'undefined' && process && process.env && process.env.NEXT_PUBLIC_LABEL_REPROJECT) || globalThis.NEXT_PUBLIC_LABEL_REPROJECT;
            return String(v) === '1';
        } catch (_) { return false; }
    }
    function labelReprojectDebug() {
        try {
            var v = (typeof process !== 'undefined' && process && process.env && process.env.NEXT_PUBLIC_LABEL_REPROJECT_DEBUG) || globalThis.NEXT_PUBLIC_LABEL_REPROJECT_DEBUG;
            return String(v) === '1';
        } catch (_) { return false; }
    }

    function labelNormEnabled() {
        try {
            var v = (typeof process !== 'undefined' && process && process.env && process.env.NEXT_PUBLIC_LABEL_NORM) || globalThis.NEXT_PUBLIC_LABEL_NORM;
            return String(v) === '1';
        } catch (_) { return false; }
    }

    function labelStrictEnabled() {
        try {
            var v = (typeof process !== 'undefined' && process && process.env && process.env.NEXT_PUBLIC_LABEL_REPROJECT_STRICT) || globalThis.NEXT_PUBLIC_LABEL_REPROJECT_STRICT;
            return String(v) === '1';
        } catch (_) { return false; }
    }

    function labelSkipRebaseEnabled() {
        try {
            var v = (typeof process !== 'undefined' && process && process.env && process.env.NEXT_PUBLIC_LABEL_REPROJECT_SKIP_REBASE) || globalThis.NEXT_PUBLIC_LABEL_REPROJECT_SKIP_REBASE;
            return String(v) === '1';
        } catch (_) { return false; }
    }

    function rembg_blobToDataURL(blob) {
        return new Promise(function(resolve, reject) {
            var reader = new FileReader();
            reader.onload = function() { resolve(reader.result); };
            reader.onerror = function(err) { reject(err); };
            reader.readAsDataURL(blob);
        });
    }

    async function rembg_createImageSafe(dataUrl) {
        var img = new Image();
        img.crossOrigin = 'anonymous';
        img.src = dataUrl;
        await img.decode();
        return img;
    }

    async function rembg_useBitmapSafely(outBlob) {
        var dataUrl = await rembg_blobToDataURL(outBlob);
        var img = await rembg_createImageSafe(dataUrl);
        return { img: img, width: img.naturalWidth || img.width, height: img.naturalHeight || img.height };
    }

    // Undo/Redo functionality - use values from paintApp structure
    const MAX_HISTORY = window.paintApp.config.MAX_HISTORY;
    const IMAGE_LABELS = window.paintApp.config.IMAGE_LABELS;
    
    // Add missing state variables to paintApp.state and use references
    window.paintApp.state.