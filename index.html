<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenPaint</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    <link rel="dns-prefetch" href="https://cdn.tailwindcss.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Suppress Tailwind production warning for this demo
        if (typeof console !== 'undefined' && console.warn) {
            const originalWarn = console.warn;
            console.warn = (...args) => {
                if (args[0] && typeof args[0] === 'string' && args[0].includes('should not be used in production')) return;
                originalWarn.apply(console, args);
            };
        }
        
        // Suppress autofill extension errors
        window.addEventListener('error', (event) => {
            if (event.message && event.message.includes('autofill.bundle.js')) {
                event.preventDefault();
                return false;
            } 
        });
    </script>
    <style>
        /* Custom styles for image list and tag system */
        .image-container {
            border-left: 2px solid transparent;
            transition: all 0.2s ease;
        }
        
        .image-container:hover {
            border-left-color: #3b82f6;
            background-color: #f8fafc;
        }
        
        .image-container[aria-selected="true"] {
            border-left-color: #3b82f6;
            background-color: #eff6ff;
        }
        
        .tag-badge {
            display: inline-block;
            background-color: #e0e7ff;
            color: #3730a3;
            font-size: 10px;
            font-weight: 500;
            padding: 2px 6px;
            border-radius: 6px;
            line-height: 1;
        }
        
        .no-tags {
            font-size: 10px;
            color: #9ca3af;
            font-style: italic;
        }
        
        .image-label:hover {
            background-color: #f1f5f9 !important;
        }

        /* Modern slider styling (align with original OpenPaint) */
        .slider {
            --accent: #3b82f6;
            --p: 0;            /* 0..1 progress (set by JS) */
            --filled: 30%;     /* legacy percent for compatibility */
            --track-h: 6px;    /* track height */
            --thumb: 16px;     /* thumb diameter (px) */
            /* align fill end exactly under thumb center across browsers */
            --pos: calc((var(--p) * (100% - var(--thumb))) + (var(--thumb) / 2));
            -webkit-appearance: none;
            appearance: none;
            outline: none;
            border-radius: 9999px;
            height: var(--track-h);
            background: transparent; /* let track draw the background */
        }

        /* WebKit/Blink track + thumb */
        .slider::-webkit-slider-runnable-track {
            height: var(--track-h);
            border-radius: 9999px;
            background: linear-gradient(
                to right,
                var(--accent) 0,
                var(--accent) var(--pos),
                #e5e7eb   var(--pos),
                #e5e7eb 100%
            );
            }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: var(--thumb);
            height: var(--thumb);
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            /* keep a subtle depth but pull the blue glow inside the thumb */
            box-shadow: inset 0 0 0 3px rgba(59, 130, 246, 0.45), 0 1px 2px rgba(0, 0, 0, 0.07);
            transition: all 0.2s ease;
            /* center the thumb on a thin track */
            margin-top: calc((var(--track-h) - var(--thumb)) / 2);
        }

        

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.08);
            box-shadow: inset 0 0 0 4px rgba(59, 130, 246, 0.55), 0 2px 3px rgba(0, 0, 0, 0.08);
        }

        /* Firefox track + thumb + progress */
        .slider::-moz-range-track {
            height: var(--track-h);
            border-radius: 9999px;
            background: #e5e7eb;
        }

        .slider::-moz-range-progress {
            height: var(--track-h);
            border-radius: 9999px;
            background: var(--accent);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
            box-shadow: inset 0 0 0 3px rgba(59, 130, 246, 0.45), 0 1px 2px rgba(0, 0, 0, 0.07);
            transition: all 0.2s ease;
        }

        .slider::-moz-range-thumb:hover {
            transform: scale(1.08);
            box-shadow: inset 0 0 0 4px rgba(59, 130, 246, 0.55), 0 2px 3px rgba(0, 0, 0, 0.08);
        }
        
        /* Match original OpenPaint slider width */
        #brushSize { width: 120px; margin: 0; }

        /* Remove native focus outline while keeping custom inset ring */
        .slider { -webkit-tap-highlight-color: transparent; }
        .slider:focus, .slider:focus-visible { outline: none !important; box-shadow: none; }
        .slider::-moz-focus-outer { border: 0; }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // Modern brand colors
                        brand: {
                            50: '#f0f9ff',
                            100: '#e0f2fe',
                            200: '#bae6fd',
                            300: '#7dd3fc',
                            400: '#38bdf8',
                            500: '#0ea5e9',
                            600: '#0284c7',
                            700: '#0369a1',
                            800: '#075985',
                            900: '#0c4a6e',
                        },
                        // Semantic colors
                        primary: {
                            50: '#eff6ff',
                            100: '#dbeafe',
                            200: '#bfdbfe',
                            300: '#93c5fd',
                            400: '#60a5fa',
                            500: '#3b82f6',
                            600: '#2563eb',
                            700: '#1d4ed8',
                            800: '#1e40af',
                            900: '#1e3a8a',
                        },
                        success: {
                            50: '#f0fdf4',
                            100: '#dcfce7',
                            200: '#bbf7d0',
                            300: '#86efac',
                            400: '#4ade80',
                            500: '#22c55e',
                            600: '#16a34a',
                            700: '#15803d',
                            800: '#166534',
                            900: '#14532d',
                        },
                        danger: {
                            50: '#fef2f2',
                            100: '#fee2e2',
                            200: '#fecaca',
                            300: '#fca5a5',
                            400: '#f87171',
                            500: '#ef4444',
                            600: '#dc2626',
                            700: '#b91c1c',
                            800: '#991b1b',
                            900: '#7f1d1d',
                        },
                        warning: {
                            50: '#fffbeb',
                            100: '#fef3c7',
                            200: '#fde68a',
                            300: '#fcd34d',
                            400: '#fbbf24',
                            500: '#f59e0b',
                            600: '#d97706',
                            700: '#b45309',
                            800: '#92400e',
                            900: '#78350f',
                        },
                    },
                    fontFamily: {
                        'sans': ['Inter', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'sans-serif'],
                    },
                    fontSize: {
                        'xs': ['0.75rem', { lineHeight: '1rem' }],
                        'sm': ['0.875rem', { lineHeight: '1.25rem' }],
                        'base': ['1rem', { lineHeight: '1.5rem' }],
                        'lg': ['1.125rem', { lineHeight: '1.75rem' }],
                        'xl': ['1.25rem', { lineHeight: '1.75rem' }],
                        '2xl': ['1.5rem', { lineHeight: '2rem' }],
                    },
                    borderRadius: {
                        'xl': '0.75rem',
                        '2xl': '1rem',
                        '3xl': '1.5rem',
                    },
                    boxShadow: {
                        'glass': '0 8px 32px 0 rgba(31, 38, 135, 0.37)',
                        'panel': '0 10px 25px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
                        'elevated': '0 25px 50px -12px rgba(0, 0, 0, 0.25)',
                    },
                    backdropBlur: {
                        'xs': '2px',
                    }
                }
            }
        }
    </script>
    
    <!-- Loading optimization and debug gate -->
    <style>
        /* Hide UI until initialization completes to prevent flash */
        .app-loading body { 
            visibility: hidden !important; 
        }
        
        /* Hide toolbar specifically during loading to prevent flash */
        .app-loading #topToolbar {
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        /* Ensure stable toolbar layout from the start */
        #topToolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 40;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-bottom: 1px solid rgb(226, 232, 240);
            height: 48px;
        }
        
        .toolbar-wrap {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 48px;
        }
        
        #tbLeft, #tbCenter, #tbRight {
            position: relative;
            display: flex;
            align-items: center;
        }
        
        .group-gap > * {
            margin-right: 6px;
        }
        
        .group-gap > *:last-child {
            margin-right: 0;
        }
        
        /* Ensure all toolbar buttons have consistent sizing */
        .tbtn {
            height: 32px;
            padding: 0 10px;
            border-radius: 8px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid rgba(148, 163, 184, 0.6);
            background: #fff;
            font-size: 12px;
            line-height: 1;
            transition: all 0.15s ease;
            white-space: nowrap;
        }
        
        .tinput {
            height: 32px;
            padding: 0 10px;
            border-radius: 8px;
            border: 1px solid rgba(148, 163, 184, 0.6);
            background: #fff;
            font-size: 12px;
            line-height: 1;
            transition: all 0.15s ease;
        }
        
        .icon-btn {
            width: 32px;
            justify-content: center;
            padding: 0;
        }
        
        /* Specific button styles to prevent layout shifts */
        #paste {
            padding: 8px 16px;
            background: rgb(59, 130, 246);
            color: white;
            font-weight: 600;
            border-radius: 12px;
            border: none;
        }
        
        #clear {
            padding: 8px 16px;
            background: rgb(239, 68, 68);
            color: white;
            font-weight: 600;
            border-radius: 12px;
            border: none;
        }
        
        #drawingModeToggle {
            padding: 8px 16px;
            background: white;
            color: rgb(34, 197, 94);
            font-weight: 600;
            border-radius: 12px;
            border: 2px solid rgb(34, 197, 94);
        }
        
        #projectName {
            width: 140px;
            padding: 8px 12px;
            border: 1px solid rgb(209, 213, 219);
            border-radius: 12px;
            background: white;
            font-size: 14px;
        }
        
        #loadProject {
            padding: 8px 16px;
            background: white;
            color: rgb(51, 65, 85);
            font-weight: 600;
            border-radius: 12px;
            border: 1px solid rgb(209, 213, 219);
            font-size: 12px;
        }
        
        #saveProjectTop {
            padding: 8px 16px;
            background: rgb(59, 130, 246);
            color: white;
            font-weight: 700;
            border-radius: 12px;
            border: 1px solid rgb(37, 99, 235);
            font-size: 14px;
        }
        
        #updateShareBtn {
            padding: 6px 12px;
            background: rgb(14, 165, 233);
            color: white;
            font-weight: 600;
            border-radius: 12px;
            border: 1px solid rgb(2, 132, 199);
            margin-left: 8px;
        }
        
        #unitToggleBtn {
            padding: 6px 12px;
            background: white;
            color: rgb(51, 65, 85);
            font-weight: 600;
            border-radius: 12px;
            border: 1px solid rgb(209, 213, 219);
        }
        
        /* Color swatches */
        .color-swatches {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .color-swatches button {
            width: 20px;
            height: 20px;
            border-radius: 9999px;
            border: 2px solid white;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
            margin: 0;
            padding: 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .color-swatches button:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.12);
        }
        

        
        /* Responsive text labels */
        .label-long {
            display: inline;
        }
        
        .label-short {
            display: none;
        }
        
        @media (max-width: 768px) {
            .label-long {
                display: none;
            }
            
            .label-short {
                display: inline;
            }
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        /* Fullscreen canvas styles */
        #canvas {
            position: fixed;
            z-index: 1;
            cursor: crosshair;
            background: #f8f9fa;
        }
        
        /* Modern floating panel base styles */
        .floating-panel {
            backdrop-filter: blur(20px);
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1), 
                       0 4px 6px -2px rgba(0, 0, 0, 0.05),
                       0 0 0 1px rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .floating-panel:hover {
            background: rgba(255, 255, 255, 0.99);
        }
        
        /* Only apply hover transform to main panels, not side panels */
        #projectPanel:hover,
        #toolsPanel:hover,
        #canvasControls:hover {
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            transform: translateY(-1px);
        }
        
        .floating-panel.dragging {
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            transform: none !important;
            transition: none !important;
        }
        
        /* Modern capture frame styles */
        #captureOverlay {
            backdrop-filter: none;
        }
        
        .capture-frame {
            background: transparent;
            transition: none !important;
        }
        
        .capture-frame.locked {
            cursor: default;
        }
        
        .capture-frame.unlocked {
            cursor: move;
        }
        
        /* Capture frame dragging - no transitions for 1:1 movement */
        .capture-frame.dragging {
            transition: none !important;
        }
        
        /* Modern resize handles - smaller and more discrete */
        .resize-handle {
            position: absolute;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        
        .capture-frame.unlocked:hover .resize-handle,
        .capture-frame.unlocked .resize-handle:hover {
            opacity: 1;
        }
        
        .resize-handle:hover {
            transform: scale(1.3);
            background: #3b82f6 !important;
            border-color: white !important;
        }
        
        /* Dark overlay - no transitions for instant response */
        #darkOverlay {
            transition: none;
        }
        
        /* macOS style popup */
        #lockPopup {
            font-size: 14px;
            font-weight: 500;
        }
        
        #lockPopup.show {
            display: flex !important;
            animation: fadeInOut 1.5s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        
        /* Lock button states */
        #captureLockButton .locked-icon {
            display: none;
        }
        
        #captureLockButton .unlocked-icon {
            display: block;
        }
        
        #captureLockButton.locked .locked-icon {
            display: block;
        }
        
        #captureLockButton.locked .unlocked-icon {
            display: none;
        }
        
        /* Hide resize handles when locked */
        .capture-frame.locked .resize-handles {
            display: none;
        }
        
        /* Drag over canvas effects */
        #canvas.drag-over {
            background: rgba(76, 175, 80, 0.05);
        }
        
        /* Panel minimization styles */
        .floating-panel.minimized {
            max-height: none !important;
            height: auto !important; /* Override any inline height when minimized */
        }
        
        .floating-panel.minimized .cursor-move {
            border-bottom: none;
        }
        
        /* When elementsBody is hidden, ensure panel shrinks to header only */
        #strokePanel:has(#elementsBody.hidden) {
            height: auto !important;
        }
        
        #imagePanel:has(#imagePanelContent.hidden) {
            height: auto !important;
            min-height: 140px !important; /* Header + name box + some padding */
        }
        
        /* Ensure Images header is always visible */
        #imagePanelHeader {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Ensure image name header is always visible and not squished */
        #imagePanel > .px-3.bg-white.border-b.border-slate-200.py-2 {
            flex-shrink: 0 !important;
            min-height: 60px !important;
            position: relative !important;
            z-index: 10 !important;
            display: block !important;
            visibility: visible !important;
        }

        /* Ensure the image name input is always visible */
        #currentImageNameBox {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            width: 100% !important;
        }

        /* Ensure image panel maintains proper height when content changes */
        #imagePanel {
            display: flex !important;
            flex-direction: column !important;
        }

        /* Ensure content area doesn't affect header visibility */
        #imagePanelContent {
            flex: 1 1 auto !important;
            min-height: 0 !important;
            overflow: hidden !important;
        }
        
        /* Smooth transitions for all panel content */
        .floating-panel [id$='Content'],
        .floating-panel [id$='Controls'],
        #elementsBody {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }
        
        .floating-panel [id$='Content'].hidden,
        .floating-panel [id$='Controls'].hidden,
        #elementsBody.hidden {
            max-height: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-top: 0 !important;
            margin-bottom: 0 !important;
            opacity: 0;
        }
        
        /* Enhanced button hover effects */
        .floating-panel button[id^='toggle']:hover svg {
            transform: scale(1.1);
        }
        
        /* Allow overflow for canvas controls to show hover menu */
        #canvasControlsContent { 
            overflow: visible !important; 
        }
        
        /* Smart label system for responsive button text */
        .label-short { 
            display: none; 
        }
        .label-long, .label-short {
            white-space: nowrap;
        }
        .smart-label-scope.compact .label-long { 
            display: none; 
        }
        .smart-label-scope.compact .label-short { 
            display: inline; 
        }
        
        /* Active state for minimized panels */
        .floating-panel.minimized {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);
        }

        /* Enhanced arrow button styling */
        #startArrow.active, #endArrow.active,
        #arrowStartBtn.active, #arrowEndBtn.active {
            background: linear-gradient(135deg, #3b82f6, #2563eb) !important;
            color: white !important;
            transform: scale(1.05) !important;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4) !important;
            border: 2px solid #1d4ed8 !important;
            font-weight: 600 !important;
        }

        #startArrow.active:hover, #endArrow.active:hover,
        #arrowStartBtn.active:hover, #arrowEndBtn.active:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8) !important;
            transform: scale(1.08) !important;
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.5) !important;
        }

        /* Arrow button transitions */
        #startArrow, #endArrow, #arrowStartBtn, #arrowEndBtn {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
        }
        
        .floating-panel:not(.minimized) {
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        /* Ensure proper dragging behavior */
        .floating-panel.dragging {
            z-index: 9999 !important;
            transform: none !important;
            transition: none !important;
        }

        /* Keep Elements header always visible; body uses remaining space */
        #strokePanel {
            display: flex;
            flex-direction: column;
            /* Let the panel grow to near full viewport height while preserving drag behavior */
            max-height: calc(100vh - 24px) !important;
        }
        #elementsHeader {
            flex: 0 0 auto;
        }
        #elementsBody {
            flex: 1 1 auto;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        /* removed elementsResizeHandle */
        #elementsControls {
            position: sticky;
            top: 0;
            z-index: 10;
            background: white;
        }
        #strokeVisibilityControls {
            flex: 1 1 auto;
            min-height: 0; /* allows flex child to shrink for scrolling in Firefox */
            overflow-y: auto !important;
        }
        
        /* Header dragging styles */
        .cursor-move:active {
            cursor: grabbing !important;
        }
        
        /* Fix stroke visibility item layout */
        .stroke-visibility-item {
            display: flex !important;
            align-items: center !important;
            gap: 8px !important;
            padding: 8px !important;
            margin-bottom: 4px !important;
            background: white !important;
            border-radius: 6px !important;
            border: 1px solid #e5e7eb !important;
            transition: all 0.2s ease !important;
        }

        /* Ensure the strokes list flows vertically and doesn't overlap */
        #strokesList { display: flex; flex-direction: column; gap: 6px; }
        .stroke-actions-panel { display: block; margin: 6px 0; }
        .stroke-actions-buttons { display: flex; gap: 8px; flex-wrap: wrap; }

        /* Make the strokes area adjustable but constrained so new items never overlap headers */
        #strokeVisibilityControls {
            min-height: 60px;
            max-height: min(60vh, 24rem) !important; /* cap to viewport or panel max-h-96 */
            overflow-y: auto !important;
            overflow-x: hidden !important;
            box-sizing: border-box;
            position: relative;
        }
        #strokeVisibilityControls hr { margin: 6px 0; }
        
        .stroke-visibility-item:hover {
            background-color: #f9fafb !important;
            border-color: #d1d5db !important;
        }
        
        .stroke-label-container {
            display: flex !important;
            align-items: center !important;
            gap: 6px !important;
            flex: 1 !important;
        }
        
        .stroke-name {
            font-weight: 600 !important;
            font-size: 14px !important;
            padding: 2px 6px !important;
            border-radius: 4px !important;
            border: 1px solid currentColor !important;
            min-width: auto !important;
        }
        
        .stroke-label-toggle-btn {
            background: none !important;
            border: none !important;
            cursor: pointer !important;
            font-size: 16px !important;
            line-height: 1 !important;
            padding: 2px !important;
            opacity: 0.8 !important;
        }
        
        .stroke-label-toggle-btn:hover {
            opacity: 1 !important;
        }
        
        .stroke-measurement {
            font-size: 13px !important;
            color: #6b7280 !important;
            font-weight: 500 !important;
        }
        
        .stroke-delete-btn {
            background: none !important;
            border: none !important;
            color: #ef4444 !important;
            cursor: pointer !important;
            font-size: 16px !important;
            font-weight: bold !important;
            padding: 2px 6px !important;
            border-radius: 4px !important;
            opacity: 0.7 !important;
            transition: all 0.2s ease !important;
        }
        
        .stroke-delete-btn:hover {
            opacity: 1 !important;
            background-color: #fef2f2 !important;
        }
        
        /* Force scrollbars to always show when content overflows */
        #strokeVisibilityControls {
            scroll-behavior: smooth;
            overflow-y: scroll !important;
            scrollbar-width: auto !important;
            scrollbar-color: #9ca3af #f3f4f6 !important;
        }
        
        /* Ensure outer image panel content never scrolls; inner #imageList handles scrolling */
        #imagePanelContent { 
            overflow: hidden !important; 
        }
        
        #strokeVisibilityControls::-webkit-scrollbar {
            width: 8px !important;
            display: block !important;
        }
        
        #strokeVisibilityControls::-webkit-scrollbar-track {
            background: #f3f4f6 !important;
            border-radius: 4px !important;
        }
        
        #strokeVisibilityControls::-webkit-scrollbar-thumb {
            background: #9ca3af !important;
            border-radius: 4px !important;
            border: 1px solid #f3f4f6 !important;
        }
        
        #strokeVisibilityControls::-webkit-scrollbar-thumb:hover {
            background: #6b7280 !important;
        }
        
        /* Keep focus treatment tidy */
        #brushSize:focus-visible {
            outline: none;
            box-shadow: 0 0 0 4px rgba(59,130,246,0.15);
        }
        
        /* Modern input styling */
        input[type="text"], input[type="number"], select {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px #3b82f6, 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Enhanced color picker active state */
        [data-color].active {
            border-color: #1f2937 !important;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 1), 0 0 0 6px #1f2937 !important;
            transform: scale(1.15);
        }
        
        /* Image Gallery Styling */
        #imageGallery {
            scrollbar-width: thin;
            scrollbar-color: #cbd5e1 #f1f5f9;
        }
        
        #imageGallery::-webkit-scrollbar {
            height: 6px;
        }
        
        #imageGallery::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        
        #imageGallery::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        
        #imageGallery::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        
        /* Image thumbnail styling */
        .image-thumbnail {
            flex-shrink: 0;
            width: 120px;
            height: 120px;
            border-radius: 12px;
            border: 2px solid transparent;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            scroll-snap-align: center;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
            overflow: hidden;
        }
        
        .image-thumbnail:hover {
            border-color: #cbd5e1;
            transform: scale(1.05);
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1);
        }
        
        .image-thumbnail.active {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2), 0 10px 25px -3px rgba(0, 0, 0, 0.15);
            transform: scale(1.05);
        }
        
        .image-thumbnail.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
            z-index: 1000;
        }
        
        .image-thumbnail.drag-over {
            border-color: #10b981;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.5);
            transform: translateY(-1px) scale(1.05);
        }
        
        .image-thumbnail .image-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
            color: white;
            padding: 8px;
            font-size: 11px;
            font-weight: 500;
            text-align: center;
            border-radius: 0 0 10px 10px;
        }
        
        .thumbnail-controls {
            position: absolute;
            top: 4px;
            right: 4px;
            display: none;
            flex-direction: column;
            gap: 2px;
        }
        
        .delete-control {
            position: absolute;
            top: 4px;
            left: 4px;
            display: none;
        }
        
        .image-thumbnail:hover .thumbnail-controls,
        .image-thumbnail:hover .delete-control {
            display: flex;
        }
        
        .control-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            color: #374151;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .control-btn:hover {
            background: white;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .delete-btn {
            background: #dc2626 !important;
            color: white !important;
            font-weight: bold;
        }
        
        .delete-btn:hover {
            background: #b91c1c !important;
            transform: scale(1.1);
        }
        
        .rotate-btn:hover {
            background: #dbeafe;
            color: #2563eb;
        }
        
        .flip-btn:hover {
            background: #d1fae5;
            color: #059669;
        }
        
        /* Navigation dots styling */
        .nav-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #cbd5e1;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .nav-dot:hover {
            background: #94a3b8;
            transform: scale(1.2);
        }
        
        .nav-dot.active {
            background: #3b82f6;
            transform: scale(1.3);
        }

        /* Modernize panel chrome and add optional sketchbook vibe */
        .floating-panel {
            border: 1px solid rgba(15, 23, 42, 0.06);
            box-shadow: 0 12px 28px rgba(2, 6, 23, 0.08);
        }
        .floating-panel .cursor-move {
            border-bottom: 1px solid rgba(15, 23, 42, 0.06) !important;
        }
        /* Tone down button effects for a cleaner feel */
        .floating-panel button {
            box-shadow: 0 1px 2px rgba(2,6,23,0.06) !important;
            transform: none !important;
        }
        .floating-panel button:hover {
            transform: translateY(-1px) !important;
        }
        /* Minimal divider */
        .panel-divider { border-top: 1px solid rgba(15,23,42,0.08); }

        /* Top toolbar styles - now handled by comprehensive CSS above */
        .tbtn.active { border-color: rgba(59,130,246,.9); background: #eff6ff; color: #1e40af; }
        .tbtn:hover, .tselect:hover, .tinput:hover {
            border-color: rgba(59,130,246,.8);
            box-shadow: 0 2px 4px rgba(59,130,246,.1);
        }
        .popover {
            position: absolute;
            top: 40px;
            left: 0;
            background: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(2,6,23,.12);
            padding: 12px;
            display: none;
            z-index: 60;
            min-width: 120px;
        }
        .popover.show {
            display: block;
        }
    </style>
    
    <script>
        // Add loading class as early as possible to prevent UI flash
        document.documentElement.classList.add('app-loading');

        // Debug gate: enable with ?debug=1 or localStorage.debug='1'
        (function () {
            try {
                const params = new URLSearchParams(location.search);
                const debug = params.has('debug') || localStorage.getItem('debug') === '1';
                window.__DEBUG__ = !!debug;
                
                if (!window.__DEBUG__) {
                    // Silence non-essential logs in production
                    const noop = () => {};
                    console.log = noop;
                    console.debug = noop;
                    console.warn = noop;
                    // Keep console.error visible for real issues
                }
            } catch (_) {
                // Fallback if localStorage access fails
                window.__DEBUG__ = false;
            }
        })();
    </script>
</head>
<body class="bg-gray-50 h-screen overflow-hidden">
    <!-- Top Toolbar -->
    <div id="topToolbar">
        <div class="toolbar-wrap smart-label-scope">
            <div id="tbLeft" class="group-gap smart-label-scope">
                <!-- Pre-populated toolbar content to prevent flash -->
                <button id="paste" class="tbtn" title="Upload Images" aria-label="Upload Images">
                    <span class="label-long">Upload Images</span><span class="label-short">Upload</span>
                </button>
                <button id="clear" class="tbtn">Clear</button>
                <button id="drawingModeToggle" class="tbtn straight-mode" title="Straight Line" aria-label="Straight Line">
                    <span class="label-long">Straight Line</span><span class="label-short">Straight</span>
                </button>
                <div class="color-swatches">
                    <button class="active" data-color="#3b82f6" style="background-color: rgb(59, 130, 246);" title="Blue"></button>
                    <button data-color="#22c55e" style="background-color: rgb(34, 197, 94);" title="Green"></button>
                    <button data-color="#ef4444" style="background-color: rgb(239, 68, 68);" title="Red"></button>
                    <button data-color="#f59e0b" style="background-color: rgb(245, 158, 11);" title="Yellow"></button>
                    <button data-color="#a855f7" style="background-color: rgb(168, 85, 247);" title="Purple"></button>
                    <button data-color="#1f2937" style="background-color: rgb(31, 41, 55);" title="Dark Gray"></button>
                    <button data-color="#ffffff" style="background-color: rgb(255, 255, 255); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); border: 1px solid #ccc;" title="White"></button>
                    <button data-color="#10b981" style="background-color: rgb(16, 185, 129);" title="#10b981"></button>
                </div>
                <input
                    type="range"
                    id="brushSize"
                    class="h-2 rounded-lg appearance-none cursor-pointer slider"
                    min="1"
                    max="50"
                    value="5"
                    style="width: 120px; margin: 0;"
                />
                <button id="arrowStartBtn" class="tbtn icon-btn" title="Start Arrow">◀</button>
                <button id="arrowEndBtn" class="tbtn icon-btn" title="End Arrow">▶</button>
                <button id="dottedBtn" class="tbtn" title="Line Style"><svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line></svg></button>
                <button id="undoBtn" class="tbtn icon-btn" title="Undo">↺</button>
                <button id="redoBtn" class="tbtn icon-btn" title="Redo">↻</button>
            </div>
            <div id="tbCenter" class="group-gap"></div>
            <div id="tbRight" class="group-gap smart-label-scope">
                <input type="text" id="projectName" placeholder="Project Name" value="New Sofa" class="tinput" data-sharkid="__1">
                <button id="loadProject" title="Load Project" class="tbtn" aria-label="Load Project">
                    <span class="label-long">Load Project</span><span class="label-short">Load</span>
                </button>
                <button id="removeBgClientTop" class="tbtn" title="Remove background using server">Remove BG</button>
                <button id="saveProjectTop" class="tbtn" title="Save Project" aria-label="Save Project">
                    <span class="label-long">Save Project</span><span class="label-short">Save</span>
                </button>
                <button id="unitToggleBtn" class="tbtn" title="Toggle units">inches</button>
            </div>
        </div>
    </div>

    <!-- Fullscreen Canvas -->
    <canvas id="canvas"></canvas>
    
    <!-- Project Header Panel -->
    <div id="projectPanel" class="floating-panel fixed top-4 right-4 z-30 rounded-2xl w-80 transition-all duration-300">
        <div class="flex items-center justify-between p-4 cursor-move border-b border-gray-200/50">
            <h3 class="text-base font-bold text-slate-800">Project Settings</h3>
            <button id="toggleProjectPanel" class="text-slate-500 hover:text-slate-700 hover:bg-slate-100 rounded-lg p-1.5 transition-all duration-200 transform hover:scale-110" title="Minimize/Expand Panel">
                <svg class="w-5 h-5 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
        </div>
        <div id="projectPanelContent" class="p-3 transition-all duration-300">
            <div class="flex flex-col gap-3">
                <!-- Project Info -->
                <div class="flex flex-col gap-3">
                    <input 
                        type="text" 
                        id="projectName" 
                        placeholder="Project Name" 
                        value="New Sofa" 
                        class="px-3 py-2.5 border border-gray-300 rounded-xl text-sm bg-white w-full focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200 shadow-sm"
                    >
                    <div class="flex items-center gap-3">
                        <label for="unitSelector" class="text-sm font-semibold text-slate-700 w-14">Units:</label>
                        <select 
                            id="unitSelector" 
                            onchange="updateMeasurementDisplay()" 
                            class="px-3 py-2.5 border border-gray-300 rounded-xl text-sm bg-white flex-1 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200 shadow-sm"
                        >
                            <option value="inch">inches</option>
                            <option value="cm">cm</option>
                        </select>
                    </div>
                    
                    <!-- Hidden inputs for functionality -->
                    <div id="measurementInput" class="hidden">
                        <div id="inchInputs" class="flex items-center gap-2">
                            <input type="number" id="inchWhole" min="0" value="0" class="w-16 px-2 py-1 border border-gray-300 rounded text-sm">
                            <select id="inchFraction" class="px-2 py-1 border border-gray-300 rounded text-sm">
                                <option value="0">0</option>
                                <option value="0.125">1/8</option>
                                <option value="0.25">1/4</option>
                                <option value="0.375">3/8</option>
                                <option value="0.5">1/2</option>
                                <option value="0.625">5/8</option>
                                <option value="0.75">3/4</option>
                                <option value="0.875">7/8</option>
                            </select>
                        </div>
                        <div id="cmInputs" class="hidden">
                            <input type="number" id="cmValue" min="0" step="0.1" value="0.0" class="w-16 px-2 py-1 border border-gray-300 rounded text-sm">
                        </div>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="panel-divider pt-3 mt-2 space-y-2">
                    <!-- Load Project button -->
                    <div class="flex justify-center">
                        <button id="loadProject" title="Load project from ZIP file" class="px-4 py-2 bg-white border border-gray-300 text-slate-700 text-xs font-semibold rounded-xl hover:bg-slate-50 transition-all">Load Project</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Drawing Tools Panel -->
    <div id="toolsPanel" class="floating-panel fixed top-4 left-4 z-30 rounded-2xl transition-all duration-300">
        <div class="flex items-center justify-between p-4 cursor-move border-b border-gray-200/50">
            <h3 class="text-base font-bold text-slate-800">Drawing Tools</h3>
            <button id="toggleToolsPanel" class="text-slate-500 hover:text-slate-700 hover:bg-slate-100 rounded-lg p-1.5 transition-all duration-200 transform hover:scale-110" title="Minimize/Expand Panel">
                <svg class="w-5 h-5 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
        </div>
        <div id="toolsPanelContent" class="p-4 transition-all duration-300 smart-label-scope">
            <div class="flex flex-col gap-4">
                <!-- Primary Tools -->
                <div class="flex items-center gap-3">
                    <button id="clear" class="px-4 py-2.5 bg-danger-500 hover:bg-danger-600 active:bg-danger-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95">Clear</button>
                    <button id="paste" class="px-4 py-2.5 bg-primary-500 hover:bg-primary-600 active:bg-primary-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95" title="Upload Images" aria-label="Upload Images">
                        <span class="label-long">Upload Images</span><span class="label-short">Upload</span>
                    </button>
                    <button id="save" class="px-4 py-2.5 bg-success-500 hover:bg-success-600 active:bg-success-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95">Save Current</button>
                    <button id="copy" class="px-4 py-2.5 bg-primary-500 hover:bg-primary-600 active:bg-primary-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95" title="Copy image to clipboard (cropped to frame)" aria-label="Copy Image">Copy</button>
                </div>
                
                <!-- Color Palette -->
                <div class="flex items-center gap-3">
                    <span class="text-sm font-semibold text-slate-700">Color:</span>
                    <div class="flex gap-2">
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110 active" data-color="#3b82f6" style="background-color: #3b82f6;" title="Blue"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#22c55e" style="background-color: #22c55e;" title="Green"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#ef4444" style="background-color: #ef4444;" title="Red"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#f59e0b" style="background-color: #f59e0b;" title="Yellow"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#a855f7" style="background-color: #a855f7;" title="Purple"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#1f2937" style="background-color: #1f2937;" title="Dark Gray"></button>
                    </div>
                    <input type="color" id="colorPicker" value="#3b82f6" class="hidden">
                </div>
                
                <!-- Drawing Mode & Controls -->
                <div class="flex items-center gap-4">
                    <button id="drawingModeToggle" class="px-4 py-2.5 bg-white border-2 border-success-500 text-success-600 text-sm font-semibold rounded-xl hover:bg-success-50 hover:border-success-600 active:bg-success-100 transition-all duration-200 transform hover:scale-105 active:scale-95 straight-mode shadow-sm" title="Straight Line" aria-label="Straight Line">
                        <span class="label-long">Straight Line</span><span class="label-short">Straight</span>
                    </button>
                    
                </div>
                
                <!-- Arrow & Line Style Controls -->
                <div class="flex items-center gap-4">
                    <div id="arrowControls" class="flex items-center gap-3">
                        <span class="text-sm font-semibold text-slate-700">Arrows:</span>
                        <button id="startArrow" class="px-3 py-2 bg-slate-100 hover:bg-slate-200 active:bg-slate-300 text-slate-700 text-sm font-medium rounded-lg transition-all duration-200 transform hover:scale-105 active:scale-95 shadow-sm" title="Toggle start arrow">◀</button>
                        <button id="endArrow" class="px-3 py-2 bg-slate-100 hover:bg-slate-200 active:bg-slate-300 text-slate-700 text-sm font-medium rounded-lg transition-all duration-200 transform hover:scale-105 active:scale-95 shadow-sm" title="Toggle end arrow">▶</button>
                    </div>
                    <div id="dashControls" class="flex items-center gap-3">
                        <span class="text-sm font-semibold text-slate-700">Style:</span>
                        <select id="dashStyleSelect" class="px-3 py-2 border border-gray-300 rounded-xl text-sm bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200 shadow-sm">
                            <option value="solid">Solid</option>
                            <option value="small">Small Dash</option>
                            <option value="medium">Medium Dash</option>
                            <option value="large">Large Dash</option>
                            <option value="dot-dash">Dot-Dash</option>
                            <option value="custom">Custom</option>
                        </select>
                        <div id="customDashControls" class="hidden items-center gap-2">
                            <input type="number" id="dashLengthInput" min="1" max="50" value="5" class="w-16 px-2 py-1.5 border border-gray-300 rounded-lg text-xs focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200" title="Dash length">
                            <span class="text-xs text-slate-500">/</span>
                            <input type="number" id="gapLengthInput" min="1" max="50" value="5" class="w-16 px-2 py-1.5 border border-gray-300 rounded-lg text-xs focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200" title="Gap length">
                        </div>
                    </div>
                </div>
                
                <!-- Stroke Counter -->
                <div class="text-sm text-gray-600 font-medium">
                    <span id="strokeCounter">Lines: 0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Vectors and Tags Panel -->
    <div id="strokePanel" class="floating-panel fixed left-4 z-30 rounded-2xl w-64 transition-all duration-300 overflow-hidden" style="top: clamp(1rem, 50vh - 20rem, calc(100vh - 40rem - 1rem)); max-height: min(40rem, calc(100vh - 2rem));">
        <div id="elementsHeader" class="flex items-center justify-between p-3 cursor-move border-b border-gray-200/50 bg-white rounded-t-2xl">
            <div class="flex items-center gap-2">
                <h3 class="text-sm font-semibold text-slate-800">Elements</h3>
                <button id="viewMeasurementsToggle" title="Toggle measurement labels display" class="px-2 py-1 text-xs bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-all font-medium">
                    Show Labels
                </button>
            </div>
            <button id="toggleStrokePanel" class="text-slate-500 hover:text-slate-700 rounded-lg p-1 transition-all" title="Minimize/Expand Panel">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
        </div>
        <!-- Panel Body (collapsible) -->
        <div id="elementsBody" role="region" aria-labelledby="elementsHeader">
        <div id="elementsControls" class="px-3 pt-3 pb-1 border-b border-gray-100">
            <div class="flex gap-2 mb-2">
                <button id="selectAllStrokesBtn" title="Select/Deselect all elements" class="flex-1 px-2 py-1 text-xs bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg transition-all font-medium">
                    Deselect All
                </button>
                <button id="showAllMeasurementsBtn" title="Show all measurements in a list" class="flex-1 px-2 py-1 text-xs bg-green-100 hover:bg-green-200 text-green-700 rounded-lg transition-all font-medium">
                    Show List
                </button>
                <button id="viewSubmittedMeasurementsBtn" title="View submitted measurements from shared projects" class="flex-1 px-2 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 rounded-lg transition-all font-medium">
                    View Submitted
                </button>
            </div>
            <div class="flex gap-2 mb-2">
                <div class="flex-1 px-2 py-1 text-xs bg-gray-50 border border-gray-200 rounded-lg">
                    <div class="text-gray-500 text-xs mb-1">Next Tag:</div>
                    <div id="nextTagDisplay" 
                         contenteditable="true" 
                         spellcheck="false"
                         class="font-semibold text-blue-600 cursor-text hover:bg-blue-50 px-1 py-0.5 rounded outline-none focus:ring-2 focus:ring-blue-300" 
                         title="Type to set next tag">A</div>
                </div>
            </div>
            <div class="flex gap-2 flex-wrap items-center">
                <button id="tagModeToggle" title="Toggle between letters only and letters with numbers" class="px-2 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 rounded-lg transition-all font-medium">
                    Letters + Numbers
                </button>
                <label class="flex items-center gap-1 text-xs bg-slate-50 border border-slate-200 px-2 py-1 rounded-lg">
                    <input id="toggleShowMeasurements" type="checkbox" class="accent-blue-600" checked>
                    Show measurements
                </label>
                <button id="unitToggleBtnSecondary" class="px-2 py-1 text-xs bg-white border border-gray-300 rounded-lg hover:bg-gray-50" title="Toggle units">inches</button>
                <button id="labelShapeToggleBtn" class="px-2 py-1 text-xs bg-white border border-gray-300 rounded-lg hover:bg-gray-50" title="Toggle tag shape" aria-pressed="true">■</button>
            </div>
        </div>
        <div id="strokeVisibilityControls" class="px-3 pt-2 pb-2 transition-all duration-300 overflow-y-auto overflow-x-hidden" style="box-sizing: border-box;"></div>
        </div>
    </div>

    <!-- Image Gallery Panel -->
    <div id="imagePanel" class="floating-panel fixed right-4 z-30 rounded-2xl w-72 transition-all duration-300 overflow-hidden" style="top: clamp(1rem, 50vh - 20rem, calc(100vh - 40rem - 1rem)); max-height: min(40rem, calc(100vh - 2rem));">
        <div id="imagePanelHeader" class="flex items-center justify-between p-3 cursor-move border-b border-gray-200/50 bg-white rounded-t-2xl">
            <h3 class="text-sm font-semibold text-slate-800">Images</h3>
            <div class="flex items-center gap-2">
                <button id="toggleImagePanel" class="text-slate-500 hover:text-slate-700 rounded-lg p-1 transition-all" title="Minimize/Expand Panel">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </button>
            </div>
        </div>
        <!-- Name/title box outside the scroll area (always visible at top of images panel) -->
        <div class="px-3 bg-white border-b border-slate-200 py-2">
            <label for="currentImageNameBox" class="block text-[10px] text-slate-500 mb-1">Image name</label>
            <input id="currentImageNameBox" type="text" class="w-full px-2 py-1 border border-slate-300 rounded-md text-[12px] focus:outline-none focus:ring-2 focus:ring-primary-300" placeholder="Rename current image" />
        </div>
            <div id="imagePanelContent" class="p-3 transition-all duration-300" style="position: relative;">
            <!-- Legacy image list for backwards compatibility -->
            <div id="imageList" class="space-y-4 mb-0 h-[60vh] overflow-y-auto overflow-x-hidden pr-0 snap-y snap-mandatory scroll-smooth pt-[28vh] pb-[28vh]"></div>

            <!-- Snap guide line -->
            <div class="pointer-events-none absolute left-0 right-0 top-1/2 -translate-y-1/2 border-t border-slate-300/70"></div>

            
            
            <!-- Gallery (disabled in vertical list mode) -->
            <div class="mb-4 hidden">
                <div id="imageGallery" class="hidden"></div>
                <div id="imageDots" class="hidden"></div>
            </div>
            
            <!-- Image meta removed (name/type inputs no longer used) -->

            <!-- Navigation controls removed -->
        </div>
    </div>

    <!-- Capture Frame -->
    <div id="captureOverlay" class="fixed inset-0 pointer-events-none" style="z-index: 15;">
        <!-- Capture frame -->
        <div id="captureFrame" class="capture-frame absolute border-2 border-gray-400 bg-transparent" style="left: calc(50% - 400px); top: calc(50% - 300px); width: 800px; height: 600px; pointer-events: none;">
            <!-- Lock button -->
            <button id="captureLockButton" class="absolute -bottom-8 -right-8 w-8 h-8 bg-white border border-gray-300 rounded shadow-md hover:bg-gray-50 transition-colors flex items-center justify-center text-gray-600" title="Lock/Unlock frame (L)">
                <!-- Locked icon -->
                <svg class="locked-icon w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"></path>
                </svg>
                <!-- Unlocked icon -->
                <svg class="unlocked-icon w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z"></path>
                </svg>
            </button>
            
            <!-- Resize handles (hidden when locked) -->
            <div class="resize-handles">
                <div class="resize-handle w-3 h-3 -top-1 -left-1 bg-white border border-blue-400 rounded-sm" style="cursor: nw-resize;" data-direction="nw"></div>
                <div class="resize-handle w-3 h-3 -top-1 left-1/2 -translate-x-1/2 bg-white border border-blue-400 rounded-sm" style="cursor: n-resize;" data-direction="n"></div>
                <div class="resize-handle w-3 h-3 -top-1 -right-1 bg-white border border-blue-400 rounded-sm" style="cursor: ne-resize;" data-direction="ne"></div>
                <div class="resize-handle w-3 h-3 top-1/2 -translate-y-1/2 -right-1 bg-white border border-blue-400 rounded-sm" style="cursor: e-resize;" data-direction="e"></div>
                <div class="resize-handle w-3 h-3 -bottom-1 -right-1 bg-white border border-blue-400 rounded-sm" style="cursor: se-resize;" data-direction="se"></div>
                <div class="resize-handle w-3 h-3 -bottom-1 left-1/2 -translate-x-1/2 bg-white border border-blue-400 rounded-sm" style="cursor: s-resize;" data-direction="s"></div>
                <div class="resize-handle w-3 h-3 -bottom-1 -left-1 bg-white border border-blue-400 rounded-sm" style="cursor: sw-resize;" data-direction="sw"></div>
                <div class="resize-handle w-3 h-3 top-1/2 -translate-y-1/2 -left-1 bg-white border border-blue-400 rounded-sm" style="cursor: w-resize;" data-direction="w"></div>
            </div>
        </div>
    </div>
    
    <!-- Instruction Text for Unlocked Mode -->
    <div id="unlockInstructions" class="fixed top-4 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-80 text-white px-4 py-2 rounded-lg shadow-xl hidden backdrop-blur-sm z-40">
        <div class="text-sm font-medium text-center">
            Press <kbd class="px-1 py-0.5 bg-white bg-opacity-20 rounded text-xs">L</kbd> or click lock icon to exit positioning mode
        </div>
    </div>
    
    <!-- macOS Style Lock Popup -->
    <div id="lockPopup" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-80 text-white px-4 py-2 rounded-lg shadow-xl hidden transition-all duration-200 backdrop-blur-sm" style="z-index: 50;">
        <div class="flex items-center gap-2">
            <svg id="lockPopupIcon" class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"></path>
            </svg>
            <span id="lockPopupText">Locked</span>
        </div>
    </div>

    <!-- Canvas Controls (Bottom Panel) -->
    <div id="canvasControls" class="floating-panel fixed bottom-4 rounded-2xl px-3 py-2 transition-all duration-300" style="left: 50%; transform: translateX(-50%); z-index: 4000;">
        <div id="canvasControlsContent" class="flex items-center gap-2 text-sm smart-label-scope">
            <button id="copyCanvasBtn" class="flex items-center gap-1 px-3 py-1 bg-primary-500 hover:bg-primary-600 active:bg-primary-700 text-white text-xs rounded-lg shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-[1.02] active:scale-95" title="Copy image to clipboard" aria-label="Copy Image">
                <svg class="w-3.5 h-3.5 opacity-90" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M16 1H4a2 2 0 00-2 2v12h2V3h12V1zm3 4H8a2 2 0 00-2 2v14a2 2 0 002 2h11a2 2 0 002-2V7a2 2 0 00-2-2zm0 16H8V7h11v14z"></path></svg>
                <span class="label-long">Copy Image</span>
                <span class="label-short">Copy</span>
            </button>
            <select id="fitModeSelect" class="px-2 py-1 border border-gray-300 rounded-lg bg-white focus:outline-none hover:bg-gray-50">
                <option value="none">Manual</option>
                <option value="fit-width" selected>Fit Width</option>
                <option value="fit-height">Fit Height</option>
                <option value="fit-canvas">Fit Canvas</option>
                <option value="actual-size">Actual Size</option>
            </select>
            <button id="applyFitCurrent" class="px-2 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg hover:bg-slate-50" title="Apply to current image">Apply</button>
            <button id="scaleButton" class="px-2 py-1 bg-white border border-gray-300 rounded-lg text-sm font-medium hover:bg-gray-50" aria-haspopup="listbox" aria-expanded="false" type="button">100% <svg class="inline w-3 h-3 -mt-0.5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M5.25 7.5l4.5 4.5 4.5-4.5H5.25z"/></svg></button>
            <div class="flex items-center gap-1 ml-2">
                <button id="rotateLeftCtrl" class="px-2 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg hover:bg-slate-50" title="Rotate 90° CCW">↶</button>
                <button id="rotateRightCtrl" class="px-2 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg hover:bg-slate-50" title="Rotate 90° CW">↷</button>
            </div>

            <!-- Share/Update next to Copy/Save -->
            <button id="shareProjectBtn" class="px-3 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg shadow-sm hover:shadow-md hover:bg-slate-50 transition-all duration-200 transform hover:scale-[1.02] active:scale-95" title="Create shareable URL for customer measurements">
                Share
            </button>
            

            <!-- Quick Save with hover menu -->
            <div id="quickSave" class="relative ml-2">
                <button id="quickSaveBtn" class="px-3 py-1 bg-success-500 hover:bg-success-600 text-white text-xs rounded-lg">
                    Save
                </button>
                <div id="quickSaveMenu"
                     class="hidden absolute bottom-full mb-1 left-0 bg-white border border-gray-200 rounded-xl shadow-lg min-w-[120px]"
                     style="white-space: nowrap; z-index: 5000;">
                    <button class="block w-full text-left px-3 py-2 text-xs hover:bg-slate-50 rounded-t-xl transition-colors" data-action="pdf">Save as PDF</button>
                    <button class="block w-full text-left px-3 py-2 text-xs hover:bg-slate-50 rounded-b-xl transition-colors" data-action="multiple">Save Multiple</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Status message element for notifications -->
    <div id="statusMessage"></div>
    
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <!-- New UI Controller Script -->
    <script>
        // Initialize top toolbar - now works with pre-populated content
        function initializeTopToolbar() {
            const left = document.getElementById('tbLeft');
            const center = document.getElementById('tbCenter');
            const right = document.getElementById('tbRight');
            const bottom = document.getElementById('canvasControlsContent') || center;

            // Helper functions
            const setUniform = el => {
                if (!el) return;
                // Do not apply text-input styling to range sliders; it breaks their visuals
                if (el.tagName === 'INPUT' && el.type === 'range') return;
                el.classList.add(el.tagName === 'SELECT' ? 'tselect' : el.tagName === 'INPUT' ? 'tinput' : 'tbtn');
            };
            
            const reparent = (id, target, beforeSetup) => {
                const el = document.getElementById(id);
                if (!el) return null;
                beforeSetup?.(el);
                target.appendChild(el);
                setUniform(el);
                return el;
            };

            // Since toolbar is now pre-populated, we just need to ensure proper styling
            // and wire up any missing functionality
            const ensureUniformStyling = () => {
                const buttons = left.querySelectorAll('button, input, select');
                buttons.forEach(setUniform);
            };
            
            ensureUniformStyling();

            // Color swatches are now pre-populated, just need to wire up functionality
            const colorButtons = left.querySelectorAll('[data-color]');
            colorButtons.forEach(button => {
                if (!button.__boundColor) {
                    button.__boundColor = true;
                    button.addEventListener('click', () => {
                        document.querySelectorAll('[data-color].active').forEach(b=>b.classList.remove('active'));
                        button.classList.add('active');
                        const hex = button.getAttribute('data-color');
                        const cp = document.getElementById('colorPicker');
                        if (cp && hex) {
                            cp.value = hex;
                            cp.dispatchEvent(new Event('change'));
                        }
                        const bs = document.getElementById('brushSize');
                        if (bs && hex) bs.style.setProperty('--accent', hex);
                    });
                }
            });
            
            // Hide the color picker since we're using swatches
            const colorInput = document.getElementById('colorPicker');
            if (colorInput) colorInput.classList.add('hidden');

            

            // Arrow and line style controls are now pre-populated, just need to wire up functionality
            const arrowStartBtn = document.getElementById('arrowStartBtn');
            const arrowEndBtn = document.getElementById('arrowEndBtn');
            const dottedBtn = document.getElementById('dottedBtn');
            
            const setLineStyleIcon = (style) => {
                if (!dottedBtn) return;
                const svgSolid = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
                const svgSmall = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="4 4"/></svg>';
                const svgMedium = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="7 5"/></svg>';
                const svgLarge = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="11 7"/></svg>';
                dottedBtn.innerHTML = style === 'small' ? svgSmall : style === 'medium' ? svgMedium : style === 'large' ? svgLarge : svgSolid;
            };
            setLineStyleIcon('solid');

            // Wire controls to UI state in paint.js
            const setActive = (el, on) => el.classList.toggle('active', !!on);
            const syncFromState = () => {
                try {
                    const as = window.paintApp?.uiState?.arrowSettings;
                    const ds = window.paintApp?.uiState?.dashSettings;
                    setActive(arrowStartBtn, as?.startArrow);
                    setActive(arrowEndBtn, as?.endArrow);
                    setLineStyleIcon(ds?.style || 'solid');
                    // Sync label shape toggle visual state
                    const state = window.paintApp?.state || {};
                    const shape = state.labelShape || 'square';
                    // Note: shapeSquareBtn and shapeCircleBtn were removed, using single toggle button instead
                } catch {}
            };
            syncFromState();
            
            arrowStartBtn.addEventListener('click', () => {
                try {
                    const as = window.paintApp.uiState.arrowSettings;
                    as.startArrow = !as.startArrow;
                    // Apply to stroke in edit mode if any
                    const edited = window.selectedStrokeInEditMode;
                    const img = window.currentImageLabel;
                    if (edited && img && window.vectorStrokesByImage?.[img]?.[edited]) {
                        const v = window.vectorStrokesByImage[img][edited];
                        v.arrowSettings = v.arrowSettings || { arrowSize: as.arrowSize, arrowStyle: as.arrowStyle, startArrow: false, endArrow: false };
                        v.arrowSettings.startArrow = as.startArrow;
                        // Ensure curved lines switch type appropriately
                        if (typeof window.updateStrokeTypeBasedOnArrows === 'function') {
                            window.updateStrokeTypeBasedOnArrows(v);
                        } else {
                            const hasArrows = !!(v.arrowSettings.startArrow || v.arrowSettings.endArrow);
                            if (v.type === 'curved' && hasArrows) v.type = 'curved-arrow';
                            if (v.type === 'curved-arrow' && !hasArrows) v.type = 'curved';
                        }
                        window.saveState?.(true, false, false);
                        window.redrawCanvasWithVisibility?.();
                    }
                    syncFromState();
                } catch {}
            });
            arrowEndBtn.addEventListener('click', () => {
                try {
                    const as = window.paintApp.uiState.arrowSettings;
                    as.endArrow = !as.endArrow;
                    // Apply to stroke in edit mode if any
                    const edited = window.selectedStrokeInEditMode;
                    const img = window.currentImageLabel;
                    if (edited && img && window.vectorStrokesByImage?.[img]?.[edited]) {
                        const v = window.vectorStrokesByImage[img][edited];
                        v.arrowSettings = v.arrowSettings || { arrowSize: as.arrowSize, arrowStyle: as.arrowStyle, startArrow: false, endArrow: false };
                        v.arrowSettings.endArrow = as.endArrow;
                        // Ensure curved lines switch type appropriately
                        if (typeof window.updateStrokeTypeBasedOnArrows === 'function') {
                            window.updateStrokeTypeBasedOnArrows(v);
                        } else {
                            const hasArrows = !!(v.arrowSettings.startArrow || v.arrowSettings.endArrow);
                            if (v.type === 'curved' && hasArrows) v.type = 'curved-arrow';
                            if (v.type === 'curved-arrow' && !hasArrows) v.type = 'curved';
                        }
                        window.saveState?.(true, false, false);
                        window.redrawCanvasWithVisibility?.();
                    }
                    syncFromState();
                } catch {}
            });
            dottedBtn.addEventListener('click', () => {
                try {
                    const ds = window.paintApp.uiState.dashSettings;
                    // Cycle: solid -> small -> medium -> large -> solid
                    const next = { 'solid': 'small', 'small': 'medium', 'medium': 'large', 'large': 'solid' };
                    ds.style = next[ds.style] || 'small';
                    ds.enabled = ds.style !== 'solid';
                    // Compute dash pattern immediately (mirror paint.js getDashPattern)
                    const computePattern = (style, dashLen, gapLen, lineWidth = 1) => {
                        const baseScale = Math.max(2, lineWidth * 0.8);
                        switch (style) {
                            case 'small': return [6 * baseScale, 4 * baseScale];
                            case 'medium': return [12 * baseScale, 8 * baseScale];
                            case 'large': return [20 * baseScale, 12 * baseScale];
                            case 'dot-dash': return [4 * baseScale, 6 * baseScale, 12 * baseScale, 6 * baseScale];
                            case 'custom': return [dashLen * baseScale, gapLen * baseScale];
                            default: return [];
                        }
                    };
                    const brush = document.getElementById('brushSize');
                    const size = parseInt(brush?.value || '5') || 5;
                    ds.pattern = computePattern(ds.style, ds.dashLength, ds.gapLength, size);
                    // If editing a stroke, also update it live
                    const edited = window.selectedStrokeInEditMode;
                    const img = window.currentImageLabel;
                    if (edited && img && window.vectorStrokesByImage?.[img]?.[edited]) {
                        const v = window.vectorStrokesByImage[img][edited];
                        const lw = parseInt(v.width || size) || size;
                        v.dashSettings = { ...ds, pattern: computePattern(ds.style, ds.dashLength, ds.gapLength, lw) };
                        window.saveState?.(true, false, false);
                        window.redrawCanvasWithVisibility?.();
                    }
                    setLineStyleIcon(ds.style);
                    syncFromState();
                } catch {}
            });

            // Undo / Redo buttons
            // Undo/Redo buttons are now pre-populated, just need to wire up functionality
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            if (undoBtn) {
                undoBtn.addEventListener('click', () => { 
                    if (typeof window.undo === 'function') window.undo(); 
                });
            }
            
            if (redoBtn) {
                redoBtn.addEventListener('click', () => { 
                    if (typeof window.redo === 'function') window.redo(); 
                });
            }

            // CENTER/BOTTOM: canvas view controls moved to bottom
            reparent('fitModeSelect', bottom);
            reparent('applyFitCurrent', bottom);
            reparent('rotateLeftCtrl', bottom, el => { 
                el.classList.add('icon-btn', 'tbtn'); 
                el.title = 'Rotate Left'; 
                el.textContent = '↶'; 
            });
            reparent('rotateRightCtrl', bottom, el => { 
                el.classList.add('icon-btn', 'tbtn'); 
                el.title = 'Rotate Right'; 
                el.textContent = '↷'; 
            });
            reparent('scaleButton', bottom);
            syncFromState();

            // RIGHT: project settings are now pre-populated, just need to wire up functionality
            const saveProjectTop = document.getElementById('saveProjectTop');
            const shareProjectBtn = document.getElementById('shareProjectBtn');
            const updateShareBtn = document.getElementById('updateShareBtn');
            
            if (saveProjectTop) {
                saveProjectTop.addEventListener('click', () => {
                    if (window.projectManager?.saveProject) window.projectManager.saveProject();
                });
            }
            
            if (shareProjectBtn) {
                shareProjectBtn.addEventListener('click', () => {
                    if (window.shareProject) window.shareProject();
                });
            }
            
            if (updateShareBtn) {
                updateShareBtn.addEventListener('click', () => {
                    if (window.updateSharedProject) window.updateSharedProject();
                });
            }

            // Unit toggle button is now pre-populated, just need to wire up functionality
            const unitToggle = document.getElementById('unitToggleBtn');
            const unitSel = document.getElementById('unitSelector');
            const unitToggleSecondary = document.getElementById('unitToggleBtnSecondary');
            
            const getUnitLabel = () => (unitSel?.value === 'inch' ? 'inches' : 'cm');
            const toggleUnits = () => {
                if (!unitSel) return;
                unitSel.value = unitSel.value === 'inch' ? 'cm' : 'inch';
                const label = getUnitLabel();
                if (unitToggle) unitToggle.textContent = label;
                if (unitToggleSecondary) unitToggleSecondary.textContent = label;
                if (typeof updateMeasurementDisplay === 'function') {
                    updateMeasurementDisplay();
                } else if (unitSel.onchange) {
                    unitSel.onchange();
                }
            };

            if (unitToggle && unitSel) {
                unitToggle.textContent = getUnitLabel();
                unitToggle.addEventListener('click', toggleUnits);
                // Hide the original select (kept for compatibility)
                unitSel.style.display = 'none';
            }

            if (unitToggleSecondary && unitSel) {
                unitToggleSecondary.textContent = getUnitLabel();
                unitToggleSecondary.addEventListener('click', toggleUnits);
            }

            // Elements panel single-button shape toggle wiring
            const labelShapeToggleBtn = document.getElementById('labelShapeToggleBtn');
            const applyShape = (val) => {
                if (window.paintApp?.state) window.paintApp.state.labelShape = val;
                if (window.redrawCanvasWithVisibility) window.redrawCanvasWithVisibility();
            };
            if (labelShapeToggleBtn) {
                const syncShapeBtn = () => {
                    const shape = (window.paintApp?.state?.labelShape) || 'square';
                    const isSquare = shape !== 'circle';
                    labelShapeToggleBtn.textContent = isSquare ? '■' : '●';
                    labelShapeToggleBtn.setAttribute('aria-pressed', String(isSquare));
                };
                labelShapeToggleBtn.addEventListener('click', () => {
                    const shape = (window.paintApp?.state?.labelShape) || 'square';
                    applyShape(shape === 'circle' ? 'square' : 'circle');
                    syncShapeBtn();
                });
                syncShapeBtn();
            }

            // Auto-update shared project when state saves (debounced)
            if (window.updateSharedProject && window.saveState && !window.__autoUpdateSharePatched) {
                window.__autoUpdateSharePatched = true;
                const originalSaveState = window.saveState;
                let updateTimer = null;
                window.saveState = function() {
                    const result = originalSaveState.apply(this, arguments);
                    clearTimeout(updateTimer);
                    updateTimer = setTimeout(() => {
                        try { window.updateSharedProject(); } catch {}
                    }, 600);
                    return result;
                };
            }

            // Hide legacy panels after moving controls (keep in DOM to preserve any lookups)
            document.getElementById('toolsPanel')?.classList.add('hidden');
            document.getElementById('projectPanel')?.classList.add('hidden');
            const cc = document.getElementById('canvasControls');
            if (cc) { cc.classList.remove('hidden'); cc.style.display='block'; }

            // Add body padding to prevent toolbar overlap
            document.body.style.paddingTop = '48px';
        }

        // Setup quick save hover menu functionality
        function setupQuickSaveHover() {
            // Quick Save hover menu (bottom panel)
            const quickSave = document.getElementById('quickSave');
            const quickSaveBtn = document.getElementById('quickSaveBtn');
            const quickSaveMenu = document.getElementById('quickSaveMenu');

            console.log('Setting up quick save hover:', { quickSave, quickSaveBtn, quickSaveMenu });

            if (quickSave && quickSaveBtn && quickSaveMenu) {
                // Click: Save current image (reuses existing 'save' button)
                quickSaveBtn.addEventListener('click', () => {
                    console.log('Quick save clicked');
                    const saveButton = document.getElementById('save');
                    if (saveButton) saveButton.click();
                });

                let hideTimer = null;
                const showMenu = () => {
                    if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
                    quickSaveMenu.classList.remove('hidden');
                };
                const scheduleHide = () => {
                    if (hideTimer) clearTimeout(hideTimer);
                    hideTimer = setTimeout(() => {
                        quickSaveMenu.classList.add('hidden');
                        hideTimer = null;
                    }, 200); // small delay prevents flicker when moving cursor to menu
                };

                // Hover to show menu on the trigger container
                quickSave.addEventListener('mouseenter', showMenu);
                quickSave.addEventListener('mouseleave', scheduleHide);

                // Keep the menu open while hovering the menu; hide after leaving it
                quickSaveMenu.addEventListener('mouseenter', showMenu);
                quickSaveMenu.addEventListener('mouseleave', scheduleHide);

                // Menu actions
                quickSaveMenu.addEventListener('click', (e) => {
                    const item = e.target.closest('[data-action]');
                    if (!item) return;
                    const action = item.dataset.action;
                    console.log('Quick save menu action:', action);

                    if (action === 'pdf') {
                        const projectName = document.getElementById('projectName')?.value || 'Untitled Project';
                        if (typeof window.showPDFExportDialog === 'function') {
                            window.showPDFExportDialog(projectName);
                        }
                    } else if (action === 'multiple') {
                        if (typeof window.saveAllImages === 'function') {
                            window.saveAllImages();
                        }
                    }
                });
                console.log('Quick save hover menu setup complete');
            } else {
                console.error('Quick save elements not found:', { quickSave, quickSaveBtn, quickSaveMenu });
            }
        }

        // Smart label system for responsive button text
        function initSmartLabels() {
            // Helper to wrap button with smart label spans
            function wrapSmartLabel(buttonEl, longText, shortText) {
                if (!buttonEl || buttonEl.querySelector('.label-long')) return; // Already wrapped
                
                buttonEl.innerHTML = `<span class="label-long">${longText}</span><span class="label-short">${shortText}</span>`;
                buttonEl.setAttribute('title', longText);
                buttonEl.setAttribute('aria-label', longText);
            }
            
            // Helper to check if container needs compact mode
            function applyCompactLabels(container) {
                if (!container) return;
                
                // Simpler, more reliable overflow detection
                const containerWidth = container.clientWidth;
                const containerScrollWidth = container.scrollWidth;
                const needsCompact = containerScrollWidth > containerWidth;
                
                if (needsCompact) {
                    container.classList.add('compact');
                } else {
                    container.classList.remove('compact');
                }
            }
            
            // Setup ResizeObserver for each smart-label-scope container
            const containers = document.querySelectorAll('.smart-label-scope');
            const observers = new Map();
            
            containers.forEach(container => {
                let debounceTimer = null;
                const debouncedApply = () => {
                    if (debounceTimer) clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        applyCompactLabels(container);
                        // Also check parent containers
                        const parent = container.closest('.smart-label-scope');
                        if (parent && parent !== container) {
                            applyCompactLabels(parent);
                        }
                    }, 50); // Reduced debounce time for better responsiveness
                };
                
                const observer = new ResizeObserver(debouncedApply);
                observer.observe(container);
                observers.set(container, observer);
                
                // Initial check with immediate execution
                applyCompactLabels(container);
            });
            
            // Setup buttons that get created dynamically by toolbar initialization
            setTimeout(() => {
                // Load Project button (created by reparent)
                const loadBtn = document.getElementById('loadProject');
                if (loadBtn) {
                    wrapSmartLabel(loadBtn, 'Load Project', 'Load');
                }
                
                // Save Project button (created dynamically)
                const saveBtn = document.getElementById('saveProjectTop');
                if (saveBtn) {
                    wrapSmartLabel(saveBtn, 'Save Project', 'Save');
                    // Make it visually distinct from bottom save button
                    saveBtn.style.background = '#3b82f6'; // Blue instead of green
                    saveBtn.style.borderColor = '#2563eb';
                    saveBtn.style.fontWeight = '700';
                    saveBtn.style.fontSize = '14px';
                    saveBtn.style.padding = '8px 16px';
                }
                
                // Immediate check for all containers
                containers.forEach(container => {
                    applyCompactLabels(container);
                });
                
                // Additional check after a short delay to ensure everything is rendered
                setTimeout(() => {
                    containers.forEach(container => {
                        applyCompactLabels(container);
                    });
                }, 100);
            }, 150);
            
            // Global function to update drawing mode toggle labels
            window.updateDrawingModeLabels = function(mode) {
                const toggle = document.getElementById('drawingModeToggle');
                if (!toggle) return;
                
                const longSpan = toggle.querySelector('.label-long');
                const shortSpan = toggle.querySelector('.label-short');
                
                if (mode === true || mode === 'freehand') {
                    const longText = 'Freehand';
                    const shortText = 'Free';
                    if (longSpan) longSpan.textContent = longText;
                    if (shortSpan) shortSpan.textContent = shortText;
                    toggle.setAttribute('title', longText);
                    toggle.setAttribute('aria-label', longText);
                } else if (mode === 'curved') {
                    const longText = 'Curved Line';
                    const shortText = 'Curved';
                    if (longSpan) longSpan.textContent = longText;
                    if (shortSpan) shortSpan.textContent = shortText;
                    toggle.setAttribute('title', longText);
                    toggle.setAttribute('aria-label', longText);
                } else {
                    // Straight mode (false or 'straight')
                    const longText = 'Straight Line';
                    const shortText = 'Straight';
                    if (longSpan) longSpan.textContent = longText;
                    if (shortSpan) shortSpan.textContent = shortText;
                    toggle.setAttribute('title', longText);
                    toggle.setAttribute('aria-label', longText);
                }
                
                // Re-check container after label change
                const container = toggle.closest('.smart-label-scope');
                if (container) applyCompactLabels(container);
            };
            
            // Store observers for cleanup if needed
            window.smartLabelObservers = observers;
        }

        // New UI functionality for modular panels and capture frame
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize top toolbar by moving existing controls
            initializeTopToolbar();
            
            // Setup quick save hover menu after toolbar initialization (with small delay)
            setTimeout(setupQuickSaveHover, 100);
            
            // Initialize smart label system
            setTimeout(initSmartLabels, 200);
            
            // (Sketchbook toggle removed per request)
            // Panel visibility toggles
            const strokePanel = document.getElementById('strokePanel');
            const imagePanel = document.getElementById('imagePanel');
            const captureOverlay = document.getElementById('captureOverlay');
            const captureFrame = document.getElementById('captureFrame');
            // Per-image capture frame storage and helpers
            window.captureFrameByLabel = window.captureFrameByLabel || {};
            function buildCaptureFrameRecord(rect) {
                const winW = Math.max(window.innerWidth, 1);
                const winH = Math.max(window.innerHeight, 1);
                return {
                    left: Math.round(rect.left),
                    top: Math.round(rect.top),
                    width: Math.round(rect.width),
                    height: Math.round(rect.height),
                    windowWidth: winW,
                    windowHeight: winH,
                    relativeLeft: rect.left / winW,
                    relativeTop: rect.top / winH,
                    relativeWidth: rect.width / winW,
                    relativeHeight: rect.height / winH
                };
            }
            function getCaptureFrameRectPixels() {
                const rect = captureFrame.getBoundingClientRect();
                return buildCaptureFrameRecord(rect);
            }
            function saveCurrentCaptureFrameForLabel(label) {
                if (!label) return;
                window.captureFrameByLabel[label] = getCaptureFrameRectPixels();
            }
            function resolveCaptureFrameRect(stored) {
                const winW = Math.max(window.innerWidth, 1);
                const winH = Math.max(window.innerHeight, 1);
                const targetAspect = 4 / 3;

                let fallbackWidth = Math.min(800, winW);
                let fallbackHeight = Math.round(fallbackWidth / targetAspect);
                if (fallbackHeight > winH) {
                    fallbackHeight = Math.min(600, winH);
                    fallbackWidth = Math.round(fallbackHeight * targetAspect);
                }

                const fallback = {
                    left: Math.max(0, Math.round((winW - fallbackWidth) / 2)),
                    top: Math.max(0, Math.round((winH - fallbackHeight) / 2)),
                    width: fallbackWidth,
                    height: fallbackHeight
                };
                if (!stored) return fallback;

                const baseW = stored.windowWidth || winW;
                const baseH = stored.windowHeight || winH;
                let width = Math.max(1, Math.round(
                    typeof stored.relativeWidth === 'number'
                        ? stored.relativeWidth * winW
                        : (stored.width ?? fallback.width)
                ));
                let height = Math.max(1, Math.round(
                    typeof stored.relativeHeight === 'number'
                        ? stored.relativeHeight * winH
                        : (stored.height ?? fallback.height)
                ));

                if (width / height > targetAspect) {
                    width = Math.round(height * targetAspect);
                } else {
                    height = Math.round(width / targetAspect);
                }

                const leftRatio = typeof stored.relativeLeft === 'number'
                    ? stored.relativeLeft
                    : (stored.left ?? fallback.left) / baseW;
                const topRatio = typeof stored.relativeTop === 'number'
                    ? stored.relativeTop
                    : (stored.top ?? fallback.top) / baseH;

                const maxLeft = Math.max(0, winW - width);
                const maxTop = Math.max(0, winH - height);

                return {
                    left: Math.min(maxLeft, Math.max(0, Math.round(leftRatio * winW))),
                    top: Math.min(maxTop, Math.max(0, Math.round(topRatio * winH))),
                    width: Math.min(width, winW),
                    height: Math.min(height, winH)
                };
            }
            function applyCaptureFrameForLabel(label) {
                const stored = window.captureFrameByLabel[label];
                const rect = resolveCaptureFrameRect(stored);
                captureFrame.style.left = `${rect.left}px`;
                captureFrame.style.top = `${rect.top}px`;
                captureFrame.style.width = `${rect.width}px`;
                captureFrame.style.height = `${rect.height}px`;

                if (label) {
                    window.captureFrameByLabel[label] = {
                        ...(stored || {}),
                        ...rect,
                        windowWidth: Math.max(window.innerWidth, 1),
                        windowHeight: Math.max(window.innerHeight, 1),
                        relativeLeft: rect.left / Math.max(window.innerWidth, 1),
                        relativeTop: rect.top / Math.max(window.innerHeight, 1),
                        relativeWidth: rect.width / Math.max(window.innerWidth, 1),
                        relativeHeight: rect.height / Math.max(window.innerHeight, 1)
                    };
                }
            }
            window.saveCurrentCaptureFrameForLabel = saveCurrentCaptureFrameForLabel;
            window.applyCaptureFrameForLabel = applyCaptureFrameForLabel;

            let captureFrameResizeRaf = null;
            window.addEventListener('resize', () => {
                if (captureFrameResizeRaf !== null) return;
                captureFrameResizeRaf = requestAnimationFrame(() => {
                    captureFrameResizeRaf = null;
                    const activeLabel = window.currentImageLabel;
                    if (typeof window.applyCaptureFrameForLabel === 'function') {
                        window.applyCaptureFrameForLabel(activeLabel);
                    }
                });
            });
            
            // Enhanced panel toggle functionality with minimize-to-header behavior
            function createPanelToggle(panelId, contentId, buttonId) {
                const panel = document.getElementById(panelId);
                const content = document.getElementById(contentId);
                const button = document.getElementById(buttonId);
                const icon = button?.querySelector('svg');
                
                if (!panel || !content || !button || !icon) return;
                
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Use the specified content element
                    const body = content;
                    const isMinimized = body.classList.contains('hidden');
                    
                    if (isMinimized) {
                        // Expand panel
                        // starting from hidden (max-height:0), set explicit height to animate open
                        body.classList.remove('hidden');
                        body.style.maxHeight = body.scrollHeight + 'px';
                        // after transition completes, allow natural growth
                        const onEnd = () => {
                            body.style.maxHeight = 'none';
                            body.removeEventListener('transitionend', onEnd);
                        };
                        body.addEventListener('transitionend', onEnd);
                        icon.style.transform = 'rotate(0deg)';
                        panel.classList.remove('minimized');
                        panel.setAttribute('aria-expanded', 'true');
                    } else {
                        // Minimize panel
                        // if maxHeight is none (auto), set current height to enable smooth collapse
                        if (!body.style.maxHeight || body.style.maxHeight === 'none') {
                            body.style.maxHeight = body.scrollHeight + 'px';
                            // force reflow
                            void body.offsetHeight;
                        }
                        // add hidden to animate to max-height:0 via CSS
                        body.classList.add('hidden');
                        icon.style.transform = 'rotate(-90deg)';
                        panel.classList.add('minimized');
                        panel.setAttribute('aria-expanded', 'false');
                    }
                });
            }
            
            // Apply toggle functionality to all panels (default open for Stroke & Images)
            createPanelToggle('projectPanel', 'projectPanelContent', 'toggleProjectPanel');
            createPanelToggle('toolsPanel', 'toolsPanelContent', 'toggleToolsPanel');
            createPanelToggle('strokePanel', 'elementsBody', 'toggleStrokePanel');
            createPanelToggle('imagePanel', 'imagePanelContent', 'toggleImagePanel');
            createPanelToggle('canvasControls', 'canvasControlsContent', 'toggleCanvasControls');

            // Ensure Vectors and tags and Images are open by default
            (function expandByDefault() {
                const strokeContent = document.getElementById('elementsBody');
                const strokeButton = document.getElementById('toggleStrokePanel');
                const imageContent = document.getElementById('imagePanelContent');
                const imageButton = document.getElementById('toggleImagePanel');
                if (strokeContent && strokeButton && strokeContent.classList.contains('hidden')) {
                    strokeButton.click();
                }
                if (imageContent && imageButton && imageContent.classList.contains('hidden')) {
                    imageButton.click();
                }
                // Ensure Elements body has no artificial cap when expanded
                const elementsBody = document.getElementById('elementsBody');
                if (elementsBody && !elementsBody.classList.contains('hidden')) {
                    elementsBody.style.maxHeight = 'none';
                }
            })();

            // removed elements resize handle wiring

            // Set up Vectors and tags panel button functionality
            const selectAllStrokesBtn = document.getElementById('selectAllStrokesBtn');
            const showAllMeasurementsBtn = document.getElementById('showAllMeasurementsBtn');

            // Select/Deselect All Strokes functionality
            if (selectAllStrokesBtn) {
                let allSelected = false; // Start with deselect all (false)
                selectAllStrokesBtn.addEventListener('click', () => {
                    const checkboxes = document.querySelectorAll('#strokeVisibilityControls input[type="checkbox"]');
                    allSelected = !allSelected;
                    
                    checkboxes.forEach(checkbox => {
                        if (checkbox.checked !== allSelected) {
                            checkbox.click(); // Use click to trigger the existing event handlers
                        }
                    });
                    
                    // Update button text
                    selectAllStrokesBtn.textContent = allSelected ? 'Deselect All' : 'Select All';
                    selectAllStrokesBtn.title = allSelected ? 'Deselect all elements' : 'Select all elements';
                });
            }

            // Show All Measurements functionality
            if (showAllMeasurementsBtn) {
                showAllMeasurementsBtn.addEventListener('click', () => {
                    if (typeof window.generateMeasurementsList === 'function') {
                        window.generateMeasurementsList();
                    }
                });
            }
            
            // View Submitted Measurements functionality
            const viewSubmittedMeasurementsBtn = document.getElementById('viewSubmittedMeasurementsBtn');
            if (viewSubmittedMeasurementsBtn) {
                viewSubmittedMeasurementsBtn.addEventListener('click', () => {
                    if (typeof window.viewSubmittedMeasurements === 'function') {
                        window.viewSubmittedMeasurements();
                    } else {
                        console.error('viewSubmittedMeasurements function not found');
                    }
                });
            }

            // Simplified Tag System
            let tagMode = 'letters+numbers'; // 'letters' or 'letters+numbers'
            
            // Helper function to find next available letter (A, B, C...)
            function findNextAvailableLetter() {
                const currentImageLabel = window.currentImageLabel || 'default';
                const lineStrokes = window.lineStrokesByImage?.[currentImageLabel] || [];
                const existingTags = lineStrokes.filter(Boolean);
                
                // Extract all letters that have been used (from both A and A1 patterns)
                const usedLetters = new Set();
                for (const tag of existingTags) {
                    if (/^[A-Z]/.test(tag)) {
                        usedLetters.add(tag[0]); // Get the first letter
                    }
                }
                
                // Find the first unused letter
                for (let i = 0; i < 26; i++) {
                    const letter = String.fromCharCode(65 + i); // A=65, B=66, etc.
                    if (!usedLetters.has(letter)) {
                        return letter;
                    }
                }
                
                // If all letters A-Z are used, start over at A
                return 'A';
            }
            
            // Helper function to find next available letter+number (A1, A2, A3...)
            function findNextAvailableLetterNumber() {
                const currentImageLabel = window.currentImageLabel || 'default';
                const lineStrokes = window.lineStrokesByImage?.[currentImageLabel] || [];
                const existingTags = lineStrokes.filter(Boolean);
                
                // Extract all base tags (A1, A2, etc.) and track the highest per letter
                const letterCounts = new Map();
                
                for (const tag of existingTags) {
                    // Handle both A1 and A1(1) patterns
                    const match = tag.match(/^([A-Z])(\d+)(?:\((\d+)\))?$/);
                    if (match) {
                        const letter = match[1];
                        const number = parseInt(match[2]);
                        const currentMax = letterCounts.get(letter) || 0;
                        letterCounts.set(letter, Math.max(currentMax, number));
                    }
                }
                
                // Find the next available tag
                for (let letter = 'A'; letter <= 'Z'; letter = String.fromCharCode(letter.charCodeAt(0) + 1)) {
                    const maxNumber = letterCounts.get(letter) || 0;
                    const nextNumber = maxNumber + 1;
                    
                    if (nextNumber <= 9) {
                        return letter + nextNumber;
                    }
                }
                
                // If we've exhausted all possibilities up to Z9, start over at A1
                return 'A1';
            }

            // Tag Mode Toggle functionality
            const tagModeToggle = document.getElementById('tagModeToggle');
            if (tagModeToggle) {
                tagModeToggle.addEventListener('click', () => {
                    const oldMode = tagMode;
                    tagMode = tagMode === 'letters' ? 'letters+numbers' : 'letters';
                    tagModeToggle.textContent = tagMode === 'letters' ? 'Letters Only' : 'Letters + Numbers';
                    
                    // Automatically set the next appropriate tag when switching modes
                    const currentImageLabel = window.currentImageLabel || 'default';
                    window.labelsByImage = window.labelsByImage || {};
                    
                    if (tagMode === 'letters') {
                        // Switching to letters only - find next available letter
                        const nextLetter = findNextAvailableLetter();
                        window.labelsByImage[currentImageLabel] = nextLetter;
                        console.log(`[tagModeToggle] Switched to letters mode, next tag: ${nextLetter}`);
                    } else {
                        // Switching to letters+numbers - find next available letter+number
                        const nextLetterNumber = findNextAvailableLetterNumber();
                        window.labelsByImage[currentImageLabel] = nextLetterNumber;
                        console.log(`[tagModeToggle] Switched to letters+numbers mode, next tag: ${nextLetterNumber}`);
                    }
                    
                    updateNextTagDisplay();
                });
            }

            // Calculate next tag based on current mode and existing tags
            function calculateNextTag() {
                console.log('[calculateNextTag] Called with tagMode:', tagMode);
                const currentImageLabel = window.currentImageLabel || 'default';
                const lineStrokes = window.lineStrokesByImage?.[currentImageLabel] || [];
                const existingTags = lineStrokes.filter(Boolean);
                
                console.log('[calculateNextTag] Current image:', currentImageLabel, 'existing tags:', existingTags);
                
                if (existingTags.length === 0) {
                    const result = tagMode === 'letters' ? 'A' : 'A1';
                    console.log('[calculateNextTag] No existing tags, returning:', result);
                    return result;
                }
                
                // Extract all base tags (without suffixes)
                const baseTags = new Set();
                
                for (const tag of existingTags) {
                    if (tagMode === 'letters') {
                        if (/^[A-Z]$/.test(tag)) {
                            baseTags.add(tag);
                        }
                    } else {
                        // Handle both A1 and A1(1), A1(2) patterns
                        const match = tag.match(/^([A-Z]\d+)(?:\((\d+)\))?$/);
                        if (match) {
                            const baseTag = match[1];
                            baseTags.add(baseTag);
                        }
                    }
                }
                
                if (baseTags.size === 0) {
                    // No valid tags found, start fresh
                    const result = tagMode === 'letters' ? 'A' : 'A1';
                    console.log('[calculateNextTag] No valid tags found, returning:', result);
                    return result;
                }
                
                // Sort tags properly for alphanumeric comparison
                const sortedBaseTags = Array.from(baseTags).sort((a, b) => {
                    if (tagMode === 'letters') {
                        // Simple alphabetic sort for letter-only mode
                        return a.localeCompare(b);
                    } else {
                        // Alphanumeric sort: compare letter first, then number
                        const matchA = a.match(/^([A-Z])(\d+)$/);
                        const matchB = b.match(/^([A-Z])(\d+)$/);
                        
                        if (!matchA || !matchB) return a.localeCompare(b);
                        
                        const [, letterA, numA] = matchA;
                        const [, letterB, numB] = matchB;
                        
                        // Compare letters first
                        if (letterA !== letterB) {
                            return letterA.localeCompare(letterB);
                        }
                        
                        // If same letter, compare numbers numerically
                        return parseInt(numA) - parseInt(numB);
                    }
                });
                
                console.log('[calculateNextTag] Sorted tags:', sortedBaseTags);
                
                if (tagMode === 'letters') {
                    // Letters only mode: Check for gaps first
                    for (let i = 0; i < sortedBaseTags.length - 1; i++) {
                        const currentLetter = sortedBaseTags[i][0];
                        const nextLetter = sortedBaseTags[i + 1][0];
                        const expectedNext = String.fromCharCode(currentLetter.charCodeAt(0) + 1);
                        
                        if (expectedNext !== nextLetter && expectedNext <= 'Z') {
                            console.log('[calculateNextTag] Letters mode, found gap:', expectedNext);
                            return expectedNext;
                        }
                    }
                    
                    // No gaps, increment from last
                    const lastLetter = sortedBaseTags[sortedBaseTags.length - 1][0];
                    const nextLetter = String.fromCharCode(lastLetter.charCodeAt(0) + 1);
                    
                    if (nextLetter > 'Z') {
                        console.log('[calculateNextTag] Letters mode, wrapped to A');
                        return 'A';
                    }
                    
                    console.log('[calculateNextTag] Letters mode, next:', nextLetter);
                    return nextLetter;
                } else {
                    // Letters + numbers mode: Check for gaps first
                    for (let i = 0; i < sortedBaseTags.length; i++) {
                        const match = sortedBaseTags[i].match(/^([A-Z])(\d+)$/);
                        if (!match) continue;
                        
                        const [, letter, number] = match;
                        const num = parseInt(number);
                        
                        // Check if this is the first tag with this letter
                        if (i === 0 || sortedBaseTags[i - 1][0] !== letter) {
                            // If it doesn't start at 1, fill from 1
                            if (num > 1) {
                                const result = letter + '1';
                                console.log('[calculateNextTag] Numbers mode, found gap at start:', result);
                                return result;
                            }
                        }
                        
                        // Check for gaps within the same letter
                        if (i < sortedBaseTags.length - 1) {
                            const nextMatch = sortedBaseTags[i + 1].match(/^([A-Z])(\d+)$/);
                            if (nextMatch) {
                                const [, nextLetter, nextNumber] = nextMatch;
                                const nextNum = parseInt(nextNumber);
                                
                                // If same letter, check for gap
                                if (letter === nextLetter && nextNum > num + 1) {
                                    const result = letter + (num + 1);
                                    console.log('[calculateNextTag] Numbers mode, found gap:', result);
                                    return result;
                                }
                            }
                        }
                    }
                    
                    // No gaps, increment from last
                    const lastBaseTag = sortedBaseTags[sortedBaseTags.length - 1];
                    const match = lastBaseTag.match(/^([A-Z])(\d+)$/);
                    if (match) {
                        const [, letter, number] = match;
                        const nextNumber = parseInt(number) + 1;
                        
                        // Check if we need to move to the next letter
                        if (nextNumber > 9) {
                            const nextLetter = String.fromCharCode(letter.charCodeAt(0) + 1);
                            if (nextLetter > 'Z') {
                                console.log('[calculateNextTag] Numbers mode, wrapped to A1');
                                return 'A1';
                            }
                            const result = nextLetter + '1';
                            console.log('[calculateNextTag] Numbers mode, exceeded 9, next:', result);
                            return result;
                        }
                        
                        const result = letter + nextNumber;
                        console.log('[calculateNextTag] Numbers mode, next:', result);
                        return result;
                    } else {
                        console.log('[calculateNextTag] Unexpected tag format, returning A1');
                        return 'A1';
                    }
                }
            }

            // Calculate the next tag after a specific tag (for manual tag setting)
            // This increments without gap-filling to preserve user intent
            function calculateNextTagFrom(tag) {
                const mode = typeof tagMode === 'string' ? tagMode : 'letters+numbers';
                
                if (mode === 'letters') {
                    // Just increment the letter
                    const nextLetter = String.fromCharCode(tag.charCodeAt(0) + 1);
                    return nextLetter > 'Z' ? 'A' : nextLetter;
                } else {
                    // Letters + numbers mode
                    const match = tag.match(/^([A-Z])(\d+)$/);
                    if (!match) return 'A1';
                    
                    const [, letter, number] = match;
                    const nextNumber = parseInt(number) + 1;
                    
                    if (nextNumber > 9) {
                        // Wrap to next letter
                        const nextLetter = String.fromCharCode(letter.charCodeAt(0) + 1);
                        if (nextLetter > 'Z') {
                            return 'A1'; // Wrap around
                        }
                        return nextLetter + '1';
                    }
                    
                    return letter + nextNumber;
                }
            }

            // Calculate the next tag after a specific tag (simple increment, no gap-filling)
            function calculateNextTagFrom(tag) {
                const mode = typeof tagMode === 'string' ? tagMode : 'letters+numbers';
                
                if (mode === 'letters') {
                    // Just increment the letter
                    const nextLetter = String.fromCharCode(tag.charCodeAt(0) + 1);
                    return nextLetter > 'Z' ? 'A' : nextLetter;
                } else {
                    // Letters + numbers mode
                    const match = tag.match(/^([A-Z])(\d+)$/);
                    if (!match) return 'A1';
                    
                    const [, letter, number] = match;
                    const nextNumber = parseInt(number) + 1;
                    
                    if (nextNumber > 9) {
                        // Wrap to next letter
                        const nextLetter = String.fromCharCode(letter.charCodeAt(0) + 1);
                        if (nextLetter > 'Z') {
                            return 'A1'; // Wrap around
                        }
                        return nextLetter + '1';
                    }
                    
                    return letter + nextNumber;
                }
            }

            // Update the next tag display
            function updateNextTagDisplay() {
                const nextTagDisplay = document.getElementById('nextTagDisplay');
                if (nextTagDisplay) {
                    const currentImageLabel = window.currentImageLabel || 'default';
                    
                    // Priority: 1) labelsByImage (immediate next), 2) manualTagByImage (manual sequence), 3) calculateNextTag (gap-filling)
                    let nextTag;
                    if (window.labelsByImage && window.labelsByImage[currentImageLabel]) {
                        nextTag = window.labelsByImage[currentImageLabel];
                        console.log('[updateNextTagDisplay] Using labelsByImage:', nextTag);
                    } else if (window.manualTagByImage && window.manualTagByImage[currentImageLabel]) {
                        // We're in a manual sequence - use the manual flag value
                        nextTag = window.manualTagByImage[currentImageLabel];
                        console.log('[updateNextTagDisplay] Using manualTagByImage:', nextTag);
                    } else {
                        // Normal gap-filling mode
                        nextTag = calculateNextTag();
                        console.log('[updateNextTagDisplay] Using calculateNextTag (gap-filling):', nextTag);
                    }
                    
                    nextTagDisplay.textContent = nextTag;
                }
            }

            // Initialize next tag display
            updateNextTagDisplay();

            // Make functions available globally for paint.js to call
            window.updateNextTagDisplay = updateNextTagDisplay;
            window.calculateNextTag = calculateNextTag;
            window.calculateNextTagFrom = calculateNextTagFrom;
            console.log('[index.html] Made calculateNextTag available globally:', typeof window.calculateNextTag);
            
            // Allow user to set the next tag directly by typing in the display
            const nextTagEl = document.getElementById('nextTagDisplay');
            
            // Store original value when user starts editing
            let originalTagValue = '';
            
            nextTagEl?.addEventListener('focus', (e) => {
                originalTagValue = e.target.textContent.trim();
                // Select all text for easy replacement
                const range = document.createRange();
                range.selectNodeContents(e.target);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            });
            
            // Handle Enter key to commit changes
            nextTagEl?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur(); // Trigger validation via blur
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    e.target.textContent = originalTagValue;
                    e.target.blur();
                }
            });
            
            // Validate and save on blur
            nextTagEl?.addEventListener('blur', (e) => {
                const mode = typeof tagMode === 'string' ? tagMode : 'letters+numbers';
                const currentImageLabel = window.currentImageLabel || 'default';
                const input = e.target.textContent.trim().toUpperCase();
                
                // If empty or unchanged, restore original
                if (!input || input === originalTagValue) {
                    e.target.textContent = originalTagValue;
                    return;
                }
                
                const valid = mode === 'letters'
                    ? /^[A-Z]$/.test(input)
                    : /^[A-Z]\d+$/.test(input);

                if (!valid) {
                    // Show error briefly and restore original
                    e.target.textContent = '❌ Invalid';
                    e.target.classList.add('text-red-600');
                    setTimeout(() => {
                        e.target.textContent = originalTagValue;
                        e.target.classList.remove('text-red-600');
                    }, 1000);
                    return;
                }

                // Ensure labelsByImage exists, then set the next tag seed
                window.labelsByImage = window.labelsByImage || {};
                window.labelsByImage[currentImageLabel] = input;
                
                // Set flag to indicate this was a manual tag (not auto-calculated)
                // This tells the system to increment from this tag, not use gap-filling
                window.manualTagByImage = window.manualTagByImage || {};
                window.manualTagByImage[currentImageLabel] = input;
                
                e.target.textContent = input;
                console.log('[nextTagDisplay] Updated next tag to:', input, '(manual override)');
            });
            
            // Capture frame lock functionality
            let isCaptureLocked = true; // Start locked for minimal appearance
            
            // Initialize capture frame on load
            updateCaptureFrameLockState();
            
            // Lock/unlock button functionality
            const lockButton = document.getElementById('captureLockButton');
            lockButton?.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleCaptureLock();
            });
            
            // Keyboard shortcut for lock/unlock (L key) - ignore when typing in inputs/textareas/selects or contenteditable
            document.addEventListener('keydown', (e) => {
                const target = e.target;
                const isTyping = target && (
                    target.tagName === 'INPUT' ||
                    target.tagName === 'TEXTAREA' ||
                    target.tagName === 'SELECT' ||
                    target.isContentEditable
                );
                if (isTyping) return;
                if (e.key && e.key.toLowerCase() === 'l') {
                    e.preventDefault();
                    toggleCaptureLock();
                }
            });
            
            function toggleCaptureLock() {
                isCaptureLocked = !isCaptureLocked;
                updateCaptureFrameLockState();
                showLockPopup();
            }
            
            function showLockPopup() {
                const popup = document.getElementById('lockPopup');
                const icon = document.getElementById('lockPopupIcon');
                const text = document.getElementById('lockPopupText');
                
                if (isCaptureLocked) {
                    text.textContent = 'Locked';
                    icon.innerHTML = '<path d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"></path>';
                } else {
                    text.textContent = 'Unlocked';
                    icon.innerHTML = '<path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z"></path>';
                }
                
                popup.classList.add('show');
                setTimeout(() => {
                    popup.classList.remove('show');
                }, 1500);
            }
            
            function updateCaptureFrameLockState() {
                const lockButton = document.getElementById('captureLockButton');
                const instructions = document.getElementById('unlockInstructions');
                const applyAllButton = document.getElementById('applyFitAll');
                
                if (isCaptureLocked) {
                    captureFrame.classList.add('locked');
                    captureFrame.classList.remove('unlocked');
                    lockButton.classList.add('locked');
                    lockButton.title = 'Unlock frame (L)';
                    instructions.classList.add('hidden');
                    
                    // Hide Apply All button for safety
                    if (applyAllButton) {
                        applyAllButton.style.display = 'none';
                    }
                    
                    // Use white overlay outside the frame for clarity
                    captureFrame.style.boxShadow = '0 0 0 2000px rgba(255,255,255,1)';
                    
                    // Enable pointer events for lock button only
                    captureFrame.style.pointerEvents = 'none';
                    lockButton.style.pointerEvents = 'auto';
                } else {
                    captureFrame.classList.remove('locked');
                    captureFrame.classList.add('unlocked');
                    lockButton.classList.remove('locked');
                    lockButton.title = 'Lock frame (L)';
                    instructions.classList.remove('hidden');
                    
                    // Show Apply All button when unlocked
                    if (applyAllButton) {
                        applyAllButton.style.display = 'inline-block';
                    }
                    
                    // Remove overlay when unlocked for transparent background while adjusting
                    captureFrame.style.boxShadow = 'none';
                    
                    // Enable pointer events for dragging and resizing
                    captureFrame.style.pointerEvents = 'auto';
                    lockButton.style.pointerEvents = 'auto';
                }
            }
            
            
            // Color picker functionality
            const colorButtons = document.querySelectorAll('[data-color]');
            colorButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all buttons
                    colorButtons.forEach(btn => btn.classList.remove('active'));
                    // Add active class to clicked button
                    button.classList.add('active');
                    // Update color picker value
                    const colorPicker = document.getElementById('colorPicker');
                    if (colorPicker) {
                        colorPicker.value = button.getAttribute('data-color');
                        // Trigger change event for existing functionality
                        colorPicker.dispatchEvent(new Event('change'));
                    }
                });
            });
            
            // Update active color button styling
            const style = document.createElement('style');
            style.textContent = `
                [data-color].active {
                    border-color: #374151 !important;
                    box-shadow: 0 0 0 2px white, 0 0 0 4px #374151 !important;
                    transform: scale(1.1);
                }
            `;
            document.head.appendChild(style);
            
            // Capture frame resize functionality
            let isResizing = false;
            let currentHandle = null;
            let startPos = { x: 0, y: 0 };
            let startRect = { x: 0, y: 0, width: 0, height: 0 };
            
            const resizeHandles = document.querySelectorAll('.resize-handle');
            resizeHandles.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    // Don't allow resizing when locked
                    if (isCaptureLocked) return;
                    
                    e.preventDefault();
                    isResizing = true;
                    currentHandle = handle.getAttribute('data-direction');
                    startPos = { x: e.clientX, y: e.clientY };
                    
                    const rect = captureFrame.getBoundingClientRect();
                    startRect = {
                        x: rect.left,
                        y: rect.top,
                        width: rect.width,
                        height: rect.height
                    };
                    
                    document.addEventListener('mousemove', handleResize);
                    document.addEventListener('mouseup', stopResize);
                });
            });
            
            function handleResize(e) {
                if (!isResizing || !currentHandle) return;
                
                const deltaX = e.clientX - startPos.x;
                const deltaY = e.clientY - startPos.y;
                
                let newX = startRect.x;
                let newY = startRect.y;
                let newWidth = startRect.width;
                let newHeight = startRect.height;
                
                // Handle different resize directions
                switch (currentHandle) {
                    case 'nw':
                        newX = startRect.x + deltaX;
                        newY = startRect.y + deltaY;
                        newWidth = startRect.width - deltaX;
                        newHeight = startRect.height - deltaY;
                        break;
                    case 'n':
                        newY = startRect.y + deltaY;
                        newHeight = startRect.height - deltaY;
                        break;
                    case 'ne':
                        newY = startRect.y + deltaY;
                        newWidth = startRect.width + deltaX;
                        newHeight = startRect.height - deltaY;
                        break;
                    case 'e':
                        newWidth = startRect.width + deltaX;
                        break;
                    case 'se':
                        newWidth = startRect.width + deltaX;
                        newHeight = startRect.height + deltaY;
                        break;
                    case 's':
                        newHeight = startRect.height + deltaY;
                        break;
                    case 'sw':
                        newX = startRect.x + deltaX;
                        newWidth = startRect.width - deltaX;
                        newHeight = startRect.height + deltaY;
                        break;
                    case 'w':
                        newX = startRect.x + deltaX;
                        newWidth = startRect.width - deltaX;
                        break;
                }
                
                // Apply minimum size constraints
                const minSize = 100;
                if (newWidth < minSize) {
                    if (currentHandle.includes('w')) newX = startRect.x + startRect.width - minSize;
                    newWidth = minSize;
                }
                if (newHeight < minSize) {
                    if (currentHandle.includes('n')) newY = startRect.y + startRect.height - minSize;
                    newHeight = minSize;
                }
                
                // Apply maximum size constraints (viewport bounds)
                const maxX = window.innerWidth - newWidth;
                const maxY = window.innerHeight - newHeight;
                newX = Math.max(0, Math.min(maxX, newX));
                newY = Math.max(0, Math.min(maxY, newY));
                
                // Update capture frame position and size
                captureFrame.style.left = newX + 'px';
                captureFrame.style.top = newY + 'px';
                captureFrame.style.width = newWidth + 'px';
                captureFrame.style.height = newHeight + 'px';
                
            }
            
            function stopResize() {
                isResizing = false;
                currentHandle = null;
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
                // Save per-image frame when resizing ends
                if (typeof window.currentImageLabel !== 'undefined') {
                    saveCurrentCaptureFrameForLabel(window.currentImageLabel);
                    
                    // Store the frame dimensions as a ratio of canvas size
                    const canvas = document.getElementById('canvas');
                    const frameRect = captureFrame.getBoundingClientRect();
                    
                    if (!window.manualFrameRatios) {
                        window.manualFrameRatios = {};
                    }
                    
                    window.manualFrameRatios[window.currentImageLabel] = {
                        widthRatio: frameRect.width / canvas.clientWidth,
                        heightRatio: frameRect.height / canvas.clientHeight,
                        leftRatio: frameRect.left / canvas.clientWidth,
                        topRatio: frameRect.top / canvas.clientHeight
                    };
                    
                    console.log(`[FRAME] Saved ${window.currentImageLabel} frame ratios: ${(window.manualFrameRatios[window.currentImageLabel].widthRatio * 100).toFixed(1)}% width, ${(window.manualFrameRatios[window.currentImageLabel].heightRatio * 100).toFixed(1)}% height`);
                }
            }
            
            // Optimized capture frame dragging - 1:1 movement with no lag
            let isCaptureDragging = false;
            let captureDragOffset = { x: 0, y: 0 };
            let lastCaptureMousePos = { x: 0, y: 0 };
            let captureRafId = null;
            
            captureFrame.addEventListener('mousedown', (e) => {
                // Don't drag if locked, clicking on handles, or buttons
                if (isCaptureLocked || e.target.classList.contains('resize-handle') || e.target.closest('button')) {
                    return;
                }
                
                // Allow Shift+click to pass through for canvas dragging
                if (e.shiftKey) {
                    return;
                }
                
                e.preventDefault();
                e.stopPropagation();
                
                isCaptureDragging = true;
                
                const rect = captureFrame.getBoundingClientRect();
                captureDragOffset.x = e.clientX - rect.left;
                captureDragOffset.y = e.clientY - rect.top;
                
                // Add dragging class for no transitions
                captureFrame.classList.add('dragging');
                
                document.addEventListener('mousemove', handleCaptureDrag, { passive: true });
                document.addEventListener('mouseup', stopCaptureDrag);
            });
            
            function handleCaptureDrag(e) {
                if (!isCaptureDragging || isCaptureLocked) return;
                
                // Store mouse position for RAF
                lastCaptureMousePos.x = e.clientX;
                lastCaptureMousePos.y = e.clientY;
                
                // Cancel previous RAF if still pending
                if (captureRafId) {
                    cancelAnimationFrame(captureRafId);
                }
                
                // Schedule position update for next frame
                captureRafId = requestAnimationFrame(updateCapturePosition);
            }
            
            function updateCapturePosition() {
                if (!isCaptureDragging) return;
                
                const newX = Math.max(0, Math.min(window.innerWidth - captureFrame.offsetWidth, lastCaptureMousePos.x - captureDragOffset.x));
                const newY = Math.max(0, Math.min(window.innerHeight - captureFrame.offsetHeight, lastCaptureMousePos.y - captureDragOffset.y));
                
                // Apply position immediately
                captureFrame.style.left = newX + 'px';
                captureFrame.style.top = newY + 'px';
                
                
                captureRafId = null;
            }
            
            function stopCaptureDrag() {
                if (!isCaptureDragging) return;
                
                isCaptureDragging = false;
                
                // Cancel any pending RAF
                if (captureRafId) {
                    cancelAnimationFrame(captureRafId);
                    captureRafId = null;
                }
                
                // Remove dragging class
                captureFrame.classList.remove('dragging');
                
                document.removeEventListener('mousemove', handleCaptureDrag);
                document.removeEventListener('mouseup', stopCaptureDrag);
                // Save per-image frame when dragging ends
                if (typeof window.currentImageLabel !== 'undefined') {
                    saveCurrentCaptureFrameForLabel(window.currentImageLabel);
                }
            }
            
            // Optimized draggable functionality - 1:1 mouse movement with requestAnimationFrame
            function makeDraggable(element, handle) {
                let isDragging = false;
                let dragOffset = { x: 0, y: 0 };
                let lastMousePos = { x: 0, y: 0 };
                let rafId = null;
                let elementWidth, elementHeight; // Cache dimensions
                
                handle.addEventListener('mousedown', (e) => {
                    // Don't start drag if clicking on buttons or inputs
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.closest('button')) {
                        return;
                    }
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isDragging = true;
                    
                    // Simplified position setup - get current position directly
                    const rect = element.getBoundingClientRect();
                    
                    // Calculate offset from mouse to element's current position
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    // Cache element dimensions to avoid repeated DOM queries
                    elementWidth = element.offsetWidth;
                    elementHeight = element.offsetHeight;
                    
                    // Set initial position and prepare for dragging
                    element.style.position = 'fixed';
                    element.style.left = rect.left + 'px';
                    element.style.top = rect.top + 'px';
                    element.style.transform = 'none';
                    
                    // Clear conflicting positioning styles when dragging starts
                    element.style.bottom = 'auto';
                    element.style.right = 'auto';
                    
                    // Add visual feedback immediately
                    element.classList.add('dragging');
                    document.body.style.userSelect = 'none';
                    
                    document.addEventListener('mousemove', onMouseMove, { passive: true });
                    document.addEventListener('mouseup', stopDrag);
                });
                
                function onMouseMove(e) {
                    if (!isDragging) return;
                    
                    // Store mouse position for RAF
                    lastMousePos.x = e.clientX;
                    lastMousePos.y = e.clientY;
                    
                    // Cancel previous RAF if still pending
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                    }
                    
                    // Schedule position update for next frame
                    rafId = requestAnimationFrame(updatePosition);
                }
                
                function updatePosition() {
                    if (!isDragging) return;
                    
                    // Calculate new position from mouse minus offset
                    const newX = Math.max(0, Math.min(window.innerWidth - elementWidth, lastMousePos.x - dragOffset.x));
                    const newY = Math.max(0, Math.min(window.innerHeight - elementHeight, lastMousePos.y - dragOffset.y));
                    
                    // Apply position immediately using left/top for immediate visual feedback
                    element.style.left = newX + 'px';
                    element.style.top = newY + 'px';
                    
                    rafId = null;
                }
                
                function stopDrag(e) {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    
                    // Cancel any pending RAF
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                        rafId = null;
                    }
                    
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', stopDrag);
                    
                    // Reset visual feedback
                    element.classList.remove('dragging');
                    document.body.style.userSelect = '';
                }
            }
            
            // Make all floating panels draggable by their headers
            const floatingPanels = document.querySelectorAll('.floating-panel');
            floatingPanels.forEach(panel => {
                const header = panel.querySelector('.cursor-move');
                if (header) {
                    header.style.cursor = 'move';
                    makeDraggable(panel, header);
                }
            });
            
            // Scale dropdown functionality
            const scaleButton = document.getElementById('scaleButton');
            const scaleDropdown = document.getElementById('scaleDropdown');
            
            if (scaleButton && scaleDropdown) {
                scaleButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // Position the dropdown relative to the button with boundary checks
                    const buttonRect = scaleButton.getBoundingClientRect();
                    const dropdownWidth = 80; // min-width from CSS
                    const dropdownHeight = 320; // approximate height for all options
                    
                    let left = buttonRect.left;
                    let top = buttonRect.bottom + 2;
                    
                    // Check right boundary
                    if (left + dropdownWidth > window.innerWidth) {
                        left = buttonRect.right - dropdownWidth;
                    }
                    
                    // Check left boundary
                    if (left < 0) {
                        left = 0;
                    }
                    
                    // Check bottom boundary - show above button if no room below
                    if (top + dropdownHeight > window.innerHeight) {
                        top = buttonRect.top - dropdownHeight - 2;
                    }
                    
                    // Check top boundary
                    if (top < 0) {
                        top = buttonRect.bottom + 2; // fallback to below button
                    }
                    
                    scaleDropdown.style.left = left + 'px';
                    scaleDropdown.style.top = top + 'px';
                    
                    scaleDropdown.classList.toggle('hidden');
                });
                
                document.addEventListener('click', () => {
                    scaleDropdown.classList.add('hidden');
                });
                
                scaleDropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                // Handle scale option selection
                const scaleOptions = scaleDropdown.querySelectorAll('.scale-option');
                scaleOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        const scale = option.dataset.scale;
                        const percentage = Math.round(parseFloat(scale) * 100);
                        scaleButton.innerHTML = `${percentage}% <svg class="inline w-3 h-3 -mt-0.5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M5.25 7.5l4.5 4.5 4.5-4.5H5.25z"/></svg>`;
                        scaleDropdown.classList.add('hidden');
                    });
                });
            }
            
            // Custom dash controls functionality
            const dashStyleSelect = document.getElementById('dashStyleSelect');
            const customDashControls = document.getElementById('customDashControls');
            
            if (dashStyleSelect && customDashControls) {
                dashStyleSelect.addEventListener('change', () => {
                    if (dashStyleSelect.value === 'custom') {
                        customDashControls.classList.remove('hidden');
                        customDashControls.classList.add('flex');
                    } else {
                        customDashControls.classList.add('hidden');
                        customDashControls.classList.remove('flex');
                    }
                });
            }
            
            // Enhanced Image Gallery with Horizontal Scroll Navigation
            let currentImageIndex = 0;
            let imageGalleryData = [];
            let intersectionObserver = null;
            
            // Initialize image gallery functionality
            function initializeImageGallery() {
                const imageGallery = document.getElementById('imageGallery');
                const imageDots = document.getElementById('imageDots');
                const prevButton = document.getElementById('prevImage');
                const nextButton = document.getElementById('nextImage');
                const imagePosition = document.getElementById('imagePosition');
                const imageCounter = document.getElementById('imageCounter');
                
                if (!imageGallery) return;
                
                // Navigation button functionality
                prevButton?.addEventListener('click', () => navigateToImage(currentImageIndex - 1));
                nextButton?.addEventListener('click', () => navigateToImage(currentImageIndex + 1));
                
                // Intersection Observer for active image detection
                intersectionObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const imageIndex = parseInt(entry.target.dataset.imageIndex);
                            if (!isNaN(imageIndex)) {
                                updateActiveImage(imageIndex);
                            }
                        }
                    });
                }, {
                    root: imageGallery,
                    threshold: 0.6,
                    rootMargin: '0px'
                });
                
                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    // Only handle keyboard navigation if image panel is visible and focused
                    if (!document.getElementById('imagePanel').classList.contains('hidden')) {
                        if (e.key === 'ArrowLeft') {
                            e.preventDefault();
                            navigateToImage(currentImageIndex - 1);
                        } else if (e.key === 'ArrowRight') {
                            e.preventDefault();
                            navigateToImage(currentImageIndex + 1);
                        }
                    }
                });

                // Canvas Controls: wire rotate/flip buttons to current image
                const rotateLeftCtrl = document.getElementById('rotateLeftCtrl');
                const rotateRightCtrl = document.getElementById('rotateRightCtrl');
                function getCurrentImageIndex() {
                    const label = window.paintApp?.state?.currentImageLabel;
                    if (!label) return currentImageIndex || 0;
                    const idx = imageGalleryData.findIndex(i => (i.label || i.original?.label) === label);
                    return idx >= 0 ? idx : (currentImageIndex || 0);
                }
                function rotateFallback(deg) {
                    const label = window.paintApp?.state?.currentImageLabel || 'blank_canvas';
                    const c = document.getElementById('canvas');
                    const w = c?.width || 800;
                    const h = c?.height || 600;
                    if (typeof window.transformImageData === 'function') {
                        window.transformImageData(label, 'rotate', deg, w, h);
                        if (window.redrawCanvasWithVisibility) window.redrawCanvasWithVisibility();
                    }
                }
                rotateLeftCtrl?.addEventListener('click', () => {
                    const idx = getCurrentImageIndex();
                    if (imageGalleryData[idx]) {
                        window.rotateImage?.(idx, -90);
                    } else {
                        rotateFallback(-90);
                    }
                });
                rotateRightCtrl?.addEventListener('click', () => {
                    const idx = getCurrentImageIndex();
                    if (imageGalleryData[idx]) {
                        window.rotateImage?.(idx, 90);
                    } else {
                        rotateFallback(90);
                    }
                });

                // Name/type inputs wiring
                const nameInput = document.getElementById('imageNameInput');
                const typeSelect = document.getElementById('imageTypeSelect');
                nameInput?.addEventListener('change', (e) => {
                    const val = e.target.value || '';
                    const idx = currentImageIndex;
                    if (imageGalleryData[idx]) {
                        imageGalleryData[idx].name = val;
                        // Update caption under the thumbnail (if present)
                        const gallery = document.getElementById('imageGallery');
                        const card = gallery?.children[idx];
                        const caption = card?.querySelector('.thumb-caption');
                        if (caption) caption.textContent = val;
                    }
                });
                typeSelect?.addEventListener('change', (e) => {
                    const val = e.target.value || '';
                    const idx = currentImageIndex;
                    if (imageGalleryData[idx]) {
                        imageGalleryData[idx].original = imageGalleryData[idx].original || {};
                        imageGalleryData[idx].original.type = val;
                    }
                });
            }
            
            // Add image to gallery
            function addImageToGallery(imageData, index) {
                console.log(`[Gallery] Adding image to gallery at index ${index}:`, imageData);
                
                const imageGallery = document.getElementById('imageGallery');
                const imageDots = document.getElementById('imageDots');
                
                if (!imageGallery || !imageDots) {
                    console.error('[Gallery] imageGallery or imageDots element not found');
                    return;
                }
                
                // Handle different image data formats from external scripts
                let imageSrc, imageName;
                if (typeof imageData === 'string') {
                    // Simple string URL
                    imageSrc = imageData;
                    imageName = `Image ${index + 1}`;
                } else if (imageData && typeof imageData === 'object') {
                    // Object with src/url and name properties
                    imageSrc = imageData.src || imageData.url || imageData.dataUrl || imageData.blob;
                    imageName = imageData.name || imageData.filename || imageData.title || `Image ${index + 1}`;
                } else {
                    console.warn('[Gallery] Invalid image data format:', imageData);
                    return;
                }
                
                // Create image thumbnail
                const thumbnail = document.createElement('div');
                thumbnail.className = 'image-thumbnail';
                thumbnail.dataset.imageIndex = index;
                thumbnail.style.backgroundImage = `url(${imageSrc})`;
                thumbnail.title = imageName;
                thumbnail.draggable = true;
                
                // Remove overlay label; use minimal caption below instead
                
                // Add hover controls (delete only)
                const controls = createThumbnailControls(index);
                // Strip rotate/flip from controls
                controls.querySelectorAll('.rotate-btn, .flip-btn').forEach(el => el.remove());
                thumbnail.appendChild(controls);
                
                // Add all event listeners using helper function
                addThumbnailEventListeners(thumbnail, index);
                
                // Wrap thumbnail in a small card with optional caption
                const card = document.createElement('div');
                card.className = 'flex flex-col items-center gap-1';
                card.appendChild(thumbnail);
                // Compute caption; hide for blank canvas
                let displayName = '';
                try {
                    if (!(originalData && originalData.isBlankCanvas)) {
                        const lbl = originalData?.label;
                        if (lbl && typeof window.getTagBasedFilename === 'function') {
                            const base = lbl.split('_')[0];
                            displayName = window.getTagBasedFilename(lbl, base) || imageName || '';
                        } else {
                            displayName = imageName || '';
                        }
                    }
                } catch (e) { displayName = imageName || ''; }
                const caption = document.createElement('div');
                caption.className = 'thumb-caption text-[11px] text-slate-500 font-medium truncate max-w-[120px]';
                caption.textContent = displayName || '';
                card.appendChild(caption);
                if (displayName) thumbnail.title = displayName; else thumbnail.removeAttribute('title');
                imageGallery.appendChild(card);
                console.log(`[Gallery] Created thumbnail element:`, thumbnail);
                console.log(`[Gallery] Gallery element children count:`, imageGallery.children.length);
                
                // Create navigation dot
                const dot = document.createElement('div');
                dot.className = 'nav-dot';
                dot.dataset.imageIndex = index;
                dot.addEventListener('click', () => navigateToImage(index));
                imageDots.appendChild(dot);
                
                // Observe thumbnail for intersection
                if (intersectionObserver) {
                    intersectionObserver.observe(thumbnail);
                }
                
                // Store normalized image data
                // Handle cases where imageData already has an 'original' property to avoid nesting
                let originalData = imageData;
                if (imageData && imageData.original && typeof imageData.original === 'object') {
                    // If imageData already has an original property, use that instead
                    originalData = imageData.original;
                    console.log('[Gallery] Using nested original data to avoid double nesting');
                }
                
                const normalizedData = {
                    src: imageSrc,
                    name: imageName,
                    original: originalData
                };
                
                // Update gallery data
                imageGalleryData[index] = normalizedData;
                updateGalleryControls();
                
                console.log('[Gallery] Added image:', normalizedData);
                
                // Ensure the image panel is visible when adding any image
                const imagePanel = document.getElementById('imagePanel');
                const imagePanelContent = document.getElementById('imagePanelContent');
                if (imagePanel) {
                    // Remove any hidden classes
                    imagePanel.classList.remove('hidden');
                    
                    // Ensure the content is also visible (not collapsed)
                    if (imagePanelContent) {
                        imagePanelContent.classList.remove('hidden');
                        
                        // Ensure content has proper max-height for expansion
                        if (imagePanelContent.style.maxHeight === '0px' || imagePanelContent.style.maxHeight === '0') {
                            imagePanelContent.style.maxHeight = 'none';
                        }
                    }
                    
                    // Don't set display:block as it can interfere with drag positioning
                    // The panel is visible by default; just ensure no hidden class
                    if (imagePanel.style.display === 'none') {
                        imagePanel.style.display = '';
                    }
                    
                    // Ensure the panel is positioned within the visible viewport
                    // This fixes the issue where the panel might be off-screen after drag operations
                    const rect = imagePanel.getBoundingClientRect();
                    const windowWidth = window.innerWidth;
                    const windowHeight = window.innerHeight;
                    
                    // Check if panel is completely off-screen or has invalid dimensions
                    const isOffScreen = rect.right < 0 || rect.left > windowWidth || 
                                       rect.bottom < 0 || rect.top > windowHeight;
                    const hasInvalidSize = rect.width === 0 || rect.height === 0;
                    
                    // Also check if panel is mostly off-screen (more than 80% hidden)
                    const visibleWidth = Math.max(0, Math.min(rect.right, windowWidth) - Math.max(rect.left, 0));
                    const visibleHeight = Math.max(0, Math.min(rect.bottom, windowHeight) - Math.max(rect.top, 0));
                    const visibleArea = visibleWidth * visibleHeight;
                    const totalArea = rect.width * rect.height;
                    const isMostlyHidden = totalArea > 0 && (visibleArea / totalArea) < 0.2;
                    
                    if (isOffScreen || hasInvalidSize || isMostlyHidden) {
                        console.log('[Gallery] Panel is off-screen or invalid, resetting position');
                        
                        // Reset to default position (right side, vertically centered)
                        imagePanel.style.position = 'fixed';
                        imagePanel.style.right = '1rem';
                        imagePanel.style.left = 'auto';
                        imagePanel.style.top = 'clamp(1rem, 50vh - 20rem, calc(100vh - 40rem - 1rem))';
                        imagePanel.style.bottom = 'auto';
                        imagePanel.style.transform = '';
                    }
                }
            }
            
            // Navigate to specific image
            function navigateToImage(index) {
                const imageGallery = document.getElementById('imageGallery');
                if (!imageGallery || index < 0 || index >= imageGalleryData.length) return;
                
                const targetThumbnail = imageGallery.querySelector(`[data-image-index="${index}"]`);
                if (targetThumbnail) {
                    targetThumbnail.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest',
                        inline: 'center'
                    });
                }
                
                // Get the image data and find corresponding legacy image
                const imageData = imageGalleryData[index];
                if (imageData && imageData.original && imageData.original.label) {
                    const label = imageData.original.label;
                    console.log(`[Gallery] Switching to image with label: ${label}`);
                    
                    // Try to switch to the image using the legacy system
                    if (window.switchToImage && typeof window.switchToImage === 'function') {
                        window.switchToImage(label);
                        console.log(`[Gallery] Called switchToImage(${label})`);
                    } else {
                        console.warn('[Gallery] switchToImage function not available');
                    }
                }
                
                updateActiveImage(index);

                // Update image name/type inputs to match current image
                const nameInput = document.getElementById('imageNameInput');
                const typeSelect = document.getElementById('imageTypeSelect');
                const data = imageGalleryData[index];
                if (nameInput && data) nameInput.value = data.name || '';
                if (typeSelect && data && data.original && data.original.type) typeSelect.value = data.original.type; else if (typeSelect) typeSelect.value = '';
            }
            
            // Reorder images in the gallery
            function reorderImages(fromIndex, toIndex) {
                console.log(`[Gallery] Reordering image from ${fromIndex} to ${toIndex}`);
                
                // Reorder the data array
                const movedImage = imageGalleryData.splice(fromIndex, 1)[0];
                imageGalleryData.splice(toIndex, 0, movedImage);
                
                // Rebuild the gallery UI
                rebuildGalleryUI();
                
                // Update active image index if needed
                if (currentImageIndex === fromIndex) {
                    currentImageIndex = toIndex;
                } else if (currentImageIndex > fromIndex && currentImageIndex <= toIndex) {
                    currentImageIndex--;
                } else if (currentImageIndex < fromIndex && currentImageIndex >= toIndex) {
                    currentImageIndex++;
                }
                
                updateActiveImage(currentImageIndex);
            }
            
            // Rebuild the entire gallery UI after reordering
            function rebuildGalleryUI() {
                const imageGallery = document.getElementById('imageGallery');
                const imageDots = document.getElementById('imageDots');
                
                if (!imageGallery || !imageDots) return;
                
                // Clear existing thumbnails and dots
                imageGallery.innerHTML = '';
                imageDots.innerHTML = '';
                
                // Rebuild with new order
                imageGalleryData.forEach((imageData, index) => {
                    // Create thumbnail
                    const thumbnail = document.createElement('div');
                    thumbnail.className = 'image-thumbnail';
                    thumbnail.dataset.imageIndex = index;
                    thumbnail.style.backgroundImage = `url(${imageData.src})`;
                    thumbnail.title = imageData.name;
                    thumbnail.draggable = true;
                    
                    // Add hover controls (delete only)
                    const controls = createThumbnailControls(index);
                    // Strip rotate/flip from controls
                    controls.querySelectorAll('.rotate-btn, .flip-btn').forEach(el => el.remove());
                    thumbnail.appendChild(controls);
                    
                    // Add all event listeners (click, drag, etc.)
                    addThumbnailEventListeners(thumbnail, index);
                    
                    imageGallery.appendChild(thumbnail);
                    
                    // Create dot
                    const dot = document.createElement('div');
                    dot.className = 'nav-dot';
                    dot.dataset.imageIndex = index;
                    dot.addEventListener('click', () => navigateToImage(index));
                    imageDots.appendChild(dot);
                    
                    // Observe for intersection
                    if (intersectionObserver) {
                        intersectionObserver.observe(thumbnail);
                    }
                });
                
                updateGalleryControls();
            }
            
            // Create thumbnail control buttons (delete only)
            function createThumbnailControls(index) {
                const controlsContainer = document.createElement('div');
                
                // Delete control (separate, top-left)
                const deleteControl = document.createElement('div');
                deleteControl.className = 'delete-control';
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'control-btn delete-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.title = 'Delete image';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteImage(index);
                });
                
                deleteControl.appendChild(deleteBtn);
                controlsContainer.appendChild(deleteControl);
                
                return controlsContainer;
            }
            
            // Helper function to add all event listeners to a thumbnail
            function addThumbnailEventListeners(thumbnail, index) {
                // Click handler
                thumbnail.addEventListener('click', () => {
                    navigateToImage(index);
                });
                
                // Drag and drop handlers
                thumbnail.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', index);
                    thumbnail.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                thumbnail.addEventListener('dragend', () => {
                    thumbnail.classList.remove('dragging');
                    // Clear scroll interval when drag ends
                    if (window.dragScrollInterval) {
                        clearInterval(window.dragScrollInterval);
                        window.dragScrollInterval = null;
                    }
                });
                
                thumbnail.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    thumbnail.classList.add('drag-over');
                });
                
                thumbnail.addEventListener('dragleave', () => {
                    thumbnail.classList.remove('drag-over');
                });
                
                thumbnail.addEventListener('drop', (e) => {
                    e.preventDefault();
                    thumbnail.classList.remove('drag-over');
                    
                    // Clear scroll interval when drop happens
                    if (window.dragScrollInterval) {
                        clearInterval(window.dragScrollInterval);
                        window.dragScrollInterval = null;
                    }
                    
                    const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const targetIndex = index;
                    
                    if (draggedIndex !== targetIndex) {
                        reorderImages(draggedIndex, targetIndex);
                    }
                });
            }
            
            // Delete image function
            function deleteImage(index) {
                if (confirm(`Delete "${imageGalleryData[index]?.name}"?`)) {
                    console.log(`[Gallery] Deleting image at index ${index}`);
                    
                    // Remove from data array
                    imageGalleryData.splice(index, 1);
                    
                    // Rebuild UI
                    rebuildGalleryUI();
                    
                    // Adjust current index if needed
                    if (currentImageIndex >= index) {
                        currentImageIndex = Math.max(0, currentImageIndex - 1);
                    }
                    
                    // Update active image
                    if (imageGalleryData.length > 0) {
                        updateActiveImage(Math.min(currentImageIndex, imageGalleryData.length - 1));
                    }
                }
            }
            
            // Rotate image function
            window.rotateImage = function rotateImage(index, degrees) {
                console.log(`[Gallery] Rotating image ${index} by ${degrees}°`);
                
                const imageData = imageGalleryData[index];
                if (!imageData) return;
                
                // Apply rotation using Canvas
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas dimensions based on rotation
                    if (Math.abs(degrees) === 90 || Math.abs(degrees) === 270) {
                        canvas.width = img.height;
                        canvas.height = img.width;
                    } else {
                        canvas.width = img.width;
                        canvas.height = img.height;
                    }
                    
                    // Rotate and draw
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate((degrees * Math.PI) / 180);
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    
                    // Update image data
                    const newSrc = canvas.toDataURL();
                    imageData.src = newSrc;
                    
                    // Update thumbnail background
                    const thumbnail = document.querySelector(`[data-image-index="${index}"]`);
                    if (thumbnail) {
                        thumbnail.style.backgroundImage = `url(${newSrc})`;
                    }
                    
                    // Update the actual canvas image if this is the current image
                    if (imageData.original && imageData.original.label) {
                        const label = imageData.original.label;
                        
                        // Get canvas dimensions instead of raw image dimensions
                        // This is critical - paint.js coordinates are relative to canvas, not original image!
                        const canvas = document.getElementById('canvas');
                        if (!canvas) {
                            console.error('[Transform] Canvas element not found!');
                            return;
                        }
                        
                        // Use actual canvas coordinate space dimensions
                        let canvasWidth = canvas.width;
                        let canvasHeight = canvas.height;
                        
                        console.log(`[Transform] Using canvas dimensions: ${canvasWidth}x${canvasHeight} instead of image: ${img.naturalWidth}x${img.naturalHeight}`);
                        
                        // Clear stored centroid if canvas dimensions changed (for screen size changes)
                        if (window.originalDrawingCentroids && window.originalDrawingCentroids[label]) {
                            if (!window.lastCanvasDimensions) window.lastCanvasDimensions = {};
                            const lastDims = window.lastCanvasDimensions[label];
                            if (lastDims && (lastDims.width !== canvasWidth || lastDims.height !== canvasHeight)) {
                                delete window.originalDrawingCentroids[label];
                                console.log(`[Transform] Cleared stored centroid for ${label} - canvas size changed from ${lastDims.width}x${lastDims.height} to ${canvasWidth}x${canvasHeight}`);
                            }
                            window.lastCanvasDimensions[label] = { width: canvasWidth, height: canvasHeight };
                        }
                        
                        // For rotations, we might need to swap canvas dimensions too
                        let transformWidth = canvasWidth;
                        let transformHeight = canvasHeight;
                        
                        if (Math.abs(degrees) === 90 || Math.abs(degrees) === 270) {
                            // For blank canvas, keep original dimensions to rotate "in place"
                            // For real images, swap dimensions to match the rotated coordinate space
                            if (imageData.original && imageData.original.isBlankCanvas) {
                                console.log(`[Transform] Keeping canvas dimensions for blank canvas rotation: ${transformWidth}x${transformHeight}`);
                            } else {
                                // After rotation, the canvas coordinate space also changes
                                transformWidth = canvasHeight;  // Width becomes height
                                transformHeight = canvasWidth;  // Height becomes width
                                console.log(`[Transform] Swapped canvas dimensions for rotation: ${transformWidth}x${transformHeight}`);
                            }
                        }
                        
                        // Transform all coordinate-based data using IMAGE dimensions (not canvas)
                        // Paint.js stores coordinates in image-relative space, not canvas space
                        // For blank canvas, use canvas dimensions since there's no actual image
                        let rotateWidth, rotateHeight;
                        if (imageData.original && imageData.original.isBlankCanvas) {
                            const canvas = document.getElementById('canvas');
                            rotateWidth = canvas ? canvas.width : 800;
                            rotateHeight = canvas ? canvas.height : 800;
                            console.log(`[Transform] Using canvas dimensions for blank canvas: ${rotateWidth}x${rotateHeight}`);
                        } else {
                            rotateWidth = img.naturalWidth;
                            rotateHeight = img.naturalHeight;
                        }
                        // Debug: Check paint.js current state
                        if (window.paintApp && window.paintApp.state) {
                            console.log(`[Transform] Paint.js current image label: ${window.paintApp.state.currentImageLabel}`);
                        }
                        
                        console.log(`[Transform] About to call transformImageData with label: ${label}, degrees: ${degrees}, dimensions: ${rotateWidth}x${rotateHeight}`);
                        transformImageData(label, 'rotate', degrees, rotateWidth, rotateHeight);
                        // Update the paint.js image data (skip for blank canvas as there's no actual image)
                        if (!imageData.original?.isBlankCanvas) {
                            if (window.originalImages && window.originalImages[label]) {
                                window.originalImages[label] = newSrc;
                            }
                            
                            // Update the canvas if this is the currently displayed image
                            if (window.paintApp && window.paintApp.state.currentImageLabel === label) {
                                console.log(`[Gallery] Updating canvas with rotated image for ${label}`);
                                updateCanvasWithNewImage(newSrc);
                            }
                        } else {
                            console.log('[Transform] Skipping image update for blank canvas - only transforming drawing data');
                            
                            // For blank canvas, just redraw the existing strokes with transformed coordinates
                            if (window.redrawCanvasWithVisibility) {
                                window.redrawCanvasWithVisibility();
                            } else if (window.drawAllStrokes) {
                                window.drawAllStrokes();
                            }
                        }
                    }
                    
                    console.log(`[Gallery] Image ${index} rotated ${degrees}°`);
                };
                img.crossOrigin = 'anonymous';
                img.src = imageData.src;
            }
            
            // Flip image function
            function flipImage(index, direction) {
                console.log(`[Gallery] Flipping image ${index} ${direction}`);
                
                const imageData = imageGalleryData[index];
                if (!imageData) return;
                
                // Apply flip using Canvas
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // Apply flip transformation
                    if (direction === 'horizontal') {
                        ctx.scale(-1, 1);
                        ctx.drawImage(img, -canvas.width, 0);
                    } else if (direction === 'vertical') {
                        ctx.scale(1, -1);
                        ctx.drawImage(img, 0, -canvas.height);
                    }
                    
                    // Update image data
                    const newSrc = canvas.toDataURL();
                    imageData.src = newSrc;
                    
                    // Update thumbnail background
                    const thumbnail = document.querySelector(`[data-image-index="${index}"]`);
                    if (thumbnail) {
                        thumbnail.style.backgroundImage = `url(${newSrc})`;
                    }
                    
                    // Update the actual canvas image if this is the current image
                    if (imageData.original && imageData.original.label) {
                        const label = imageData.original.label;
                        
                        // Get canvas dimensions for coordinate transformation  
                        // Paint.js coordinates are relative to canvas, not original image!
                        const canvas = document.getElementById('canvas');
                        if (!canvas) {
                            console.error('[Transform] Canvas element not found!');
                            return;
                        }
                        
                        // Use actual canvas coordinate space dimensions
                        const canvasWidth = canvas.width;
                        const canvasHeight = canvas.height;
                        
                        console.log(`[Transform] Using canvas dimensions for flip: ${canvasWidth}x${canvasHeight}`);
                        
                        // Transform all coordinate-based data using IMAGE dimensions (not canvas)  
                        // Paint.js stores coordinates in image-relative space, not canvas space
                        // For blank canvas, use canvas dimensions since there's no actual image
                        let flipWidth, flipHeight;
                        if (imageData.original && imageData.original.isBlankCanvas) {
                            flipWidth = canvasWidth;
                            flipHeight = canvasHeight;
                            console.log(`[Transform] Using canvas dimensions for blank canvas flip: ${flipWidth}x${flipHeight}`);
                        } else {
                            flipWidth = img.naturalWidth;
                            flipHeight = img.naturalHeight;
                        }
                        transformImageData(label, 'flip', direction, flipWidth, flipHeight);
                        // Update the paint.js image data (skip for blank canvas as there's no actual image)
                        if (!imageData.original?.isBlankCanvas) {
                            if (window.originalImages && window.originalImages[label]) {
                                window.originalImages[label] = newSrc;
                            }
                            
                            // Update the canvas if this is the currently displayed image
                            if (window.paintApp && window.paintApp.state.currentImageLabel === label) {
                                console.log(`[Gallery] Updating canvas with flipped image for ${label}`);
                                updateCanvasWithNewImage(newSrc);
                            }
                        } else {
                            console.log('[Transform] Skipping image update for blank canvas flip - only transforming drawing data');
                            
                            // For blank canvas, just redraw the existing strokes with transformed coordinates
                            if (window.redrawCanvasWithVisibility) {
                                window.redrawCanvasWithVisibility();
                            } else if (window.drawAllStrokes) {
                                window.drawAllStrokes();
                            }
                        }
                    }
                    
                    console.log(`[Gallery] Image ${index} flipped ${direction}`);
                };
                img.crossOrigin = 'anonymous';
                img.src = imageData.src;
            }
            
            // Test function to validate coordinate transformations
            function testCoordinateTransformations() {
                console.log('=== Testing Coordinate Transformations ===');
                
                // Get actual canvas dimensions dynamically
                const canvas = document.getElementById('canvas');
                const canvasWidth = canvas ? canvas.width : 1920;
                const canvasHeight = canvas ? canvas.height : 945;
                
                console.log(`[Test] Using actual canvas dimensions: ${canvasWidth}x${canvasHeight}`);
                
                // Test corner points that were previously going out of bounds
                const testPoints = [
                    {x: 100, y: 100, label: 'top-left area'},
                    {x: 1800, y: 100, label: 'top-right area'}, 
                    {x: 100, y: 800, label: 'bottom-left area'},
                    {x: 1800, y: 800, label: 'bottom-right area'},
                    {x: 960, y: 472.5, label: 'center'}
                ];
                
                let allTestsPassed = true;
                
                testPoints.forEach(point => {
                    console.log(`\nTesting ${point.label} at (${point.x}, ${point.y}):`);
                    
                    // Test 90° rotation
                    const rotated90 = rotateCoordinates(point.x, point.y, 90, canvasWidth, canvasHeight);
                    console.log(`  90° rotation: (${rotated90.x.toFixed(1)}, ${rotated90.y.toFixed(1)})`);
                    
                    // Test 180° rotation  
                    const rotated180 = rotateCoordinates(point.x, point.y, 180, canvasWidth, canvasHeight);
                    console.log(`  180° rotation: (${rotated180.x.toFixed(1)}, ${rotated180.y.toFixed(1)})`);
                    
                    // Test horizontal flip
                    const flippedH = flipCoordinates(point.x, point.y, 'horizontal', canvasWidth, canvasHeight);
                    console.log(`  Horizontal flip: (${flippedH.x.toFixed(1)}, ${flippedH.y.toFixed(1)})`);
                    
                    // Test vertical flip
                    const flippedV = flipCoordinates(point.x, point.y, 'vertical', canvasWidth, canvasHeight);
                    console.log(`  Vertical flip: (${flippedV.x.toFixed(1)}, ${flippedV.y.toFixed(1)})`);
                    
                    // Verify all results are within bounds (for 90°: width becomes height)
                    const bounds90 = rotated90.x >= 0 && rotated90.x <= canvasHeight && rotated90.y >= 0 && rotated90.y <= canvasWidth;
                    const bounds180 = rotated180.x >= 0 && rotated180.x <= canvasWidth && rotated180.y >= 0 && rotated180.y <= canvasHeight;
                    const boundsFlipH = flippedH.x >= 0 && flippedH.x <= canvasWidth && flippedH.y >= 0 && flippedH.y <= canvasHeight;
                    const boundsFlipV = flippedV.x >= 0 && flippedV.x <= canvasWidth && flippedV.y >= 0 && flippedV.y <= canvasHeight;
                    
                    console.log(`  Within bounds: 90°=${bounds90}, 180°=${bounds180}, H-flip=${boundsFlipH}, V-flip=${boundsFlipV}`);
                    
                    if (!bounds90 || !bounds180 || !boundsFlipH || !boundsFlipV) {
                        allTestsPassed = false;
                        console.error(`  ❌ BOUNDARY TEST FAILED for ${point.label}`);
                    }
                });
                
                if (allTestsPassed) {
                    console.log('\n✅ All coordinate transformation tests PASSED - boundary constraints working correctly');
                } else {
                    console.error('\n❌ Some coordinate transformation tests FAILED - boundary constraints need adjustment');
                }
                
                console.log('=== Transformation Test Complete ===');
                return allTestsPassed;
            }

            // Transform offset vectors (relative to anchor points) for rotation/flip
            // Offsets are ALWAYS rotated as pure vectors around origin (0,0) - no center logic
            function rotateOffsetVector(x, y, degrees) {
                // Pure vector rotation: O' = R(degrees) * O
                // For -90°: (x,y) → (y,-x), e.g., (-710,-427.5) → (-427.5,710)
                const radians = (degrees * Math.PI) / 180;
                const cos = Math.cos(radians);
                const sin = Math.sin(radians);
                
                const rotatedX = x * cos - y * sin;
                const rotatedY = x * sin + y * cos;
                
                console.log(`[Transform] Vector rotation: (${x.toFixed(1)}, ${y.toFixed(1)}) → (${rotatedX.toFixed(1)}, ${rotatedY.toFixed(1)}) by ${degrees}°`);
                
                return {
                    x: rotatedX,
                    y: rotatedY
                };
            }
            
            function flipOffsetVector(x, y, direction) {
                if (direction === 'horizontal') {
                    return { x: -x, y: y };  // Flip X offset
                } else if (direction === 'vertical') {
                    return { x: x, y: -y };  // Flip Y offset
                }
                return { x, y };
            }
            
            // Get stroke midpoint from vector data in image space
            function getStrokeMidpointImageSpace(vectorStrokesSource, imageLabel, strokeLabel) {
                const vectorData = vectorStrokesSource[imageLabel][strokeLabel];
                if (!vectorData || !vectorData.points || vectorData.points.length === 0) {
                    console.warn(`[Transform] No vector data found for stroke ${strokeLabel}`);
                    return { x: 0, y: 0 };
                }
                
                const midpointIndex = Math.floor(vectorData.points.length / 2);
                const midpoint = vectorData.points[midpointIndex];
                return { x: midpoint.x, y: midpoint.y };
            }
            
            // Rotate a point around a center point
            function rotatePoint(point, center, degrees) {
                const radians = (degrees * Math.PI) / 180;
                const cos = Math.cos(radians);
                const sin = Math.sin(radians);
                
                const dx = point.x - center.x;
                const dy = point.y - center.y;
                
                return {
                    x: center.x + (dx * cos - dy * sin),
                    y: center.y + (dx * sin + dy * cos)
                };
            }

            // Coordinate transformation functions for image rotate/flip
            function rotateCoordinates(x, y, degrees, imageWidth, imageHeight, customCenter = null, keepDimensions = false) {
                let centerX, centerY;
                
                if (customCenter) {
                    centerX = customCenter.x;
                    centerY = customCenter.y;
                    console.log(`[Transform] Using drawing centroid (${centerX.toFixed(1)}, ${centerY.toFixed(1)}) for blank canvas`);
                } else {
                    centerX = imageWidth / 2;
                    centerY = imageHeight / 2;
                    console.log(`[Transform] Using canvas center (${centerX}, ${centerY})`);
                }
                
                console.log(`[Transform] Rotating point (${x}, ${y}) around center (${centerX.toFixed(1)}, ${centerY.toFixed(1)}) by ${degrees}°`);
                
                // Translate to origin (relative to center)
                const translatedX = x - centerX;
                const translatedY = y - centerY;
                
                // Convert degrees to radians
                const radians = (degrees * Math.PI) / 180;
                const cos = Math.cos(radians);
                const sin = Math.sin(radians);
                
                // Apply rotation matrix
                const rotatedX = translatedX * cos - translatedY * sin;
                const rotatedY = translatedX * sin + translatedY * cos;
                
                // For 90° and 270° rotations, dimensions swap
                let newCenterX, newCenterY;
                if (Math.abs(degrees) === 90 || Math.abs(degrees) === 270) {
                    // For blank canvas, keep the same rotation center to avoid orbital motion
                    if (customCenter) {
                        // Keep the drawing centroid as rotation center
                        newCenterX = centerX;
                        newCenterY = centerY;
                        console.log(`[Transform] Keeping rotation center (${newCenterX.toFixed(1)}, ${newCenterY.toFixed(1)}) for blank canvas 90°/270° rotation`);
                    } else {
                        // For regular images, swap center with dimensions
                        newCenterX = imageHeight / 2;  // New width is old height
                        newCenterY = imageWidth / 2;   // New height is old width
                    }
                } else {
                    newCenterX = centerX;
                    newCenterY = centerY;
                }
                
                // Translate back from new center
                let finalX = rotatedX + newCenterX;
                let finalY = rotatedY + newCenterY;
                
                // Get the final canvas dimensions (after potential rotation)
                let finalWidth, finalHeight;
                if (keepDimensions || !(Math.abs(degrees) === 90 || Math.abs(degrees) === 270)) {
                    // Keep original dimensions for blank canvas or non-90/270 rotations
                    finalWidth = imageWidth;
                    finalHeight = imageHeight;
                } else {
                    // Swap dimensions for regular image 90/270 rotations
                    finalWidth = imageHeight;
                    finalHeight = imageWidth;
                }
                
                // For blank canvas, skip bounds clamping to prevent shape distortion during rotation
                if (!keepDimensions) {
                    // Constrain coordinates to stay within canvas bounds (0 to width-1, 0 to height-1)
                    finalX = Math.max(0, Math.min(finalWidth - 1, finalX));
                    finalY = Math.max(0, Math.min(finalHeight - 1, finalY));
                }
                
                console.log(`[Transform] Final coordinates: (${finalX}, ${finalY}) [bounds: ${finalWidth}x${finalHeight}]`);
                
                return {
                    x: finalX,
                    y: finalY
                };
            }
            
            function flipCoordinates(x, y, direction, imageWidth, imageHeight) {
                let finalX = x, finalY = y;
                
                if (direction === 'horizontal') {
                    finalX = imageWidth - x;
                } else if (direction === 'vertical') {
                    finalY = imageHeight - y;
                }
                
                // Apply boundary constraints (0 to width-1, 0 to height-1)
                finalX = Math.max(0, Math.min(imageWidth - 1, finalX));
                finalY = Math.max(0, Math.min(imageHeight - 1, finalY));
                
                return { 
                    x: finalX, 
                    y: finalY 
                };
            }
            
            // Calculate the centroid (center of mass) of all drawn strokes
            function calculateDrawingCentroid(vectorStrokesByImage, imageLabel) {
                const vectorStrokes = vectorStrokesByImage[imageLabel];
                if (!vectorStrokes || Object.keys(vectorStrokes).length === 0) {
                    return null;
                }
                
                let totalX = 0, totalY = 0, totalPoints = 0;
                
                Object.values(vectorStrokes).forEach(stroke => {
                    if (stroke.points && stroke.points.length > 0) {
                        stroke.points.forEach(point => {
                            totalX += point.x;
                            totalY += point.y;
                            totalPoints++;
                        });
                    }
                });
                
                if (totalPoints === 0) return null;
                
                const centroid = {
                    x: totalX / totalPoints,
                    y: totalY / totalPoints
                };
                
                console.log(`[Transform] Drawing centroid: (${centroid.x.toFixed(1)}, ${centroid.y.toFixed(1)}) from ${totalPoints} points`);
                return centroid;
            }
            
            // Transform all stroke and label data for an image
            window.transformImageData = function transformImageData(imageLabel, transformType, transformValue, imageWidth, imageHeight) {
                console.log(`[Transform] ===== TRANSFORMING DATA =====`);
                console.log(`[Transform] Image: ${imageLabel}, Type: ${transformType} ${transformValue}`);
                console.log(`[Transform] Using IMAGE dimensions: ${imageWidth} x ${imageHeight}`);
                
                // Debug: Check both global state and paintApp state
                if (window.paintApp && window.paintApp.state) {
                    console.log(`[Transform] Paint.js current image label: ${window.paintApp.state.currentImageLabel}`);
                    console.log(`[Transform] Paint.js vectorStrokesByImage keys:`, Object.keys(window.paintApp.state.vectorStrokesByImage || {}));
                }
                
                // Debug: Check what data exists for this image label
                if (window.vectorStrokesByImage) {
                    console.log(`[Transform] Available vectorStrokesByImage labels:`, Object.keys(window.vectorStrokesByImage));
                    if (window.vectorStrokesByImage[imageLabel]) {
                        console.log(`[Transform] Found ${Object.keys(window.vectorStrokesByImage[imageLabel]).length} strokes for label ${imageLabel}`);
                    } else {
                        console.log(`[Transform] No strokes found for label ${imageLabel}`);
                    }
                } else {
                    console.log(`[Transform] Global vectorStrokesByImage is undefined!`);
                }
                
                // Try paint.js state if global variables are empty
                let vectorStrokesSource = window.vectorStrokesByImage;
                let labelPositionsSource = window.customLabelPositions;
                let labelOffsetsSource = window.calculatedLabelOffsets;
                
                console.log(`[DEBUG] Initial sources - vectorStrokesSource:`, !!vectorStrokesSource, 'labelPositionsSource:', !!labelPositionsSource, 'labelOffsetsSource:', !!labelOffsetsSource);
                
                if (window.paintApp && window.paintApp.state) {
                    if (!vectorStrokesSource || !vectorStrokesSource[imageLabel]) {
                        vectorStrokesSource = window.paintApp.state.vectorStrokesByImage;
                        console.log(`[Transform] Using paint.js state vectorStrokesByImage instead`);
                    }
                    if (!labelPositionsSource || !labelPositionsSource[imageLabel]) {
                        labelPositionsSource = window.paintApp.state.customLabelPositions;
                        console.log(`[Transform] Using paint.js state customLabelPositions instead`);
                    }
                    if (!labelOffsetsSource || !labelOffsetsSource[imageLabel]) {
                        labelOffsetsSource = window.paintApp.state.calculatedLabelOffsets;
                        console.log(`[Transform] Using paint.js state calculatedLabelOffsets instead`);
                    }
                }
                
                // Calculate the rotation center
                let rotationCenter = null;
                // Treat as blank-like when no bitmap exists for this label or label is explicitly 'blank_canvas'
                const isBlankCanvas = (imageLabel === 'blank_canvas') || !(window.originalImages && window.originalImages[imageLabel]);
                if (transformType === 'rotate' && vectorStrokesSource) {
                    // For blank canvas, rotate around the actual drawing center (fallback to canvas center if no strokes)
                    if (isBlankCanvas) {
                        // Initialize original centroid storage if it doesn't exist
                        if (!window.originalDrawingCentroids) {
                            window.originalDrawingCentroids = {};
                        }
                        
                        // Store the original centroid on first rotation, then reuse it
                        if (!window.originalDrawingCentroids[imageLabel]) {
                            window.originalDrawingCentroids[imageLabel] = calculateDrawingCentroid(vectorStrokesSource, imageLabel);
                            console.log(`[Transform] Storing original drawing centroid for ${imageLabel}:`, window.originalDrawingCentroids[imageLabel]);
                            
                            // Also store the canvas dimensions when we store the centroid
                            const canvas = document.getElementById('canvas');
                            if (canvas) {
                                if (!window.lastCanvasDimensions) window.lastCanvasDimensions = {};
                                window.lastCanvasDimensions[imageLabel] = { width: canvas.width, height: canvas.height };
                                console.log(`[Transform] Stored canvas dimensions for ${imageLabel}: ${canvas.width}x${canvas.height}`);
                            }
                        }
                        
                        rotationCenter = window.originalDrawingCentroids[imageLabel] || { x: imageWidth / 2, y: imageHeight / 2 };
                        console.log(`[Transform] Using stored centroid or canvas center for ${imageLabel}:`, rotationCenter);
                    } else {
                        // For regular images, rotate strokes around the image center to match bitmap rotation
                        rotationCenter = null;
                        console.log(`[Transform] Using image center for rotation of ${imageLabel}`);
                    }
                }

                // Record rotation metadata for testing harness
                if (transformType === 'rotate') {
                    // Determine real image label used by state (avoid 'blank_canvas' leaks)
                    const realImageLabel = window.currentImageLabel || imageLabel;
                    
                    // Store rotation metadata with normalized delta and canvas coordinates
                    if (!window.lastRotationMeta) window.lastRotationMeta = {};
                    
                    // For regular images (rotationCenter = null), use image center
                    const centerToRecord = rotationCenter || { x: imageWidth / 2, y: imageHeight / 2 };
                    
                    window.lastRotationMeta[realImageLabel] = {
                        centerCanvas: { x: centerToRecord.x, y: centerToRecord.y },
                        delta: window.normalizeDelta ? window.normalizeDelta((transformValue * Math.PI) / 180) : ((transformValue * Math.PI) / 180)
                    };
                    console.log(`[Transform] Recorded rotation meta for ${realImageLabel}: center=(${centerToRecord.x.toFixed(1)}, ${centerToRecord.y.toFixed(1)}), delta=${transformValue}°`);
                }
                
                // Transform vector strokes
                if (vectorStrokesSource && vectorStrokesSource[imageLabel]) {
                    const vectorStrokes = vectorStrokesSource[imageLabel];
                    console.log(`[Transform] Processing ${Object.keys(vectorStrokes).length} vector strokes:`, Object.keys(vectorStrokes));
                    
                    Object.keys(vectorStrokes).forEach(strokeLabel => {
                        const strokeData = vectorStrokes[strokeLabel];
                        if (strokeData && strokeData.points) {
                            console.log(`[Transform] Stroke ${strokeLabel}: ${strokeData.points.length} points`);
                            console.log(`[Transform] Before:`, strokeData.points.slice(0, 2)); // Show first 2 points
                            
                            strokeData.points = strokeData.points.map(point => {
                                if (transformType === 'rotate') {
                                    return rotateCoordinates(point.x, point.y, transformValue, imageWidth, imageHeight, rotationCenter, isBlankCanvas);
                                } else if (transformType === 'flip') {
                                    return flipCoordinates(point.x, point.y, transformValue, imageWidth, imageHeight);
                                }
                                return point;
                            });
                            
                            console.log(`[Transform] After:`, strokeData.points.slice(0, 2)); // Show first 2 transformed points
                        }
                    });
                    console.log(`[Transform] Updated ${Object.keys(vectorStrokes).length} vector strokes`);
                }
                
                // Transform custom label positions for rotations - maintain exact positioning
                // User-positioned labels should stay at the same relative position after rotation
                if (transformType === 'rotate') {
                    const allCustomTransformSources = [
                        window.customLabelPositions,
                        window.paintApp?.state?.customLabelPositions
                    ].filter(Boolean);
                    
                    allCustomTransformSources.forEach(source => {
                        if (source && source[imageLabel]) {
                            console.log(`[Transform] Rotating custom label positions for ${imageLabel}`);
                            Object.keys(source[imageLabel]).forEach(strokeLabel => {
                                const offset = source[imageLabel][strokeLabel];
                                if (offset && typeof offset.x === 'number' && typeof offset.y === 'number') {
                                    console.log(`[Transform] Before rotation - ${strokeLabel}: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)})`);
                                    const rotated = rotateCoordinates(offset.x, offset.y, transformValue, imageWidth, imageHeight, rotationCenter, isBlankCanvas);
                                    offset.x = rotated.x;
                                    offset.y = rotated.y;
                                    console.log(`[Transform] After rotation - ${strokeLabel}: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)})`);
                                }
                            });
                        }
                    });
                }
                
                // Transform absolute tag positions for rotations - maintain exact positioning
                if (transformType === 'rotate') {
                    const allAbsoluteTransformSources = [
                        window.customLabelAbsolutePositions,
                        window.paintApp?.state?.customLabelAbsolutePositions
                    ].filter(Boolean);
                    
                    allAbsoluteTransformSources.forEach(source => {
                        if (source && source[imageLabel]) {
                            console.log(`[Transform] Rotating absolute tag positions for ${imageLabel}`);
                            Object.keys(source[imageLabel]).forEach(strokeLabel => {
                                const absPos = source[imageLabel][strokeLabel];
                                if (absPos && typeof absPos.x === 'number' && typeof absPos.y === 'number') {
                                    console.log(`[Transform] Before rotation - ${strokeLabel} absolute: (${absPos.x.toFixed(1)}, ${absPos.y.toFixed(1)})`);
                                    const rotated = rotateCoordinates(absPos.x, absPos.y, transformValue, imageWidth, imageHeight, rotationCenter, isBlankCanvas);
                                    absPos.x = rotated.x;
                                    absPos.y = rotated.y;
                                    console.log(`[Transform] After rotation - ${strokeLabel} absolute: (${absPos.x.toFixed(1)}, ${absPos.y.toFixed(1)})`);
                                }
                            });
                        }
                    });
                }
                
                // Transform calculated label offsets using simple vector rotation
                // This maintains proper positioning during rotations without accumulating errors
                if (labelOffsetsSource && labelOffsetsSource[imageLabel] && transformType === 'rotate') {
                    const labelOffsets = labelOffsetsSource[imageLabel];
                    console.log(`[Transform] Transforming ${Object.keys(labelOffsets).length} calculated label offsets for rotation`);
                    
                    // Transform each label offset as a vector relative to the stroke's anchor point
                    Object.keys(labelOffsets).forEach(labelKey => {
                        const offset = labelOffsets[labelKey];
                        if (offset && typeof offset.x === 'number' && typeof offset.y === 'number') {
                            // Transform the offset vector using pure rotation (no translation)
                            // Offsets are relative vectors that should rotate around origin (0,0)
                            const rotatedOffset = rotateOffsetVector(offset.x, offset.y, transformValue);
                            labelOffsets[labelKey] = rotatedOffset;
                            console.log(`[Transform] Transformed label offset ${labelKey}: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)}) → (${rotatedOffset.x.toFixed(1)}, ${rotatedOffset.y.toFixed(1)})`);
                        }
                    });
                    console.log(`[Transform] Transformed ${Object.keys(labelOffsets).length} calculated label offsets`);
                }
                
                // NEW RELATIVE POSITIONING SYSTEM: Use relative positions to recalculate absolute positions after rotation
                console.log(`[REL-TRANSFORM] Using relative positioning system for rotation-resistant custom labels`);
                
                if (transformType === 'rotate' && window.customLabelRelativePositions && window.customLabelRelativePositions[imageLabel]) {
                    const relativePositions = window.customLabelRelativePositions[imageLabel];
                    const strokeLabels = Object.keys(relativePositions);
                    console.log(`[REL-TRANSFORM] Found ${strokeLabels.length} relative positions to recalculate:`, strokeLabels);
                    
                    // Initialize absolute position storage if needed
                    if (!window.customLabelPositions[imageLabel]) {
                        window.customLabelPositions[imageLabel] = {};
                    }
                    
                    let updatedPositions = 0;
                    strokeLabels.forEach(strokeLabel => {
                        const relativePos = relativePositions[strokeLabel];
                        if (relativePos && typeof relativePos.percentageAlongLine === 'number' && typeof relativePos.perpendicularDistance === 'number') {
                            // Recalculate absolute position from relative position after stroke rotation
                            const newAbsoluteOffset = window.convertRelativeToAbsolutePosition(strokeLabel, relativePos, imageLabel);
                            if (newAbsoluteOffset) {
                                window.customLabelPositions[imageLabel][strokeLabel] = newAbsoluteOffset;
                                updatedPositions++;
                                console.log(`[REL-TRANSFORM] Recalculated ${strokeLabel}: ${(relativePos.percentageAlongLine * 100).toFixed(1)}% + ${relativePos.perpendicularDistance.toFixed(1)}px → (${newAbsoluteOffset.x.toFixed(1)}, ${newAbsoluteOffset.y.toFixed(1)})`);
                            } else {
                                console.warn(`[REL-TRANSFORM] Failed to recalculate position for ${strokeLabel}`);
                            }
                        }
                    });
                    
                    console.log(`[REL-TRANSFORM] Successfully recalculated ${updatedPositions}/${strokeLabels.length} custom positions using relative positioning`);
                } else {
                    console.log(`[REL-TRANSFORM] No relative positions found for ${imageLabel} or not a rotation transform`);
                    
                    // Fallback: Clear absolute positions for non-rotation transforms to force recalculation
                    if (transformType !== 'rotate' && window.customLabelPositions && window.customLabelPositions[imageLabel]) {
                        const customPositions = window.customLabelPositions[imageLabel];
                        const strokeLabels = Object.keys(customPositions);
                        console.log(`[REL-TRANSFORM] Clearing ${strokeLabels.length} absolute custom positions for ${transformType} - will be recalculated`);
                        
                        strokeLabels.forEach(strokeLabel => {
                            delete customPositions[strokeLabel];
                        });
                    }
                }
                
                if (transformType !== 'rotate' && labelOffsetsSource && labelOffsetsSource[imageLabel]) {
                    // For non-rotation transforms (flip), clear offsets to force recalculation
                    const labelOffsets = labelOffsetsSource[imageLabel];
                    console.log(`[Transform] Clearing ${Object.keys(labelOffsets).length} calculated label offsets for ${transformType}`);
                    
                    Object.keys(labelOffsets).forEach(labelKey => {
                        delete labelOffsets[labelKey];
                    });
                    console.log(`[Transform] Cleared calculated label offsets - will be recalculated on next draw`);
                }
                
                // Update image dimensions if rotating by 90/270 degrees
                // Skip dimension swapping for blank-like images (no real bitmap to swap)
                if (transformType === 'rotate' && (Math.abs(transformValue) === 90 || Math.abs(transformValue) === 270)) {
                    // Treat as blank-like when no bitmap exists for this label or label is explicitly 'blank_canvas'
                    const isBlankCanvas = (imageLabel === 'blank_canvas') || !(window.originalImages && window.originalImages[imageLabel]);
                    
                    if (!isBlankCanvas && window.originalImageDimensions && window.originalImageDimensions[imageLabel]) {
                        const dims = window.originalImageDimensions[imageLabel];
                        window.originalImageDimensions[imageLabel] = {
                            width: dims.height,
                            height: dims.width
                        };
                        console.log(`[Transform] Swapped image dimensions: ${dims.width}x${dims.height} → ${dims.height}x${dims.width}`);
                    } else if (isBlankCanvas) {
                        console.log(`[Transform] Skipping dimension swap for blank-like canvas (${imageLabel})`);
                    }
                }

                // Update rotation stamps and cumulative rotation for custom labels persistence
                if (transformType === 'rotate') {
                    // 1) Determine real image label used by state (avoid 'blank_canvas' leaks)
                    const img = window.currentImageLabel || imageLabel;

                    // 2) Rotation delta already known (transformValue in degrees); normalize it in radians
                    const deltaRadians = (transformValue * Math.PI) / 180;
                    const normalizedDelta = window.normalizeDelta ? window.normalizeDelta(deltaRadians) : deltaRadians;

                    // 3) Update per-stroke rotation stamps for custom offsets
                    if (!window.customLabelOffsetsRotationByImageAndStroke) {
                        window.customLabelOffsetsRotationByImageAndStroke = {};
                    }
                    if (!window.customLabelOffsetsRotationByImageAndStroke[img]) {
                        window.customLabelOffsetsRotationByImageAndStroke[img] = {};
                    }

                    // Update stamps for all strokes that have custom offsets
                    if (window.customLabelPositions && window.customLabelPositions[img]) {
                        Object.keys(window.customLabelPositions[img]).forEach(stroke => {
                            const lastStamp = window.customLabelOffsetsRotationByImageAndStroke[img][stroke] || 0;
                            const newStamp = window.normalizeDelta ? window.normalizeDelta(lastStamp + normalizedDelta) : (lastStamp + normalizedDelta);
                            window.customLabelOffsetsRotationByImageAndStroke[img][stroke] = newStamp;
                        });
                    }

                    // 4) Advance image cumulative rotation so future sync math remains aligned
                    if (!window.imageRotationByLabel) {
                        window.imageRotationByLabel = {};
                    }
                    const currentRotation = window.imageRotationByLabel[img] || 0;
                    window.imageRotationByLabel[img] = window.normalizeDelta ? window.normalizeDelta(currentRotation + normalizedDelta) : (currentRotation + normalizedDelta);

                    console.log(`[Transform] Updated rotation state for ${img}: delta=${(transformValue)}°, cumulative=${(window.imageRotationByLabel[img] * 180 / Math.PI).toFixed(1)}°`);
                }
            }
            
            // Helper function to update canvas with new image data
            function updateCanvasWithNewImage(newImageSrc) {
                try {
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.getElementById('canvas');
                        if (canvas) {
                            const ctx = canvas.getContext('2d');
                            
                            console.log(`[Canvas] Updating canvas (${canvas.width}x${canvas.height}) with new image (${img.width}x${img.height})`);
                            
                            // Clear canvas
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            // Get current scale and position from paint.js
                            const currentLabel = window.paintApp?.state?.currentImageLabel || window.currentImageLabel;
                            const scale = window.imageScaleByLabel?.[currentLabel] || 1.0;
                            const position = window.imagePositionByLabel?.[currentLabel] || { x: 0, y: 0 };
                            
                            console.log(`[Canvas] Using scale: ${scale}, position: (${position.x}, ${position.y})`);
                            
                            // Calculate scaled dimensions and positioning
                            const scaledWidth = img.width * scale;
                            const scaledHeight = img.height * scale;
                            const x = (canvas.width - scaledWidth) / 2 + position.x;
                            const y = (canvas.height - scaledHeight) / 2 + position.y;
                            
                            // Draw image with proper scaling and positioning
                            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                            
                            // Trigger paint.js to redraw strokes if available
                            if (window.redrawCanvasWithVisibility) {
                                window.redrawCanvasWithVisibility();
                            } else if (window.drawAllStrokes) {
                                window.drawAllStrokes();
                            }
                            
                            console.log('[Gallery] Canvas updated with new image using paint.js scale/position');
                        }
                    };
                    img.crossOrigin = 'anonymous';
                    img.src = newImageSrc;
                } catch (error) {
                    console.error('[Gallery] Error updating canvas:', error);
                }
            }
            
            // Update active image highlighting
            function updateActiveImage(index) {
                currentImageIndex = index;
                
                // Update thumbnail highlighting
                document.querySelectorAll('.image-thumbnail').forEach((thumb, idx) => {
                    thumb.classList.toggle('active', idx === index);
                });
                
                // Update navigation dots
                document.querySelectorAll('.nav-dot').forEach((dot, idx) => {
                    dot.classList.toggle('active', idx === index);
                });
                
                // Sync inputs to current image
                const data = imageGalleryData[index];
                const nameEl = document.getElementById('imageNameInput');
                const typeEl = document.getElementById('imageTypeSelect');
                if (nameEl && data) nameEl.value = data.name || '';
                if (typeEl && data && data.original) typeEl.value = data.original.type || '';
                
                updateGalleryControls();
            }
            
            // Update gallery controls and counters
            function updateGalleryControls() {
                const prevButton = document.getElementById('prevImage');
                const nextButton = document.getElementById('nextImage');
                const imagePosition = document.getElementById('imagePosition');
                const imageCounter = document.getElementById('imageCounter');
                
                const totalImages = imageGalleryData.length;
                
                if (prevButton && nextButton) {
                    prevButton.disabled = currentImageIndex <= 0;
                    nextButton.disabled = currentImageIndex >= totalImages - 1;
                }
                
                if (imagePosition) {
                    imagePosition.textContent = `${currentImageIndex + 1} / ${totalImages}`;
                }
                
                if (imageCounter) {
                    imageCounter.textContent = totalImages > 0 ? `${totalImages} images` : '';
                }
            }
            
            // Clear image gallery
            function clearImageGallery() {
                const imageGallery = document.getElementById('imageGallery');
                const imageDots = document.getElementById('imageDots');
                
                if (imageGallery) imageGallery.innerHTML = '';
                if (imageDots) imageDots.innerHTML = '';
                
                imageGalleryData = [];
                currentImageIndex = 0;
                updateGalleryControls();
            }
            
            // Initialize gallery on page load
            initializeImageGallery();
            
            // Reveal UI once initialization is complete
            document.documentElement.classList.remove('app-loading');
            
            // Ensure toolbar is visible after loading
            const topToolbar = document.getElementById('topToolbar');
            if (topToolbar) {
                topToolbar.style.opacity = '1';
            }
            
            // Store reference to original addImageToSidebar if it exists
            const originalAddImageToSidebar = window.addImageToSidebar;
            
            // Enhanced compatibility function that works with both new and old formats
            window.addImageToSidebar = function(imageUrl, label, filename) {
                console.log('[COMPAT] addImageToSidebar called with:', { imageUrl: imageUrl?.substring?.(0, 50) || imageUrl, label, filename });
                
                // Call original function first if it exists (for backwards compatibility)
                if (originalAddImageToSidebar && typeof originalAddImageToSidebar === 'function') {
                    try {
                        originalAddImageToSidebar.apply(this, arguments);
                    } catch (error) {
                        console.warn('[COMPAT] Original addImageToSidebar failed:', error);
                    }
                }
                
                // Add to new gallery
                if (imageUrl) {
                    const index = imageGalleryData.length;
                    const imageData = {
                        src: imageUrl,
                        url: imageUrl,
                        name: filename || label || `Image ${index + 1}`,
                        label: label,
                        filename: filename
                    };
                    
                    addImageToGallery(imageData, index);
                    console.log('[COMPAT] Added to new gallery at index', index, 'Total images now:', imageGalleryData.length);
                    
                    return index;
                } else {
                    console.warn('[COMPAT] No valid imageUrl provided');
                    return -1;
                }
            };
            
            window.switchToImage = function(imageIndex) {
                if (typeof imageIndex === 'number') {
                    navigateToImage(imageIndex);
                    console.log('[COMPAT] Switched to image:', imageIndex);
                }
            };
            
            // Legacy image list compatibility
            window.updateImageList = function() {
                // This function exists for compatibility but the new gallery handles updates automatically
                console.log('[COMPAT] updateImageList called - handled by new gallery system');
            };
            
            // Clear images function
            window.clearImageSidebar = function() {
                clearImageGallery();
                console.log('[COMPAT] Cleared image sidebar');
            };
            
            console.log('[INIT] Image gallery and compatibility functions initialized');
            
            // Setup container-level drag auto-scroll
            const imageListContainer = document.getElementById('imageList');
            if (imageListContainer) {
                imageListContainer.addEventListener('dragover', (e) => {
                    const rect = imageListContainer.getBoundingClientRect();
                    const scrollThreshold = 80; // Distance from edge to trigger scroll
                    const scrollSpeed = 10; // Pixels per scroll
                    const mouseY = e.clientY;
                    
                    // Clear any existing scroll interval
                    if (window.dragScrollInterval) {
                        clearInterval(window.dragScrollInterval);
                        window.dragScrollInterval = null;
                    }
                    
                    // Check if near top edge
                    if (mouseY - rect.top < scrollThreshold && mouseY > rect.top) {
                        window.dragScrollInterval = setInterval(() => {
                            imageListContainer.scrollBy(0, -scrollSpeed);
                        }, 20);
                    }
                    // Check if near bottom edge
                    else if (rect.bottom - mouseY < scrollThreshold && mouseY < rect.bottom) {
                        window.dragScrollInterval = setInterval(() => {
                            imageListContainer.scrollBy(0, scrollSpeed);
                        }, 20);
                    }
                });
                
                // Clear scroll interval when drag ends anywhere
                imageListContainer.addEventListener('drop', () => {
                    if (window.dragScrollInterval) {
                        clearInterval(window.dragScrollInterval);
                        window.dragScrollInterval = null;
                    }
                });
                
                imageListContainer.addEventListener('dragleave', (e) => {
                    // Only clear if leaving the container entirely
                    if (e.target === imageListContainer) {
                        if (window.dragScrollInterval) {
                            clearInterval(window.dragScrollInterval);
                            window.dragScrollInterval = null;
                        }
                    }
                });
            }
            
            // Debug function to inspect paint.js state
            window.debugPaintState = function() {
                console.log('=== PAINT.JS STATE DEBUG ===');
                
                if (window.paintApp && window.paintApp.state) {
                    console.log('Current image label:', window.paintApp.state.currentImageLabel);
                    console.log('Paint app state keys:', Object.keys(window.paintApp.state));
                }
                
                if (window.vectorStrokesByImage) {
                    const labels = Object.keys(window.vectorStrokesByImage);
                    console.log('vectorStrokesByImage labels:', labels);
                    labels.forEach(label => {
                        const strokes = window.vectorStrokesByImage[label];
                        console.log(`  ${label}: ${Object.keys(strokes || {}).length} strokes`);
                    });
                } else {
                    console.log('vectorStrokesByImage not found');
                }
                
                if (window.customLabelPositions) {
                    const labels = Object.keys(window.customLabelPositions);
                    console.log('customLabelPositions labels:', labels);
                } else {
                    console.log('customLabelPositions not found');
                }
                
                console.log('imageGalleryData length:', imageGalleryData.length);
                console.log('currentImageIndex:', currentImageIndex);
                if (imageGalleryData[currentImageIndex]) {
                    console.log('Current image:', imageGalleryData[currentImageIndex].name, imageGalleryData[currentImageIndex].original?.label);
                    console.log('Full current image data:', JSON.stringify(imageGalleryData[currentImageIndex], null, 2));
                }
                
                // Also debug all gallery images
                console.log('All gallery images:');
                imageGalleryData.forEach((img, index) => {
                    console.log(`  [${index}] ${img.name}: label=${img.original?.label}, isBlankCanvas=${img.original?.isBlankCanvas}`);
                });
            };
            
            // Test function to add mock drawing data for blank canvas
            window.addTestTriangle = function() {
                // Try to get the actual current image label from gallery
                let targetLabel = 'blank_canvas'; // fallback
                if (imageGalleryData[currentImageIndex]?.original?.label) {
                    targetLabel = imageGalleryData[currentImageIndex].original.label;
                }
                const paintLabel = window.paintApp?.state?.currentImageLabel;
                
                console.log(`[Test] Gallery current index: ${currentImageIndex}`);
                console.log(`[Test] Gallery target label: ${targetLabel}`);
                console.log(`[Test] Paint.js current label: ${paintLabel}`);
                console.log(`[Test] Adding test triangle to label: ${targetLabel}`);
                
                // Mock stroke data for a simple triangle
                const mockStroke = {
                    points: [
                        { x: 300, y: 200 },  // Top point
                        { x: 200, y: 400 },  // Bottom left
                        { x: 400, y: 400 },  // Bottom right
                        { x: 300, y: 200 }   // Back to top
                    ],
                    color: '#ff0000',
                    thickness: 3,
                    type: 'freehand'
                };
                
                // Add to both global and paint.js state
                if (window.vectorStrokesByImage) {
                    if (!window.vectorStrokesByImage[targetLabel]) {
                        window.vectorStrokesByImage[targetLabel] = {};
                    }
                    window.vectorStrokesByImage[targetLabel]['test_triangle'] = mockStroke;
                }
                
                if (window.paintApp?.state?.vectorStrokesByImage) {
                    if (!window.paintApp.state.vectorStrokesByImage[targetLabel]) {
                        window.paintApp.state.vectorStrokesByImage[targetLabel] = {};
                    }
                    window.paintApp.state.vectorStrokesByImage[targetLabel]['test_triangle'] = mockStroke;
                }
                
                // Also switch paint.js to the correct label if it's not already there
                if (paintLabel !== targetLabel && window.switchToImage) {
                    console.log(`[Test] Switching paint.js from '${paintLabel}' to '${targetLabel}'`);
                    window.switchToImage(targetLabel);
                }
                
                console.log(`[Test] Added test triangle. Use debugPaintState() to verify.`);
                
                // Redraw if function exists
                if (window.redrawCanvasWithVisibility) {
                    window.redrawCanvasWithVisibility();
                }
            };
            
            // Note: Stored centroid system removed - blank canvas now uses fixed canvas center
            
            // Test function to try rotating the current image
            window.testRotate = function() {
                console.log(`[Test] Testing rotation on current image (index ${currentImageIndex})`);
                if (currentImageIndex >= 0 && currentImageIndex < imageGalleryData.length) {
                    const imageData = imageGalleryData[currentImageIndex];
                    console.log(`[Test] Rotating image: ${imageData.name}`);
                    rotateImage(currentImageIndex, 90);
                } else {
                    console.log(`[Test] Invalid image index: ${currentImageIndex}`);
                }
            };
            
            // Hook into addImageToSidebar after external scripts load
            let hookAttempts = 0;
            const maxHookAttempts = 50;
            
            function attemptHook() {
                hookAttempts++;
                
                // Check if paint.js has loaded and defined its own addImageToSidebar
                if (window.addImageToSidebar && window.addImageToSidebar.toString().includes('imageList')) {
                    console.log('[HOOK] Found original addImageToSidebar from paint.js, hooking into it...');
                    
                    // Store the original function
                    const paintJsAddImageToSidebar = window.addImageToSidebar;
                    
                    // Create our intercepting function
                    window.addImageToSidebar = function(imageUrl, label, filename) {
                        console.log('[HOOK] Intercepted addImageToSidebar call:', { imageUrl: imageUrl?.substring?.(0, 50) || imageUrl, label, filename });
                        
                        // Call the original paint.js function
                        const result = paintJsAddImageToSidebar.apply(this, arguments);
                        
                        // Add to our new gallery
                        if (imageUrl) {
                            const index = imageGalleryData.length;
                            const imageData = {
                                src: imageUrl,
                                url: imageUrl,
                                name: filename || label || `Image ${index + 1}`,
                                label: label,
                                filename: filename
                            };
                            
                            addImageToGallery(imageData, index);
                            console.log('[HOOK] Added to new gallery at index', index);
                        }
                        
                        return result;
                    };
                    
                    console.log('[HOOK] Successfully hooked addImageToSidebar');
                    return true;
                } else if (hookAttempts < maxHookAttempts) {
                    setTimeout(attemptHook, 100);
                } else {
                    if (window.__DEBUG__) console.warn('[HOOK] Max attempts reached, could not hook addImageToSidebar');
                }
            }
            
            // Start attempting to hook after a short delay
            setTimeout(attemptHook, 500);
            
            // Function to sync existing legacy images to new gallery
            function syncLegacyImagesToGallery() {
                const imageList = document.getElementById('imageList');
                if (!imageList) {
                    console.log('[SYNC] ERROR: No imageList element found');
                    return;
                }
                
                const imageContainers = imageList.querySelectorAll('.image-container');
                console.log(`[SYNC] Processing ${imageContainers.length} legacy images`);
                
                let newImagesAdded = 0;
                
                imageContainers.forEach((container, index) => {
                    const img = container.querySelector('img');
                    const labelDiv = container.querySelector('.image-label');
                    const label = container.dataset.label;
                    
                    if (img && img.src) {
                        const imageData = {
                            src: img.src,
                            url: img.src,
                            name: labelDiv ? labelDiv.textContent : label || `Image ${index + 1}`,
                            label: label,
                            filename: labelDiv ? labelDiv.textContent : undefined
                        };
                        
                        // Check if this image is already in the gallery
                        const existingIndex = imageGalleryData.findIndex(item => item.src === img.src);
                        
                        if (existingIndex === -1) {
                            addImageToGallery(imageData, imageGalleryData.length);
                            console.log(`[SYNC] ✓ Added: ${imageData.name}`);
                            newImagesAdded++;
                        }
                    }
                });
                
                if (newImagesAdded > 0) {
                    console.log(`[SYNC] Added ${newImagesAdded} new images. Total: ${imageGalleryData.length}`);
                }
            }
            
            // Function to clear demo images
            function clearDemoImages() {
                console.log('[DEMO] Clearing demo images...');
                imageGalleryData = imageGalleryData.filter(item => !item.name?.includes('Demo Image') && !item.name?.includes('Blank Canvas'));
                
                // Manually update the gallery UI instead of calling undefined function
                const gallery = document.getElementById('imageGallery');
                const dots = document.getElementById('imageDots');
                
                if (gallery) {
                    // Remove demo image thumbnails
                    const demoThumbnails = gallery.querySelectorAll('.image-thumbnail');
                    demoThumbnails.forEach(thumb => {
                        const overlay = thumb.querySelector('.image-overlay');
                        if (overlay && (overlay.textContent.includes('Demo Image') || overlay.textContent.includes('Blank Canvas'))) {
                            thumb.remove();
                        }
                    });
                }
                
                if (dots) {
                    // Clear demo dots
                    const demoDots = dots.querySelectorAll('.nav-dot');
                    demoDots.forEach(dot => dot.remove());
                }
                
                // Update counter if function exists
                if (typeof updateImageCounter === 'function') {
                    updateImageCounter();
                } else {
                    // Update counter manually
                    const counter = document.getElementById('imageCounter');
                    if (counter) {
                        counter.textContent = imageGalleryData.length > 0 ? `${imageGalleryData.length} images` : '';
                    }
                }
                console.log('[DEMO] Demo images cleared, remaining images:', imageGalleryData.length);
            }
            
            // Removed manual sync button - syncing is now automatic
            
            // Test the gallery with some demo images after everything loads
            setTimeout(() => {
                console.log('[INIT] ===== Initial gallery setup =====');
                console.log('[INIT] imageGalleryData before sync:', imageGalleryData.length);
                
                // First, sync any existing legacy images
                console.log('[INIT] Step 1: Syncing existing legacy images...');
                syncLegacyImagesToGallery();
                
                console.log('[INIT] imageGalleryData after sync:', imageGalleryData.length);
                
                // Check if we have any real images (non-demo)
                const realImagesCount = imageGalleryData.filter(item => !item.name?.includes('Demo Image') && !item.name?.includes('Blank Canvas')).length;
                console.log('[INIT] Real images found:', realImagesCount);
                
                // Do not add demo/blank images; keep gallery empty until user adds/loads
                console.log(`[INIT] Skipping demo images. Real count: ${realImagesCount}`);
                
                // Test the addImageToSidebar function to see if hooking works
                if (window.addImageToSidebar) {
                    console.log('[TEST] addImageToSidebar function is available');
                } else {
                    console.log('[TEST] addImageToSidebar not available yet');
                }
                
                console.log('[INIT] ===== Initial setup complete =====');
                
                // Ensure we always start with the first image
                if (imageGalleryData.length > 0) {
                    console.log('[INIT] Navigating to first image (index 0)');
                    setTimeout(() => {
                        navigateToImage(0);
                        updateActiveImage(0);
                    }, 100); // Small delay to ensure everything is ready
                }
            }, 2000);
            
            // Track last known legacy count to avoid unnecessary syncs
            let lastLegacyCount = 0;
            
            // Also set up a periodic sync to catch any images that get added later (less frequent)
            // Only run when tab is visible to reduce performance impact
            let syncInterval;
            const startSyncInterval = () => {
                syncInterval = setInterval(() => {
                    // Skip if tab is not visible
                    if (document.hidden) return;
                    
                    const currentLegacyCount = document.getElementById('imageList')?.querySelectorAll('.image-container').length || 0;
                    const currentRealImagesCount = imageGalleryData.filter(item => !item.name?.includes('Demo Image') && !item.name?.includes('Blank Canvas')).length;
                    
                    // Only sync if there's actually a change in legacy count
                    if (currentLegacyCount > lastLegacyCount) {
                        console.log('[PERIODIC] New legacy images detected, syncing...');
                        console.log(`[PERIODIC] Legacy: ${currentLegacyCount} (was ${lastLegacyCount}), Gallery real: ${currentRealImagesCount}`);
                        
                        // No demo images are used anymore; skip clearing
                        
                        syncLegacyImagesToGallery();
                        
                        // After adding new images, silently load the first one without scrolling
                        if (imageGalleryData.length > 0) {
                            const firstImage = imageGalleryData[0];
                            const firstLabel = firstImage?.name || firstImage?.label;
                            
                            if (firstLabel) {
                                console.log('[PERIODIC] Loading first image silently:', firstLabel);
                            setTimeout(() => {
                                    // Directly update canvas without scrolling thumbnail
                                    if (window.pastedImages && window.pastedImages[firstLabel]) {
                                        window.currentImageLabel = firstLabel;
                                        const imgElement = window.pastedImages[firstLabel];
                                        if (imgElement && imgElement.complete) {
                                            window.redrawCanvasWithVisibility();
                                            // Update active state without scrolling
                                            const thumbnails = document.querySelectorAll('.image-container');
                                            thumbnails.forEach((thumb, idx) => {
                                                if (thumb.dataset.label === firstLabel || thumb.getAttribute('title') === firstLabel) {
                                                    thumb.classList.add('active');
                                                    thumb.setAttribute('aria-selected', 'true');
                                                } else {
                                                    thumb.classList.remove('active');
                                                    thumb.removeAttribute('aria-selected');
                                                }
                                            });
                                        }
                                    }
                            }, 200);
                            }
                        }
                        
                        lastLegacyCount = currentLegacyCount;
                    }
                }, 3000);  // Check every 3 seconds instead of 2
            };
            
            // Start interval and handle visibility changes
            startSyncInterval();
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    clearInterval(syncInterval);
                } else {
                    startSyncInterval();
                }
            });
        });

        // View Measurements toggle functionality
        document.addEventListener('DOMContentLoaded', () => {
            // View Measurements toggle functionality
            const viewMeasurementsToggle = document.getElementById('viewMeasurementsToggle');
            if (viewMeasurementsToggle) {
                let measurementsVisible = true; // Default state

                const updateToggleAppearance = () => {
                    if (measurementsVisible) {
                        viewMeasurementsToggle.classList.remove('bg-gray-500', 'text-white');
                        viewMeasurementsToggle.classList.add('bg-blue-500', 'text-white');
                        viewMeasurementsToggle.textContent = 'Show Labels';
                        viewMeasurementsToggle.title = 'Hide measurement labels';
                    } else {
                        viewMeasurementsToggle.classList.remove('bg-blue-500', 'text-white');
                        viewMeasurementsToggle.classList.add('bg-gray-500', 'text-white');
                        viewMeasurementsToggle.textContent = 'Hide Labels';
                        viewMeasurementsToggle.title = 'Show measurement labels';
                    }
                };

                viewMeasurementsToggle.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent panel dragging
                    measurementsVisible = !measurementsVisible;
                    updateToggleAppearance();

                    // Toggle all measurement labels visibility
                    if (window.strokeLabelVisibility && window.currentImageLabel) {
                        const imageLabels = window.strokeLabelVisibility[window.currentImageLabel];
                        if (imageLabels) {
                            for (const strokeLabel in imageLabels) {
                                window.strokeLabelVisibility[window.currentImageLabel][strokeLabel] = measurementsVisible;
                            }
                        }
                    }

                    // Update all label toggle buttons in the stroke list
                    const labelToggleBtns = document.querySelectorAll('.stroke-label-toggle');
                    labelToggleBtns.forEach(btn => {
                        btn.innerHTML = measurementsVisible ? '🏷️' : ' 🏷️ ';
                        btn.title = measurementsVisible ? 'Hide Label' : 'Show Label';
                    });

                    // Redraw canvas to apply changes
                    if (typeof window.redrawCanvasWithVisibility === 'function') {
                        window.redrawCanvasWithVisibility();
                    }
                });

                // Set initial appearance
                updateToggleAppearance();
            }
        });
    </script>
    
    <!-- Scale Dropdown - positioned outside panel hierarchy -->
    <div id="scaleDropdown" class="fixed bg-white border border-gray-300 rounded shadow-lg hidden max-h-64 overflow-y-auto" style="z-index: 9999; min-width: 80px;">
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.1">10%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.15">15%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.2">20%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.25">25%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.33">33%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.5">50%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.67">67%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.75">75%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.8">80%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.9">90%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm bg-blue-50" data-scale="1" data-default="true">100%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.1">110%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.25">125%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.5">150%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.75">175%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="2">200%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="2.5">250%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="3">300%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="4">400%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="5">500%</div>
    </div>

    <script>console.log('[INDEX] before paint.js'); window.onerror=(m,s,l,c,e)=>console.error('[INDEX] onerror',m,s,l,c,e);</script>
    <script>(function(){try{window.NEXT_PUBLIC_REMBG_SAFESHIM='1';}catch(_){}})();</script>
    <!-- New coordinate system scripts -->
    <script src="js/transform.js?v=20250820123456"></script>
    <script src="js/geometry.js?v=20250820123456"></script>
    <script src="js/migration.js?v=20250820123456"></script>
    <script src="diagnostics-overlay.js?v=20250820123456"></script>
    <script src="test-coordinate-system.js?v=20250912113000"></script>

    <script src="js/paint.js?v=20250912113000"></script>
    <script src="js/project-manager.js?v=20250912113000"></script>
    <script src="js/tag-manager.js?v=20250912113000"></script>
</body>
</html>
