<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenPaint</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Suppress Tailwind production warning for this demo
        if (typeof console !== 'undefined' && console.warn) {
            const originalWarn = console.warn;
            console.warn = (...args) => {
                if (args[0] && args[0].includes && args[0].includes('should not be used in production')) return;
                originalWarn.apply(console, args);
            };
        }
    </script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // Modern brand colors
                        brand: {
                            50: '#f0f9ff',
                            100: '#e0f2fe',
                            200: '#bae6fd',
                            300: '#7dd3fc',
                            400: '#38bdf8',
                            500: '#0ea5e9',
                            600: '#0284c7',
                            700: '#0369a1',
                            800: '#075985',
                            900: '#0c4a6e',
                        },
                        // Semantic colors
                        primary: {
                            50: '#eff6ff',
                            100: '#dbeafe',
                            200: '#bfdbfe',
                            300: '#93c5fd',
                            400: '#60a5fa',
                            500: '#3b82f6',
                            600: '#2563eb',
                            700: '#1d4ed8',
                            800: '#1e40af',
                            900: '#1e3a8a',
                        },
                        success: {
                            50: '#f0fdf4',
                            100: '#dcfce7',
                            200: '#bbf7d0',
                            300: '#86efac',
                            400: '#4ade80',
                            500: '#22c55e',
                            600: '#16a34a',
                            700: '#15803d',
                            800: '#166534',
                            900: '#14532d',
                        },
                        danger: {
                            50: '#fef2f2',
                            100: '#fee2e2',
                            200: '#fecaca',
                            300: '#fca5a5',
                            400: '#f87171',
                            500: '#ef4444',
                            600: '#dc2626',
                            700: '#b91c1c',
                            800: '#991b1b',
                            900: '#7f1d1d',
                        },
                        warning: {
                            50: '#fffbeb',
                            100: '#fef3c7',
                            200: '#fde68a',
                            300: '#fcd34d',
                            400: '#fbbf24',
                            500: '#f59e0b',
                            600: '#d97706',
                            700: '#b45309',
                            800: '#92400e',
                            900: '#78350f',
                        },
                    },
                    fontFamily: {
                        'sans': ['Inter', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'sans-serif'],
                    },
                    fontSize: {
                        'xs': ['0.75rem', { lineHeight: '1rem' }],
                        'sm': ['0.875rem', { lineHeight: '1.25rem' }],
                        'base': ['1rem', { lineHeight: '1.5rem' }],
                        'lg': ['1.125rem', { lineHeight: '1.75rem' }],
                        'xl': ['1.25rem', { lineHeight: '1.75rem' }],
                        '2xl': ['1.5rem', { lineHeight: '2rem' }],
                    },
                    borderRadius: {
                        'xl': '0.75rem',
                        '2xl': '1rem',
                        '3xl': '1.5rem',
                    },
                    boxShadow: {
                        'glass': '0 8px 32px 0 rgba(31, 38, 135, 0.37)',
                        'panel': '0 10px 25px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
                        'elevated': '0 25px 50px -12px rgba(0, 0, 0, 0.25)',
                    },
                    backdropBlur: {
                        'xs': '2px',
                    }
                }
            }
        }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        /* Fullscreen canvas styles */
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
            cursor: crosshair;
            background: #f8f9fa;
        }
        
        /* Modern floating panel base styles */
        .floating-panel {
            backdrop-filter: blur(20px);
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1), 
                       0 4px 6px -2px rgba(0, 0, 0, 0.05),
                       0 0 0 1px rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .floating-panel:hover {
            background: rgba(255, 255, 255, 0.99);
        }
        
        /* Only apply hover transform to main panels, not side panels */
        #projectPanel:hover,
        #toolsPanel:hover,
        #canvasControls:hover {
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            transform: translateY(-1px);
        }
        
        .floating-panel.dragging {
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            transform: none !important;
            transition: none !important;
        }
        
        /* Modern capture frame styles */
        #captureOverlay {
            backdrop-filter: none;
        }
        
        .capture-frame {
            background: transparent;
            transition: none !important;
        }
        
        .capture-frame.locked {
            cursor: default;
        }
        
        .capture-frame.unlocked {
            cursor: move;
        }
        
        /* Capture frame dragging - no transitions for 1:1 movement */
        .capture-frame.dragging {
            transition: none !important;
        }
        
        /* Modern resize handles - smaller and more discrete */
        .resize-handle {
            position: absolute;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        
        .capture-frame.unlocked:hover .resize-handle,
        .capture-frame.unlocked .resize-handle:hover {
            opacity: 1;
        }
        
        .resize-handle:hover {
            transform: scale(1.3);
            background: #3b82f6 !important;
            border-color: white !important;
        }
        
        /* Dark overlay - no transitions for instant response */
        #darkOverlay {
            transition: none;
        }
        
        /* macOS style popup */
        #lockPopup {
            font-size: 14px;
            font-weight: 500;
        }
        
        #lockPopup.show {
            display: flex !important;
            animation: fadeInOut 1.5s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        
        /* Lock button states */
        #captureLockButton .locked-icon {
            display: none;
        }
        
        #captureLockButton .unlocked-icon {
            display: block;
        }
        
        #captureLockButton.locked .locked-icon {
            display: block;
        }
        
        #captureLockButton.locked .unlocked-icon {
            display: none;
        }
        
        /* Hide resize handles when locked */
        .capture-frame.locked .resize-handles {
            display: none;
        }
        
        /* Drag over canvas effects */
        #canvas.drag-over {
            background: rgba(76, 175, 80, 0.05);
        }
        
        /* Panel minimization styles */
        .floating-panel.minimized {
            max-height: none !important;
        }
        
        .floating-panel.minimized .cursor-move {
            border-bottom: none;
        }
        
        /* Smooth transitions for all panel content */
        .floating-panel [id$='Content'],
        .floating-panel [id$='Controls'] {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }
        
        .floating-panel [id$='Content'].hidden,
        .floating-panel [id$='Controls'].hidden {
            max-height: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-top: 0 !important;
            margin-bottom: 0 !important;
            opacity: 0;
        }
        
        /* Enhanced button hover effects */
        .floating-panel button[id^='toggle']:hover svg {
            transform: scale(1.1);
        }
        
        /* Active state for minimized panels */
        .floating-panel.minimized {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);
        }
        
        .floating-panel:not(.minimized) {
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        /* Ensure proper dragging behavior */
        .floating-panel.dragging {
            z-index: 9999 !important;
            transform: none !important;
            transition: none !important;
        }
        
        /* Header dragging styles */
        .cursor-move:active {
            cursor: grabbing !important;
        }
        
        /* Fix stroke visibility item layout */
        .stroke-visibility-item {
            display: flex !important;
            align-items: center !important;
            gap: 8px !important;
            padding: 8px !important;
            margin-bottom: 4px !important;
            background: white !important;
            border-radius: 6px !important;
            border: 1px solid #e5e7eb !important;
            transition: all 0.2s ease !important;
        }
        
        .stroke-visibility-item:hover {
            background-color: #f9fafb !important;
            border-color: #d1d5db !important;
        }
        
        .stroke-label-container {
            display: flex !important;
            align-items: center !important;
            gap: 6px !important;
            flex: 1 !important;
        }
        
        .stroke-name {
            font-weight: 600 !important;
            font-size: 14px !important;
            padding: 2px 6px !important;
            border-radius: 4px !important;
            border: 1px solid currentColor !important;
            min-width: auto !important;
        }
        
        .stroke-label-toggle-btn {
            background: none !important;
            border: none !important;
            cursor: pointer !important;
            font-size: 14px !important;
            padding: 2px !important;
            opacity: 0.7 !important;
        }
        
        .stroke-label-toggle-btn:hover {
            opacity: 1 !important;
        }
        
        .stroke-measurement {
            font-size: 13px !important;
            color: #6b7280 !important;
            font-weight: 500 !important;
        }
        
        .stroke-delete-btn {
            background: none !important;
            border: none !important;
            color: #ef4444 !important;
            cursor: pointer !important;
            font-size: 16px !important;
            font-weight: bold !important;
            padding: 2px 6px !important;
            border-radius: 4px !important;
            opacity: 0.7 !important;
            transition: all 0.2s ease !important;
        }
        
        .stroke-delete-btn:hover {
            opacity: 1 !important;
            background-color: #fef2f2 !important;
        }
        
        /* Force scrollbars to always show when content overflows */
        #strokeVisibilityControls,
        #imagePanelContent {
            scroll-behavior: smooth;
            overflow-y: scroll !important;
            scrollbar-width: auto !important;
            scrollbar-color: #9ca3af #f3f4f6 !important;
        }
        
        #strokeVisibilityControls::-webkit-scrollbar,
        #imagePanelContent::-webkit-scrollbar {
            width: 8px !important;
            display: block !important;
        }
        
        #strokeVisibilityControls::-webkit-scrollbar-track,
        #imagePanelContent::-webkit-scrollbar-track {
            background: #f3f4f6 !important;
            border-radius: 4px !important;
        }
        
        #strokeVisibilityControls::-webkit-scrollbar-thumb,
        #imagePanelContent::-webkit-scrollbar-thumb {
            background: #9ca3af !important;
            border-radius: 4px !important;
            border: 1px solid #f3f4f6 !important;
        }
        
        #strokeVisibilityControls::-webkit-scrollbar-thumb:hover,
        #imagePanelContent::-webkit-scrollbar-thumb:hover {
            background: #6b7280 !important;
        }
        
        /* Modern slider styling */
        .slider {
            --accent: #3b82f6;
            --filled: 30%;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, var(--accent) 0%, var(--accent) var(--filled), #e5e7eb var(--filled), #e5e7eb 100%);
            outline: none;
            border-radius: 9999px;
            height: 6px;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
            transition: all 0.2s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(59, 130, 246, 0.4);
        }
        
        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
            transition: all 0.2s ease;
        }
        
        .slider::-moz-range-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(59, 130, 246, 0.4);
        }
        
        /* Modern input styling */
        input[type="text"], input[type="number"], select {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            ring: 2px;
            ring-color: #3b82f6;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Enhanced color picker active state */
        [data-color].active {
            border-color: #1f2937 !important;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 1), 0 0 0 6px #1f2937 !important;
            transform: scale(1.15);
        }
        
        /* Image Gallery Styling */
        #imageGallery {
            scrollbar-width: thin;
            scrollbar-color: #cbd5e1 #f1f5f9;
        }
        
        #imageGallery::-webkit-scrollbar {
            height: 6px;
        }
        
        #imageGallery::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        
        #imageGallery::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        
        #imageGallery::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        
        /* Image thumbnail styling */
        .image-thumbnail {
            flex-shrink: 0;
            width: 120px;
            height: 120px;
            border-radius: 12px;
            border: 2px solid transparent;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            snap-align: center;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
            overflow: hidden;
        }
        
        .image-thumbnail:hover {
            border-color: #cbd5e1;
            transform: scale(1.05);
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1);
        }
        
        .image-thumbnail.active {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2), 0 10px 25px -3px rgba(0, 0, 0, 0.15);
            transform: scale(1.05);
        }
        
        .image-thumbnail.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
            z-index: 1000;
        }
        
        .image-thumbnail.drag-over {
            border-color: #10b981;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.5);
            transform: translateY(-1px) scale(1.05);
        }
        
        .image-thumbnail .image-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
            color: white;
            padding: 8px;
            font-size: 11px;
            font-weight: 500;
            text-align: center;
            border-radius: 0 0 10px 10px;
        }
        
        .thumbnail-controls {
            position: absolute;
            top: 4px;
            right: 4px;
            display: none;
            flex-direction: column;
            gap: 2px;
        }
        
        .delete-control {
            position: absolute;
            top: 4px;
            left: 4px;
            display: none;
        }
        
        .image-thumbnail:hover .thumbnail-controls,
        .image-thumbnail:hover .delete-control {
            display: flex;
        }
        
        .control-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            color: #374151;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .control-btn:hover {
            background: white;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .delete-btn {
            background: #dc2626 !important;
            color: white !important;
            font-weight: bold;
        }
        
        .delete-btn:hover {
            background: #b91c1c !important;
            transform: scale(1.1);
        }
        
        .rotate-btn:hover {
            background: #dbeafe;
            color: #2563eb;
        }
        
        .flip-btn:hover {
            background: #d1fae5;
            color: #059669;
        }
        
        /* Navigation dots styling */
        .nav-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #cbd5e1;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .nav-dot:hover {
            background: #94a3b8;
            transform: scale(1.2);
        }
        
        .nav-dot.active {
            background: #3b82f6;
            transform: scale(1.3);
        }

        /* Modernize panel chrome and add optional sketchbook vibe */
        .floating-panel {
            border: 1px solid rgba(15, 23, 42, 0.06);
            box-shadow: 0 12px 28px rgba(2, 6, 23, 0.08);
        }
        .floating-panel .cursor-move {
            border-bottom: 1px solid rgba(15, 23, 42, 0.06) !important;
        }
        /* Tone down button effects for a cleaner feel */
        .floating-panel button {
            box-shadow: 0 1px 2px rgba(2,6,23,0.06) !important;
            transform: none !important;
        }
        .floating-panel button:hover {
            transform: translateY(-1px) !important;
        }
        /* Minimal divider */
        .panel-divider { border-top: 1px solid rgba(15,23,42,0.08); }

        /* Top toolbar styles */
        #topToolbar {
            height: 48px;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .toolbar-wrap {
            height: 48px;
        }
        .tbtn, .tselect, .tinput {
            height: 32px;
            padding: 0 10px;
            border-radius: 8px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid rgba(148,163,184,.6);
            background: #fff;
            font-size: 12px;
            line-height: 1;
            transition: all 0.15s ease;
        }
        .tbtn.active { border-color: rgba(59,130,246,.9); background: #eff6ff; color: #1e40af; }
        .tbtn:hover, .tselect:hover, .tinput:hover {
            border-color: rgba(59,130,246,.8);
            box-shadow: 0 2px 4px rgba(59,130,246,.1);
        }
        .icon-btn {
            width: 32px;
            justify-content: center;
            padding: 0;
        }
        .group-gap > * {
            margin-right: 6px;
        }
        .group-gap > *:last-child {
            margin-right: 0;
        }
        .popover {
            position: absolute;
            top: 40px;
            left: 0;
            background: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(2,6,23,.12);
            padding: 12px;
            display: none;
            z-index: 60;
            min-width: 120px;
        }
        .popover.show {
            display: block;
        }
    </style>
</head>
<body class="bg-gray-50 h-screen overflow-hidden">
    <!-- Top Toolbar -->
    <div id="topToolbar" class="fixed top-0 inset-x-0 z-40 bg-white/85 backdrop-blur border-b border-slate-200">
        <div class="toolbar-wrap mx-auto max-w-[1400px] px-3 flex items-center justify-between">
            <div id="tbLeft" class="relative flex items-center group-gap"></div>
            <div id="tbCenter" class="relative flex items-center group-gap"></div>
            <div id="tbRight" class="relative flex items-center group-gap"></div>
        </div>
    </div>

    <!-- Fullscreen Canvas -->
    <canvas id="canvas" class="w-full h-full"></canvas>
    
    <!-- Project Header Panel -->
    <div id="projectPanel" class="floating-panel fixed top-4 right-4 z-30 rounded-2xl w-80 transition-all duration-300">
        <div class="flex items-center justify-between p-4 cursor-move border-b border-gray-200/50">
            <h3 class="text-base font-bold text-slate-800">Project Settings</h3>
            <button id="toggleProjectPanel" class="text-slate-500 hover:text-slate-700 hover:bg-slate-100 rounded-lg p-1.5 transition-all duration-200 transform hover:scale-110" title="Minimize/Expand Panel">
                <svg class="w-5 h-5 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
        </div>
        <div id="projectPanelContent" class="p-3 transition-all duration-300">
            <div class="flex flex-col gap-3">
                <!-- Project Info -->
                <div class="flex flex-col gap-3">
                    <input 
                        type="text" 
                        id="projectName" 
                        placeholder="Project Name" 
                        value="New Sofa" 
                        class="px-3 py-2.5 border border-gray-300 rounded-xl text-sm bg-white w-full focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200 shadow-sm"
                    >
                    <div class="flex items-center gap-3">
                        <label class="text-sm font-semibold text-slate-700 w-14">Units:</label>
                        <select 
                            id="unitSelector" 
                            onchange="updateMeasurementDisplay()" 
                            class="px-3 py-2.5 border border-gray-300 rounded-xl text-sm bg-white flex-1 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200 shadow-sm"
                        >
                            <option value="inch">inches</option>
                            <option value="cm">cm</option>
                        </select>
                    </div>
                    
                    <!-- Hidden inputs for functionality -->
                    <div id="measurementInput" class="hidden">
                        <div id="inchInputs" class="flex items-center gap-2">
                            <input type="number" id="inchWhole" min="0" value="0" class="w-16 px-2 py-1 border border-gray-300 rounded text-sm">
                            <select id="inchFraction" class="px-2 py-1 border border-gray-300 rounded text-sm">
                                <option value="0">0</option>
                                <option value="0.125">1/8</option>
                                <option value="0.25">1/4</option>
                                <option value="0.375">3/8</option>
                                <option value="0.5">1/2</option>
                                <option value="0.625">5/8</option>
                                <option value="0.75">3/4</option>
                                <option value="0.875">7/8</option>
                            </select>
                        </div>
                        <div id="cmInputs" class="hidden">
                            <input type="number" id="cmValue" min="0" step="0.1" value="0.0" class="w-16 px-2 py-1 border border-gray-300 rounded text-sm">
                        </div>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="grid grid-cols-2 gap-2 panel-divider pt-3 mt-2">
                    <button id="saveProject" title="Save project as ZIP file" class="px-3 py-2 bg-white border border-gray-300 text-slate-700 text-xs font-semibold rounded-xl hover:bg-slate-50 transition-all">Save</button>
                    <button id="loadProject" title="Load project from ZIP file" class="px-3 py-2 bg-white border border-gray-300 text-slate-700 text-xs font-semibold rounded-xl hover:bg-slate-50 transition-all">Load</button>
                    <button id="generateMeasurements" title="Generate list of all measurements" class="px-3 py-2 bg-white border border-gray-300 text-slate-700 text-xs font-semibold rounded-xl hover:bg-slate-50 transition-all">Measurements</button>
                    <button id="saveAllImages" title="Save all images as individual files" class="px-3 py-2 bg-white border border-gray-300 text-slate-700 text-xs font-semibold rounded-xl hover:bg-slate-50 transition-all">Images</button>
                    <button id="saveAsPdf" title="Export measurements as PDF form" class="px-3 py-2 bg-white border border-danger-300 text-danger-600 text-xs font-semibold rounded-xl hover:bg-danger-50 transition-all col-span-2">Save as PDF</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Drawing Tools Panel -->
    <div id="toolsPanel" class="floating-panel fixed top-4 left-4 z-30 rounded-2xl transition-all duration-300">
        <div class="flex items-center justify-between p-4 cursor-move border-b border-gray-200/50">
            <h3 class="text-base font-bold text-slate-800">Drawing Tools</h3>
            <button id="toggleToolsPanel" class="text-slate-500 hover:text-slate-700 hover:bg-slate-100 rounded-lg p-1.5 transition-all duration-200 transform hover:scale-110" title="Minimize/Expand Panel">
                <svg class="w-5 h-5 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
        </div>
        <div id="toolsPanelContent" class="p-4 transition-all duration-300">
            <div class="flex flex-col gap-4">
                <!-- Primary Tools -->
                <div class="flex items-center gap-3">
                    <button id="clear" class="px-4 py-2.5 bg-danger-500 hover:bg-danger-600 active:bg-danger-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95">Clear</button>
                    <button id="paste" class="px-4 py-2.5 bg-primary-500 hover:bg-primary-600 active:bg-primary-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95">Upload Images</button>
                    <button id="save" class="px-4 py-2.5 bg-success-500 hover:bg-success-600 active:bg-success-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95">Save</button>
                </div>
                
                <!-- Color Palette -->
                <div class="flex items-center gap-3">
                    <span class="text-sm font-semibold text-slate-700">Color:</span>
                    <div class="flex gap-2">
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110 active" data-color="#3b82f6" style="background-color: #3b82f6;" title="Blue"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#22c55e" style="background-color: #22c55e;" title="Green"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#ef4444" style="background-color: #ef4444;" title="Red"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#f59e0b" style="background-color: #f59e0b;" title="Yellow"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#a855f7" style="background-color: #a855f7;" title="Purple"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#1f2937" style="background-color: #1f2937;" title="Dark Gray"></button>
                    </div>
                    <input type="color" id="colorPicker" value="#3b82f6" class="hidden">
                </div>
                
                <!-- Drawing Mode & Controls -->
                <div class="flex items-center gap-4">
                    <button id="drawingModeToggle" class="px-4 py-2.5 bg-white border-2 border-success-500 text-success-600 text-sm font-semibold rounded-xl hover:bg-success-50 hover:border-success-600 active:bg-success-100 transition-all duration-200 transform hover:scale-105 active:scale-95 straight-mode shadow-sm">
                        Straight Line
                    </button>
                    <div class="flex items-center gap-3">
                        <span class="text-sm font-semibold text-slate-700">Size:</span>
                        <input type="range" id="brushSize" min="1" max="50" value="5" class="w-24 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider">
                    </div>
                </div>
                
                <!-- Arrow & Line Style Controls -->
                <div class="flex items-center gap-4">
                    <div id="arrowControls" class="flex items-center gap-3">
                        <span class="text-sm font-semibold text-slate-700">Arrows:</span>
                        <button id="startArrow" class="px-3 py-2 bg-slate-100 hover:bg-slate-200 active:bg-slate-300 text-slate-700 text-sm font-medium rounded-lg transition-all duration-200 transform hover:scale-105 active:scale-95 shadow-sm" title="Toggle start arrow">◀</button>
                        <button id="endArrow" class="px-3 py-2 bg-slate-100 hover:bg-slate-200 active:bg-slate-300 text-slate-700 text-sm font-medium rounded-lg transition-all duration-200 transform hover:scale-105 active:scale-95 shadow-sm" title="Toggle end arrow">▶</button>
                    </div>
                    <div id="dashControls" class="flex items-center gap-3">
                        <span class="text-sm font-semibold text-slate-700">Style:</span>
                        <select id="dashStyleSelect" class="px-3 py-2 border border-gray-300 rounded-xl text-sm bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200 shadow-sm">
                            <option value="solid">Solid</option>
                            <option value="small">Small Dash</option>
                            <option value="medium">Medium Dash</option>
                            <option value="large">Large Dash</option>
                            <option value="dot-dash">Dot-Dash</option>
                            <option value="custom">Custom</option>
                        </select>
                        <div id="customDashControls" class="hidden items-center gap-2">
                            <input type="number" id="dashLengthInput" min="1" max="50" value="5" class="w-16 px-2 py-1.5 border border-gray-300 rounded-lg text-xs focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200" title="Dash length">
                            <span class="text-xs text-slate-500">/</span>
                            <input type="number" id="gapLengthInput" min="1" max="50" value="5" class="w-16 px-2 py-1.5 border border-gray-300 rounded-lg text-xs focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200" title="Gap length">
                        </div>
                    </div>
                </div>
                
                <!-- Stroke Counter -->
                <div class="text-sm text-gray-600 font-medium">
                    <span id="strokeCounter">Lines: 0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Stroke Manager Panel -->
    <div id="strokePanel" class="floating-panel fixed left-4 top-1/2 -translate-y-1/2 z-30 rounded-2xl w-64 max-h-96 transition-all duration-300 overflow-hidden">
        <div class="flex items-center justify-between p-3 cursor-move border-b border-gray-200/50 bg-white rounded-t-2xl">
            <h3 class="text-sm font-semibold text-slate-800">Stroke Visibility</h3>
            <button id="toggleStrokePanel" class="text-slate-500 hover:text-slate-700 rounded-lg p-1 transition-all" title="Minimize/Expand Panel">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
        </div>
        <div id="strokeVisibilityControls" class="p-3 transition-all duration-300" style="max-height: 320px; overflow-y: scroll; overflow-x: hidden;"></div>
    </div>

    <!-- Image Gallery Panel -->
    <div id="imagePanel" class="floating-panel fixed right-4 top-1/2 -translate-y-1/2 z-30 rounded-2xl w-72 max-h-[380px] transition-all duration-300 overflow-hidden">
        <div class="flex items-center justify-between p-3 cursor-move border-b border-gray-200/50 bg-white rounded-t-2xl">
            <h3 class="text-sm font-semibold text-slate-800">Images</h3>
            <div class="flex items-center gap-2">
                <button id="toggleImagePanel" class="text-slate-500 hover:text-slate-700 rounded-lg p-1 transition-all" title="Minimize/Expand Panel">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </button>
            </div>
        </div>
        <div id="imagePanelContent" class="p-3 transition-all duration-300" style="max-height: 300px;">
            <!-- Legacy image list for backwards compatibility -->
            <div id="imageList" class="hidden space-y-3 mb-4"></div>
            
            <!-- New Image Gallery with Horizontal Scroll Snap -->
            <div class="mb-4">
                <div id="imageGallery" class="flex gap-3 overflow-x-auto snap-x snap-mandatory scroll-smooth pb-2" style="scrollbar-width: thin;">
                    <!-- Images will be dynamically inserted here -->
                </div>
                <!-- Navigation Dots -->
                <div id="imageDots" class="flex justify-center gap-2 mt-3">
                    <!-- Dots will be dynamically inserted here -->
                </div>
            </div>
            
            <!-- Image meta: name + quick type -->
            <div class="flex items-center gap-2 mb-2">
                <input id="imageNameInput" type="text" class="flex-1 px-2 py-1 border border-gray-300 rounded-lg text-xs focus:outline-none focus:ring-1 focus:ring-slate-300" placeholder="Image name" />
                <select id="imageTypeSelect" class="px-2 py-1 border border-gray-300 rounded-lg bg-white text-xs">
                    <option value="">Type</option>
                    <option value="sofa">sofa</option>
                    <option value="armchair">armchair</option>
                    <option value="chaise">chaise</option>
                    <option value="ottoman">ottoman</option>
                    <option value="cushion">cushion</option>
                    <option value="windowseat">windowseat</option>
                </select>
            </div>

            <!-- Navigation Controls -->
                <div class="flex items-center justify-between mb-4">
                <button id="prevImage" class="p-2 bg-slate-100 hover:bg-slate-200 active:bg-slate-300 text-slate-700 rounded-lg transition-all duration-200 transform hover:scale-105 active:scale-95 shadow-sm disabled:opacity-50 disabled:cursor-not-allowed" title="Previous image">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                    </svg>
                </button>
                    <div class="text-xs text-slate-600 font-medium hidden" id="imagePosition">0 / 0</div>
                <button id="nextImage" class="p-2 bg-slate-100 hover:bg-slate-200 active:bg-slate-300 text-slate-700 rounded-lg transition-all duration-200 transform hover:scale-105 active:scale-95 shadow-sm disabled:opacity-50 disabled:cursor-not-allowed" title="Next image">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Capture Frame -->
    <div id="captureOverlay" class="fixed inset-0 pointer-events-none" style="z-index: 15;">
        <!-- Capture frame -->
        <div id="captureFrame" class="capture-frame absolute border-2 border-gray-400 bg-transparent" style="left: calc(50% - 400px); top: calc(50% - 300px); width: 800px; height: 600px; pointer-events: none;">
            <!-- Lock button -->
            <button id="captureLockButton" class="absolute -bottom-8 -right-8 w-8 h-8 bg-white border border-gray-300 rounded shadow-md hover:bg-gray-50 transition-colors flex items-center justify-center text-gray-600" title="Lock/Unlock frame (L)">
                <!-- Locked icon -->
                <svg class="locked-icon w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"></path>
                </svg>
                <!-- Unlocked icon -->
                <svg class="unlocked-icon w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z"></path>
                </svg>
            </button>
            
            <!-- Resize handles (hidden when locked) -->
            <div class="resize-handles">
                <div class="resize-handle w-3 h-3 -top-1 -left-1 bg-white border border-blue-400 rounded-sm" style="cursor: nw-resize;" data-direction="nw"></div>
                <div class="resize-handle w-3 h-3 -top-1 left-1/2 -translate-x-1/2 bg-white border border-blue-400 rounded-sm" style="cursor: n-resize;" data-direction="n"></div>
                <div class="resize-handle w-3 h-3 -top-1 -right-1 bg-white border border-blue-400 rounded-sm" style="cursor: ne-resize;" data-direction="ne"></div>
                <div class="resize-handle w-3 h-3 top-1/2 -translate-y-1/2 -right-1 bg-white border border-blue-400 rounded-sm" style="cursor: e-resize;" data-direction="e"></div>
                <div class="resize-handle w-3 h-3 -bottom-1 -right-1 bg-white border border-blue-400 rounded-sm" style="cursor: se-resize;" data-direction="se"></div>
                <div class="resize-handle w-3 h-3 -bottom-1 left-1/2 -translate-x-1/2 bg-white border border-blue-400 rounded-sm" style="cursor: s-resize;" data-direction="s"></div>
                <div class="resize-handle w-3 h-3 -bottom-1 -left-1 bg-white border border-blue-400 rounded-sm" style="cursor: sw-resize;" data-direction="sw"></div>
                <div class="resize-handle w-3 h-3 top-1/2 -translate-y-1/2 -left-1 bg-white border border-blue-400 rounded-sm" style="cursor: w-resize;" data-direction="w"></div>
            </div>
        </div>
    </div>
    
    <!-- Instruction Text for Unlocked Mode -->
    <div id="unlockInstructions" class="fixed top-4 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-80 text-white px-4 py-2 rounded-lg shadow-xl hidden backdrop-blur-sm z-40">
        <div class="text-sm font-medium text-center">
            Press <kbd class="px-1 py-0.5 bg-white bg-opacity-20 rounded text-xs">L</kbd> or click lock icon to exit positioning mode
        </div>
    </div>
    
    <!-- macOS Style Lock Popup -->
    <div id="lockPopup" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-80 text-white px-4 py-2 rounded-lg shadow-xl hidden transition-all duration-200 backdrop-blur-sm" style="z-index: 50;">
        <div class="flex items-center gap-2">
            <svg id="lockPopupIcon" class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"></path>
            </svg>
            <span id="lockPopupText">Locked</span>
        </div>
    </div>

    <!-- Canvas Controls (Bottom Panel) -->
    <div id="canvasControls" class="floating-panel fixed bottom-4 z-50 rounded-2xl px-3 py-2 transition-all duration-300" style="left: 50%; transform: translateX(-50%);">
        <div id="canvasControlsContent" class="flex items-center gap-2 text-sm">
            <select id="fitModeSelect" class="px-2 py-1 border border-gray-300 rounded-lg bg-white focus:outline-none hover:bg-gray-50">
                <option value="none">Manual</option>
                <option value="fit-width" selected>Fit Width</option>
                <option value="fit-height">Fit Height</option>
                <option value="fit-canvas">Fit Canvas</option>
                <option value="actual-size">Actual Size</option>
            </select>
            <button id="applyFitCurrent" class="px-2 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg hover:bg-slate-50" title="Apply to current image">Apply</button>
            <button id="scaleButton" class="px-2 py-1 bg-white border border-gray-300 rounded-lg text-sm font-medium hover:bg-gray-50">100% ▼</button>
            <div class="flex items-center gap-1 ml-2">
                <button id="rotateLeftCtrl" class="px-2 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg hover:bg-slate-50" title="Rotate 90° CCW">↶</button>
                <button id="rotateRightCtrl" class="px-2 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg hover:bg-slate-50" title="Rotate 90° CW">↷</button>
                <button id="flipHCtrl" class="px-2 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg hover:bg-slate-50" title="Flip Horizontal">↔</button>
                <button id="flipVCtrl" class="px-2 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg hover:bg-slate-50" title="Flip Vertical">↕</button>
            </div>
        </div>
    </div>
    
    <!-- Status message element for notifications -->
    <div id="statusMessage"></div>
    
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <!-- New UI Controller Script -->
    <script>
        // Initialize top toolbar by moving existing controls
        function initializeTopToolbar() {
            const left = document.getElementById('tbLeft');
            const center = document.getElementById('tbCenter');
            const right = document.getElementById('tbRight');
            const bottom = document.getElementById('canvasControlsContent') || center;

            // Helper functions
            const setUniform = el => {
                if (!el) return;
                el.classList.add(el.tagName === 'SELECT' ? 'tselect' : el.tagName === 'INPUT' ? 'tinput' : 'tbtn');
            };
            
            const reparent = (id, target, beforeSetup) => {
                const el = document.getElementById(id);
                if (!el) return null;
                beforeSetup?.(el);
                target.appendChild(el);
                setUniform(el);
                return el;
            };

            // LEFT: drawing tools
            reparent('paste', left);
            reparent('clear', left);
            reparent('drawingModeToggle', left);

            // Inline color swatches (8 colors in a row) using existing swatch buttons; add extras if needed
            const swatchRow = document.createElement('div');
            swatchRow.className = 'flex items-center gap-1';
            const toolsPanel = document.getElementById('toolsPanel');
            if (toolsPanel) {
                let swatches = toolsPanel.querySelectorAll('[data-color]');
                swatches.forEach((b, i) => {
                    if (i < 8) {
                        b.style.width='20px'; b.style.height='20px'; b.style.borderRadius='9999px'; b.style.border='2px solid #fff'; b.style.boxShadow='0 1px 2px rgba(0,0,0,.08)';
                        swatchRow.appendChild(b);
                    }
                });
                // If fewer than 8, add unique colors (ensure only one black)
                const ensureColors = ['#111827','#10b981','#06b6d4','#f43f5e','#22c55e','#f59e0b','#a855f7','#3b82f6'];
                const existing = Array.from(swatchRow.querySelectorAll('[data-color]')).map(x=>x.getAttribute('data-color'));
                ensureColors.forEach(c => {
                    if (swatchRow.querySelectorAll('[data-color]').length >= 8) return;
                    // Avoid adding duplicate blacks if already present
                    if (!existing.includes(c) && !(c==='#111827' && existing.includes('#111827'))) {
                        const btn = document.createElement('button');
                        btn.setAttribute('data-color', c);
                        btn.title = c;
                        btn.style.width='20px'; btn.style.height='20px'; btn.style.borderRadius='9999px'; btn.style.border='2px solid #fff'; btn.style.boxShadow='0 1px 2px rgba(0,0,0,.08)'; btn.style.backgroundColor=c;
                        swatchRow.appendChild(btn);
                    }
                });
                // Rebind color buttons (since we moved/added)
                setTimeout(() => {
                    const colorButtons = document.querySelectorAll('[data-color]');
                    colorButtons.forEach(button => {
                        if (!button.__boundColor) {
                            button.__boundColor = true;
                            button.addEventListener('click', () => {
                                document.querySelectorAll('[data-color].active').forEach(b=>b.classList.remove('active'));
                                button.classList.add('active');
                                const hex = button.getAttribute('data-color');
                                const cp = document.getElementById('colorPicker');
                                if (cp && hex) {
                                    cp.value = hex;
                                    cp.dispatchEvent(new Event('change'));
                                }
                                const bs = document.getElementById('brushSize');
                                if (bs && hex) bs.style.setProperty('--accent', hex);
                            });
                        }
                    });
                }, 0);
            }
            left.appendChild(swatchRow);
            const colorInput = document.getElementById('colorPicker');
            if (colorInput) colorInput.classList.add('hidden');

            // Inline thickness slider in toolbar (uses existing #brushSize)
            const brush = document.getElementById('brushSize');
            if (brush) {
                brush.style.width = '120px';
                brush.style.margin = '0';
                // Initialize slider fill and color to current selected color
                const cp = document.getElementById('colorPicker');
                if (cp) brush.style.setProperty('--accent', cp.value || '#3b82f6');
                const updateSliderVisual = () => {
                    const min = parseFloat(brush.min || '1');
                    const max = parseFloat(brush.max || '50');
                    const val = parseFloat(brush.value || '5');
                    const pct = Math.max(0, Math.min(100, ((val - min) / (max - min)) * 100));
                    brush.style.setProperty('--filled', pct + '%');
                };
                updateSliderVisual();
                brush.addEventListener('input', updateSliderVisual);
                brush.addEventListener('change', updateSliderVisual);
                left.appendChild(brush);
            }

            // Arrow and line style controls
            const arrowStartBtn = document.createElement('button');
            arrowStartBtn.id = 'arrowStartBtn';
            arrowStartBtn.className = 'tbtn icon-btn';
            arrowStartBtn.title = 'Start Arrow';
            arrowStartBtn.textContent = '◀';
            left.appendChild(arrowStartBtn);

            const arrowEndBtn = document.createElement('button');
            arrowEndBtn.id = 'arrowEndBtn';
            arrowEndBtn.className = 'tbtn icon-btn';
            arrowEndBtn.title = 'End Arrow';
            arrowEndBtn.textContent = '▶';
            left.appendChild(arrowEndBtn);

            const dottedBtn = document.createElement('button');
            dottedBtn.id = 'dottedBtn';
            dottedBtn.className = 'tbtn';
            dottedBtn.title = 'Line Style';
            const setLineStyleIcon = (style) => {
                const svgSolid = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
                const svgSmall = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="4 4"/></svg>';
                const svgMedium = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="7 5"/></svg>';
                const svgLarge = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="11 7"/></svg>';
                dottedBtn.innerHTML = style === 'small' ? svgSmall : style === 'medium' ? svgMedium : style === 'large' ? svgLarge : svgSolid;
            };
            setLineStyleIcon('solid');
            left.appendChild(dottedBtn);

            // Wire controls to UI state in paint.js
            const setActive = (el, on) => el.classList.toggle('active', !!on);
            const syncFromState = () => {
                try {
                    const as = window.paintApp?.uiState?.arrowSettings;
                    const ds = window.paintApp?.uiState?.dashSettings;
                    setActive(arrowStartBtn, as?.startArrow);
                    setActive(arrowEndBtn, as?.endArrow);
                    setLineStyleIcon(ds?.style || 'solid');
                } catch {}
            };
            syncFromState();
            
            arrowStartBtn.addEventListener('click', () => {
                try {
                    const as = window.paintApp.uiState.arrowSettings;
                    as.startArrow = !as.startArrow;
                    // Apply to stroke in edit mode if any
                    const edited = window.selectedStrokeInEditMode;
                    const img = window.currentImageLabel;
                    if (edited && img && window.vectorStrokesByImage?.[img]?.[edited]) {
                        const v = window.vectorStrokesByImage[img][edited];
                        v.arrowSettings = v.arrowSettings || { arrowSize: as.arrowSize, arrowStyle: as.arrowStyle, startArrow: false, endArrow: false };
                        v.arrowSettings.startArrow = as.startArrow;
                        // Ensure curved lines switch type appropriately
                        if (typeof window.updateStrokeTypeBasedOnArrows === 'function') {
                            window.updateStrokeTypeBasedOnArrows(v);
                        } else {
                            const hasArrows = !!(v.arrowSettings.startArrow || v.arrowSettings.endArrow);
                            if (v.type === 'curved' && hasArrows) v.type = 'curved-arrow';
                            if (v.type === 'curved-arrow' && !hasArrows) v.type = 'curved';
                        }
                        window.saveState?.(true, false, false);
                        window.redrawCanvasWithVisibility?.();
                    }
                    syncFromState();
                } catch {}
            });
            arrowEndBtn.addEventListener('click', () => {
                try {
                    const as = window.paintApp.uiState.arrowSettings;
                    as.endArrow = !as.endArrow;
                    // Apply to stroke in edit mode if any
                    const edited = window.selectedStrokeInEditMode;
                    const img = window.currentImageLabel;
                    if (edited && img && window.vectorStrokesByImage?.[img]?.[edited]) {
                        const v = window.vectorStrokesByImage[img][edited];
                        v.arrowSettings = v.arrowSettings || { arrowSize: as.arrowSize, arrowStyle: as.arrowStyle, startArrow: false, endArrow: false };
                        v.arrowSettings.endArrow = as.endArrow;
                        // Ensure curved lines switch type appropriately
                        if (typeof window.updateStrokeTypeBasedOnArrows === 'function') {
                            window.updateStrokeTypeBasedOnArrows(v);
                        } else {
                            const hasArrows = !!(v.arrowSettings.startArrow || v.arrowSettings.endArrow);
                            if (v.type === 'curved' && hasArrows) v.type = 'curved-arrow';
                            if (v.type === 'curved-arrow' && !hasArrows) v.type = 'curved';
                        }
                        window.saveState?.(true, false, false);
                        window.redrawCanvasWithVisibility?.();
                    }
                    syncFromState();
                } catch {}
            });
            dottedBtn.addEventListener('click', () => {
                try {
                    const ds = window.paintApp.uiState.dashSettings;
                    // Cycle: solid -> small -> medium -> large -> solid
                    const next = { 'solid': 'small', 'small': 'medium', 'medium': 'large', 'large': 'solid' };
                    ds.style = next[ds.style] || 'small';
                    ds.enabled = ds.style !== 'solid';
                    // Compute dash pattern immediately (mirror paint.js getDashPattern)
                    const computePattern = (style, dashLen, gapLen, lineWidth = 1) => {
                        const baseScale = Math.max(2, lineWidth * 0.8);
                        switch (style) {
                            case 'small': return [6 * baseScale, 4 * baseScale];
                            case 'medium': return [12 * baseScale, 8 * baseScale];
                            case 'large': return [20 * baseScale, 12 * baseScale];
                            case 'dot-dash': return [4 * baseScale, 6 * baseScale, 12 * baseScale, 6 * baseScale];
                            case 'custom': return [dashLen * baseScale, gapLen * baseScale];
                            default: return [];
                        }
                    };
                    const brush = document.getElementById('brushSize');
                    const size = parseInt(brush?.value || '5') || 5;
                    ds.pattern = computePattern(ds.style, ds.dashLength, ds.gapLength, size);
                    // If editing a stroke, also update it live
                    const edited = window.selectedStrokeInEditMode;
                    const img = window.currentImageLabel;
                    if (edited && img && window.vectorStrokesByImage?.[img]?.[edited]) {
                        const v = window.vectorStrokesByImage[img][edited];
                        const lw = parseInt(v.width || size) || size;
                        v.dashSettings = { ...ds, pattern: computePattern(ds.style, ds.dashLength, ds.gapLength, lw) };
                        window.saveState?.(true, false, false);
                        window.redrawCanvasWithVisibility?.();
                    }
                    setLineStyleIcon(ds.style);
                    syncFromState();
                } catch {}
            });

            // Undo / Redo buttons
            const mkIconBtn = (id, title, symbol, handler) => {
                const b = document.createElement('button'); 
                b.id = id; 
                b.className = 'tbtn icon-btn'; 
                b.title = title; 
                b.textContent = symbol;
                b.addEventListener('click', handler); 
                left.appendChild(b);
                return b;
            };
            mkIconBtn('undoBtn', 'Undo', '↺', () => { if (typeof window.undo === 'function') window.undo(); });
            mkIconBtn('redoBtn', 'Redo', '↻', () => { if (typeof window.redo === 'function') window.redo(); });

            // CENTER/BOTTOM: canvas view controls moved to bottom
            reparent('fitModeSelect', bottom);
            reparent('applyFitCurrent', bottom);
            reparent('rotateLeftCtrl', bottom, el => { 
                el.classList.add('icon-btn', 'tbtn'); 
                el.title = 'Rotate Left'; 
                el.textContent = '↶'; 
            });
            reparent('rotateRightCtrl', bottom, el => { 
                el.classList.add('icon-btn', 'tbtn'); 
                el.title = 'Rotate Right'; 
                el.textContent = '↷'; 
            });
            reparent('flipHCtrl', bottom, el => { 
                el.classList.add('icon-btn', 'tbtn'); 
                el.title = 'Flip Horizontal'; 
                el.textContent = '↔'; 
            });
            reparent('flipVCtrl', bottom, el => { 
                el.classList.add('icon-btn', 'tbtn'); 
                el.title = 'Flip Vertical'; 
                el.textContent = '↕'; 
            });
            reparent('scaleButton', bottom);

            // RIGHT: project settings
            reparent('projectName', right, el => {
                el.style.width = '140px';
            });
            // Move unit selector into More menu (not in top toolbar)
            reparent('saveProject', right);
            reparent('loadProject', right);

            // More menu for secondary project actions
            const moreWrap = document.createElement('div'); 
            moreWrap.style.position = 'relative';
            const moreBtn = document.createElement('button'); 
            moreBtn.id = 'projectMoreBtn'; 
            moreBtn.className = 'tbtn'; 
            moreBtn.textContent = 'More ▾';
            moreBtn.title = 'More Actions';
            
            const moreMenu = document.createElement('div'); 
            moreMenu.id = 'projectMoreMenu'; 
            moreMenu.className = 'popover'; 
            moreMenu.style.right = '0'; 
            moreMenu.style.left = 'auto';
            moreMenu.style.minWidth = '160px';
            
            // Replace unit selector with a simple toggle button in the top-right toolbar
            const unitSel = document.getElementById('unitSelector');
            if (unitSel) {
                const unitToggle = document.createElement('button');
                unitToggle.id = 'unitToggleBtn';
                unitToggle.className = 'tbtn';
                const getLabel = () => unitSel.value === 'inch' ? 'inches' : 'cm';
                unitToggle.textContent = getLabel();
                unitToggle.title = 'Toggle units';
                unitToggle.addEventListener('click', () => {
                    unitSel.value = unitSel.value === 'inch' ? 'cm' : 'inch';
                    unitToggle.textContent = getLabel();
                    if (typeof updateMeasurementDisplay === 'function') {
                        updateMeasurementDisplay();
                    } else if (unitSel.onchange) {
                        unitSel.onchange();
                    }
                });
                right.appendChild(unitToggle);
                // Hide the original select (kept for compatibility)
                unitSel.style.display = 'none';
            }

            ['generateMeasurements', 'saveAllImages', 'saveAsPdf'].forEach(id => {
                const el = document.getElementById(id);
                if (el) { 
                    setUniform(el); 
                    el.style.display = 'block'; 
                    el.style.width = '100%'; 
                    el.style.margin = '2px 0';
                    el.style.textAlign = 'left';
                    moreMenu.appendChild(el); 
                }
            });
            
            moreWrap.appendChild(moreBtn); 
            moreWrap.appendChild(moreMenu); 
            right.appendChild(moreWrap);
            
            moreBtn.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                moreMenu.classList.toggle('show');
            });

            // Global click handler to close all popovers
            document.addEventListener('click', () => {
                moreMenu.classList.remove('show');
            });

            // Prevent popover clicks from closing the popover
            [moreMenu].forEach(popover => {
                popover.addEventListener('click', (e) => e.stopPropagation());
            });

            // Hide legacy panels after moving controls (keep in DOM to preserve any lookups)
            document.getElementById('toolsPanel')?.classList.add('hidden');
            document.getElementById('projectPanel')?.classList.add('hidden');
            const cc = document.getElementById('canvasControls');
            if (cc) { cc.classList.remove('hidden'); cc.style.display='block'; }

            // Add body padding to prevent toolbar overlap
            document.body.style.paddingTop = '48px';
        }

        // New UI functionality for modular panels and capture frame
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize top toolbar by moving existing controls
            initializeTopToolbar();
            
            // (Sketchbook toggle removed per request)
            // Panel visibility toggles
            const strokePanel = document.getElementById('strokePanel');
            const imagePanel = document.getElementById('imagePanel');
            const captureOverlay = document.getElementById('captureOverlay');
            const captureFrame = document.getElementById('captureFrame');
            // Per-image capture frame storage and helpers
            window.captureFrameByLabel = window.captureFrameByLabel || {};
            function getCaptureFrameRectPixels() {
                const rect = captureFrame.getBoundingClientRect();
                return { left: rect.left, top: rect.top, width: rect.width, height: rect.height };
            }
            function saveCurrentCaptureFrameForLabel(label) {
                if (!label) return;
                window.captureFrameByLabel[label] = getCaptureFrameRectPixels();
            }
            function applyCaptureFrameForLabel(label) {
                const stored = window.captureFrameByLabel[label];
                const fallback = {
                    left: Math.max(0, Math.round((window.innerWidth - 800) / 2)),
                    top: Math.max(0, Math.round((window.innerHeight - 600) / 2)),
                    width: 800,
                    height: 600
                };
                const target = stored || fallback;
                captureFrame.style.left = `${Math.max(0, Math.round(target.left))}px`;
                captureFrame.style.top = `${Math.max(0, Math.round(target.top))}px`;
                captureFrame.style.width = `${Math.round(target.width)}px`;
                captureFrame.style.height = `${Math.round(target.height)}px`;
            }
            window.applyCaptureFrameForLabel = applyCaptureFrameForLabel;
            
            // Enhanced panel toggle functionality with minimize-to-header behavior
            function createPanelToggle(panelId, contentId, buttonId) {
                const panel = document.getElementById(panelId);
                const content = document.getElementById(contentId);
                const button = document.getElementById(buttonId);
                const icon = button?.querySelector('svg');
                
                if (!panel || !content || !button || !icon) return;
                
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isMinimized = content.classList.contains('hidden');
                    
                    if (isMinimized) {
                        // Expand panel
                        content.classList.remove('hidden');
                        icon.style.transform = 'rotate(0deg)';
                        panel.classList.remove('minimized');
                    } else {
                        // Minimize panel
                        content.classList.add('hidden');
                        icon.style.transform = 'rotate(-90deg)';
                        panel.classList.add('minimized');
                    }
                });
            }
            
            // Apply toggle functionality to all panels (default open for Stroke & Images)
            createPanelToggle('projectPanel', 'projectPanelContent', 'toggleProjectPanel');
            createPanelToggle('toolsPanel', 'toolsPanelContent', 'toggleToolsPanel');
            createPanelToggle('strokePanel', 'strokeVisibilityControls', 'toggleStrokePanel');
            createPanelToggle('imagePanel', 'imagePanelContent', 'toggleImagePanel');
            createPanelToggle('canvasControls', 'canvasControlsContent', 'toggleCanvasControls');

            // Ensure Stroke Visibility and Images are open by default
            (function expandByDefault() {
                const strokeContent = document.getElementById('strokeVisibilityControls');
                const strokeButton = document.getElementById('toggleStrokePanel');
                const imageContent = document.getElementById('imagePanelContent');
                const imageButton = document.getElementById('toggleImagePanel');
                if (strokeContent && strokeButton && strokeContent.classList.contains('hidden')) {
                    strokeButton.click();
                }
                if (imageContent && imageButton && imageContent.classList.contains('hidden')) {
                    imageButton.click();
                }
            })();
            
            // Capture frame lock functionality
            let isCaptureLocked = true; // Start locked for minimal appearance
            
            // Initialize capture frame on load
            updateCaptureFrameLockState();
            
            // Lock/unlock button functionality
            const lockButton = document.getElementById('captureLockButton');
            lockButton?.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleCaptureLock();
            });
            
            // Keyboard shortcut for lock/unlock (L key) - ignore when typing in inputs/textareas/selects or contenteditable
            document.addEventListener('keydown', (e) => {
                const target = e.target;
                const isTyping = target && (
                    target.tagName === 'INPUT' ||
                    target.tagName === 'TEXTAREA' ||
                    target.tagName === 'SELECT' ||
                    target.isContentEditable
                );
                if (isTyping) return;
                if (e.key && e.key.toLowerCase() === 'l') {
                    e.preventDefault();
                    toggleCaptureLock();
                }
            });
            
            function toggleCaptureLock() {
                isCaptureLocked = !isCaptureLocked;
                updateCaptureFrameLockState();
                showLockPopup();
            }
            
            function showLockPopup() {
                const popup = document.getElementById('lockPopup');
                const icon = document.getElementById('lockPopupIcon');
                const text = document.getElementById('lockPopupText');
                
                if (isCaptureLocked) {
                    text.textContent = 'Locked';
                    icon.innerHTML = '<path d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"></path>';
                } else {
                    text.textContent = 'Unlocked';
                    icon.innerHTML = '<path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z"></path>';
                }
                
                popup.classList.add('show');
                setTimeout(() => {
                    popup.classList.remove('show');
                }, 1500);
            }
            
            function updateCaptureFrameLockState() {
                const lockButton = document.getElementById('captureLockButton');
                const instructions = document.getElementById('unlockInstructions');
                const applyAllButton = document.getElementById('applyFitAll');
                
                if (isCaptureLocked) {
                    captureFrame.classList.add('locked');
                    captureFrame.classList.remove('unlocked');
                    lockButton.classList.add('locked');
                    lockButton.title = 'Unlock frame (L)';
                    instructions.classList.add('hidden');
                    
                    // Hide Apply All button for safety
                    if (applyAllButton) {
                        applyAllButton.style.display = 'none';
                    }
                    
                    // Use white overlay outside the frame for clarity
                    captureFrame.style.boxShadow = '0 0 0 2000px rgba(255,255,255,1)';
                    
                    // Enable pointer events for lock button only
                    captureFrame.style.pointerEvents = 'none';
                    lockButton.style.pointerEvents = 'auto';
                } else {
                    captureFrame.classList.remove('locked');
                    captureFrame.classList.add('unlocked');
                    lockButton.classList.remove('locked');
                    lockButton.title = 'Lock frame (L)';
                    instructions.classList.remove('hidden');
                    
                    // Show Apply All button when unlocked
                    if (applyAllButton) {
                        applyAllButton.style.display = 'inline-block';
                    }
                    
                    // Remove overlay when unlocked for transparent background while adjusting
                    captureFrame.style.boxShadow = 'none';
                    
                    // Enable pointer events for dragging and resizing
                    captureFrame.style.pointerEvents = 'auto';
                    lockButton.style.pointerEvents = 'auto';
                }
            }
            
            
            // Color picker functionality
            const colorButtons = document.querySelectorAll('[data-color]');
            colorButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all buttons
                    colorButtons.forEach(btn => btn.classList.remove('active'));
                    // Add active class to clicked button
                    button.classList.add('active');
                    // Update color picker value
                    const colorPicker = document.getElementById('colorPicker');
                    if (colorPicker) {
                        colorPicker.value = button.getAttribute('data-color');
                        // Trigger change event for existing functionality
                        colorPicker.dispatchEvent(new Event('change'));
                    }
                });
            });
            
            // Update active color button styling
            const style = document.createElement('style');
            style.textContent = `
                [data-color].active {
                    border-color: #374151 !important;
                    box-shadow: 0 0 0 2px white, 0 0 0 4px #374151 !important;
                    transform: scale(1.1);
                }
            `;
            document.head.appendChild(style);
            
            // Capture frame resize functionality
            let isResizing = false;
            let currentHandle = null;
            let startPos = { x: 0, y: 0 };
            let startRect = { x: 0, y: 0, width: 0, height: 0 };
            
            const resizeHandles = document.querySelectorAll('.resize-handle');
            resizeHandles.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    // Don't allow resizing when locked
                    if (isCaptureLocked) return;
                    
                    e.preventDefault();
                    isResizing = true;
                    currentHandle = handle.getAttribute('data-direction');
                    startPos = { x: e.clientX, y: e.clientY };
                    
                    const rect = captureFrame.getBoundingClientRect();
                    startRect = {
                        x: rect.left,
                        y: rect.top,
                        width: rect.width,
                        height: rect.height
                    };
                    
                    document.addEventListener('mousemove', handleResize);
                    document.addEventListener('mouseup', stopResize);
                });
            });
            
            function handleResize(e) {
                if (!isResizing || !currentHandle) return;
                
                const deltaX = e.clientX - startPos.x;
                const deltaY = e.clientY - startPos.y;
                
                let newX = startRect.x;
                let newY = startRect.y;
                let newWidth = startRect.width;
                let newHeight = startRect.height;
                
                // Handle different resize directions
                switch (currentHandle) {
                    case 'nw':
                        newX = startRect.x + deltaX;
                        newY = startRect.y + deltaY;
                        newWidth = startRect.width - deltaX;
                        newHeight = startRect.height - deltaY;
                        break;
                    case 'n':
                        newY = startRect.y + deltaY;
                        newHeight = startRect.height - deltaY;
                        break;
                    case 'ne':
                        newY = startRect.y + deltaY;
                        newWidth = startRect.width + deltaX;
                        newHeight = startRect.height - deltaY;
                        break;
                    case 'e':
                        newWidth = startRect.width + deltaX;
                        break;
                    case 'se':
                        newWidth = startRect.width + deltaX;
                        newHeight = startRect.height + deltaY;
                        break;
                    case 's':
                        newHeight = startRect.height + deltaY;
                        break;
                    case 'sw':
                        newX = startRect.x + deltaX;
                        newWidth = startRect.width - deltaX;
                        newHeight = startRect.height + deltaY;
                        break;
                    case 'w':
                        newX = startRect.x + deltaX;
                        newWidth = startRect.width - deltaX;
                        break;
                }
                
                // Apply minimum size constraints
                const minSize = 100;
                if (newWidth < minSize) {
                    if (currentHandle.includes('w')) newX = startRect.x + startRect.width - minSize;
                    newWidth = minSize;
                }
                if (newHeight < minSize) {
                    if (currentHandle.includes('n')) newY = startRect.y + startRect.height - minSize;
                    newHeight = minSize;
                }
                
                // Apply maximum size constraints (viewport bounds)
                const maxX = window.innerWidth - newWidth;
                const maxY = window.innerHeight - newHeight;
                newX = Math.max(0, Math.min(maxX, newX));
                newY = Math.max(0, Math.min(maxY, newY));
                
                // Update capture frame position and size
                captureFrame.style.left = newX + 'px';
                captureFrame.style.top = newY + 'px';
                captureFrame.style.width = newWidth + 'px';
                captureFrame.style.height = newHeight + 'px';
                
            }
            
            function stopResize() {
                isResizing = false;
                currentHandle = null;
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
                // Save per-image frame when resizing ends
                if (typeof window.currentImageLabel !== 'undefined') {
                    saveCurrentCaptureFrameForLabel(window.currentImageLabel);
                }
            }
            
            // Optimized capture frame dragging - 1:1 movement with no lag
            let isCaptureDragging = false;
            let captureDragOffset = { x: 0, y: 0 };
            let lastCaptureMousePos = { x: 0, y: 0 };
            let captureRafId = null;
            
            captureFrame.addEventListener('mousedown', (e) => {
                // Don't drag if locked, clicking on handles, or buttons
                if (isCaptureLocked || e.target.classList.contains('resize-handle') || e.target.closest('button')) {
                    return;
                }
                
                // Allow Shift+click to pass through for canvas dragging
                if (e.shiftKey) {
                    return;
                }
                
                e.preventDefault();
                e.stopPropagation();
                
                isCaptureDragging = true;
                
                const rect = captureFrame.getBoundingClientRect();
                captureDragOffset.x = e.clientX - rect.left;
                captureDragOffset.y = e.clientY - rect.top;
                
                // Add dragging class for no transitions
                captureFrame.classList.add('dragging');
                
                document.addEventListener('mousemove', handleCaptureDrag, { passive: true });
                document.addEventListener('mouseup', stopCaptureDrag);
            });
            
            function handleCaptureDrag(e) {
                if (!isCaptureDragging || isCaptureLocked) return;
                
                // Store mouse position for RAF
                lastCaptureMousePos.x = e.clientX;
                lastCaptureMousePos.y = e.clientY;
                
                // Cancel previous RAF if still pending
                if (captureRafId) {
                    cancelAnimationFrame(captureRafId);
                }
                
                // Schedule position update for next frame
                captureRafId = requestAnimationFrame(updateCapturePosition);
            }
            
            function updateCapturePosition() {
                if (!isCaptureDragging) return;
                
                const newX = Math.max(0, Math.min(window.innerWidth - captureFrame.offsetWidth, lastCaptureMousePos.x - captureDragOffset.x));
                const newY = Math.max(0, Math.min(window.innerHeight - captureFrame.offsetHeight, lastCaptureMousePos.y - captureDragOffset.y));
                
                // Apply position immediately
                captureFrame.style.left = newX + 'px';
                captureFrame.style.top = newY + 'px';
                
                
                captureRafId = null;
            }
            
            function stopCaptureDrag() {
                if (!isCaptureDragging) return;
                
                isCaptureDragging = false;
                
                // Cancel any pending RAF
                if (captureRafId) {
                    cancelAnimationFrame(captureRafId);
                    captureRafId = null;
                }
                
                // Remove dragging class
                captureFrame.classList.remove('dragging');
                
                document.removeEventListener('mousemove', handleCaptureDrag);
                document.removeEventListener('mouseup', stopCaptureDrag);
                // Save per-image frame when dragging ends
                if (typeof window.currentImageLabel !== 'undefined') {
                    saveCurrentCaptureFrameForLabel(window.currentImageLabel);
                }
            }
            
            // Optimized draggable functionality - 1:1 mouse movement with requestAnimationFrame
            function makeDraggable(element, handle) {
                let isDragging = false;
                let dragOffset = { x: 0, y: 0 };
                let lastMousePos = { x: 0, y: 0 };
                let rafId = null;
                let elementWidth, elementHeight; // Cache dimensions
                
                handle.addEventListener('mousedown', (e) => {
                    // Don't start drag if clicking on buttons or inputs
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.closest('button')) {
                        return;
                    }
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isDragging = true;
                    
                    // Simplified position setup - get current position directly
                    const rect = element.getBoundingClientRect();
                    
                    // Calculate offset from mouse to element's current position
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    // Cache element dimensions to avoid repeated DOM queries
                    elementWidth = element.offsetWidth;
                    elementHeight = element.offsetHeight;
                    
                    // Set initial position and prepare for dragging
                    element.style.position = 'fixed';
                    element.style.left = rect.left + 'px';
                    element.style.top = rect.top + 'px';
                    element.style.transform = 'none';
                    
                    // Clear conflicting positioning styles when dragging starts
                    element.style.bottom = 'auto';
                    element.style.right = 'auto';
                    
                    // Add visual feedback immediately
                    element.classList.add('dragging');
                    document.body.style.userSelect = 'none';
                    
                    document.addEventListener('mousemove', onMouseMove, { passive: true });
                    document.addEventListener('mouseup', stopDrag);
                });
                
                function onMouseMove(e) {
                    if (!isDragging) return;
                    
                    // Store mouse position for RAF
                    lastMousePos.x = e.clientX;
                    lastMousePos.y = e.clientY;
                    
                    // Cancel previous RAF if still pending
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                    }
                    
                    // Schedule position update for next frame
                    rafId = requestAnimationFrame(updatePosition);
                }
                
                function updatePosition() {
                    if (!isDragging) return;
                    
                    // Calculate new position from mouse minus offset
                    const newX = Math.max(0, Math.min(window.innerWidth - elementWidth, lastMousePos.x - dragOffset.x));
                    const newY = Math.max(0, Math.min(window.innerHeight - elementHeight, lastMousePos.y - dragOffset.y));
                    
                    // Apply position immediately using left/top for immediate visual feedback
                    element.style.left = newX + 'px';
                    element.style.top = newY + 'px';
                    
                    rafId = null;
                }
                
                function stopDrag(e) {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    
                    // Cancel any pending RAF
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                        rafId = null;
                    }
                    
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', stopDrag);
                    
                    // Reset visual feedback
                    element.classList.remove('dragging');
                    document.body.style.userSelect = '';
                }
            }
            
            // Make all floating panels draggable by their headers
            const floatingPanels = document.querySelectorAll('.floating-panel');
            floatingPanels.forEach(panel => {
                const header = panel.querySelector('.cursor-move');
                if (header) {
                    header.style.cursor = 'move';
                    makeDraggable(panel, header);
                }
            });
            
            // Scale dropdown functionality
            const scaleButton = document.getElementById('scaleButton');
            const scaleDropdown = document.getElementById('scaleDropdown');
            
            if (scaleButton && scaleDropdown) {
                scaleButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // Position the dropdown relative to the button with boundary checks
                    const buttonRect = scaleButton.getBoundingClientRect();
                    const dropdownWidth = 80; // min-width from CSS
                    const dropdownHeight = 320; // approximate height for all options
                    
                    let left = buttonRect.left;
                    let top = buttonRect.bottom + 2;
                    
                    // Check right boundary
                    if (left + dropdownWidth > window.innerWidth) {
                        left = buttonRect.right - dropdownWidth;
                    }
                    
                    // Check left boundary
                    if (left < 0) {
                        left = 0;
                    }
                    
                    // Check bottom boundary - show above button if no room below
                    if (top + dropdownHeight > window.innerHeight) {
                        top = buttonRect.top - dropdownHeight - 2;
                    }
                    
                    // Check top boundary
                    if (top < 0) {
                        top = buttonRect.bottom + 2; // fallback to below button
                    }
                    
                    scaleDropdown.style.left = left + 'px';
                    scaleDropdown.style.top = top + 'px';
                    
                    scaleDropdown.classList.toggle('hidden');
                });
                
                document.addEventListener('click', () => {
                    scaleDropdown.classList.add('hidden');
                });
                
                scaleDropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                // Handle scale option selection
                const scaleOptions = scaleDropdown.querySelectorAll('.scale-option');
                scaleOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        const scale = option.dataset.scale;
                        const percentage = Math.round(parseFloat(scale) * 100);
                        scaleButton.textContent = percentage + '% ▼';
                        scaleDropdown.classList.add('hidden');
                    });
                });
            }
            
            // Custom dash controls functionality
            const dashStyleSelect = document.getElementById('dashStyleSelect');
            const customDashControls = document.getElementById('customDashControls');
            
            if (dashStyleSelect && customDashControls) {
                dashStyleSelect.addEventListener('change', () => {
                    if (dashStyleSelect.value === 'custom') {
                        customDashControls.classList.remove('hidden');
                        customDashControls.classList.add('flex');
                    } else {
                        customDashControls.classList.add('hidden');
                        customDashControls.classList.remove('flex');
                    }
                });
            }
            
            // Enhanced Image Gallery with Horizontal Scroll Navigation
            let currentImageIndex = 0;
            let imageGalleryData = [];
            let intersectionObserver = null;
            
            // Initialize image gallery functionality
            function initializeImageGallery() {
                const imageGallery = document.getElementById('imageGallery');
                const imageDots = document.getElementById('imageDots');
                const prevButton = document.getElementById('prevImage');
                const nextButton = document.getElementById('nextImage');
                const imagePosition = document.getElementById('imagePosition');
                const imageCounter = document.getElementById('imageCounter');
                
                if (!imageGallery) return;
                
                // Navigation button functionality
                prevButton?.addEventListener('click', () => navigateToImage(currentImageIndex - 1));
                nextButton?.addEventListener('click', () => navigateToImage(currentImageIndex + 1));
                
                // Intersection Observer for active image detection
                intersectionObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const imageIndex = parseInt(entry.target.dataset.imageIndex);
                            if (!isNaN(imageIndex)) {
                                updateActiveImage(imageIndex);
                            }
                        }
                    });
                }, {
                    root: imageGallery,
                    threshold: 0.6,
                    rootMargin: '0px'
                });
                
                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    // Only handle keyboard navigation if image panel is visible and focused
                    if (!document.getElementById('imagePanel').classList.contains('hidden')) {
                        if (e.key === 'ArrowLeft') {
                            e.preventDefault();
                            navigateToImage(currentImageIndex - 1);
                        } else if (e.key === 'ArrowRight') {
                            e.preventDefault();
                            navigateToImage(currentImageIndex + 1);
                        }
                    }
                });

                // Canvas Controls: wire rotate/flip buttons to current image
                const rotateLeftCtrl = document.getElementById('rotateLeftCtrl');
                const rotateRightCtrl = document.getElementById('rotateRightCtrl');
                const flipHCtrl = document.getElementById('flipHCtrl');
                const flipVCtrl = document.getElementById('flipVCtrl');
                function getCurrentImageIndex() {
                    const label = window.paintApp?.state?.currentImageLabel;
                    if (!label) return currentImageIndex || 0;
                    const idx = imageGalleryData.findIndex(i => (i.label || i.original?.label) === label);
                    return idx >= 0 ? idx : (currentImageIndex || 0);
                }
                function rotateFallback(deg) {
                    const label = window.paintApp?.state?.currentImageLabel || 'blank_canvas';
                    const c = document.getElementById('canvas');
                    const w = c?.width || 800;
                    const h = c?.height || 600;
                    if (typeof window.transformImageData === 'function') {
                        window.transformImageData(label, 'rotate', deg, w, h);
                        if (window.redrawCanvasWithVisibility) window.redrawCanvasWithVisibility();
                    }
                }
                rotateLeftCtrl?.addEventListener('click', () => {
                    const idx = getCurrentImageIndex();
                    if (imageGalleryData[idx]) {
                        window.rotateImage?.(idx, -90);
                    } else {
                        rotateFallback(-90);
                    }
                });
                rotateRightCtrl?.addEventListener('click', () => {
                    const idx = getCurrentImageIndex();
                    if (imageGalleryData[idx]) {
                        window.rotateImage?.(idx, 90);
                    } else {
                        rotateFallback(90);
                    }
                });
                flipHCtrl?.addEventListener('click', () => {
                    const idx = getCurrentImageIndex();
                    if (imageGalleryData[idx] && typeof flipImage === 'function') {
                        flipImage(idx, 'horizontal');
                    } else if (typeof window.transformImageData === 'function') {
                        const label = window.paintApp?.state?.currentImageLabel || 'blank_canvas';
                        const c = document.getElementById('canvas');
                        const w = c?.width || 800;
                        const h = c?.height || 600;
                        window.transformImageData(label, 'flip', 'horizontal', w, h);
                        if (window.redrawCanvasWithVisibility) window.redrawCanvasWithVisibility();
                    }
                });
                flipVCtrl?.addEventListener('click', () => {
                    const idx = getCurrentImageIndex();
                    if (imageGalleryData[idx] && typeof flipImage === 'function') {
                        flipImage(idx, 'vertical');
                    } else if (typeof window.transformImageData === 'function') {
                        const label = window.paintApp?.state?.currentImageLabel || 'blank_canvas';
                        const c = document.getElementById('canvas');
                        const w = c?.width || 800;
                        const h = c?.height || 600;
                        window.transformImageData(label, 'flip', 'vertical', w, h);
                        if (window.redrawCanvasWithVisibility) window.redrawCanvasWithVisibility();
                    }
                });

                // Name/type inputs wiring
                const nameInput = document.getElementById('imageNameInput');
                const typeSelect = document.getElementById('imageTypeSelect');
                nameInput?.addEventListener('change', (e) => {
                    const val = e.target.value || '';
                    const idx = currentImageIndex;
                    if (imageGalleryData[idx]) {
                        imageGalleryData[idx].name = val;
                        // Update caption under the thumbnail (if present)
                        const gallery = document.getElementById('imageGallery');
                        const card = gallery?.children[idx];
                        const caption = card?.querySelector('.thumb-caption');
                        if (caption) caption.textContent = val;
                    }
                });
                typeSelect?.addEventListener('change', (e) => {
                    const val = e.target.value || '';
                    const idx = currentImageIndex;
                    if (imageGalleryData[idx]) {
                        imageGalleryData[idx].original = imageGalleryData[idx].original || {};
                        imageGalleryData[idx].original.type = val;
                    }
                });
            }
            
            // Add image to gallery
            function addImageToGallery(imageData, index) {
                console.log(`[Gallery] Adding image to gallery at index ${index}:`, imageData);
                
                const imageGallery = document.getElementById('imageGallery');
                const imageDots = document.getElementById('imageDots');
                
                if (!imageGallery || !imageDots) {
                    console.error('[Gallery] imageGallery or imageDots element not found');
                    return;
                }
                
                // Handle different image data formats from external scripts
                let imageSrc, imageName;
                if (typeof imageData === 'string') {
                    // Simple string URL
                    imageSrc = imageData;
                    imageName = `Image ${index + 1}`;
                } else if (imageData && typeof imageData === 'object') {
                    // Object with src/url and name properties
                    imageSrc = imageData.src || imageData.url || imageData.dataUrl || imageData.blob;
                    imageName = imageData.name || imageData.filename || imageData.title || `Image ${index + 1}`;
                } else {
                    console.warn('[Gallery] Invalid image data format:', imageData);
                    return;
                }
                
                // Create image thumbnail
                const thumbnail = document.createElement('div');
                thumbnail.className = 'image-thumbnail';
                thumbnail.dataset.imageIndex = index;
                thumbnail.style.backgroundImage = `url(${imageSrc})`;
                thumbnail.title = imageName;
                thumbnail.draggable = true;
                
                // Remove overlay label; use minimal caption below instead
                
                // Add hover controls (delete only)
                const controls = createThumbnailControls(index);
                // Strip rotate/flip from controls
                controls.querySelectorAll('.rotate-btn, .flip-btn').forEach(el => el.remove());
                thumbnail.appendChild(controls);
                
                // Add all event listeners using helper function
                addThumbnailEventListeners(thumbnail, index);
                
                // Wrap thumbnail in a small card with optional caption
                const card = document.createElement('div');
                card.className = 'flex flex-col items-center gap-1';
                card.appendChild(thumbnail);
                // Compute caption; hide for blank canvas
                let displayName = '';
                try {
                    if (!(originalData && originalData.isBlankCanvas)) {
                        const lbl = originalData?.label;
                        if (lbl && typeof window.getTagBasedFilename === 'function') {
                            const base = lbl.split('_')[0];
                            displayName = window.getTagBasedFilename(lbl, base) || imageName || '';
                        } else {
                            displayName = imageName || '';
                        }
                    }
                } catch (e) { displayName = imageName || ''; }
                const caption = document.createElement('div');
                caption.className = 'thumb-caption text-[11px] text-slate-500 font-medium truncate max-w-[120px]';
                caption.textContent = displayName || '';
                card.appendChild(caption);
                if (displayName) thumbnail.title = displayName; else thumbnail.removeAttribute('title');
                imageGallery.appendChild(card);
                console.log(`[Gallery] Created thumbnail element:`, thumbnail);
                console.log(`[Gallery] Gallery element children count:`, imageGallery.children.length);
                
                // Create navigation dot
                const dot = document.createElement('div');
                dot.className = 'nav-dot';
                dot.dataset.imageIndex = index;
                dot.addEventListener('click', () => navigateToImage(index));
                imageDots.appendChild(dot);
                
                // Observe thumbnail for intersection
                if (intersectionObserver) {
                    intersectionObserver.observe(thumbnail);
                }
                
                // Store normalized image data
                // Handle cases where imageData already has an 'original' property to avoid nesting
                let originalData = imageData;
                if (imageData && imageData.original && typeof imageData.original === 'object') {
                    // If imageData already has an original property, use that instead
                    originalData = imageData.original;
                    console.log('[Gallery] Using nested original data to avoid double nesting');
                }
                
                const normalizedData = {
                    src: imageSrc,
                    name: imageName,
                    original: originalData
                };
                
                // Update gallery data
                imageGalleryData[index] = normalizedData;
                updateGalleryControls();
                
                console.log('[Gallery] Added image:', normalizedData);
                
                // Ensure the image panel is visible when adding any image
                const imagePanel = document.getElementById('imagePanel');
                if (imagePanel) {
                    imagePanel.classList.remove('hidden');
                    imagePanel.style.display = 'block';
                }
            }
            
            // Navigate to specific image
            function navigateToImage(index) {
                const imageGallery = document.getElementById('imageGallery');
                if (!imageGallery || index < 0 || index >= imageGalleryData.length) return;
                
                const targetThumbnail = imageGallery.querySelector(`[data-image-index="${index}"]`);
                if (targetThumbnail) {
                    targetThumbnail.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest',
                        inline: 'center'
                    });
                }
                
                // Get the image data and find corresponding legacy image
                const imageData = imageGalleryData[index];
                if (imageData && imageData.original && imageData.original.label) {
                    const label = imageData.original.label;
                    console.log(`[Gallery] Switching to image with label: ${label}`);
                    
                    // Try to switch to the image using the legacy system
                    if (window.switchToImage && typeof window.switchToImage === 'function') {
                        window.switchToImage(label);
                        console.log(`[Gallery] Called switchToImage(${label})`);
                    } else {
                        console.warn('[Gallery] switchToImage function not available');
                    }
                }
                
                updateActiveImage(index);

                // Update image name/type inputs to match current image
                const nameInput = document.getElementById('imageNameInput');
                const typeSelect = document.getElementById('imageTypeSelect');
                const data = imageGalleryData[index];
                if (nameInput && data) nameInput.value = data.name || '';
                if (typeSelect && data && data.original && data.original.type) typeSelect.value = data.original.type; else if (typeSelect) typeSelect.value = '';
            }
            
            // Reorder images in the gallery
            function reorderImages(fromIndex, toIndex) {
                console.log(`[Gallery] Reordering image from ${fromIndex} to ${toIndex}`);
                
                // Reorder the data array
                const movedImage = imageGalleryData.splice(fromIndex, 1)[0];
                imageGalleryData.splice(toIndex, 0, movedImage);
                
                // Rebuild the gallery UI
                rebuildGalleryUI();
                
                // Update active image index if needed
                if (currentImageIndex === fromIndex) {
                    currentImageIndex = toIndex;
                } else if (currentImageIndex > fromIndex && currentImageIndex <= toIndex) {
                    currentImageIndex--;
                } else if (currentImageIndex < fromIndex && currentImageIndex >= toIndex) {
                    currentImageIndex++;
                }
                
                updateActiveImage(currentImageIndex);
            }
            
            // Rebuild the entire gallery UI after reordering
            function rebuildGalleryUI() {
                const imageGallery = document.getElementById('imageGallery');
                const imageDots = document.getElementById('imageDots');
                
                if (!imageGallery || !imageDots) return;
                
                // Clear existing thumbnails and dots
                imageGallery.innerHTML = '';
                imageDots.innerHTML = '';
                
                // Rebuild with new order
                imageGalleryData.forEach((imageData, index) => {
                    // Create thumbnail
                    const thumbnail = document.createElement('div');
                    thumbnail.className = 'image-thumbnail';
                    thumbnail.dataset.imageIndex = index;
                    thumbnail.style.backgroundImage = `url(${imageData.src})`;
                    thumbnail.title = imageData.name;
                    thumbnail.draggable = true;
                    
                    // Add hover controls (delete only)
                    const controls = createThumbnailControls(index);
                    // Strip rotate/flip from controls
                    controls.querySelectorAll('.rotate-btn, .flip-btn').forEach(el => el.remove());
                    thumbnail.appendChild(controls);
                    
                    // Add all event listeners (click, drag, etc.)
                    addThumbnailEventListeners(thumbnail, index);
                    
                    imageGallery.appendChild(thumbnail);
                    
                    // Create dot
                    const dot = document.createElement('div');
                    dot.className = 'nav-dot';
                    dot.dataset.imageIndex = index;
                    dot.addEventListener('click', () => navigateToImage(index));
                    imageDots.appendChild(dot);
                    
                    // Observe for intersection
                    if (intersectionObserver) {
                        intersectionObserver.observe(thumbnail);
                    }
                });
                
                updateGalleryControls();
            }
            
            // Create thumbnail control buttons (delete only)
            function createThumbnailControls(index) {
                const controlsContainer = document.createElement('div');
                
                // Delete control (separate, top-left)
                const deleteControl = document.createElement('div');
                deleteControl.className = 'delete-control';
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'control-btn delete-btn';
                deleteBtn.innerHTML = '×';
                deleteBtn.title = 'Delete image';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteImage(index);
                });
                
                deleteControl.appendChild(deleteBtn);
                controlsContainer.appendChild(deleteControl);
                
                return controlsContainer;
            }
            
            // Helper function to add all event listeners to a thumbnail
            function addThumbnailEventListeners(thumbnail, index) {
                // Click handler
                thumbnail.addEventListener('click', () => {
                    navigateToImage(index);
                });
                
                // Drag and drop handlers
                thumbnail.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', index);
                    thumbnail.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                thumbnail.addEventListener('dragend', () => {
                    thumbnail.classList.remove('dragging');
                });
                
                thumbnail.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    thumbnail.classList.add('drag-over');
                });
                
                thumbnail.addEventListener('dragleave', () => {
                    thumbnail.classList.remove('drag-over');
                });
                
                thumbnail.addEventListener('drop', (e) => {
                    e.preventDefault();
                    thumbnail.classList.remove('drag-over');
                    
                    const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const targetIndex = index;
                    
                    if (draggedIndex !== targetIndex) {
                        reorderImages(draggedIndex, targetIndex);
                    }
                });
            }
            
            // Delete image function
            function deleteImage(index) {
                if (confirm(`Delete "${imageGalleryData[index]?.name}"?`)) {
                    console.log(`[Gallery] Deleting image at index ${index}`);
                    
                    // Remove from data array
                    imageGalleryData.splice(index, 1);
                    
                    // Rebuild UI
                    rebuildGalleryUI();
                    
                    // Adjust current index if needed
                    if (currentImageIndex >= index) {
                        currentImageIndex = Math.max(0, currentImageIndex - 1);
                    }
                    
                    // Update active image
                    if (imageGalleryData.length > 0) {
                        updateActiveImage(Math.min(currentImageIndex, imageGalleryData.length - 1));
                    }
                }
            }
            
            // Rotate image function
            window.rotateImage = function rotateImage(index, degrees) {
                console.log(`[Gallery] Rotating image ${index} by ${degrees}°`);
                
                const imageData = imageGalleryData[index];
                if (!imageData) return;
                
                // Apply rotation using Canvas
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas dimensions based on rotation
                    if (Math.abs(degrees) === 90 || Math.abs(degrees) === 270) {
                        canvas.width = img.height;
                        canvas.height = img.width;
                    } else {
                        canvas.width = img.width;
                        canvas.height = img.height;
                    }
                    
                    // Rotate and draw
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate((degrees * Math.PI) / 180);
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    
                    // Update image data
                    const newSrc = canvas.toDataURL();
                    imageData.src = newSrc;
                    
                    // Update thumbnail background
                    const thumbnail = document.querySelector(`[data-image-index="${index}"]`);
                    if (thumbnail) {
                        thumbnail.style.backgroundImage = `url(${newSrc})`;
                    }
                    
                    // Update the actual canvas image if this is the current image
                    if (imageData.original && imageData.original.label) {
                        const label = imageData.original.label;
                        
                        // Get canvas dimensions instead of raw image dimensions
                        // This is critical - paint.js coordinates are relative to canvas, not original image!
                        const canvas = document.getElementById('canvas');
                        if (!canvas) {
                            console.error('[Transform] Canvas element not found!');
                            return;
                        }
                        
                        // Use actual canvas coordinate space dimensions
                        let canvasWidth = canvas.width;
                        let canvasHeight = canvas.height;
                        
                        console.log(`[Transform] Using canvas dimensions: ${canvasWidth}x${canvasHeight} instead of image: ${img.naturalWidth}x${img.naturalHeight}`);
                        
                        // Clear stored centroid if canvas dimensions changed (for screen size changes)
                        if (window.originalDrawingCentroids && window.originalDrawingCentroids[label]) {
                            if (!window.lastCanvasDimensions) window.lastCanvasDimensions = {};
                            const lastDims = window.lastCanvasDimensions[label];
                            if (lastDims && (lastDims.width !== canvasWidth || lastDims.height !== canvasHeight)) {
                                delete window.originalDrawingCentroids[label];
                                console.log(`[Transform] Cleared stored centroid for ${label} - canvas size changed from ${lastDims.width}x${lastDims.height} to ${canvasWidth}x${canvasHeight}`);
                            }
                            window.lastCanvasDimensions[label] = { width: canvasWidth, height: canvasHeight };
                        }
                        
                        // For rotations, we might need to swap canvas dimensions too
                        let transformWidth = canvasWidth;
                        let transformHeight = canvasHeight;
                        
                        if (Math.abs(degrees) === 90 || Math.abs(degrees) === 270) {
                            // For blank canvas, keep original dimensions to rotate "in place"
                            // For real images, swap dimensions to match the rotated coordinate space
                            if (imageData.original && imageData.original.isBlankCanvas) {
                                console.log(`[Transform] Keeping canvas dimensions for blank canvas rotation: ${transformWidth}x${transformHeight}`);
                            } else {
                                // After rotation, the canvas coordinate space also changes
                                transformWidth = canvasHeight;  // Width becomes height
                                transformHeight = canvasWidth;  // Height becomes width
                                console.log(`[Transform] Swapped canvas dimensions for rotation: ${transformWidth}x${transformHeight}`);
                            }
                        }
                        
                        // Transform all coordinate-based data using IMAGE dimensions (not canvas)
                        // Paint.js stores coordinates in image-relative space, not canvas space
                        // For blank canvas, use canvas dimensions since there's no actual image
                        let rotateWidth, rotateHeight;
                        if (imageData.original && imageData.original.isBlankCanvas) {
                            const canvas = document.getElementById('canvas');
                            rotateWidth = canvas ? canvas.width : 800;
                            rotateHeight = canvas ? canvas.height : 800;
                            console.log(`[Transform] Using canvas dimensions for blank canvas: ${rotateWidth}x${rotateHeight}`);
                        } else {
                            rotateWidth = img.naturalWidth;
                            rotateHeight = img.naturalHeight;
                        }
                        // Debug: Check paint.js current state
                        if (window.paintApp && window.paintApp.state) {
                            console.log(`[Transform] Paint.js current image label: ${window.paintApp.state.currentImageLabel}`);
                        }
                        
                        console.log(`[Transform] About to call transformImageData with label: ${label}, degrees: ${degrees}, dimensions: ${rotateWidth}x${rotateHeight}`);
                        transformImageData(label, 'rotate', degrees, rotateWidth, rotateHeight);
                        // Update the paint.js image data (skip for blank canvas as there's no actual image)
                        if (!imageData.original?.isBlankCanvas) {
                            if (window.originalImages && window.originalImages[label]) {
                                window.originalImages[label] = newSrc;
                            }
                            
                            // Update the canvas if this is the currently displayed image
                            if (window.paintApp && window.paintApp.state.currentImageLabel === label) {
                                console.log(`[Gallery] Updating canvas with rotated image for ${label}`);
                                updateCanvasWithNewImage(newSrc);
                            }
                        } else {
                            console.log('[Transform] Skipping image update for blank canvas - only transforming drawing data');
                            
                            // For blank canvas, just redraw the existing strokes with transformed coordinates
                            if (window.redrawCanvasWithVisibility) {
                                window.redrawCanvasWithVisibility();
                            } else if (window.drawAllStrokes) {
                                window.drawAllStrokes();
                            }
                        }
                    }
                    
                    console.log(`[Gallery] Image ${index} rotated ${degrees}°`);
                };
                img.crossOrigin = 'anonymous';
                img.src = imageData.src;
            }
            
            // Flip image function
            function flipImage(index, direction) {
                console.log(`[Gallery] Flipping image ${index} ${direction}`);
                
                const imageData = imageGalleryData[index];
                if (!imageData) return;
                
                // Apply flip using Canvas
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // Apply flip transformation
                    if (direction === 'horizontal') {
                        ctx.scale(-1, 1);
                        ctx.drawImage(img, -canvas.width, 0);
                    } else if (direction === 'vertical') {
                        ctx.scale(1, -1);
                        ctx.drawImage(img, 0, -canvas.height);
                    }
                    
                    // Update image data
                    const newSrc = canvas.toDataURL();
                    imageData.src = newSrc;
                    
                    // Update thumbnail background
                    const thumbnail = document.querySelector(`[data-image-index="${index}"]`);
                    if (thumbnail) {
                        thumbnail.style.backgroundImage = `url(${newSrc})`;
                    }
                    
                    // Update the actual canvas image if this is the current image
                    if (imageData.original && imageData.original.label) {
                        const label = imageData.original.label;
                        
                        // Get canvas dimensions for coordinate transformation  
                        // Paint.js coordinates are relative to canvas, not original image!
                        const canvas = document.getElementById('canvas');
                        if (!canvas) {
                            console.error('[Transform] Canvas element not found!');
                            return;
                        }
                        
                        // Use actual canvas coordinate space dimensions
                        const canvasWidth = canvas.width;
                        const canvasHeight = canvas.height;
                        
                        console.log(`[Transform] Using canvas dimensions for flip: ${canvasWidth}x${canvasHeight}`);
                        
                        // Transform all coordinate-based data using IMAGE dimensions (not canvas)  
                        // Paint.js stores coordinates in image-relative space, not canvas space
                        // For blank canvas, use canvas dimensions since there's no actual image
                        let flipWidth, flipHeight;
                        if (imageData.original && imageData.original.isBlankCanvas) {
                            flipWidth = canvasWidth;
                            flipHeight = canvasHeight;
                            console.log(`[Transform] Using canvas dimensions for blank canvas flip: ${flipWidth}x${flipHeight}`);
                        } else {
                            flipWidth = img.naturalWidth;
                            flipHeight = img.naturalHeight;
                        }
                        transformImageData(label, 'flip', direction, flipWidth, flipHeight);
                        // Update the paint.js image data (skip for blank canvas as there's no actual image)
                        if (!imageData.original?.isBlankCanvas) {
                            if (window.originalImages && window.originalImages[label]) {
                                window.originalImages[label] = newSrc;
                            }
                            
                            // Update the canvas if this is the currently displayed image
                            if (window.paintApp && window.paintApp.state.currentImageLabel === label) {
                                console.log(`[Gallery] Updating canvas with flipped image for ${label}`);
                                updateCanvasWithNewImage(newSrc);
                            }
                        } else {
                            console.log('[Transform] Skipping image update for blank canvas flip - only transforming drawing data');
                            
                            // For blank canvas, just redraw the existing strokes with transformed coordinates
                            if (window.redrawCanvasWithVisibility) {
                                window.redrawCanvasWithVisibility();
                            } else if (window.drawAllStrokes) {
                                window.drawAllStrokes();
                            }
                        }
                    }
                    
                    console.log(`[Gallery] Image ${index} flipped ${direction}`);
                };
                img.crossOrigin = 'anonymous';
                img.src = imageData.src;
            }
            
            // Test function to validate coordinate transformations
            function testCoordinateTransformations() {
                console.log('=== Testing Coordinate Transformations ===');
                
                // Get actual canvas dimensions dynamically
                const canvas = document.getElementById('canvas');
                const canvasWidth = canvas ? canvas.width : 1920;
                const canvasHeight = canvas ? canvas.height : 945;
                
                console.log(`[Test] Using actual canvas dimensions: ${canvasWidth}x${canvasHeight}`);
                
                // Test corner points that were previously going out of bounds
                const testPoints = [
                    {x: 100, y: 100, label: 'top-left area'},
                    {x: 1800, y: 100, label: 'top-right area'}, 
                    {x: 100, y: 800, label: 'bottom-left area'},
                    {x: 1800, y: 800, label: 'bottom-right area'},
                    {x: 960, y: 472.5, label: 'center'}
                ];
                
                let allTestsPassed = true;
                
                testPoints.forEach(point => {
                    console.log(`\nTesting ${point.label} at (${point.x}, ${point.y}):`);
                    
                    // Test 90° rotation
                    const rotated90 = rotateCoordinates(point.x, point.y, 90, canvasWidth, canvasHeight);
                    console.log(`  90° rotation: (${rotated90.x.toFixed(1)}, ${rotated90.y.toFixed(1)})`);
                    
                    // Test 180° rotation  
                    const rotated180 = rotateCoordinates(point.x, point.y, 180, canvasWidth, canvasHeight);
                    console.log(`  180° rotation: (${rotated180.x.toFixed(1)}, ${rotated180.y.toFixed(1)})`);
                    
                    // Test horizontal flip
                    const flippedH = flipCoordinates(point.x, point.y, 'horizontal', canvasWidth, canvasHeight);
                    console.log(`  Horizontal flip: (${flippedH.x.toFixed(1)}, ${flippedH.y.toFixed(1)})`);
                    
                    // Test vertical flip
                    const flippedV = flipCoordinates(point.x, point.y, 'vertical', canvasWidth, canvasHeight);
                    console.log(`  Vertical flip: (${flippedV.x.toFixed(1)}, ${flippedV.y.toFixed(1)})`);
                    
                    // Verify all results are within bounds (for 90°: width becomes height)
                    const bounds90 = rotated90.x >= 0 && rotated90.x <= canvasHeight && rotated90.y >= 0 && rotated90.y <= canvasWidth;
                    const bounds180 = rotated180.x >= 0 && rotated180.x <= canvasWidth && rotated180.y >= 0 && rotated180.y <= canvasHeight;
                    const boundsFlipH = flippedH.x >= 0 && flippedH.x <= canvasWidth && flippedH.y >= 0 && flippedH.y <= canvasHeight;
                    const boundsFlipV = flippedV.x >= 0 && flippedV.x <= canvasWidth && flippedV.y >= 0 && flippedV.y <= canvasHeight;
                    
                    console.log(`  Within bounds: 90°=${bounds90}, 180°=${bounds180}, H-flip=${boundsFlipH}, V-flip=${boundsFlipV}`);
                    
                    if (!bounds90 || !bounds180 || !boundsFlipH || !boundsFlipV) {
                        allTestsPassed = false;
                        console.error(`  ❌ BOUNDARY TEST FAILED for ${point.label}`);
                    }
                });
                
                if (allTestsPassed) {
                    console.log('\n✅ All coordinate transformation tests PASSED - boundary constraints working correctly');
                } else {
                    console.error('\n❌ Some coordinate transformation tests FAILED - boundary constraints need adjustment');
                }
                
                console.log('=== Transformation Test Complete ===');
                return allTestsPassed;
            }

            // Transform offset vectors (relative to anchor points) for rotation/flip
            // Offsets are ALWAYS rotated as pure vectors around origin (0,0) - no center logic
            function rotateOffsetVector(x, y, degrees) {
                // Pure vector rotation: O' = R(degrees) * O
                // For -90°: (x,y) → (y,-x), e.g., (-710,-427.5) → (-427.5,710)
                const radians = (degrees * Math.PI) / 180;
                const cos = Math.cos(radians);
                const sin = Math.sin(radians);
                
                const rotatedX = x * cos - y * sin;
                const rotatedY = x * sin + y * cos;
                
                console.log(`[Transform] Vector rotation: (${x.toFixed(1)}, ${y.toFixed(1)}) → (${rotatedX.toFixed(1)}, ${rotatedY.toFixed(1)}) by ${degrees}°`);
                
                return {
                    x: rotatedX,
                    y: rotatedY
                };
            }
            
            function flipOffsetVector(x, y, direction) {
                if (direction === 'horizontal') {
                    return { x: -x, y: y };  // Flip X offset
                } else if (direction === 'vertical') {
                    return { x: x, y: -y };  // Flip Y offset
                }
                return { x, y };
            }
            
            // Get stroke midpoint from vector data in image space
            function getStrokeMidpointImageSpace(vectorStrokesSource, imageLabel, strokeLabel) {
                const vectorData = vectorStrokesSource[imageLabel][strokeLabel];
                if (!vectorData || !vectorData.points || vectorData.points.length === 0) {
                    console.warn(`[Transform] No vector data found for stroke ${strokeLabel}`);
                    return { x: 0, y: 0 };
                }
                
                const midpointIndex = Math.floor(vectorData.points.length / 2);
                const midpoint = vectorData.points[midpointIndex];
                return { x: midpoint.x, y: midpoint.y };
            }
            
            // Rotate a point around a center point
            function rotatePoint(point, center, degrees) {
                const radians = (degrees * Math.PI) / 180;
                const cos = Math.cos(radians);
                const sin = Math.sin(radians);
                
                const dx = point.x - center.x;
                const dy = point.y - center.y;
                
                return {
                    x: center.x + (dx * cos - dy * sin),
                    y: center.y + (dx * sin + dy * cos)
                };
            }

            // Coordinate transformation functions for image rotate/flip
            function rotateCoordinates(x, y, degrees, imageWidth, imageHeight, customCenter = null, keepDimensions = false) {
                let centerX, centerY;
                
                if (customCenter) {
                    centerX = customCenter.x;
                    centerY = customCenter.y;
                    console.log(`[Transform] Using drawing centroid (${centerX.toFixed(1)}, ${centerY.toFixed(1)}) for blank canvas`);
                } else {
                    centerX = imageWidth / 2;
                    centerY = imageHeight / 2;
                    console.log(`[Transform] Using canvas center (${centerX}, ${centerY})`);
                }
                
                console.log(`[Transform] Rotating point (${x}, ${y}) around center (${centerX.toFixed(1)}, ${centerY.toFixed(1)}) by ${degrees}°`);
                
                // Translate to origin (relative to center)
                const translatedX = x - centerX;
                const translatedY = y - centerY;
                
                // Convert degrees to radians
                const radians = (degrees * Math.PI) / 180;
                const cos = Math.cos(radians);
                const sin = Math.sin(radians);
                
                // Apply rotation matrix
                const rotatedX = translatedX * cos - translatedY * sin;
                const rotatedY = translatedX * sin + translatedY * cos;
                
                // For 90° and 270° rotations, dimensions swap
                let newCenterX, newCenterY;
                if (Math.abs(degrees) === 90 || Math.abs(degrees) === 270) {
                    // For blank canvas, keep the same rotation center to avoid orbital motion
                    if (customCenter) {
                        // Keep the drawing centroid as rotation center
                        newCenterX = centerX;
                        newCenterY = centerY;
                        console.log(`[Transform] Keeping rotation center (${newCenterX.toFixed(1)}, ${newCenterY.toFixed(1)}) for blank canvas 90°/270° rotation`);
                    } else {
                        // For regular images, swap center with dimensions
                        newCenterX = imageHeight / 2;  // New width is old height
                        newCenterY = imageWidth / 2;   // New height is old width
                    }
                } else {
                    newCenterX = centerX;
                    newCenterY = centerY;
                }
                
                // Translate back from new center
                let finalX = rotatedX + newCenterX;
                let finalY = rotatedY + newCenterY;
                
                // Get the final canvas dimensions (after potential rotation)
                let finalWidth, finalHeight;
                if (keepDimensions || !(Math.abs(degrees) === 90 || Math.abs(degrees) === 270)) {
                    // Keep original dimensions for blank canvas or non-90/270 rotations
                    finalWidth = imageWidth;
                    finalHeight = imageHeight;
                } else {
                    // Swap dimensions for regular image 90/270 rotations
                    finalWidth = imageHeight;
                    finalHeight = imageWidth;
                }
                
                // For blank canvas, skip bounds clamping to prevent shape distortion during rotation
                if (!keepDimensions) {
                    // Constrain coordinates to stay within canvas bounds (0 to width-1, 0 to height-1)
                    finalX = Math.max(0, Math.min(finalWidth - 1, finalX));
                    finalY = Math.max(0, Math.min(finalHeight - 1, finalY));
                }
                
                console.log(`[Transform] Final coordinates: (${finalX}, ${finalY}) [bounds: ${finalWidth}x${finalHeight}]`);
                
                return {
                    x: finalX,
                    y: finalY
                };
            }
            
            function flipCoordinates(x, y, direction, imageWidth, imageHeight) {
                let finalX = x, finalY = y;
                
                if (direction === 'horizontal') {
                    finalX = imageWidth - x;
                } else if (direction === 'vertical') {
                    finalY = imageHeight - y;
                }
                
                // Apply boundary constraints (0 to width-1, 0 to height-1)
                finalX = Math.max(0, Math.min(imageWidth - 1, finalX));
                finalY = Math.max(0, Math.min(imageHeight - 1, finalY));
                
                return { 
                    x: finalX, 
                    y: finalY 
                };
            }
            
            // Calculate the centroid (center of mass) of all drawn strokes
            function calculateDrawingCentroid(vectorStrokesByImage, imageLabel) {
                const vectorStrokes = vectorStrokesByImage[imageLabel];
                if (!vectorStrokes || Object.keys(vectorStrokes).length === 0) {
                    return null;
                }
                
                let totalX = 0, totalY = 0, totalPoints = 0;
                
                Object.values(vectorStrokes).forEach(stroke => {
                    if (stroke.points && stroke.points.length > 0) {
                        stroke.points.forEach(point => {
                            totalX += point.x;
                            totalY += point.y;
                            totalPoints++;
                        });
                    }
                });
                
                if (totalPoints === 0) return null;
                
                const centroid = {
                    x: totalX / totalPoints,
                    y: totalY / totalPoints
                };
                
                console.log(`[Transform] Drawing centroid: (${centroid.x.toFixed(1)}, ${centroid.y.toFixed(1)}) from ${totalPoints} points`);
                return centroid;
            }
            
            // Transform all stroke and label data for an image
            window.transformImageData = function transformImageData(imageLabel, transformType, transformValue, imageWidth, imageHeight) {
                console.log(`[Transform] ===== TRANSFORMING DATA =====`);
                console.log(`[Transform] Image: ${imageLabel}, Type: ${transformType} ${transformValue}`);
                console.log(`[Transform] Using IMAGE dimensions: ${imageWidth} x ${imageHeight}`);
                
                // Debug: Check both global state and paintApp state
                if (window.paintApp && window.paintApp.state) {
                    console.log(`[Transform] Paint.js current image label: ${window.paintApp.state.currentImageLabel}`);
                    console.log(`[Transform] Paint.js vectorStrokesByImage keys:`, Object.keys(window.paintApp.state.vectorStrokesByImage || {}));
                }
                
                // Debug: Check what data exists for this image label
                if (window.vectorStrokesByImage) {
                    console.log(`[Transform] Available vectorStrokesByImage labels:`, Object.keys(window.vectorStrokesByImage));
                    if (window.vectorStrokesByImage[imageLabel]) {
                        console.log(`[Transform] Found ${Object.keys(window.vectorStrokesByImage[imageLabel]).length} strokes for label ${imageLabel}`);
                    } else {
                        console.log(`[Transform] No strokes found for label ${imageLabel}`);
                    }
                } else {
                    console.log(`[Transform] Global vectorStrokesByImage is undefined!`);
                }
                
                // Try paint.js state if global variables are empty
                let vectorStrokesSource = window.vectorStrokesByImage;
                let labelPositionsSource = window.customLabelPositions;
                let labelOffsetsSource = window.calculatedLabelOffsets;
                
                console.log(`[DEBUG] Initial sources - vectorStrokesSource:`, !!vectorStrokesSource, 'labelPositionsSource:', !!labelPositionsSource, 'labelOffsetsSource:', !!labelOffsetsSource);
                
                if (window.paintApp && window.paintApp.state) {
                    if (!vectorStrokesSource || !vectorStrokesSource[imageLabel]) {
                        vectorStrokesSource = window.paintApp.state.vectorStrokesByImage;
                        console.log(`[Transform] Using paint.js state vectorStrokesByImage instead`);
                    }
                    if (!labelPositionsSource || !labelPositionsSource[imageLabel]) {
                        labelPositionsSource = window.paintApp.state.customLabelPositions;
                        console.log(`[Transform] Using paint.js state customLabelPositions instead`);
                    }
                    if (!labelOffsetsSource || !labelOffsetsSource[imageLabel]) {
                        labelOffsetsSource = window.paintApp.state.calculatedLabelOffsets;
                        console.log(`[Transform] Using paint.js state calculatedLabelOffsets instead`);
                    }
                }
                
                // Calculate the rotation center
                let rotationCenter = null;
                let isBlankCanvas = false;
                if (transformType === 'rotate' && vectorStrokesSource) {
                    // For blank canvas, rotate around the actual drawing center for intuitive behavior
                    if (imageLabel === 'blank_canvas') {
                        isBlankCanvas = true;
                        
                        // Initialize original centroid storage if it doesn't exist
                        if (!window.originalDrawingCentroids) {
                            window.originalDrawingCentroids = {};
                        }
                        
                        // Store the original centroid on first rotation, then reuse it
                        if (!window.originalDrawingCentroids[imageLabel]) {
                            window.originalDrawingCentroids[imageLabel] = calculateDrawingCentroid(vectorStrokesSource, imageLabel);
                            console.log(`[Transform] Storing original drawing centroid for ${imageLabel}:`, window.originalDrawingCentroids[imageLabel]);
                            
                            // Also store the canvas dimensions when we store the centroid
                            const canvas = document.getElementById('canvas');
                            if (canvas) {
                                if (!window.lastCanvasDimensions) window.lastCanvasDimensions = {};
                                window.lastCanvasDimensions[imageLabel] = { width: canvas.width, height: canvas.height };
                                console.log(`[Transform] Stored canvas dimensions for ${imageLabel}: ${canvas.width}x${canvas.height}`);
                            }
                        }
                        
                        rotationCenter = window.originalDrawingCentroids[imageLabel];
                        console.log(`[Transform] Using stored original centroid for ${imageLabel}:`, rotationCenter);
                    } else {
                        // For regular images, rotate strokes around the image center to match bitmap rotation
                        rotationCenter = null;
                        console.log(`[Transform] Using image center for rotation of ${imageLabel}`);
                    }
                }

                // Record rotation metadata for testing harness
                if (transformType === 'rotate') {
                    // Determine real image label used by state (avoid 'blank_canvas' leaks)
                    const realImageLabel = window.currentImageLabel || imageLabel;
                    
                    // Store rotation metadata with normalized delta and canvas coordinates
                    if (!window.lastRotationMeta) window.lastRotationMeta = {};
                    
                    // For regular images (rotationCenter = null), use image center
                    const centerToRecord = rotationCenter || { x: imageWidth / 2, y: imageHeight / 2 };
                    
                    window.lastRotationMeta[realImageLabel] = {
                        centerCanvas: { x: centerToRecord.x, y: centerToRecord.y },
                        delta: window.normalizeDelta ? window.normalizeDelta((transformValue * Math.PI) / 180) : ((transformValue * Math.PI) / 180)
                    };
                    console.log(`[Transform] Recorded rotation meta for ${realImageLabel}: center=(${centerToRecord.x.toFixed(1)}, ${centerToRecord.y.toFixed(1)}), delta=${transformValue}°`);
                }
                
                // Transform vector strokes
                if (vectorStrokesSource && vectorStrokesSource[imageLabel]) {
                    const vectorStrokes = vectorStrokesSource[imageLabel];
                    console.log(`[Transform] Processing ${Object.keys(vectorStrokes).length} vector strokes:`, Object.keys(vectorStrokes));
                    
                    Object.keys(vectorStrokes).forEach(strokeLabel => {
                        const strokeData = vectorStrokes[strokeLabel];
                        if (strokeData && strokeData.points) {
                            console.log(`[Transform] Stroke ${strokeLabel}: ${strokeData.points.length} points`);
                            console.log(`[Transform] Before:`, strokeData.points.slice(0, 2)); // Show first 2 points
                            
                            strokeData.points = strokeData.points.map(point => {
                                if (transformType === 'rotate') {
                                    return rotateCoordinates(point.x, point.y, transformValue, imageWidth, imageHeight, rotationCenter, isBlankCanvas);
                                } else if (transformType === 'flip') {
                                    return flipCoordinates(point.x, point.y, transformValue, imageWidth, imageHeight);
                                }
                                return point;
                            });
                            
                            console.log(`[Transform] After:`, strokeData.points.slice(0, 2)); // Show first 2 transformed points
                        }
                    });
                    console.log(`[Transform] Updated ${Object.keys(vectorStrokes).length} vector strokes`);
                }
                
                // Transform custom label positions for rotations - maintain exact positioning
                // User-positioned labels should stay at the same relative position after rotation
                if (transformType === 'rotate') {
                    const allCustomTransformSources = [
                        window.customLabelPositions,
                        window.paintApp?.state?.customLabelPositions
                    ].filter(source => source && source[imageLabel]);
                    
                    allCustomTransformSources.forEach((source, index) => {
                        if (source && source[imageLabel]) {
                            const labelPositions = source[imageLabel];
                            const positionCount = Object.keys(labelPositions).length;
                            console.log(`[Transform] Transforming ${positionCount} custom label positions from source ${index + 1}`);
                            
                            // Transform each custom position using vector rotation
                            Object.keys(labelPositions).forEach(labelKey => {
                                const position = labelPositions[labelKey];
                                if (position && typeof position.x === 'number' && typeof position.y === 'number') {
                                    const rotatedPosition = rotateOffsetVector(position.x, position.y, transformValue);
                                    labelPositions[labelKey] = rotatedPosition;
                                    console.log(`[Transform] Transformed custom position ${labelKey}: (${position.x.toFixed(1)}, ${position.y.toFixed(1)}) → (${rotatedPosition.x.toFixed(1)}, ${rotatedPosition.y.toFixed(1)})`);
                                }
                            });
                            console.log(`[Transform] Transformed ${positionCount} custom positions from source ${index + 1}`);
                        }
                    });
                } else {
                    // For non-rotation transforms (flip), clear custom positions to force recalculation
                    const allCustomClearSources = [
                        window.customLabelPositions,
                        window.paintApp?.state?.customLabelPositions
                    ].filter(source => source && source[imageLabel]);
                    
                    allCustomClearSources.forEach((source, index) => {
                        if (source && source[imageLabel]) {
                            const labelPositions = source[imageLabel];
                            console.log(`[Transform] Clearing ${Object.keys(labelPositions).length} custom label positions from source ${index + 1} for recalculation`);
                            
                            // Clear custom positions so they get recalculated with the new stroke positions
                            Object.keys(labelPositions).forEach(labelKey => {
                                delete labelPositions[labelKey];
                            });
                            console.log(`[Transform] Cleared custom label positions from source ${index + 1} - will be recalculated on next draw`);
                        }
                    });
                }
                
                // Transform calculated label offsets using simple vector rotation
                // This maintains proper positioning during rotations without accumulating errors
                if (labelOffsetsSource && labelOffsetsSource[imageLabel] && transformType === 'rotate') {
                    const labelOffsets = labelOffsetsSource[imageLabel];
                    console.log(`[Transform] Transforming ${Object.keys(labelOffsets).length} calculated label offsets for rotation`);
                    
                    // Transform each label offset as a vector relative to the stroke's anchor point
                    Object.keys(labelOffsets).forEach(labelKey => {
                        const offset = labelOffsets[labelKey];
                        if (offset && typeof offset.x === 'number' && typeof offset.y === 'number') {
                            // Transform the offset vector using pure rotation (no translation)
                            // Offsets are relative vectors that should rotate around origin (0,0)
                            const rotatedOffset = rotateOffsetVector(offset.x, offset.y, transformValue);
                            labelOffsets[labelKey] = rotatedOffset;
                            console.log(`[Transform] Transformed label offset ${labelKey}: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)}) → (${rotatedOffset.x.toFixed(1)}, ${rotatedOffset.y.toFixed(1)})`);
                        }
                    });
                    console.log(`[Transform] Transformed ${Object.keys(labelOffsets).length} calculated label offsets`);
                }
                
                // NEW RELATIVE POSITIONING SYSTEM: Use relative positions to recalculate absolute positions after rotation
                console.log(`[REL-TRANSFORM] Using relative positioning system for rotation-resistant custom labels`);
                
                if (transformType === 'rotate' && window.customLabelRelativePositions && window.customLabelRelativePositions[imageLabel]) {
                    const relativePositions = window.customLabelRelativePositions[imageLabel];
                    const strokeLabels = Object.keys(relativePositions);
                    console.log(`[REL-TRANSFORM] Found ${strokeLabels.length} relative positions to recalculate:`, strokeLabels);
                    
                    // Initialize absolute position storage if needed
                    if (!window.customLabelPositions[imageLabel]) {
                        window.customLabelPositions[imageLabel] = {};
                    }
                    
                    let updatedPositions = 0;
                    strokeLabels.forEach(strokeLabel => {
                        const relativePos = relativePositions[strokeLabel];
                        if (relativePos && typeof relativePos.percentageAlongLine === 'number' && typeof relativePos.perpendicularDistance === 'number') {
                            // Recalculate absolute position from relative position after stroke rotation
                            const newAbsoluteOffset = window.convertRelativeToAbsolutePosition(strokeLabel, relativePos, imageLabel);
                            if (newAbsoluteOffset) {
                                window.customLabelPositions[imageLabel][strokeLabel] = newAbsoluteOffset;
                                updatedPositions++;
                                console.log(`[REL-TRANSFORM] Recalculated ${strokeLabel}: ${(relativePos.percentageAlongLine * 100).toFixed(1)}% + ${relativePos.perpendicularDistance.toFixed(1)}px → (${newAbsoluteOffset.x.toFixed(1)}, ${newAbsoluteOffset.y.toFixed(1)})`);
                            } else {
                                console.warn(`[REL-TRANSFORM] Failed to recalculate position for ${strokeLabel}`);
                            }
                        }
                    });
                    
                    console.log(`[REL-TRANSFORM] Successfully recalculated ${updatedPositions}/${strokeLabels.length} custom positions using relative positioning`);
                } else {
                    console.log(`[REL-TRANSFORM] No relative positions found for ${imageLabel} or not a rotation transform`);
                    
                    // Fallback: Clear absolute positions for non-rotation transforms to force recalculation
                    if (transformType !== 'rotate' && window.customLabelPositions && window.customLabelPositions[imageLabel]) {
                        const customPositions = window.customLabelPositions[imageLabel];
                        const strokeLabels = Object.keys(customPositions);
                        console.log(`[REL-TRANSFORM] Clearing ${strokeLabels.length} absolute custom positions for ${transformType} - will be recalculated`);
                        
                        strokeLabels.forEach(strokeLabel => {
                            delete customPositions[strokeLabel];
                        });
                    }
                }
                
                if (transformType !== 'rotate' && labelOffsetsSource && labelOffsetsSource[imageLabel]) {
                    // For non-rotation transforms (flip), clear offsets to force recalculation
                    const labelOffsets = labelOffsetsSource[imageLabel];
                    console.log(`[Transform] Clearing ${Object.keys(labelOffsets).length} calculated label offsets for ${transformType}`);
                    
                    Object.keys(labelOffsets).forEach(labelKey => {
                        delete labelOffsets[labelKey];
                    });
                    console.log(`[Transform] Cleared calculated label offsets - will be recalculated on next draw`);
                }
                
                // Update image dimensions if rotating by 90/270 degrees
                if (transformType === 'rotate' && (Math.abs(transformValue) === 90 || Math.abs(transformValue) === 270)) {
                    if (window.originalImageDimensions && window.originalImageDimensions[imageLabel]) {
                        const dims = window.originalImageDimensions[imageLabel];
                        window.originalImageDimensions[imageLabel] = {
                            width: dims.height,
                            height: dims.width
                        };
                        console.log(`[Transform] Swapped image dimensions: ${dims.width}x${dims.height} → ${dims.height}x${dims.width}`);
                    }
                }

                // Update rotation stamps and cumulative rotation for custom labels persistence
                if (transformType === 'rotate') {
                    // 1) Determine real image label used by state (avoid 'blank_canvas' leaks)
                    const img = window.currentImageLabel || imageLabel;

                    // 2) Rotation delta already known (transformValue in degrees); normalize it in radians
                    const deltaRadians = (transformValue * Math.PI) / 180;
                    const normalizedDelta = window.normalizeDelta ? window.normalizeDelta(deltaRadians) : deltaRadians;

                    // 3) Update per-stroke rotation stamps for custom offsets
                    if (!window.customLabelOffsetsRotationByImageAndStroke) {
                        window.customLabelOffsetsRotationByImageAndStroke = {};
                    }
                    if (!window.customLabelOffsetsRotationByImageAndStroke[img]) {
                        window.customLabelOffsetsRotationByImageAndStroke[img] = {};
                    }

                    // Update stamps for all strokes that have custom offsets
                    if (window.customLabelPositions && window.customLabelPositions[img]) {
                        Object.keys(window.customLabelPositions[img]).forEach(stroke => {
                            const lastStamp = window.customLabelOffsetsRotationByImageAndStroke[img][stroke] || 0;
                            const newStamp = window.normalizeDelta ? window.normalizeDelta(lastStamp + normalizedDelta) : (lastStamp + normalizedDelta);
                            window.customLabelOffsetsRotationByImageAndStroke[img][stroke] = newStamp;
                        });
                    }

                    // 4) Advance image cumulative rotation so future sync math remains aligned
                    if (!window.imageRotationByLabel) {
                        window.imageRotationByLabel = {};
                    }
                    const currentRotation = window.imageRotationByLabel[img] || 0;
                    window.imageRotationByLabel[img] = window.normalizeDelta ? window.normalizeDelta(currentRotation + normalizedDelta) : (currentRotation + normalizedDelta);

                    console.log(`[Transform] Updated rotation state for ${img}: delta=${(transformValue)}°, cumulative=${(window.imageRotationByLabel[img] * 180 / Math.PI).toFixed(1)}°`);
                }
            }
            
            // Helper function to update canvas with new image data
            function updateCanvasWithNewImage(newImageSrc) {
                try {
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.getElementById('canvas');
                        if (canvas) {
                            const ctx = canvas.getContext('2d');
                            
                            console.log(`[Canvas] Updating canvas (${canvas.width}x${canvas.height}) with new image (${img.width}x${img.height})`);
                            
                            // Clear canvas
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            // Get current scale and position from paint.js
                            const currentLabel = window.paintApp?.state?.currentImageLabel || window.currentImageLabel;
                            const scale = window.imageScaleByLabel?.[currentLabel] || 1.0;
                            const position = window.imagePositionByLabel?.[currentLabel] || { x: 0, y: 0 };
                            
                            console.log(`[Canvas] Using scale: ${scale}, position: (${position.x}, ${position.y})`);
                            
                            // Calculate scaled dimensions and positioning
                            const scaledWidth = img.width * scale;
                            const scaledHeight = img.height * scale;
                            const x = (canvas.width - scaledWidth) / 2 + position.x;
                            const y = (canvas.height - scaledHeight) / 2 + position.y;
                            
                            // Draw image with proper scaling and positioning
                            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                            
                            // Trigger paint.js to redraw strokes if available
                            if (window.redrawCanvasWithVisibility) {
                                window.redrawCanvasWithVisibility();
                            } else if (window.drawAllStrokes) {
                                window.drawAllStrokes();
                            }
                            
                            console.log('[Gallery] Canvas updated with new image using paint.js scale/position');
                        }
                    };
                    img.crossOrigin = 'anonymous';
                    img.src = newImageSrc;
                } catch (error) {
                    console.error('[Gallery] Error updating canvas:', error);
                }
            }
            
            // Update active image highlighting
            function updateActiveImage(index) {
                currentImageIndex = index;
                
                // Update thumbnail highlighting
                document.querySelectorAll('.image-thumbnail').forEach((thumb, idx) => {
                    thumb.classList.toggle('active', idx === index);
                });
                
                // Update navigation dots
                document.querySelectorAll('.nav-dot').forEach((dot, idx) => {
                    dot.classList.toggle('active', idx === index);
                });
                
                // Sync inputs to current image
                const data = imageGalleryData[index];
                const nameEl = document.getElementById('imageNameInput');
                const typeEl = document.getElementById('imageTypeSelect');
                if (nameEl && data) nameEl.value = data.name || '';
                if (typeEl && data && data.original) typeEl.value = data.original.type || '';
                
                updateGalleryControls();
            }
            
            // Update gallery controls and counters
            function updateGalleryControls() {
                const prevButton = document.getElementById('prevImage');
                const nextButton = document.getElementById('nextImage');
                const imagePosition = document.getElementById('imagePosition');
                const imageCounter = document.getElementById('imageCounter');
                
                const totalImages = imageGalleryData.length;
                
                if (prevButton && nextButton) {
                    prevButton.disabled = currentImageIndex <= 0;
                    nextButton.disabled = currentImageIndex >= totalImages - 1;
                }
                
                if (imagePosition) {
                    imagePosition.textContent = `${currentImageIndex + 1} / ${totalImages}`;
                }
                
                if (imageCounter) {
                    imageCounter.textContent = totalImages > 0 ? `${totalImages} images` : '';
                }
            }
            
            // Clear image gallery
            function clearImageGallery() {
                const imageGallery = document.getElementById('imageGallery');
                const imageDots = document.getElementById('imageDots');
                
                if (imageGallery) imageGallery.innerHTML = '';
                if (imageDots) imageDots.innerHTML = '';
                
                imageGalleryData = [];
                currentImageIndex = 0;
                updateGalleryControls();
            }
            
            // Initialize gallery on page load
            initializeImageGallery();
            
            // Store reference to original addImageToSidebar if it exists
            const originalAddImageToSidebar = window.addImageToSidebar;
            
            // Enhanced compatibility function that works with both new and old formats
            window.addImageToSidebar = function(imageUrl, label, filename) {
                console.log('[COMPAT] addImageToSidebar called with:', { imageUrl: imageUrl?.substring?.(0, 50) || imageUrl, label, filename });
                
                // Call original function first if it exists (for backwards compatibility)
                if (originalAddImageToSidebar && typeof originalAddImageToSidebar === 'function') {
                    try {
                        originalAddImageToSidebar.apply(this, arguments);
                    } catch (error) {
                        console.warn('[COMPAT] Original addImageToSidebar failed:', error);
                    }
                }
                
                // Add to new gallery
                if (imageUrl) {
                    const index = imageGalleryData.length;
                    const imageData = {
                        src: imageUrl,
                        url: imageUrl,
                        name: filename || label || `Image ${index + 1}`,
                        label: label,
                        filename: filename
                    };
                    
                    addImageToGallery(imageData, index);
                    console.log('[COMPAT] Added to new gallery at index', index, 'Total images now:', imageGalleryData.length);
                    
                    return index;
                } else {
                    console.warn('[COMPAT] No valid imageUrl provided');
                    return -1;
                }
            };
            
            window.switchToImage = function(imageIndex) {
                if (typeof imageIndex === 'number') {
                    navigateToImage(imageIndex);
                    console.log('[COMPAT] Switched to image:', imageIndex);
                }
            };
            
            // Legacy image list compatibility
            window.updateImageList = function() {
                // This function exists for compatibility but the new gallery handles updates automatically
                console.log('[COMPAT] updateImageList called - handled by new gallery system');
            };
            
            // Clear images function
            window.clearImageSidebar = function() {
                clearImageGallery();
                console.log('[COMPAT] Cleared image sidebar');
            };
            
            console.log('[INIT] Image gallery and compatibility functions initialized');
            
            // Debug function to inspect paint.js state
            window.debugPaintState = function() {
                console.log('=== PAINT.JS STATE DEBUG ===');
                
                if (window.paintApp && window.paintApp.state) {
                    console.log('Current image label:', window.paintApp.state.currentImageLabel);
                    console.log('Paint app state keys:', Object.keys(window.paintApp.state));
                }
                
                if (window.vectorStrokesByImage) {
                    const labels = Object.keys(window.vectorStrokesByImage);
                    console.log('vectorStrokesByImage labels:', labels);
                    labels.forEach(label => {
                        const strokes = window.vectorStrokesByImage[label];
                        console.log(`  ${label}: ${Object.keys(strokes || {}).length} strokes`);
                    });
                } else {
                    console.log('vectorStrokesByImage not found');
                }
                
                if (window.customLabelPositions) {
                    const labels = Object.keys(window.customLabelPositions);
                    console.log('customLabelPositions labels:', labels);
                } else {
                    console.log('customLabelPositions not found');
                }
                
                console.log('imageGalleryData length:', imageGalleryData.length);
                console.log('currentImageIndex:', currentImageIndex);
                if (imageGalleryData[currentImageIndex]) {
                    console.log('Current image:', imageGalleryData[currentImageIndex].name, imageGalleryData[currentImageIndex].original?.label);
                    console.log('Full current image data:', JSON.stringify(imageGalleryData[currentImageIndex], null, 2));
                }
                
                // Also debug all gallery images
                console.log('All gallery images:');
                imageGalleryData.forEach((img, index) => {
                    console.log(`  [${index}] ${img.name}: label=${img.original?.label}, isBlankCanvas=${img.original?.isBlankCanvas}`);
                });
            };
            
            // Test function to add mock drawing data for blank canvas
            window.addTestTriangle = function() {
                // Try to get the actual current image label from gallery
                let targetLabel = 'blank_canvas'; // fallback
                if (imageGalleryData[currentImageIndex]?.original?.label) {
                    targetLabel = imageGalleryData[currentImageIndex].original.label;
                }
                const paintLabel = window.paintApp?.state?.currentImageLabel;
                
                console.log(`[Test] Gallery current index: ${currentImageIndex}`);
                console.log(`[Test] Gallery target label: ${targetLabel}`);
                console.log(`[Test] Paint.js current label: ${paintLabel}`);
                console.log(`[Test] Adding test triangle to label: ${targetLabel}`);
                
                // Mock stroke data for a simple triangle
                const mockStroke = {
                    points: [
                        { x: 300, y: 200 },  // Top point
                        { x: 200, y: 400 },  // Bottom left
                        { x: 400, y: 400 },  // Bottom right
                        { x: 300, y: 200 }   // Back to top
                    ],
                    color: '#ff0000',
                    thickness: 3,
                    type: 'freehand'
                };
                
                // Add to both global and paint.js state
                if (window.vectorStrokesByImage) {
                    if (!window.vectorStrokesByImage[targetLabel]) {
                        window.vectorStrokesByImage[targetLabel] = {};
                    }
                    window.vectorStrokesByImage[targetLabel]['test_triangle'] = mockStroke;
                }
                
                if (window.paintApp?.state?.vectorStrokesByImage) {
                    if (!window.paintApp.state.vectorStrokesByImage[targetLabel]) {
                        window.paintApp.state.vectorStrokesByImage[targetLabel] = {};
                    }
                    window.paintApp.state.vectorStrokesByImage[targetLabel]['test_triangle'] = mockStroke;
                }
                
                // Also switch paint.js to the correct label if it's not already there
                if (paintLabel !== targetLabel && window.switchToImage) {
                    console.log(`[Test] Switching paint.js from '${paintLabel}' to '${targetLabel}'`);
                    window.switchToImage(targetLabel);
                }
                
                console.log(`[Test] Added test triangle. Use debugPaintState() to verify.`);
                
                // Redraw if function exists
                if (window.redrawCanvasWithVisibility) {
                    window.redrawCanvasWithVisibility();
                }
            };
            
            // Note: Stored centroid system removed - blank canvas now uses fixed canvas center
            
            // Test function to try rotating the current image
            window.testRotate = function() {
                console.log(`[Test] Testing rotation on current image (index ${currentImageIndex})`);
                if (currentImageIndex >= 0 && currentImageIndex < imageGalleryData.length) {
                    const imageData = imageGalleryData[currentImageIndex];
                    console.log(`[Test] Rotating image: ${imageData.name}`);
                    rotateImage(currentImageIndex, 90);
                } else {
                    console.log(`[Test] Invalid image index: ${currentImageIndex}`);
                }
            };
            
            // Hook into addImageToSidebar after external scripts load
            let hookAttempts = 0;
            const maxHookAttempts = 50;
            
            function attemptHook() {
                hookAttempts++;
                
                // Check if paint.js has loaded and defined its own addImageToSidebar
                if (window.addImageToSidebar && window.addImageToSidebar.toString().includes('imageList')) {
                    console.log('[HOOK] Found original addImageToSidebar from paint.js, hooking into it...');
                    
                    // Store the original function
                    const paintJsAddImageToSidebar = window.addImageToSidebar;
                    
                    // Create our intercepting function
                    window.addImageToSidebar = function(imageUrl, label, filename) {
                        console.log('[HOOK] Intercepted addImageToSidebar call:', { imageUrl: imageUrl?.substring?.(0, 50) || imageUrl, label, filename });
                        
                        // Call the original paint.js function
                        const result = paintJsAddImageToSidebar.apply(this, arguments);
                        
                        // Add to our new gallery
                        if (imageUrl) {
                            const index = imageGalleryData.length;
                            const imageData = {
                                src: imageUrl,
                                url: imageUrl,
                                name: filename || label || `Image ${index + 1}`,
                                label: label,
                                filename: filename
                            };
                            
                            addImageToGallery(imageData, index);
                            console.log('[HOOK] Added to new gallery at index', index);
                        }
                        
                        return result;
                    };
                    
                    console.log('[HOOK] Successfully hooked addImageToSidebar');
                    return true;
                } else if (hookAttempts < maxHookAttempts) {
                    setTimeout(attemptHook, 100);
                } else {
                    console.warn('[HOOK] Max attempts reached, could not hook addImageToSidebar');
                }
            }
            
            // Start attempting to hook after a short delay
            setTimeout(attemptHook, 500);
            
            // Function to sync existing legacy images to new gallery
            function syncLegacyImagesToGallery() {
                const imageList = document.getElementById('imageList');
                if (!imageList) {
                    console.log('[SYNC] ERROR: No imageList element found');
                    return;
                }
                
                const imageContainers = imageList.querySelectorAll('.image-container');
                console.log(`[SYNC] Processing ${imageContainers.length} legacy images`);
                
                let newImagesAdded = 0;
                
                imageContainers.forEach((container, index) => {
                    const img = container.querySelector('img');
                    const labelDiv = container.querySelector('.image-label');
                    const label = container.dataset.label;
                    
                    if (img && img.src) {
                        const imageData = {
                            src: img.src,
                            url: img.src,
                            name: labelDiv ? labelDiv.textContent : label || `Image ${index + 1}`,
                            label: label,
                            filename: labelDiv ? labelDiv.textContent : undefined
                        };
                        
                        // Check if this image is already in the gallery
                        const existingIndex = imageGalleryData.findIndex(item => item.src === img.src);
                        
                        if (existingIndex === -1) {
                            addImageToGallery(imageData, imageGalleryData.length);
                            console.log(`[SYNC] ✓ Added: ${imageData.name}`);
                            newImagesAdded++;
                        }
                    }
                });
                
                if (newImagesAdded > 0) {
                    console.log(`[SYNC] Added ${newImagesAdded} new images. Total: ${imageGalleryData.length}`);
                }
            }
            
            // Function to clear demo images
            function clearDemoImages() {
                console.log('[DEMO] Clearing demo images...');
                imageGalleryData = imageGalleryData.filter(item => !item.name?.includes('Demo Image') && !item.name?.includes('Blank Canvas'));
                
                // Manually update the gallery UI instead of calling undefined function
                const gallery = document.getElementById('imageGallery');
                const dots = document.getElementById('imageDots');
                
                if (gallery) {
                    // Remove demo image thumbnails
                    const demoThumbnails = gallery.querySelectorAll('.image-thumbnail');
                    demoThumbnails.forEach(thumb => {
                        const overlay = thumb.querySelector('.image-overlay');
                        if (overlay && (overlay.textContent.includes('Demo Image') || overlay.textContent.includes('Blank Canvas'))) {
                            thumb.remove();
                        }
                    });
                }
                
                if (dots) {
                    // Clear demo dots
                    const demoDots = dots.querySelectorAll('.nav-dot');
                    demoDots.forEach(dot => dot.remove());
                }
                
                // Update counter if function exists
                if (typeof updateImageCounter === 'function') {
                    updateImageCounter();
                } else {
                    // Update counter manually
                    const counter = document.getElementById('imageCounter');
                    if (counter) {
                        counter.textContent = imageGalleryData.length > 0 ? `${imageGalleryData.length} images` : '';
                    }
                }
                console.log('[DEMO] Demo images cleared, remaining images:', imageGalleryData.length);
            }
            
            // Removed manual sync button - syncing is now automatic
            
            // Test the gallery with some demo images after everything loads
            setTimeout(() => {
                console.log('[INIT] ===== Initial gallery setup =====');
                console.log('[INIT] imageGalleryData before sync:', imageGalleryData.length);
                
                // First, sync any existing legacy images
                console.log('[INIT] Step 1: Syncing existing legacy images...');
                syncLegacyImagesToGallery();
                
                console.log('[INIT] imageGalleryData after sync:', imageGalleryData.length);
                
                // Check if we have any real images (non-demo)
                const realImagesCount = imageGalleryData.filter(item => !item.name?.includes('Demo Image') && !item.name?.includes('Blank Canvas')).length;
                console.log('[INIT] Real images found:', realImagesCount);
                
                // Do not add demo/blank images; keep gallery empty until user adds/loads
                console.log(`[INIT] Skipping demo images. Real count: ${realImagesCount}`);
                
                // Test the addImageToSidebar function to see if hooking works
                if (window.addImageToSidebar) {
                    console.log('[TEST] addImageToSidebar function is available');
                } else {
                    console.log('[TEST] addImageToSidebar not available yet');
                }
                
                console.log('[INIT] ===== Initial setup complete =====');
                
                // Ensure we always start with the first image
                if (imageGalleryData.length > 0) {
                    console.log('[INIT] Navigating to first image (index 0)');
                    setTimeout(() => {
                        navigateToImage(0);
                        updateActiveImage(0);
                    }, 100); // Small delay to ensure everything is ready
                }
            }, 2000);
            
            // Track last known legacy count to avoid unnecessary syncs
            let lastLegacyCount = 0;
            
            // Also set up a periodic sync to catch any images that get added later (less frequent)
            setInterval(() => {
                const currentLegacyCount = document.getElementById('imageList')?.querySelectorAll('.image-container').length || 0;
                const currentRealImagesCount = imageGalleryData.filter(item => !item.name?.includes('Demo Image') && !item.name?.includes('Blank Canvas')).length;
                
                // Only sync if there's actually a change in legacy count
                if (currentLegacyCount > lastLegacyCount) {
                    console.log('[PERIODIC] New legacy images detected, syncing...');
                    console.log(`[PERIODIC] Legacy: ${currentLegacyCount} (was ${lastLegacyCount}), Gallery real: ${currentRealImagesCount}`);
                    
                    // No demo images are used anymore; skip clearing
                    
                    syncLegacyImagesToGallery();
                    
                    // After adding new images, ensure we start at the first one if we're not already there
                    if (currentImageIndex !== 0 && imageGalleryData.length > 0) {
                        console.log('[PERIODIC] Resetting to first image after adding new images');
                        setTimeout(() => {
                            navigateToImage(0);
                            updateActiveImage(0);
                        }, 200);
                    }
                    
                    lastLegacyCount = currentLegacyCount;
                }
            }, 2000);  // Check every 2 seconds instead of 1
        });
    </script>
    
    <!-- Scale Dropdown - positioned outside panel hierarchy -->
    <div id="scaleDropdown" class="fixed bg-white border border-gray-300 rounded shadow-lg hidden max-h-64 overflow-y-auto" style="z-index: 9999; min-width: 80px;">
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.1">10%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.15">15%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.2">20%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.25">25%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.33">33%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.5">50%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.67">67%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.75">75%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.8">80%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.9">90%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm bg-blue-50" data-scale="1" data-default="true">100%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.1">110%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.25">125%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.5">150%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.75">175%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="2">200%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="2.5">250%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="3">300%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="4">400%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="5">500%</div>
    </div>

    <script src="public/js/paint.js"></script>
    <script src="public/js/project-manager.js"></script>
    <script src="public/js/tag-manager.js"></script>
</body>
</html>