<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenPaint</title>
    <script>
        // Toolbar initialization - MUST run first to set data-toolbar-mode before CSS renders
        (function() {
            document.documentElement.classList.add('app-loading');
            const windowWidth = window.innerWidth || 1920;
            const isMobile = windowWidth <= 768;
            const toolbarMode = isMobile ? 'compact' : 'full';
            document.documentElement.setAttribute('data-toolbar-mode', toolbarMode);
            document.documentElement.setAttribute('data-toolbar-initial', toolbarMode);
        })();
    </script>
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/tailwind.build.css" />
    <script>
        // Suppress autofill extension errors
        window.addEventListener('error', (event) => {
            if (event.message && event.message.includes('autofill.bundle.js')) {
                event.preventDefault();
                return false;
            }
        });
    </script>
    <style>
        /* Custom styles for image list and tag system */
        .image-container {
            border-left: 2px solid transparent;
            transition: all 0.2s ease;
        }
        
        .image-container:hover {
            border-left-color: #3b82f6;
            background-color: #f8fafc;
        }
        
        .image-container[aria-selected="true"] {
            border-left-color: #3b82f6;
            background-color: #eff6ff;
        }
        
        .tag-badge {
            display: inline-block;
            background-color: #e0e7ff;
            color: #3730a3;
            font-size: 10px;
            font-weight: 500;
            padding: 2px 6px;
            border-radius: 6px;
            line-height: 1;
        }
        
        .no-tags {
            font-size: 10px;
            color: #9ca3af;
            font-style: italic;
        }
        
        .image-label:hover {
            background-color: #f1f5f9 !important;
        }

        /* Modern slider styling (align with original OpenPaint) */
        .slider {
            --accent: #3b82f6;
            --p: 0;            /* 0..1 progress (set by JS) */
            --filled: 30%;     /* legacy percent for compatibility */
            --track-h: 6px;    /* track height */
            --thumb: 16px;     /* thumb diameter (px) */
            /* align fill end exactly under thumb center across browsers */
            --pos: calc((var(--p) * (100% - var(--thumb))) + (var(--thumb) / 2));
            -webkit-appearance: none;
            appearance: none;
            outline: none;
            border-radius: 9999px;
            height: var(--track-h);
            background: transparent; /* let track draw the background */
        }

        /* WebKit/Blink track + thumb */
        .slider::-webkit-slider-runnable-track {
            height: var(--track-h);
            border-radius: 9999px;
            background: linear-gradient(
                to right,
                var(--accent) 0,
                var(--accent) var(--pos),
                #e5e7eb   var(--pos),
                #e5e7eb 100%
            );
            }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: var(--thumb);
            height: var(--thumb);
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            /* keep a subtle depth but pull the blue glow inside the thumb */
            box-shadow: inset 0 0 0 3px rgba(59, 130, 246, 0.45), 0 1px 2px rgba(0, 0, 0, 0.07);
            transition: all 0.2s ease;
            /* center the thumb on a thin track */
            margin-top: calc((var(--track-h) - var(--thumb)) / 2);
        }

        

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.08);
            box-shadow: inset 0 0 0 4px rgba(59, 130, 246, 0.55), 0 2px 3px rgba(0, 0, 0, 0.08);
        }

        /* Firefox track + thumb + progress */
        .slider::-moz-range-track {
            height: var(--track-h);
            border-radius: 9999px;
            background: #e5e7eb;
        }

        .slider::-moz-range-progress {
            height: var(--track-h);
            border-radius: 9999px;
            background: var(--accent);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
            box-shadow: inset 0 0 0 3px rgba(59, 130, 246, 0.45), 0 1px 2px rgba(0, 0, 0, 0.07);
            transition: all 0.2s ease;
        }

        .slider::-moz-range-thumb:hover {
            transform: scale(1.08);
            box-shadow: inset 0 0 0 4px rgba(59, 130, 246, 0.55), 0 2px 3px rgba(0, 0, 0, 0.08);
        }
        
        /* Match original OpenPaint slider width */
        #brushSize { width: 120px; margin: 0; }

        /* Remove native focus outline while keeping custom inset ring */
        .slider { -webkit-tap-highlight-color: transparent; }
        .slider:focus, .slider:focus-visible { outline: none !important; box-shadow: none; }
        .slider::-moz-focus-outer { border: 0; }
    </style>
    
    <!-- Loading optimization and debug gate -->
    <style>
        /* Hide UI until initialization completes to prevent flash */
        .app-loading body { 
            visibility: hidden !important; 
        }
        
        /* Hide toolbar completely until ready - prevents any flicker */
        #topToolbar:not(.toolbar-ready) {
            display: none !important; /* Completely remove from layout */
        }
        
        /* Show toolbar only when ready */
        #topToolbar.toolbar-ready {
            display: block !important;
            opacity: 1 !important;
            visibility: visible !important;
            transition: none !important; /* Disable transitions during initialization to prevent flicker */
        }
        
        /* After initialization completes, enable smooth transitions */
        #topToolbar.toolbar-ready.toolbar-stable {
            transition: opacity 0.2s ease, visibility 0s;
        }
        
        /* Panels load immediately - no hiding during app-loading */
        /* They start expanded and visible by default */
        
        /* Ensure stable toolbar layout from the start */
        #topToolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 40;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-bottom: 1px solid rgb(226, 232, 240);
            height: 48px;
        }
        
        .toolbar-wrap {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 48px;
        }
        
        #tbLeft, #tbCenter, #tbRight {
            position: relative;
            display: flex;
            align-items: center;
            flex-shrink: 0; /* Prevent shrinking that causes layout shifts */
            min-width: 0; /* Allow flex items to shrink below content size if needed */
        }
        
        /* Stabilize button widths to prevent jumping */
        #tbLeft .tbtn, #tbRight .tbtn {
            min-width: fit-content; /* Ensure buttons don't collapse */
            white-space: nowrap; /* Prevent text wrapping */
        }
        
        /* Ensure label spans don't cause width changes */
        .label-long, .label-short {
            display: inline-block; /* Use inline-block for more stable layout */
            white-space: nowrap;
        }

        /* Mobile: Make toolbar horizontally scrollable by default */
        @media (max-width: 768px) {
            .toolbar-wrap {
                overflow-x: auto;
                overflow-y: hidden;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
                scrollbar-color: rgba(148, 163, 184, 0.5) transparent;
                justify-content: flex-start;
                gap: 12px;
                padding: 0 8px;
                position: relative;
                cursor: pointer;
            }
            
            .toolbar-wrap::-webkit-scrollbar {
                height: 4px;
            }
            
            .toolbar-wrap::-webkit-scrollbar-track {
                background: transparent;
            }
            
            .toolbar-wrap::-webkit-scrollbar-thumb {
                background: rgba(148, 163, 184, 0.5);
                border-radius: 2px;
            }
            
            .toolbar-wrap::-webkit-scrollbar-thumb:hover {
                background: rgba(148, 163, 184, 0.7);
            }
            
            /* Prevent toolbar groups from wrapping in scrollable mode */
            .toolbar-wrap:not(.expanded) #tbLeft,
            .toolbar-wrap:not(.expanded) #tbCenter,
            .toolbar-wrap:not(.expanded) #tbRight {
                flex-shrink: 0;
                flex-wrap: nowrap;
            }
            
            /* Ensure buttons don't shrink in scrollable mode */
            .toolbar-wrap:not(.expanded) .tbtn,
            .toolbar-wrap:not(.expanded) .tinput,
            .toolbar-wrap:not(.expanded) .color-swatches,
            .toolbar-wrap:not(.expanded) .slider {
                flex-shrink: 0;
            }
            
            /* Expanded/wrapped mode - up to 5 rows */
            .toolbar-wrap.expanded {
                overflow-x: visible;
                overflow-y: visible;
                flex-wrap: wrap;
                align-content: flex-start;
                height: auto;
                max-height: calc(5 * (32px + 6px)); /* 5 rows: button height + gap */
                padding: 8px;
                gap: 6px;
            }
            
            /* In expanded mode, flatten groups so items wrap together */
            .toolbar-wrap.expanded #tbLeft,
            .toolbar-wrap.expanded #tbCenter,
            .toolbar-wrap.expanded #tbRight {
                flex-wrap: wrap;
                flex-shrink: 1;
                gap: 6px;
                display: contents; /* Flatten structure so items wrap together */
            }
            
            /* Ensure items maintain spacing in expanded mode */
            .toolbar-wrap.expanded .group-gap > * {
                margin-right: 6px;
                margin-bottom: 0;
            }
            
            .toolbar-wrap.expanded .tbtn,
            .toolbar-wrap.expanded .tinput,
            .toolbar-wrap.expanded .color-swatches,
            .toolbar-wrap.expanded .slider {
                flex-shrink: 0;
            }
            
            /* Visual indicator at bottom for tap area */
            .toolbar-wrap::after {
                content: '';
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                height: 8px;
                background: linear-gradient(to top, rgba(148, 163, 184, 0.1), transparent);
                pointer-events: none;
                opacity: 0.5;
                transition: opacity 0.2s;
            }
            
            .toolbar-wrap.expanded::after {
                opacity: 0;
            }
            
            /* Blue glow animation when expandable */
            @keyframes blueGlow {
                0%, 100% {
                    box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
                }
                50% {
                    box-shadow: 0 0 12px 4px rgba(59, 130, 246, 0.6);
                }
            }
            
            .toolbar-wrap.expandable {
                animation: blueGlow 0.5s ease-in-out;
                animation-fill-mode: none; /* Don't persist animation state */
            }
            
            .toolbar-wrap.tapped {
                animation: blueGlow 1s ease-in-out;
                animation-fill-mode: none; /* Don't persist animation state */
            }
            
            /* Glow on hover only if expandable (when scrollable) */
            .toolbar-wrap:not(.expanded)[data-scrollable="true"]:hover:not(.no-glow) {
                box-shadow: 0 0 12px 4px rgba(59, 130, 246, 0.6);
                transition: box-shadow 0.2s ease-in-out;
            }
            
            /* Ensure no glow when not hovering (even if scrollable) */
            .toolbar-wrap:not(.expanded)[data-scrollable="true"]:not(:hover):not(.expandable):not(.tapped) {
                box-shadow: none !important;
            }
            
            /* Force no glow when no-glow class is present */
            .toolbar-wrap.no-glow {
                box-shadow: none !important;
            }
        }

        .group-gap > * {
            margin-right: 6px;
        }
        
        .group-gap > *:last-child {
            margin-right: 0;
        }
        
        /* Ensure all toolbar buttons have consistent sizing */
        .tbtn {
            height: 32px;
            padding: 0 10px;
            border-radius: 8px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid rgba(148, 163, 184, 0.6);
            background: #fff;
            font-size: 12px;
            line-height: 1;
            transition: all 0.15s ease;
            white-space: nowrap;
        }
        
        .tinput {
            height: 32px;
            padding: 0 10px;
            border-radius: 8px;
            border: 1px solid rgba(148, 163, 184, 0.6);
            background: #fff;
            font-size: 12px;
            line-height: 1;
            transition: all 0.15s ease;
        }
        
        .icon-btn {
            width: 32px;
            justify-content: center;
            padding: 0;
        }
        
        /* Specific button styles to prevent layout shifts */
        #paste {
            padding: 8px 16px;
            background: rgb(59, 130, 246);
            color: white;
            font-weight: 600;
            border-radius: 12px;
            border: none;
        }
        
        #clear {
            padding: 8px 16px;
            background: rgb(239, 68, 68);
            color: white;
            font-weight: 600;
            border-radius: 12px;
            border: none;
        }
        
        #drawingModeToggle {
            padding: 8px 16px;
            background: white;
            color: rgb(34, 197, 94);
            font-weight: 600;
            border-radius: 12px;
            border: 2px solid rgb(34, 197, 94);
        }
        
        #projectName {
            width: 140px;
            padding: 8px 12px;
            border: 1px solid rgb(209, 213, 219);
            border-radius: 12px;
            background: white;
            font-size: 14px;
        }
        
        #loadProject {
            padding: 8px 16px;
            background: white;
            color: rgb(51, 65, 85);
            font-weight: 600;
            border-radius: 12px;
            border: 1px solid rgb(209, 213, 219);
            font-size: 12px;
        }
        
        #saveProjectTop {
            padding: 8px 16px;
            background: rgb(59, 130, 246);
            color: white;
            font-weight: 700;
            border-radius: 12px;
            border: 1px solid rgb(37, 99, 235);
            font-size: 14px;
        }
        
        #updateShareBtn {
            padding: 6px 12px;
            background: rgb(14, 165, 233);
            color: white;
            font-weight: 600;
            border-radius: 12px;
            border: 1px solid rgb(2, 132, 199);
            margin-left: 8px;
        }
        
        #unitToggleBtn {
            padding: 6px 12px;
            background: white;
            color: rgb(51, 65, 85);
            font-weight: 600;
            border-radius: 12px;
            border: 1px solid rgb(209, 213, 219);
        }
        
        /* Color swatches */
        .color-swatches {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .color-swatches button {
            width: 20px;
            height: 20px;
            border-radius: 9999px;
            border: 2px solid white;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
            margin: 0;
            padding: 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .color-swatches button:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.12);
        }
        

        
        /* Responsive text labels */
        .label-long {
            display: inline-block;
            white-space: nowrap;
        }
        
        .label-short {
            display: none;
            white-space: nowrap;
        }
        
        @media (max-width: 768px) {
            .label-long {
                display: none;
            }

            .label-short {
                display: inline-block;
            }

            /* Constrain panel widths on mobile to trigger scrolling */
            #toolsPanel {
                max-width: calc(100vw - 2rem);
                left: 1rem !important;
            }

            #canvasControls {
                max-width: calc(100vw - 2rem);
                overflow-x: auto;
                overflow-y: hidden;
                -webkit-overflow-scrolling: touch;
            }

            /* Enable horizontal scrolling for panel content on mobile */
            #toolsPanelContent,
            #canvasControlsContent {
                overflow-x: auto !important;
                overflow-y: visible !important;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
                flex-wrap: nowrap !important;
            }
            
            /* Ensure buttons don't shrink */
            #canvasControlsContent > * {
                flex-shrink: 0;
            }

            /* Prevent wrapping on flex rows inside panels */
            #toolsPanelContent .flex.items-center,
            #toolsPanelContent > div,
            #canvasControlsContent.flex {
                flex-wrap: nowrap !important;
            }

            /* Ensure buttons don't shrink */
            #toolsPanelContent button,
            #canvasControlsContent button,
            #canvasControlsContent select {
                flex-shrink: 0;
            }

            /* Hide scrollbars for cleaner look */
            #toolsPanelContent::-webkit-scrollbar,
            #canvasControlsContent::-webkit-scrollbar {
                height: 4px;
            }

            #toolsPanelContent::-webkit-scrollbar-thumb,
            #canvasControlsContent::-webkit-scrollbar-thumb {
                background: rgba(0, 0, 0, 0.2);
                border-radius: 2px;
            }
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        /* Fullscreen canvas styles */
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 5; /* Above background (z-1) but below UI panels (z-30) */
            cursor: crosshair;
            background: #f8f9fa;
            touch-action: none; /* Prevent scrolling on touch devices */
        }
        
        /* Fabric.js wrappers need the same fullscreen treatment */
        .canvas-container,
        .canvas-container canvas {
            position: fixed !important;
            top: 0;
            left: 0;
            width: 100vw !important;
            height: 100vh !important;
        }
        
        .canvas-container {
            z-index: 5;
            pointer-events: none; /* Upper canvas will capture events */
        }
        
        .canvas-container .lower-canvas {
            z-index: 5;
        }
        
        .canvas-container .upper-canvas {
            z-index: 6;
            pointer-events: auto;
        }
        
        /* Keep placeholder content visible without needing to scroll */
        #frame-capture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            min-height: 100vh;
            z-index: 7;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }
        
        #frame-content {
            pointer-events: auto;
        }

        /* Fabric.js containers ensure event surface aligns with original canvas */
        .canvas-container,
        .canvas-container canvas {
            position: fixed !important;
            top: 0;
            left: 0;
            width: 100vw !important;
            height: 100vh !important;
        }

        .canvas-container {
            z-index: 5;
            pointer-events: none; /* let upper canvas capture events */
        }

        .canvas-container .upper-canvas {
            z-index: 6;
            pointer-events: auto;
        }

        .canvas-container .lower-canvas {
            z-index: 5;
        }

        /* Frame capture placeholder sits centered behind canvas */
        #frame-capture {
            position: absolute;
            inset: 0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 2;
        }

        #frame-content {
            pointer-events: auto;
        }
        
        /* Modern floating panel base styles */
        .floating-panel {
            backdrop-filter: blur(20px);
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1), 
                       0 4px 6px -2px rgba(0, 0, 0, 0.05),
                       0 0 0 1px rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .floating-panel:hover {
            background: rgba(255, 255, 255, 0.99);
        }
        
        /* Only apply hover transform to main panels, not side panels */
        #projectPanel:hover,
        #toolsPanel:hover,
        #canvasControls:hover {
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            transform: translateY(-1px);
        }
        
        .floating-panel.dragging {
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            transform: none !important;
            transition: none !important;
        }
        
        /* Modern capture frame styles */
        #captureOverlay {
            backdrop-filter: none;
        }
        
        .capture-frame {
            background: transparent;
            transition: none !important;
        }
        
        .capture-frame.locked {
            cursor: default;
        }
        
        .capture-frame.unlocked {
            cursor: move;
        }
        
        /* Capture frame dragging - no transitions for 1:1 movement */
        .capture-frame.dragging {
            transition: none !important;
        }
        
        /* Modern resize handles - smaller and more discrete */
        .resize-handle {
            position: absolute;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        
        .capture-frame.unlocked:hover .resize-handle,
        .capture-frame.unlocked .resize-handle:hover {
            opacity: 1;
        }
        
        .resize-handle:hover {
            transform: scale(1.3);
            background: #3b82f6 !important;
            border-color: white !important;
        }
        
        /* Dark overlay - no transitions for instant response */
        #darkOverlay {
            transition: none;
        }
        
        /* macOS style popup */
        #lockPopup {
            font-size: 14px;
            font-weight: 500;
        }
        
        #lockPopup.show {
            display: flex !important;
            animation: fadeInOut 1.5s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        
        /* Lock button states */
        #captureLockButton .locked-icon {
            display: none;
        }
        
        #captureLockButton .unlocked-icon {
            display: block;
        }
        
        #captureLockButton.locked .locked-icon {
            display: block;
        }
        
        #captureLockButton.locked .unlocked-icon {
            display: none;
        }
        
        /* Hide resize handles when locked */
        .capture-frame.locked .resize-handles {
            display: none;
        }
        
        /* Drag over canvas effects */
        #canvas.drag-over {
            background: rgba(76, 175, 80, 0.05);
        }
        
        /* Panel minimization styles */
        .floating-panel.minimized {
            max-height: none !important;
            height: auto !important; /* Override any inline height when minimized */
        }
        
        .floating-panel.minimized .cursor-move {
            border-bottom: none;
        }
        
        /* When elementsBody is hidden, ensure panel shrinks to header only */
        #strokePanel:has(#elementsBody.hidden) {
            height: auto !important;
        }
        
        #imagePanel:has(#imagePanelContent.hidden) {
            height: auto !important;
            min-height: 140px !important; /* Header + name box + some padding */
        }
        
        /* Ensure entire panels load simultaneously - no sequential loading */
        #imagePanel,
        #strokePanel {
            display: flex;
            flex-direction: column !important;
        }
        
        /* Ensure all panel parts load together (no header-first loading) */
        #imagePanelHeader,
        #imagePanel > .px-3.bg-white.border-b.border-slate-200.py-2,
        #imagePanelContent,
        #elementsHeader,
        #elementsBody {
            visibility: visible;
            opacity: 1;
        }
        
        /* Disable transitions on initial load to prevent sequential appearance */
        #imagePanel:not([data-loaded]),
        #strokePanel:not([data-loaded]) {
            transition: none !important;
        }
        
        #imagePanelContent:not([data-loaded]),
        #elementsBody:not([data-loaded]) {
            transition: none !important;
        }

        /* Ensure image name header is always visible and not squished */
        #imagePanel > .px-3.bg-white.border-b.border-slate-200.py-2 {
            flex-shrink: 0 !important;
            min-height: 60px !important;
            position: relative !important;
            z-index: 10 !important;
            display: block !important;
        }

        /* Ensure the image name input is always visible */
        #currentImageNameBox {
            display: block !important;
            width: 100% !important;
        }

        /* On mobile, allow JavaScript to control visibility */
        @media (max-width: 768px) {
            #imagePanel[style*="display: none"] {
                display: none !important;
            }
        }

        /* Ensure content area doesn't affect header visibility */
        #imagePanelContent {
            flex: 1 1 auto !important;
            min-height: 0 !important;
            overflow: hidden !important;
        }

        /* Panel toggle icons for mobile */
        .panel-toggle-icon {
            position: fixed;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            display: none; /* Hidden by default, shown via JS on mobile */
            align-items: center;
            justify-content: center;
            font-size: 28px;
            cursor: pointer;
            z-index: 10100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
            pointer-events: auto;
            opacity: 0; /* Start hidden to prevent pop-in */
        }
        
        /* Smooth fade-in when shown */
        .panel-toggle-icon[style*="display: flex"] {
            opacity: 1;
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .panel-toggle-icon:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .panel-toggle-icon:active {
            transform: scale(0.95);
        }

        #strokePanelIcon {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #imagePanelIcon {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        /* Position when minimized */
        #strokePanelIcon.minimized {
            left: 1rem;
            bottom: 5rem;
            top: auto;
        }

        #imagePanelIcon.minimized {
            right: 1rem;
            bottom: 5rem;
            top: auto;
        }
        
        /* Mobile: Position canvasControls above the panel toggle icons */
        @media (max-width: 768px) {
            #canvasControls {
                bottom: calc(5rem + 56px + 1rem) !important; /* Above icons (5rem) + icon height (56px) + spacing (1rem) */
                left: 50% !important;
                transform: translateX(-50%) !important;
            }
        }

        /* Position when expanded */
        #strokePanelIcon.expanded {
            left: 0.5rem;
            top: 0.5rem;
            bottom: auto;
        }

        #imagePanelIcon.expanded {
            right: 0.5rem;
            top: 0.5rem;
            left: auto;
            bottom: auto;
        }

        /* Minimal Numeric Pill Strip Styling */
        #mini-stepper {
            scrollbar-width: none;
            -ms-overflow-style: none;
            min-height: 60px;
        }

        #mini-stepper::-webkit-scrollbar {
            display: none;
        }

        /* Navigation container styling - Always visible, independent of panel state */
        #navigation-container {
            background: white;
            box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
            position: fixed !important;
            bottom: 0 !important;
            left: 0 !important;
            right: 0 !important;
            z-index: 5000 !important;
            width: 100% !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Ensure navigation container stays visible even when imagePanel is minimized */
        #imagePanel.minimized ~ #navigation-container,
        #imagePanel:has(#imagePanelContent.hidden) ~ #navigation-container,
        body:has(#imagePanel.minimized) #navigation-container,
        body:has(#imagePanel:has(#imagePanelContent.hidden)) #navigation-container {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Ensure the navigation strip is always visible */
        nav[aria-label="Image quick nav"] {
            display: block !important;
            visibility: visible !important;
        }
        
        /* Ensure navigation container is never affected by panel collapse */
        #navigation-container,
        #navigation-container * {
            pointer-events: auto !important;
        }

        #mini-stepper .step {
            min-width: 2rem;
            min-height: 2rem;
            border: 1px solid transparent;
            cursor: pointer;
            position: relative;
            z-index: 10;
        }

        #mini-stepper .step:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 20;
        }

        #mini-stepper .step:focus {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
            z-index: 20;
        }

        #mini-stepper .step[aria-current="true"] {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            z-index: 20;
        }

        /* Ensure pills are always clickable */
        #mini-stepper button {
            pointer-events: auto !important;
            user-select: none;
            cursor: pointer;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }

        /* Ensure stepper is always visible - independent of panel state */
        #mini-stepper {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        
        /* Ensure stepper stays visible when imagePanel is minimized */
        #imagePanel.minimized ~ #navigation-container #mini-stepper,
        #imagePanel:has(#imagePanelContent.hidden) ~ #navigation-container #mini-stepper,
        body:has(#imagePanel.minimized) #mini-stepper,
        body:has(#imagePanel:has(#imagePanelContent.hidden)) #mini-stepper {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Ensure frame capture container allows scrolling */
        #frame-capture {
            scroll-behavior: smooth;
        }

        /* Section styling for better visual separation */
        #frame-capture section {
            scroll-margin-top: 2rem;
        }

        /* Responsive adjustments for mobile */
        @media (max-width: 768px) {
            #mini-stepper .step {
                min-width: 2.5rem;
                min-height: 2.5rem;
                font-size: 0.875rem;
            }

            #mini-stepper {
                gap: 0.75rem;
                padding-left: 1rem;
                padding-right: 1rem;
            }
        }
        
        /* Smooth transitions for all panel content */
        .floating-panel [id$='Content'],
        .floating-panel [id$='Controls'],
        #elementsBody {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }
        
        .floating-panel [id$='Content'].hidden,
        .floating-panel [id$='Controls'].hidden,
        #elementsBody.hidden {
            max-height: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-top: 0 !important;
            margin-bottom: 0 !important;
            opacity: 0;
        }
        
        /* Enhanced button hover effects */
        .floating-panel button[id^='toggle']:hover svg {
            transform: scale(1.1);
        }
        
        /* Make canvasControls scrollable on all screen sizes */

        
        #canvasControls::-webkit-scrollbar {
            height: 4px;
        }
        
        #canvasControls::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #canvasControls::-webkit-scrollbar-thumb {
            background: rgba(148, 163, 184, 0.5);
            border-radius: 2px;
        }
        
        #canvasControls::-webkit-scrollbar-thumb:hover {
            background: rgba(148, 163, 184, 0.7);
        }
        
        /* Allow overflow for canvas controls to show hover menu and enable scrolling */
        #canvasControlsContent { 
            /* Overflow handled by media query for mobile */
            flex-wrap: nowrap !important;
            min-width: max-content;
            /* Override generic panel overflow to allow dropdowns */
            overflow: visible !important;
        }
        
        #canvasControlsContent::-webkit-scrollbar {
            height: 4px;
        }
        
        #canvasControlsContent::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #canvasControlsContent::-webkit-scrollbar-thumb {
            background: rgba(148, 163, 184, 0.5);
            border-radius: 2px;
        }
        
        #canvasControlsContent::-webkit-scrollbar-thumb:hover {
            background: rgba(148, 163, 184, 0.7);
        }
        
        /* Ensure buttons and controls don't shrink */
        #canvasControlsContent > * {
            flex-shrink: 0;
        }
        
        /* Note: overflow-x: auto takes precedence for horizontal scrolling */
        /* Vertical overflow remains visible for dropdown menus */
        
        /* STEP 2: CSS variants - Use data-toolbar-mode to control label display */
        /* 
         * Toolbar Label Sizing System:
         * 
         * This system uses a global data-toolbar-mode attribute on <html> to control
         * toolbar label display, preventing flicker and pop-in during page load.
         * 
         * How it works:
         * 1. Early script (in <head>) sets data-toolbar-mode='full' or 'compact' based on viewport width
         * 2. CSS reads this attribute to show/hide .label-long and .label-short spans
         * 3. JS fallback recalculates after fonts load and on window resize
         * 4. ResizeObserver is disabled for toolbar containers to prevent flicker loops
         * 
         * Benefits:
         * - No DOM rewrites (only attribute changes)
         * - CSS handles display immediately (no JS delay)
         * - Prevents flicker by determining size before toolbar becomes visible
         * - Works on both desktop and mobile
         */
        /* Base state: show long labels, hide short labels */
        .label-long { 
            display: inline-block;
            white-space: nowrap;
        }
        .label-short { 
            display: none;
            white-space: nowrap;
        }
        
        /* When toolbar mode is 'compact', show short labels instead */
        [data-toolbar-mode="compact"] .smart-label-scope .label-long,
        [data-toolbar-mode="compact"] .toolbar-wrap .label-long {
            display: none !important;
        }
        [data-toolbar-mode="compact"] .smart-label-scope .label-short,
        [data-toolbar-mode="compact"] .toolbar-wrap .label-short {
            display: inline-block !important;
        }
        
        /* When toolbar mode is 'full', ensure full labels show (override any compact classes) */
        [data-toolbar-mode="full"] .smart-label-scope .label-long,
        [data-toolbar-mode="full"] .toolbar-wrap .label-long,
        [data-toolbar-mode="full"] .smart-label-scope.compact .label-long,
        [data-toolbar-mode="full"] .toolbar-wrap.compact .label-long {
            display: inline-block !important;
        }
        [data-toolbar-mode="full"] .smart-label-scope .label-short,
        [data-toolbar-mode="full"] .toolbar-wrap .label-short,
        [data-toolbar-mode="full"] .smart-label-scope.compact .label-short,
        [data-toolbar-mode="full"] .toolbar-wrap.compact .label-short {
            display: none !important;
        }
        
        /* Legacy support: Keep old compact class behavior for non-toolbar elements */
        .smart-label-scope.compact:not(.toolbar-wrap):not([id^="tb"]) .label-long { 
            display: none; 
        }
        .smart-label-scope.compact:not(.toolbar-wrap):not([id^="tb"]) .label-short { 
            display: inline-block; 
        }
        
        /* Button width reservations to prevent layout shift */
        #paste {
            min-width: 60px; /* "Upload" short label width */
            max-width: 140px; /* "Upload Images" long label width */
        }
        #saveProjectTop {
            min-width: 50px; /* "Save" short label width */
            max-width: 120px; /* "Save Project" long label width */
        }
        #loadProject {
            min-width: 50px; /* "Load" short label width */
            max-width: 120px; /* "Load Project" long label width */
        }
        #exportAISVG {
            min-width: 70px; /* "AI SVG" short label width */
            max-width: 130px; /* "AI SVG Export" long label width */
        }
        #drawingModeToggle {
            min-width: 70px; /* "Straight" short label width */
            max-width: 120px; /* "Straight Line" long label width */
        }
        #textModeToggle {
            min-width: 40px; /* "Text" short label width */
            max-width: 60px; /* "Text" long label width */
        }
        #projectName {
            min-width: 100px;
            max-width: 200px;
        }
        
        /* Text mode active state */
        .text-mode-active {
            background: #3b82f6 !important;
            color: white !important;
            border-color: #2563eb !important;
        }
        
        /* Active state for minimized panels */
        .floating-panel.minimized {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);
        }

        /* Enhanced arrow button styling */
        #startArrow.active, #endArrow.active,
        #arrowStartBtn.active, #arrowEndBtn.active {
            background: linear-gradient(135deg, #3b82f6, #2563eb) !important;
            color: white !important;
            transform: scale(1.05) !important;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4) !important;
            border: 2px solid #1d4ed8 !important;
            font-weight: 600 !important;
        }

        #startArrow.active:hover, #endArrow.active:hover,
        #arrowStartBtn.active:hover, #arrowEndBtn.active:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8) !important;
            transform: scale(1.08) !important;
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.5) !important;
        }

        /* Arrow button transitions */
        #startArrow, #endArrow, #arrowStartBtn, #arrowEndBtn {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
        }
        
        .floating-panel:not(.minimized) {
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        /* Ensure proper dragging behavior */
        .floating-panel.dragging {
            z-index: 9999 !important;
            transform: none !important;
            transition: none !important;
        }

        /* Keep Elements header always visible; body uses remaining space */
        #strokePanel {
            display: flex;
            flex-direction: column;
            /* Let the panel grow to near full viewport height while preserving drag behavior */
            max-height: calc(100vh - 24px) !important;
        }
        #elementsHeader {
            flex: 0 0 auto;
        }
        #elementsBody {
            flex: 1 1 auto;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        /* removed elementsResizeHandle */
        #elementsControls {
            position: sticky;
            top: 0;
            z-index: 10;
            background: white;
        }
        #strokeVisibilityControls {
            flex: 1 1 auto;
            min-height: 0; /* allows flex child to shrink for scrolling in Firefox */
            overflow-y: auto !important;
            /* Remove transition that causes flickering */
            transition: none !important;
        }
        
        /* Header dragging styles */
        .cursor-move:active {
            cursor: grabbing !important;
        }
        
        /* Fix stroke visibility item layout */
        .stroke-visibility-item {
            display: flex !important;
            align-items: center !important;
            gap: 8px !important;
            padding: 8px !important;
            margin-bottom: 4px !important;
            background: white !important;
            border-radius: 6px !important;
            border: 1px solid #e5e7eb !important;
            transition: all 0.2s ease !important;
        }

        /* Ensure the strokes list flows vertically and doesn't overlap */
        #strokesList { display: flex; flex-direction: column; gap: 6px; }
        .stroke-actions-panel { display: block; margin: 6px 0; }
        .stroke-actions-buttons { display: flex; gap: 8px; flex-wrap: wrap; }

        /* Make the strokes area adjustable but constrained so new items never overlap headers */
        #strokeVisibilityControls {
            min-height: 60px;
            max-height: min(60vh, 24rem) !important; /* cap to viewport or panel max-h-96 */
            overflow-y: auto !important;
            overflow-x: hidden !important;
            box-sizing: border-box;
            position: relative;
        }
        #strokeVisibilityControls hr { margin: 6px 0; }
        
        .stroke-visibility-item:hover {
            background-color: #f9fafb !important;
            border-color: #d1d5db !important;
        }
        
        .stroke-label-container {
            display: flex !important;
            align-items: center !important;
            gap: 6px !important;
            flex: 1 !important;
        }
        
        .stroke-name {
            font-weight: 600 !important;
            font-size: 14px !important;
            padding: 2px 6px !important;
            border-radius: 4px !important;
            border: 1px solid currentColor !important;
            min-width: auto !important;
        }
        
        .stroke-label-toggle-btn {
            background: none !important;
            border: none !important;
            cursor: pointer !important;
            font-size: 16px !important;
            line-height: 1 !important;
            padding: 2px !important;
            opacity: 0.8 !important;
        }
        
        .stroke-label-toggle-btn:hover {
            opacity: 1 !important;
        }
        
        .stroke-measurement {
            font-size: 13px !important;
            color: #6b7280 !important;
            font-weight: 500 !important;
            user-select: text !important;
            cursor: pointer !important;
            padding: 1px 4px !important;
            border-radius: 3px !important;
            transition: background-color 0.2s !important;
            min-width: 30px !important;
            display: inline-block !important;
            text-align: center !important;
            min-height: 20px !important;
            vertical-align: middle !important;
        }

        .stroke-measurement.empty-measurement {
            border: 1px solid #d1d5db !important; /* Grey outline */
        }

        .stroke-measurement:focus,
        .stroke-measurement[contenteditable="true"] {
            outline: none !important;
            border: 1px solid #3b82f6 !important; /* Blue outline */
            box-shadow: 0 0 0 1px #3b82f6 !important;
            background-color: white !important;
        }

        .stroke-measurement:hover {
            background-color: #f3f4f6 !important;
            color: #374151 !important;
        }
        
        .stroke-delete-btn {
            background: none !important;
            border: none !important;
            color: #ef4444 !important;
            cursor: pointer !important;
            font-size: 16px !important;
            font-weight: bold !important;
            padding: 2px 6px !important;
            border-radius: 4px !important;
            opacity: 0.7 !important;
            transition: all 0.2s ease !important;
        }
        
        .stroke-delete-btn:hover {
            opacity: 1 !important;
            background-color: #fef2f2 !important;
        }
        
        /* Force scrollbars to always show when content overflows */
        #strokeVisibilityControls {
            scroll-behavior: smooth;
            overflow-y: scroll !important;
            scrollbar-width: auto !important;
            scrollbar-color: #9ca3af #f3f4f6 !important;
        }
        
        /* Ensure outer image panel content never scrolls; inner #imageList handles scrolling */
        #imagePanelContent { 
            overflow: hidden !important; 
        }
        
        #strokeVisibilityControls::-webkit-scrollbar {
            width: 8px !important;
            display: block !important;
        }
        
        #strokeVisibilityControls::-webkit-scrollbar-track {
            background: #f3f4f6 !important;
            border-radius: 4px !important;
        }
        
        #strokeVisibilityControls::-webkit-scrollbar-thumb {
            background: #9ca3af !important;
            border-radius: 4px !important;
            border: 1px solid #f3f4f6 !important;
        }
        
        #strokeVisibilityControls::-webkit-scrollbar-thumb:hover {
            background: #6b7280 !important;
        }
        
        /* Keep focus treatment tidy */
        #brushSize:focus-visible {
            outline: none;
            box-shadow: 0 0 0 4px rgba(59,130,246,0.15);
        }
        
        /* Modern input styling */
        input[type="text"], input[type="number"], select {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px #3b82f6, 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Enhanced color picker active state */
        [data-color].active {
            border-color: #1f2937 !important;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 1), 0 0 0 6px #1f2937 !important;
            transform: scale(1.15);
        }

        /* Image Gallery Styling */
        #imageGallery {
            scrollbar-width: thin;
            scrollbar-color: #cbd5e1 #f1f5f9;
        }
        
        #imageGallery::-webkit-scrollbar {
            height: 6px;
        }
        
        #imageGallery::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        
        #imageGallery::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        
        #imageGallery::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        
        /* Image thumbnail styling */
        .image-thumbnail {
            flex-shrink: 0;
            width: 120px;
            height: 120px;
            border-radius: 12px;
            border: 2px solid transparent;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            scroll-snap-align: center;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
            overflow: hidden;
        }
        
        .image-thumbnail:hover {
            border-color: #cbd5e1;
            transform: scale(1.05);
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1);
        }
        
        .image-thumbnail.active {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2), 0 10px 25px -3px rgba(0, 0, 0, 0.15);
            transform: scale(1.05);
        }
        
        .image-thumbnail.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
            z-index: 1000;
        }
        
        .image-thumbnail.drag-over {
            border-color: #10b981;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.5);
            transform: translateY(-1px) scale(1.05);
        }
        
        .image-thumbnail .image-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
            color: white;
            padding: 8px;
            font-size: 11px;
            font-weight: 500;
            text-align: center;
            border-radius: 0 0 10px 10px;
        }
        
        .thumbnail-controls {
            position: absolute;
            top: 4px;
            right: 4px;
            display: none;
            flex-direction: column;
            gap: 2px;
        }
        
        .delete-control {
            position: absolute;
            top: 4px;
            left: 4px;
            display: none;
        }
        
        .image-thumbnail:hover .thumbnail-controls,
        .image-thumbnail:hover .delete-control {
            display: flex;
        }
        
        .control-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            color: #374151;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .control-btn:hover {
            background: white;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .delete-btn {
            background: #dc2626 !important;
            color: white !important;
            font-weight: bold;
        }
        
        .delete-btn:hover {
            background: #b91c1c !important;
            transform: scale(1.1);
        }
        
        .rotate-btn:hover {
            background: #dbeafe;
            color: #2563eb;
        }
        
        .flip-btn:hover {
            background: #d1fae5;
            color: #059669;
        }
        
        /* Navigation dots styling */
        .nav-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #cbd5e1;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .nav-dot:hover {
            background: #94a3b8;
            transform: scale(1.2);
        }
        
        .nav-dot.active {
            background: #3b82f6;
            transform: scale(1.3);
        }

        /* Modernize panel chrome and add optional sketchbook vibe */
        .floating-panel {
            border: 1px solid rgba(15, 23, 42, 0.06);
            box-shadow: 0 12px 28px rgba(2, 6, 23, 0.08);
        }
        .floating-panel .cursor-move {
            border-bottom: 1px solid rgba(15, 23, 42, 0.06) !important;
        }
        /* Tone down button effects for a cleaner feel */
        .floating-panel button {
            box-shadow: 0 1px 2px rgba(2,6,23,0.06) !important;
            transform: none !important;
        }
        .floating-panel button:hover {
            transform: translateY(-1px) !important;
        }
        /* Minimal divider */
        .panel-divider { border-top: 1px solid rgba(15,23,42,0.08); }

        /* Top toolbar styles - now handled by comprehensive CSS above */
        .tbtn.active { border-color: rgba(59,130,246,.9); background: #eff6ff; color: #1e40af; }
        .tbtn:hover, .tselect:hover, .tinput:hover {
            border-color: rgba(59,130,246,.8);
            box-shadow: 0 2px 4px rgba(59,130,246,.1);
        }
        .popover {
            position: absolute;
            top: 40px;
            left: 0;
            background: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(2,6,23,.12);
            padding: 12px;
            display: none;
            z-index: 60;
            min-width: 120px;
        }
        .popover.show {
            display: block;
        }
    </style>
    
    
    <script>
        // STEP 3: JS fallback - Re-check sizing after fonts load and on resize
        // This updates the global data-toolbar-mode attribute (no DOM rewrites)
        (function() {
            let resizeTimer = null;
            let isCalculating = false;
            
            const calculateToolbarMode = () => {
                // Prevent concurrent calculations
                if (isCalculating) return;
                isCalculating = true;
                
                const toolbarWrap = document.getElementById('toolbarWrap') || document.querySelector('.toolbar-wrap');
                if (!toolbarWrap) {
                    isCalculating = false;
                    return;
                }
                
                const windowWidth = window.innerWidth;
                const isMobile = windowWidth <= 768;
                
                // Desktop: always use full mode
                if (!isMobile) {
                    document.documentElement.setAttribute('data-toolbar-mode', 'full');
                    isCalculating = false;
                    return;
                }
                
                // Mobile: Measure if compact is needed
                // Temporarily set to full mode for measurement
                document.documentElement.setAttribute('data-toolbar-mode', 'full');
                
                // Force layout calculation
                void toolbarWrap.offsetWidth;
                
                // Measure if content overflows
                const toolbarWidth = toolbarWrap.clientWidth;
                const toolbarScrollWidth = toolbarWrap.scrollWidth;
                const needsCompact = toolbarScrollWidth > toolbarWidth;
                
                // Set the correct mode based on measurement
                document.documentElement.setAttribute('data-toolbar-mode', needsCompact ? 'compact' : 'full');
                
                isCalculating = false;
            };
            
            // Calculate immediately when toolbar exists
            const initCalculation = () => {
                const toolbarWrap = document.getElementById('toolbarWrap') || document.querySelector('.toolbar-wrap');
                if (toolbarWrap) {
                    calculateToolbarMode();
                } else if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initCalculation);
                } else {
                    setTimeout(initCalculation, 0);
                }
            };
            
            // Start calculation
            initCalculation();
            
            // Recalculate after fonts load (for accurate text measurement)
            if (document.fonts && document.fonts.ready) {
                document.fonts.ready.then(() => {
                    setTimeout(calculateToolbarMode, 50);
                });
            }
            
            // Recalculate on window resize (throttled)
            window.addEventListener('resize', () => {
                if (resizeTimer) clearTimeout(resizeTimer);
                resizeTimer = setTimeout(calculateToolbarMode, 150);
            });
        })();
    </script>
</head>
<body class="bg-gray-50 h-screen overflow-hidden" data-heic-worker-url="https://openpaint-heic-converter.sofapaint-api.workers.dev">
    <!-- Top Toolbar -->
    <div id="topToolbar">
        <div class="toolbar-wrap smart-label-scope" id="toolbarWrap">
            <div id="tbLeft" class="group-gap smart-label-scope">
                <!-- Pre-populated toolbar content to prevent flash -->
                <button id="paste" class="tbtn" title="Upload Images" aria-label="Upload Images">
                    <span class="label-long">Upload Images</span><span class="label-short">Upload</span>
                </button>
                <button id="clear" class="tbtn">Clear</button>
                <button id="drawingModeToggle" class="tbtn straight-mode" title="Straight Line" aria-label="Straight Line">
                    <span class="label-long">Straight Line</span><span class="label-short">Straight</span>
                </button>
                <button id="textModeToggle" class="tbtn" title="Text Tool" aria-label="Text Tool">
                    <span class="label-long">Text</span><span class="label-short">Text</span>
                </button>
                <div class="color-swatches">
                    <button class="active tbtn" data-color="#3b82f6" style="background-color: #3b82f6; box-shadow: 0 0 10px rgba(59, 130, 246, 0.6);" title="Bright Blue"></button>
                    <button data-color="#22c55e" style="background-color: #22c55e; box-shadow: 0 0 10px rgba(34, 197, 94, 0.6);" title="Bright Green" class="tbtn"></button>
                    <button data-color="#ef4444" style="background-color: #ef4444; box-shadow: 0 0 10px rgba(239, 68, 68, 0.6);" title="Bright Red" class="tbtn"></button>
                    <button data-color="#f59e0b" style="background-color: #f59e0b; box-shadow: 0 0 10px rgba(245, 158, 11, 0.6);" title="Bright Yellow" class="tbtn"></button>
                    <button data-color="#a855f7" style="background-color: #a855f7; box-shadow: 0 0 10px rgba(168, 85, 247, 0.6);" title="Bright Purple" class="tbtn"></button>
                    <button data-color="#1f2937" style="background-color: #1f2937;" title="Dark Gray" class="tbtn"></button>
                    <button data-color="#ffffff" style="background-color: rgb(255, 255, 255); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); border: 1px solid #ccc;" title="White" class="tbtn"></button>
                    <button data-color="#10b981" style="background-color: #10b981; box-shadow: 0 0 10px rgba(16, 185, 129, 0.6);" title="Bright Emerald" class="tbtn"></button>
                </div>
                <select
                    id="brushSize"
                    class="px-2 py-1 border border-gray-300 rounded text-sm"
                    style="height: 34px; margin: 0; cursor: pointer;"
                >
                    <option value="2">2px</option>
                    <option value="4">4px</option>
                    <option value="6">6px</option>
                    <option value="8">8px</option>
                    <option value="10" selected>10px</option>
                    <option value="15">15px</option>
                    <option value="20">20px</option>
                </select>
                <button id="arrowStartBtn" class="tbtn icon-btn" title="Start Arrow"></button>
                <button id="arrowEndBtn" class="tbtn icon-btn" title="End Arrow"></button>
                <button id="dottedBtn" class="tbtn" title="Line Style"><svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line></svg></button>
                <button id="undoBtn" class="tbtn icon-btn" title="Undo"></button>
                <button id="redoBtn" class="tbtn icon-btn" title="Redo"></button>
            </div>
            <div id="tbCenter" class="group-gap"></div>
            <div id="tbRight" class="group-gap smart-label-scope">
                <input type="text" id="projectName" placeholder="Project Name" value="New Sofa" class="tinput" data-sharkid="__1">
                <button id="loadProject" title="Load Project" class="tbtn" aria-label="Load Project">
                    <span class="label-long">Load Project</span><span class="label-short">Load</span>
                </button>
                <button id="removeBgClientTop" class="tbtn" title="Remove background using server">Remove BG</button>
                <button id="exportAISVG" class="tbtn" title="AI SVG Export" aria-label="AI SVG Export" style="background: #8b5cf6; border-color: #7c3aed;">
                    <span class="label-long">AI SVG Export</span><span class="label-short">AI SVG</span>
                </button>
                <button id="saveProjectTop" class="tbtn" title="Save Project" aria-label="Save Project">
                    <span class="label-long">Save Project</span><span class="label-short">Save</span>
                </button>
                <button id="unitToggleBtn" class="tbtn" title="Toggle units">inches</button>
                    </div>
                </div>
    </div>
    
    <script>
        // Mark toolbar as ready - size should already be calculated by previous script
        (function() {
            const markToolbarReady = () => {
                try {
                    const topToolbar = document.getElementById('topToolbar');
                    const toolbarWrap = document.getElementById('toolbarWrap') || document.querySelector('.toolbar-wrap');
                    
                    if (topToolbar && toolbarWrap) {
                        // Toolbar size should already be set by the calculation script
                        // Just mark it as ready to make it visible
                        topToolbar.classList.add('toolbar-ready');
                        toolbarWrap.classList.add('toolbar-ready');
                        // Toolbar is now ready - CSS will make it visible
                        window.__toolbarReady = true;
                    }
                } catch(e) {
                    console.error('[TOOLBAR-INIT] Error marking toolbar ready:', e);
                }
            };
            
            // Try immediately
            markToolbarReady();
            
            // Also try on DOMContentLoaded
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', markToolbarReady);
            } else {
                setTimeout(markToolbarReady, 0);
            }
        })();
    </script>

    <!-- Fullscreen Canvas -->
    <canvas id="canvas"></canvas>

    <!-- Main Content Container for Frame Capture -->
    <div id="frame-capture" class="w-full">
        <!-- Content will be dynamically generated based on images -->
        <div id="frame-content" class="min-h-screen flex items-center justify-center">
            <div class="text-center p-8">
                <h1 class="text-4xl font-bold text-slate-800 mb-4">OpenPaint Frame Capture</h1>
                <p class="text-slate-600">Images will appear here as you add them to your project</p>
            </div>
        </div>
    </div>
    <script>
        (function () {
            const frameCapture = document.getElementById('frame-capture');
            if (!frameCapture) return;

            function toggleFramePlaceholder() {
                const hasImages = window.originalImages && Object.keys(window.originalImages).length > 0;
                frameCapture.classList.toggle('hidden', !!hasImages);
            }

            window.__hideFrameCapture = toggleFramePlaceholder;

            if (document.readyState === 'complete') {
                toggleFramePlaceholder();
            } else {
                window.addEventListener('load', toggleFramePlaceholder, { once: true });
            }
        })();
    </script>

    <!-- Minimal Numeric Pill Strip Navigation - Positioned under frame capture -->
    <div id="navigation-container" class="w-full" style="background: white; border-top: 1px solid #cbd5e1; position: relative; z-index: 10; display: block;">
        <nav aria-label="Image quick nav" class="w-full">
            <ol id="mini-stepper" class="flex gap-3 px-4 py-3 overflow-x-auto snap-x snap-mandatory justify-center items-center min-h-[60px]">
                <!-- Pills will be generated by JavaScript -->
            </ol>
        </nav>
    </div>
    
    <!-- Project Header Panel -->
    <div id="projectPanel" class="floating-panel fixed top-4 right-4 z-30 rounded-2xl w-80 transition-all duration-300">
        <div class="flex items-center justify-between p-4 cursor-move border-b border-gray-200/50">
            <h3 class="text-base font-bold text-slate-800">Project Settings</h3>
            <button id="toggleProjectPanel" class="text-slate-500 hover:text-slate-700 hover:bg-slate-100 rounded-lg p-1.5 transition-all duration-200 transform hover:scale-110" title="Minimize/Expand Panel">
                <svg class="w-5 h-5 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
        </div>
        <div id="projectPanelContent" class="p-3 transition-all duration-300">
            <div class="flex flex-col gap-3">
                <!-- Project Info -->
                <div class="flex flex-col gap-3">
                    <input 
                        type="text" 
                        id="projectNamePanel" 
                        placeholder="Project Name" 
                        value="New Sofa" 
                        class="px-3 py-2.5 border border-gray-300 rounded-xl text-sm bg-white w-full focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200 shadow-sm"
                    >
                    <div class="flex items-center gap-3">
                        <label for="unitSelector" class="text-sm font-semibold text-slate-700 w-14">Units:</label>
                        <select 
                            id="unitSelector" 
                            class="px-3 py-2.5 border border-gray-300 rounded-xl text-sm bg-white flex-1 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200 shadow-sm"
                        >
                            <option value="inch">inches</option>
                            <option value="cm">cm</option>
                        </select>
                    </div>
                    
                    <!-- Hidden inputs for functionality -->
                    <div id="measurementInput" class="hidden">
                        <div id="inchInputs" class="flex items-center gap-2">
                            <input type="number" id="inchWhole" min="0" value="0" class="w-16 px-2 py-1 border border-gray-300 rounded text-sm">
                            <select id="inchFraction" class="px-2 py-1 border border-gray-300 rounded text-sm">
                                <option value="0">0</option>
                                <option value="0.125">1/8</option>
                                <option value="0.25">1/4</option>
                                <option value="0.375">3/8</option>
                                <option value="0.5">1/2</option>
                                <option value="0.625">5/8</option>
                                <option value="0.75">3/4</option>
                                <option value="0.875">7/8</option>
                            </select>
                        </div>
                        <div id="cmInputs" class="hidden">
                            <input type="number" id="cmValue" min="0" step="0.1" value="0.0" class="w-16 px-2 py-1 border border-gray-300 rounded text-sm">
                        </div>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="panel-divider pt-3 mt-2 space-y-2">
                    <!-- Load Project button -->
                    <div class="flex justify-center">
                        <button id="loadProject" title="Load project from ZIP file" class="px-4 py-2 bg-white border border-gray-300 text-slate-700 text-xs font-semibold rounded-xl hover:bg-slate-50 transition-all">Load Project</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Drawing Tools Panel -->
    <div id="toolsPanel" class="floating-panel fixed top-4 left-4 z-30 rounded-2xl transition-all duration-300">
        <div class="flex items-center justify-between p-4 cursor-move border-b border-gray-200/50">
            <h3 class="text-base font-bold text-slate-800">Drawing Tools</h3>
            <button id="toggleToolsPanel" class="text-slate-500 hover:text-slate-700 hover:bg-slate-100 rounded-lg p-1.5 transition-all duration-200 transform hover:scale-110" title="Minimize/Expand Panel">
                <svg class="w-5 h-5 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
        </div>
        <div id="toolsPanelContent" class="p-4 transition-all duration-300 smart-label-scope">
            <div class="flex flex-col gap-4">
                <!-- Primary Tools -->
                <div class="flex items-center gap-3">
                    <button id="clear" class="px-4 py-2.5 bg-danger-500 hover:bg-danger-600 active:bg-danger-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95">Clear</button>
                    <button id="paste" class="px-4 py-2.5 bg-primary-500 hover:bg-primary-600 active:bg-primary-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95" title="Upload Images" aria-label="Upload Images">
                        <span class="label-long">Upload Images</span><span class="label-short">Upload</span>
                    </button>
                    <button id="save" class="px-4 py-2.5 bg-success-500 hover:bg-success-600 active:bg-success-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95">Save Current</button>
                    <button id="copy" class="px-4 py-2.5 bg-primary-500 hover:bg-primary-600 active:bg-primary-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95" title="Copy image to clipboard (cropped to frame)" aria-label="Copy Image">Copy</button>
                </div>
                
                <!-- AI Tools -->
                <div class="flex items-center gap-3">
                    <button id="generateSofaBasics" class="px-4 py-2.5 bg-purple-500 hover:bg-purple-600 active:bg-purple-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95" title="Generate AI Sofa Dimensions" aria-label="Generate AI Sofa Dimensions">
                        <span class="label-long"> Generate Sofa Basics</span><span class="label-short">AI Basics</span>
                    </button>
                </div>
                
                <!-- Color Palette -->
                <div class="flex items-center gap-3">
                    <span class="text-sm font-semibold text-slate-700">Color:</span>
                    <div class="flex gap-2">
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110 active" data-color="#3b82f6" style="background-color: #3b82f6; box-shadow: 0 0 10px rgba(59, 130, 246, 0.6);" title="Bright Blue"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#22c55e" style="background-color: #22c55e; box-shadow: 0 0 10px rgba(34, 197, 94, 0.6);" title="Bright Green"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#ef4444" style="background-color: #ef4444; box-shadow: 0 0 10px rgba(239, 68, 68, 0.6);" title="Bright Red"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#f59e0b" style="background-color: #f59e0b; box-shadow: 0 0 10px rgba(245, 158, 11, 0.6);" title="Bright Yellow"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#a855f7" style="background-color: #a855f7; box-shadow: 0 0 10px rgba(168, 85, 247, 0.6);" title="Bright Purple"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#1f2937" style="background-color: #1f2937;" title="Dark Gray"></button>
                    </div>
                    <input type="color" id="colorPicker" value="#3b82f6" class="hidden">
                </div>
                
                <!-- Drawing Mode & Controls -->
                <div class="flex items-center gap-4">
                    <button id="drawingModeToggle" class="px-4 py-2.5 bg-white border-2 border-success-500 text-success-600 text-sm font-semibold rounded-xl hover:bg-success-50 hover:border-success-600 active:bg-success-100 transition-all duration-200 transform hover:scale-105 active:scale-95 straight-mode shadow-sm" title="Straight Line" aria-label="Straight Line">
                        <span class="label-long">Straight Line</span><span class="label-short">Straight</span>
                    </button>
                    <button id="textModeToggle" class="px-4 py-2.5 bg-white border-2 border-slate-400 text-slate-700 text-sm font-semibold rounded-xl hover:bg-slate-50 hover:border-slate-500 active:bg-slate-100 transition-all duration-200 transform hover:scale-105 active:scale-95 shadow-sm" title="Text Tool" aria-label="Text Tool">
                        <span class="label-long">Text</span><span class="label-short">Text</span>
                    </button>
                    
                </div>
                
                <!-- Arrow & Line Style Controls -->
                <div class="flex items-center gap-4">
                    <div id="arrowControls" class="flex items-center gap-3">
                        <span class="text-sm font-semibold text-slate-700">Arrows:</span>
                        <button id="arrowStartBtn" class="tbtn icon-btn" title="Start Arrow"></button>
                        <button id="arrowEndBtn" class="tbtn icon-btn" title="End Arrow"></button>
                        
                        <div class="w-px h-6 bg-slate-200 mx-1"></div>
                        
                        <div class="flex items-center gap-2" title="Arrow Size">
                            <span class="text-xs text-slate-500">Size:</span>
                            <input type="range" id="arrowSize" min="5" max="50" value="15" class="w-20 accent-blue-500">
                        </div>
                        
                        <select id="arrowStyle" class="text-xs border border-slate-300 rounded px-1 py-1 bg-white text-slate-700 focus:outline-none focus:border-blue-500">
                            <option value="triangular">Triangular</option>
                            <option value="filled">Filled</option>
                            <option value="curved">Curved</option>
                        </select>
                    </div>
                    <div id="dashControls" class="flex items-center gap-3">
                        <span class="text-sm font-semibold text-slate-700">Style:</span>
                        <select id="dashStyleSelect" class="px-3 py-2 border border-gray-300 rounded-xl text-sm bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200 shadow-sm">
                            <option value="solid">Solid</option>
                            <option value="dotted">Dotted</option>
                            <option value="small">Small Dash</option>
                            <option value="medium">Medium Dash</option>
                            <option value="large">Large Dash</option>
                            <option value="dot-dash">Dot-Dash</option>
                            <option value="custom">Custom</option>
                        </select>
                        <div id="customDashControls" class="hidden items-center gap-2">
                            <input type="number" id="dashLengthInput" min="1" max="50" value="5" class="w-16 px-2 py-1.5 border border-gray-300 rounded-lg text-xs focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200" title="Dash length">
                            <span class="text-xs text-slate-500">/</span>
                            <input type="number" id="gapLengthInput" min="1" max="50" value="5" class="w-16 px-2 py-1.5 border border-gray-300 rounded-lg text-xs focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200" title="Gap length">
                        </div>
                    </div>
                </div>
                
                <!-- Stroke Counter -->
                <div class="text-sm text-gray-600 font-medium">
                    <span id="strokeCounter">Lines: 0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Vectors and Tags Panel -->
    <div id="strokePanel" class="floating-panel fixed left-4 z-30 rounded-2xl w-64 transition-all duration-300 overflow-hidden" style="top: clamp(1rem, 50vh - 20rem, calc(100vh - 40rem - 1rem)); max-height: min(40rem, calc(100vh - 2rem));">
        <div id="elementsHeader" class="flex items-center justify-between p-3 cursor-move border-b border-gray-200/50 bg-white rounded-t-2xl">
            <div class="flex items-center gap-2">
                <h3 class="text-sm font-semibold text-slate-800">Elements</h3>
                <button id="viewMeasurementsToggle" title="Toggle measurement labels display" class="px-2 py-1 text-xs bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-all font-medium">
                    Show Labels
                </button>
            </div>
            <button id="toggleStrokePanel" class="text-slate-500 hover:text-slate-700 rounded-lg p-1 transition-all" title="Minimize/Expand Panel">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
        </div>
        <!-- Panel Body (collapsible) -->
        <div id="elementsBody" role="region" aria-labelledby="elementsHeader">
        <div id="elementsControls" class="px-3 pt-3 pb-1 border-b border-gray-100">
            <div class="flex gap-2 mb-2">
                <button id="selectAllStrokesBtn" title="Select/Deselect all elements" class="flex-1 px-2 py-1 text-xs bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg transition-all font-medium">
                    Deselect All
                </button>
                <button id="showAllMeasurementsBtn" title="Show all measurements in a list" class="flex-1 px-2 py-1 text-xs bg-green-100 hover:bg-green-200 text-green-700 rounded-lg transition-all font-medium">
                    Show List
                </button>
                <button id="viewSubmittedMeasurementsBtn" title="View submitted measurements from shared projects" class="flex-1 px-2 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 rounded-lg transition-all font-medium">
                    View Submitted
                </button>
            </div>
            <div class="flex gap-2 mb-2">
                <div class="flex-1 px-2 py-1 text-xs bg-gray-50 border border-gray-200 rounded-lg">
                    <div class="text-gray-500 text-xs mb-1">Next Tag:</div>
                    <div id="nextTagDisplay" 
                         contenteditable="true" 
                         spellcheck="false"
                         class="font-semibold text-blue-600 cursor-text hover:bg-blue-50 px-1 py-0.5 rounded outline-none focus:ring-2 focus:ring-blue-300" 
                         title="Type to set next tag">A</div>
                </div>
            </div>
            <div class="flex gap-2 flex-wrap items-center">
                <button id="tagModeToggle" title="Toggle between letters only and letters with numbers" class="px-2 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 rounded-lg transition-all font-medium">
                    Letters + Numbers
                </button>
                <label class="flex items-center gap-1 text-xs bg-slate-50 border border-slate-200 px-2 py-1 rounded-lg">
                    <input id="toggleShowMeasurements" type="checkbox" class="accent-blue-600" checked>
                    Show measurements
                </label>
                <button id="toggleReviewOnly" title="Show only measurements under review" class="px-2 py-1 text-xs bg-slate-50 border border-slate-200 rounded-lg hover:bg-slate-100 transition-colors">
                    Review only
                </button>
                <div class="flex items-center gap-1 text-xs bg-slate-50 border border-slate-200 px-2 py-1 rounded-lg">
                    <span class="text-slate-600">Tag Size:</span>
                    <button id="decreaseAllTagSize" title="Decrease tag size for all tags on this image" class="w-5 h-5 bg-white border border-slate-300 rounded hover:bg-slate-50 flex items-center justify-center text-slate-600 hover:text-slate-800 transition-colors"></button>
                    <span id="currentTagSize" class="text-slate-700 font-medium min-w-[2ch] text-center">20</span>
                    <button id="increaseAllTagSize" title="Increase tag size for all tags on this image" class="w-5 h-5 bg-white border border-slate-300 rounded hover:bg-slate-50 flex items-center justify-center text-slate-600 hover:text-slate-800 transition-colors">+</button>
                </div>

                <button id="unitToggleBtnSecondary" class="px-2 py-1 text-xs bg-white border border-gray-300 rounded-lg hover:bg-gray-50" title="Toggle units">inches</button>
                <button id="labelShapeToggleBtn" class="px-2 py-1 text-xs bg-white border border-gray-300 rounded-lg hover:bg-gray-50" title="Toggle tag shape" aria-pressed="true"></button>
                <button id="labelBackgroundToggleBtn" class="px-2 py-1 text-xs bg-white border border-gray-300 rounded-lg hover:bg-gray-50" title="Toggle label background" aria-pressed="false">Solid</button>
            </div>
        </div>
        <div id="strokeVisibilityControls" class="px-3 pt-2 pb-2 overflow-y-auto overflow-x-hidden" style="box-sizing: border-box;"></div>
        </div>
    </div>

    <!-- Image Gallery Panel -->
    <div id="imagePanel" class="floating-panel fixed right-4 z-30 rounded-2xl w-72 transition-all duration-300 overflow-hidden" style="top: clamp(1rem, 50vh - 20rem, calc(100vh - 40rem - 1rem)); max-height: min(40rem, calc(100vh - 2rem));">
        <div id="imagePanelHeader" class="flex items-center justify-between p-3 cursor-move border-b border-gray-200/50 bg-white rounded-t-2xl">
            <h3 class="text-sm font-semibold text-slate-800">Images</h3>
            <div class="flex items-center gap-2">
                <label class="flex items-center gap-1 text-[11px] font-medium text-slate-600 bg-slate-100 border border-slate-200 rounded-lg px-2 py-1 select-none" title="Toggle whether scrolling selects images automatically">
                    <input type="checkbox" id="scrollSelectToggle" class="accent-blue-600" checked>
                    <span>Scroll selects</span>
                    <span class="text-[10px] uppercase tracking-wide text-blue-600" id="scrollSelectModeLabel">Auto</span>
                </label>
                <button id="toggleImagePanel" class="text-slate-500 hover:text-slate-700 rounded-lg p-1 transition-all" title="Minimize/Expand Panel">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </button>
            </div>
        </div>
        <!-- Name/title box outside the scroll area (always visible at top of images panel) -->
        <div class="px-3 bg-white border-b border-slate-200 py-2">
            <label for="currentImageNameBox" class="block text-[10px] text-slate-500 mb-1">Image name</label>
            <input id="currentImageNameBox" type="text" class="w-full px-2 py-1 border border-slate-300 rounded-md text-[12px] focus:outline-none focus:ring-2 focus:ring-primary-300" placeholder="Rename current image" />
        </div>
        <div id="imagePanelContent" class="p-3 transition-all duration-300" style="position: relative;">
            <!-- Legacy image list for backwards compatibility -->
                <div id="imageList" class="space-y-4 mb-0 h-[60vh] overflow-y-auto overflow-x-hidden pr-0 snap-y snap-mandatory scroll-smooth" style="padding-top: calc(30vh - 5rem); padding-bottom: calc(30vh - 5rem);"></div>

            <!-- Snap guide line -->
            <div class="pointer-events-none absolute left-0 right-0 top-1/2 -translate-y-1/2 border-t border-slate-300/70"></div>

            
            
            <!-- Gallery (disabled in vertical list mode) -->
            <div class="mb-4 hidden">
                <div id="imageGallery" class="hidden"></div>
                <div id="imageDots" class="hidden"></div>
            </div>
            
            <!-- Image meta removed (name/type inputs no longer used) -->

            <!-- Navigation controls removed -->
        </div>
    </div>

    <!-- Mobile panel toggle icons (outside panels to avoid overflow clipping) -->
    <div id="strokePanelIcon" class="panel-toggle-icon" data-panel="strokePanel" style="display: none; opacity: 0;"></div>
    <div id="imagePanelIcon" class="panel-toggle-icon" data-panel="imagePanel" style="display: none; opacity: 0;"></div>

    <!-- Capture Frame -->
    <div id="captureOverlay" class="fixed inset-0 pointer-events-none" style="z-index: 15;">
        <!-- Capture frame -->
        <div id="captureFrame" class="capture-frame absolute border-2 border-gray-400 bg-transparent" style="left: calc(50% - 400px); top: calc(50% - 300px); width: 800px; height: 600px; pointer-events: none;">
            <!-- Lock button -->
            <button id="captureLockButton" class="absolute -bottom-8 -right-8 w-8 h-8 bg-white border border-gray-300 rounded shadow-md hover:bg-gray-50 transition-colors flex items-center justify-center text-gray-600" title="Lock/Unlock frame (L)">
                <!-- Locked icon -->
                <svg class="locked-icon w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"></path>
                </svg>
                <!-- Unlocked icon -->
                <svg class="unlocked-icon w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z"></path>
                </svg>
            </button>
            
            <!-- Resize handles (hidden when locked) -->
            <div class="resize-handles">
                <div class="resize-handle w-3 h-3 -top-1 -left-1 bg-white border border-blue-400 rounded-sm" style="cursor: nw-resize;" data-direction="nw"></div>
                <div class="resize-handle w-3 h-3 -top-1 left-1/2 -translate-x-1/2 bg-white border border-blue-400 rounded-sm" style="cursor: n-resize;" data-direction="n"></div>
                <div class="resize-handle w-3 h-3 -top-1 -right-1 bg-white border border-blue-400 rounded-sm" style="cursor: ne-resize;" data-direction="ne"></div>
                <div class="resize-handle w-3 h-3 top-1/2 -translate-y-1/2 -right-1 bg-white border border-blue-400 rounded-sm" style="cursor: e-resize;" data-direction="e"></div>
                <div class="resize-handle w-3 h-3 -bottom-1 -right-1 bg-white border border-blue-400 rounded-sm" style="cursor: se-resize;" data-direction="se"></div>
                <div class="resize-handle w-3 h-3 -bottom-1 left-1/2 -translate-x-1/2 bg-white border border-blue-400 rounded-sm" style="cursor: s-resize;" data-direction="s"></div>
                <div class="resize-handle w-3 h-3 -bottom-1 -left-1 bg-white border border-blue-400 rounded-sm" style="cursor: sw-resize;" data-direction="sw"></div>
                <div class="resize-handle w-3 h-3 top-1/2 -translate-y-1/2 -left-1 bg-white border border-blue-400 rounded-sm" style="cursor: w-resize;" data-direction="w"></div>
            </div>
        </div>
    </div>
    
    <!-- Instruction Text for Unlocked Mode -->
    <div id="unlockInstructions" class="fixed top-4 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-80 text-white px-4 py-2 rounded-lg shadow-xl hidden backdrop-blur-sm z-40">
        <div class="text-sm font-medium text-center">
            Press <kbd class="px-1 py-0.5 bg-white bg-opacity-20 rounded text-xs">L</kbd> or click lock icon to exit positioning mode
        </div>
    </div>
    
    <!-- macOS Style Lock Popup -->
    <div id="lockPopup" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-80 text-white px-4 py-2 rounded-lg shadow-xl hidden transition-all duration-200 backdrop-blur-sm" style="z-index: 50;">
        <div class="flex items-center gap-2">
            <svg id="lockPopupIcon" class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"></path>
            </svg>
            <span id="lockPopupText">Locked</span>
        </div>
    </div>

    <!-- Canvas Controls (Bottom Panel) -->
    <div id="canvasControls" class="floating-panel fixed rounded-2xl px-3 py-2 transition-all duration-300" style="bottom: 4rem; left: 50%; transform: translateX(-50%); z-index: 10000; display: block;">
        <div id="canvasControlsContent" class="flex items-center gap-2 text-sm smart-label-scope">
            <button id="copyCanvasBtn" class="flex items-center gap-1 px-3 py-1 bg-blue-600 hover:bg-blue-700 active:bg-blue-800 text-white text-xs rounded-lg shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-[1.02] active:scale-95" title="Copy image to clipboard" aria-label="Copy Image">
                <svg class="w-3.5 h-3.5 opacity-90" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M16 1H4a2 2 0 00-2 2v12h2V3h12V1zm3 4H8a2 2 0 00-2 2v14a2 2 0 002 2h11a2 2 0 002-2V7a2 2 0 00-2-2zm0 16H8V7h11v14z"></path></svg>
                <span class="label-long">Copy Image</span>
                <span class="label-short">Copy</span>
            </button>
            <select id="fitModeSelect" class="px-2 py-1 border border-gray-300 rounded-lg bg-white focus:outline-none hover:bg-gray-50">
                <option value="fit-width" selected>Fit Width</option>
                <option value="fit-height">Fit Height</option>
                <option value="fit-canvas">Fit Canvas</option>
                <option value="actual-size">Actual Size</option>
            </select>
            <button id="scaleButton" class="px-2 py-1 bg-white border border-gray-300 rounded-lg text-sm font-medium hover:bg-gray-50" aria-haspopup="listbox" aria-expanded="false" type="button">100% <svg class="inline w-3 h-3 -mt-0.5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M5.25 7.5l4.5 4.5 4.5-4.5H5.25z"/></svg></button>
            <div class="flex items-center gap-1 ml-2">
                <button id="rotateLeftCtrl" class="px-2 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg hover:bg-slate-50" title="Rotate 90 CCW"></button>
                <button id="rotateRightCtrl" class="px-2 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg hover:bg-slate-50" title="Rotate 90 CW"></button>
            </div>

            <!-- Share/Update next to Copy/Save -->
            <button id="shareProjectBtn" class="px-3 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg shadow-sm hover:shadow-md hover:bg-slate-50 transition-all duration-200 transform hover:scale-[1.02] active:scale-95" title="Create shareable URL for customer measurements">
                Share
            </button>
            

            <!-- Quick Save with hover menu -->
            <div id="quickSave" class="relative ml-2">
                <button id="quickSaveBtn" class="px-3 py-1 bg-green-600 hover:bg-green-700 text-white text-xs rounded-lg">
                    Save
                </button>
                <div id="quickSaveMenu"
                     class="hidden absolute bottom-full mb-1 left-0 bg-white border border-gray-200 rounded-xl shadow-lg min-w-[120px]"
                     style="white-space: nowrap; z-index: 5000;">
                    <button class="block w-full text-left px-3 py-2 text-xs hover:bg-slate-50 rounded-t-xl transition-colors" data-action="pdf">Save as PDF</button>
                    <button class="block w-full text-left px-3 py-2 text-xs hover:bg-slate-50 rounded-b-xl transition-colors" data-action="multiple">Save Multiple</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Status message element for notifications -->
    <div id="statusMessage"></div>
    
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <!-- New UI Controller Script -->
    <script>
        // Initialize top toolbar - now works with pre-populated content
        function initializeTopToolbar() {
            const left = document.getElementById('tbLeft');
            const center = document.getElementById('tbCenter');
            const right = document.getElementById('tbRight');
            const bottom = document.getElementById('canvasControlsContent') || center;

            // Helper functions
            const setUniform = el => {
                if (!el) return;
                // Do not apply text-input styling to range sliders; it breaks their visuals
                if (el.tagName === 'INPUT' && el.type === 'range') return;
                el.classList.add(el.tagName === 'SELECT' ? 'tselect' : el.tagName === 'INPUT' ? 'tinput' : 'tbtn');
            };
            
            const reparent = (id, target, beforeSetup) => {
                const el = document.getElementById(id);
                if (!el) return null;
                beforeSetup?.(el);
                target.appendChild(el);
                setUniform(el);
                return el;
            };

            // Since toolbar is now pre-populated, we just need to ensure proper styling
            // and wire up any missing functionality
            const ensureUniformStyling = () => {
                const buttons = left.querySelectorAll('button, input, select');
                buttons.forEach(setUniform);
            };
            
            ensureUniformStyling();

            // Color swatches are now pre-populated, just need to wire up functionality
            const colorButtons = left.querySelectorAll('[data-color]');
            colorButtons.forEach(button => {
                if (!button.__boundColor) {
                    button.__boundColor = true;
                    button.addEventListener('click', () => {
                        document.querySelectorAll('[data-color].active').forEach(b=>b.classList.remove('active'));
                        button.classList.add('active');
                        const hex = button.getAttribute('data-color');
                        const cp = document.getElementById('colorPicker');
                        if (cp && hex) {
                            cp.value = hex;
                            cp.dispatchEvent(new Event('change'));
                        }
                        const bs = document.getElementById('brushSize');
                        if (bs && hex) bs.style.setProperty('--accent', hex);
                    });
                }
            });
            
            // Hide the color picker since we're using swatches
            const colorInput = document.getElementById('colorPicker');
            if (colorInput) colorInput.classList.add('hidden');

            // Arrow and line style controls are now pre-populated, just need to wire up functionality
            const arrowStartBtn = document.getElementById('arrowStartBtn');
            const arrowEndBtn = document.getElementById('arrowEndBtn');
            const dottedBtn = document.getElementById('dottedBtn');
            
            const setLineStyleIcon = (style) => {
                if (!dottedBtn) return;
                const svgSolid = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
                const svgSmall = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="4 4"/></svg>';
                const svgMedium = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="7 5"/></svg>';
                const svgLarge = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="11 7"/></svg>';
                dottedBtn.innerHTML = style === 'small' ? svgSmall : style === 'medium' ? svgMedium : style === 'large' ? svgLarge : svgSolid;
            };
            setLineStyleIcon('solid');

            // Wire controls to UI state in paint.js
            const setActive = (el, on) => el.classList.toggle('active', !!on);
            const syncFromState = () => {
                try {
                    const as = window.paintApp?.uiState?.arrowSettings;
                    const ds = window.paintApp?.uiState?.dashSettings;
                    setActive(arrowStartBtn, as?.startArrow);
                    setActive(arrowEndBtn, as?.endArrow);
                    setLineStyleIcon(ds?.style || 'solid');
                    // Sync label shape toggle visual state
                    const state = window.paintApp?.state || {};
                    const shape = state.labelShape || 'square';
                    // Note: shapeSquareBtn and shapeCircleBtn were removed, using single toggle button instead
                } catch {}
            };
            syncFromState();
            
            arrowStartBtn.addEventListener('click', () => {
                try {
                    const as = window.paintApp.uiState.arrowSettings;
                    as.startArrow = !as.startArrow;
                    // Apply to stroke in edit mode if any
                    const edited = window.selectedStrokeInEditMode;
                    const img = window.currentImageLabel;
                    if (edited && img && window.vectorStrokesByImage?.[img]?.[edited]) {
                        const v = window.vectorStrokesByImage[img][edited];
                        v.arrowSettings = v.arrowSettings || { arrowSize: as.arrowSize, arrowStyle: as.arrowStyle, startArrow: false, endArrow: false };
                        v.arrowSettings.startArrow = as.startArrow;
                        // Ensure curved lines switch type appropriately
                        if (typeof window.updateStrokeTypeBasedOnArrows === 'function') {
                            window.updateStrokeTypeBasedOnArrows(v);
                        } else {
                            const hasArrows = !!(v.arrowSettings.startArrow || v.arrowSettings.endArrow);
                            if (v.type === 'curved' && hasArrows) v.type = 'curved-arrow';
                            if (v.type === 'curved-arrow' && !hasArrows) v.type = 'curved';
                        }
                        window.saveState?.(true, false, false);
                        window.redrawCanvasWithVisibility?.();
                    }
                    syncFromState();
                } catch {}
            });
            arrowEndBtn.addEventListener('click', () => {
                try {
                    const as = window.paintApp.uiState.arrowSettings;
                    as.endArrow = !as.endArrow;
                    // Apply to stroke in edit mode if any
                    const edited = window.selectedStrokeInEditMode;
                    const img = window.currentImageLabel;
                    if (edited && img && window.vectorStrokesByImage?.[img]?.[edited]) {
                        const v = window.vectorStrokesByImage[img][edited];
                        v.arrowSettings = v.arrowSettings || { arrowSize: as.arrowSize, arrowStyle: as.arrowStyle, startArrow: false, endArrow: false };
                        v.arrowSettings.endArrow = as.endArrow;
                        // Ensure curved lines switch type appropriately
                        if (typeof window.updateStrokeTypeBasedOnArrows === 'function') {
                            window.updateStrokeTypeBasedOnArrows(v);
                        } else {
                            const hasArrows = !!(v.arrowSettings.startArrow || v.arrowSettings.endArrow);
                            if (v.type === 'curved' && hasArrows) v.type = 'curved-arrow';
                            if (v.type === 'curved-arrow' && !hasArrows) v.type = 'curved';
                        }
                        window.saveState?.(true, false, false);
                        window.redrawCanvasWithVisibility?.();
                    }
                    syncFromState();
                } catch {}
            });
            dottedBtn.addEventListener('click', () => {
                try {
                    const ds = window.paintApp.uiState.dashSettings;
                    // Cycle: solid -> small -> medium -> large -> solid
                    const next = { 'solid': 'small', 'small': 'medium', 'medium': 'large', 'large': 'solid' };
                    ds.style = next[ds.style] || 'small';
                    ds.enabled = ds.style !== 'solid';
                    // Compute dash pattern immediately (mirror paint.js getDashPattern)
                    const computePattern = (style, dashLen, gapLen, lineWidth = 1) => {
                        const baseScale = Math.max(2, lineWidth * 0.8);
                        switch (style) {
                            case 'small': return [6 * baseScale, 4 * baseScale];
                            case 'medium': return [12 * baseScale, 8 * baseScale];
                            case 'large': return [20 * baseScale, 12 * baseScale];
                            case 'dot-dash': return [4 * baseScale, 6 * baseScale, 12 * baseScale, 6 * baseScale];
                            case 'custom': return [dashLen * baseScale, gapLen * baseScale];
                            default: return [];
                        }
                    };
                    const brush = document.getElementById('brushSize');
                    const size = parseInt(brush?.value || '5') || 5;
                    ds.pattern = computePattern(ds.style, ds.dashLength, ds.gapLength, size);
                    // If editing a stroke, also update it live
                    const edited = window.selectedStrokeInEditMode;
                    const img = window.currentImageLabel;
                    if (edited && img && window.vectorStrokesByImage?.[img]?.[edited]) {
                        const v = window.vectorStrokesByImage[img][edited];
                        const lw = parseInt(v.width || size) || size;
                        v.dashSettings = { ...ds, pattern: computePattern(ds.style, ds.dashLength, ds.gapLength, lw) };
                        window.saveState?.(true, false, false);
                        window.redrawCanvasWithVisibility?.();
                    }
                    setLineStyleIcon(ds.style);
                    syncFromState();
                } catch {}
            });

            // Undo / Redo buttons
            // Undo/Redo buttons are now pre-populated, just need to wire up functionality
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            if (undoBtn) {
                undoBtn.addEventListener('click', () => { 
                    if (typeof window.undo === 'function') window.undo(); 
                });
            }
            
            if (redoBtn) {
                redoBtn.addEventListener('click', () => { 
                    if (typeof window.redo === 'function') window.redo(); 
                });
            }

            // CENTER/BOTTOM: canvas view controls moved to bottom
            reparent('fitModeSelect', bottom);
            reparent('rotateLeftCtrl', bottom, el => { 
                el.classList.add('icon-btn', 'tbtn'); 
                el.title = 'Rotate Left'; 
                el.textContent = ''; 
            });
            reparent('rotateRightCtrl', bottom, el => { 
                el.classList.add('icon-btn', 'tbtn'); 
                el.title = 'Rotate Right'; 
                el.textContent = ''; 
            });
            reparent('scaleButton', bottom);
            syncFromState();

            // RIGHT: project settings are now pre-populated, just need to wire up functionality
            const saveProjectTop = document.getElementById('saveProjectTop');
            const shareProjectBtn = document.getElementById('shareProjectBtn');
            const updateShareBtn = document.getElementById('updateShareBtn');
            
            if (saveProjectTop) {
                saveProjectTop.addEventListener('click', () => {
                    if (window.projectManager?.saveProject) window.projectManager.saveProject();
                });
            }
            
            if (shareProjectBtn) {
                shareProjectBtn.addEventListener('click', () => {
                    if (window.shareProject) window.shareProject();
                });
            }
            
            if (updateShareBtn) {
                updateShareBtn.addEventListener('click', () => {
                    if (window.updateSharedProject) window.updateSharedProject();
                });
            }

            // Unit toggle button is now pre-populated, just need to wire up functionality
            const unitToggle = document.getElementById('unitToggleBtn');
            const unitSel = document.getElementById('unitSelector');
            const unitToggleSecondary = document.getElementById('unitToggleBtnSecondary');
            
            const getUnitLabel = () => (unitSel?.value === 'inch' ? 'inches' : 'cm');
            const toggleUnits = () => {
                if (!unitSel) return;
                unitSel.value = unitSel.value === 'inch' ? 'cm' : 'inch';
                const label = getUnitLabel();
                if (unitToggle) unitToggle.textContent = label;
                if (unitToggleSecondary) unitToggleSecondary.textContent = label;
                if (typeof updateMeasurementDisplay === 'function') {
                    updateMeasurementDisplay();
                } else if (unitSel.onchange) {
                    unitSel.onchange();
                }
            };

            if (unitToggle && unitSel) {
                unitToggle.textContent = getUnitLabel();
                unitToggle.addEventListener('click', toggleUnits);
                // Hide the original select (kept for compatibility)
                unitSel.style.display = 'none';
            }

            if (unitToggleSecondary && unitSel) {
                unitToggleSecondary.textContent = getUnitLabel();
                unitToggleSecondary.addEventListener('click', toggleUnits);
            }

            // Elements panel single-button shape toggle wiring
            const labelShapeToggleBtn = document.getElementById('labelShapeToggleBtn');
            const applyShape = (val) => {
                if (window.paintApp?.state) window.paintApp.state.labelShape = val;
                if (window.redrawCanvasWithVisibility) window.redrawCanvasWithVisibility();
            };
            if (labelShapeToggleBtn) {
                const syncShapeBtn = () => {
                    const shape = (window.paintApp?.state?.labelShape) || 'square';
                    const isSquare = shape !== 'circle';
                    labelShapeToggleBtn.textContent = isSquare ? '' : '';
                    labelShapeToggleBtn.setAttribute('aria-pressed', String(isSquare));
                };
                labelShapeToggleBtn.addEventListener('click', () => {
                    const shape = (window.paintApp?.state?.labelShape) || 'square';
                    applyShape(shape === 'circle' ? 'square' : 'circle');
                    syncShapeBtn();
                });
                syncShapeBtn();
            }

            // Label background style toggle button
            const labelBackgroundToggleBtn = document.getElementById('labelBackgroundToggleBtn');
            const backgroundStyles = ['solid', 'clear-black', 'clear-color', 'clear-white'];
            const backgroundLabels = {
                'solid': 'Solid',
                'clear-black': 'Clear Black',
                'clear-color': 'Clear Color',
                'clear-white': 'Clear White'
            };

            if (labelBackgroundToggleBtn) {
                labelBackgroundToggleBtn.addEventListener('click', () => {
                    console.log('[TagBackground] Button clicked, app.tagManager available:', !!window.app?.tagManager);
                    if (window.app?.tagManager) {
                        const currentStyle = window.app.tagManager.tagBackgroundStyle || 'solid';
                        console.log('[TagBackground] Current style:', currentStyle);
                        const currentIndex = backgroundStyles.indexOf(currentStyle);
                        const nextIndex = (currentIndex + 1) % backgroundStyles.length;
                        const nextStyle = backgroundStyles[nextIndex];
                        console.log('[TagBackground] Next style:', nextStyle);

                        window.app.tagManager.setBackgroundStyle(nextStyle);
                        labelBackgroundToggleBtn.textContent = backgroundLabels[nextStyle];
                        labelBackgroundToggleBtn.setAttribute('aria-pressed', String(nextStyle !== 'solid'));
                        console.log('[TagBackground] Updated to:', nextStyle);
                    } else {
                        console.warn('[TagBackground] Button clicked but tagManager not available');
                    }
                });
            } else {
                console.warn('[TagBackground] Button element not found');
            }

            // Auto-update shared project when state saves (debounced)
            if (window.updateSharedProject && window.saveState && !window.__autoUpdateSharePatched) {
                window.__autoUpdateSharePatched = true;
                const originalSaveState = window.saveState;
                let updateTimer = null;
                window.saveState = function() {
                    const result = originalSaveState.apply(this, arguments);
                    clearTimeout(updateTimer);
                    updateTimer = setTimeout(() => {
                        try { window.updateSharedProject(); } catch {}
                    }, 600);
                    return result;
                };
            }

            // Hide legacy panels after moving controls (keep in DOM to preserve any lookups)
            document.getElementById('toolsPanel')?.classList.add('hidden');
            document.getElementById('projectPanel')?.classList.add('hidden');
            const cc = document.getElementById('canvasControls');
            if (cc) { cc.classList.remove('hidden'); cc.style.display='block'; }

            // Add body padding to prevent toolbar overlap
            document.body.style.paddingTop = '48px';
        }

        // Setup quick save hover menu functionality
        function setupQuickSaveHover() {
            // Quick Save hover menu (bottom panel)
            const quickSave = document.getElementById('quickSave');
            const quickSaveBtn = document.getElementById('quickSaveBtn');
            const quickSaveMenu = document.getElementById('quickSaveMenu');

            console.log('Setting up quick save hover:', { quickSave, quickSaveBtn, quickSaveMenu });

            if (quickSave && quickSaveBtn && quickSaveMenu) {
                // Click: Save current image (reuses existing 'save' button)
                quickSaveBtn.addEventListener('click', () => {
                    console.log('Quick save clicked');
                    const saveButton = document.getElementById('save');
                    if (saveButton) saveButton.click();
                });

                let hideTimer = null;
                const showMenu = () => {
                    if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
                    quickSaveMenu.classList.remove('hidden');
                };
                const scheduleHide = () => {
                    if (hideTimer) clearTimeout(hideTimer);
                    hideTimer = setTimeout(() => {
                        quickSaveMenu.classList.add('hidden');
                        hideTimer = null;
                    }, 200); // small delay prevents flicker when moving cursor to menu
                };

                // Hover to show menu on the trigger container
                quickSave.addEventListener('mouseenter', showMenu);
                quickSave.addEventListener('mouseleave', scheduleHide);

                // Keep the menu open while hovering the menu; hide after leaving it
                quickSaveMenu.addEventListener('mouseenter', showMenu);
                quickSaveMenu.addEventListener('mouseleave', scheduleHide);

                // Menu actions
                quickSaveMenu.addEventListener('click', (e) => {
                    const item = e.target.closest('[data-action]');
                    if (!item) return;
                    const action = item.dataset.action;
                    console.log('Quick save menu action:', action);

                    if (action === 'pdf') {
                        const projectName = document.getElementById('projectName')?.value || 'Untitled Project';
                        if (typeof window.showPDFExportDialog === 'function') {
                            window.showPDFExportDialog(projectName);
                        }
                    } else if (action === 'multiple') {
                        if (typeof window.saveAllImages === 'function') {
                            window.saveAllImages();
                        }
                    }
                });
                console.log('Quick save hover menu setup complete');
            } else {
                console.error('Quick save elements not found:', { quickSave, quickSaveBtn, quickSaveMenu });
            }
        }

        // Extracted helper function to check if container needs compact mode
        // NOTE: Toolbar containers are now handled by data-toolbar-mode attribute
        // This function only applies to non-toolbar smart-label-scope containers
        const compactStateCache = new Map(); // Track previous state to prevent thrashing
        
            function applyCompactLabels(container) {
                if (!container) return;
                
                // Skip toolbar containers - they're handled by data-toolbar-mode
                if (container.closest('#topToolbar')) {
                    return;
                }
                
                // Check if we're on desktop - never add compact class on desktop
                const isMobile = window.innerWidth <= 768;
                
                // Skip smart labels on desktop - always show full labels
                if (!isMobile) {
                    container.classList.remove('compact');
                    return;
                }
                
                // Simpler, more reliable overflow detection with hysteresis
                const containerWidth = container.clientWidth;
                const containerScrollWidth = container.scrollWidth;
                
                // Add 2px threshold to prevent rapid toggling near the boundary
                const threshold = 2;
                const needsCompact = containerScrollWidth > (containerWidth + threshold);
                const wasCompact = container.classList.contains('compact');
                const cachedState = compactStateCache.get(container);
                
                // Only toggle if state actually changed and difference is significant
                if (needsCompact !== wasCompact) {
                    // Check if we're near the boundary - if so, keep current state to prevent thrashing
                    const nearBoundary = Math.abs(containerScrollWidth - containerWidth) < threshold * 2;
                    if (nearBoundary && cachedState === wasCompact) {
                        // Near boundary and state hasn't changed - keep current state
                        return;
                    }
                    
                    // Update state
                    if (needsCompact) {
                        container.classList.add('compact');
                    } else {
                        container.classList.remove('compact');
                    }
                    compactStateCache.set(container, needsCompact);
                }
        }

        // Pre-calculate toolbar layout before making it visible
        // NOTE: Toolbar label sizing is now handled by data-toolbar-mode attribute
        // This function now only handles final layout stabilization
        function calculateInitialToolbarLayout() {
            const toolbarWrap = document.querySelector('.toolbar-wrap');
            if (!toolbarWrap) {
                return;
            }
            
            // Toolbar mode should already be set by the earlier script
            // Just ensure layout is stable
            
            // Force initial layout calculation to ensure all styles are applied
            void toolbarWrap.offsetWidth;
            
            // Final layout stabilization - force calculation on all toolbar elements
            const allButtons = toolbarWrap.querySelectorAll('button, input, select');
            allButtons.forEach(el => {
                void el.offsetWidth; // Force layout calculation
            });
            
            // One final layout calculation to ensure everything is stable
            void toolbarWrap.offsetWidth;
            
            // Toolbar-ready class should already be added (done earlier to prevent opacity transitions)
            // But ensure it's set here as well for consistency
            const topToolbar = document.getElementById('topToolbar');
            if (topToolbar && !topToolbar.classList.contains('toolbar-ready')) {
                topToolbar.classList.add('toolbar-ready');
            }
            if (!toolbarWrap.classList.contains('toolbar-ready')) {
                toolbarWrap.classList.add('toolbar-ready');
            }
            
            // After layout is stable, enable smooth transitions
            setTimeout(() => {
                if (topToolbar) {
                    topToolbar.classList.add('toolbar-stable');
                }
                if (toolbarWrap) {
                    toolbarWrap.classList.add('toolbar-stable');
                }
            }, 100);
        }

        // Smart label system for responsive button text
        function initSmartLabels(skipInitialCheck = false) {
            // Helper to wrap button with smart label spans
            function wrapSmartLabel(buttonEl, longText, shortText) {
                if (!buttonEl || buttonEl.querySelector('.label-long')) return; // Already wrapped
                
                buttonEl.innerHTML = `<span class="label-long">${longText}</span><span class="label-short">${shortText}</span>`;
                buttonEl.setAttribute('title', longText);
                buttonEl.setAttribute('aria-label', longText);
            }
            
            // Setup ResizeObserver for each smart-label-scope container
            const containers = document.querySelectorAll('.smart-label-scope');
            const observers = new Map();
            
            // Flag to prevent ResizeObserver from firing during initial setup
            let isInitializing = !skipInitialCheck;
            const initStartTime = Date.now();
            
            containers.forEach(container => {
                let debounceTimer = null;
                let lastWidth = 0;
                let lastHeight = 0;
                let isProcessing = false; // Prevent concurrent processing
                
                const debouncedApply = (entries) => {
                    // Skip if we're still initializing or already processing
                    if (isInitializing || isProcessing) return;
                    
                    // Check if enough time has passed since initialization started
                    const timeSinceInit = Date.now() - initStartTime;
                    if (timeSinceInit < 800) return; // Wait 800ms before allowing ResizeObserver to fire
                    
                    // Check if size actually changed significantly (prevent micro-adjustments)
                    const entry = entries && entries[0];
                    if (entry) {
                        const { width, height } = entry.contentRect;
                        const widthDiff = Math.abs(width - lastWidth);
                        const heightDiff = Math.abs(height - lastHeight);
                        
                        // Only process if change is significant (more than 2px to prevent micro-adjustments)
                        if (widthDiff < 2 && heightDiff < 2) {
                            return;
                        }
                        
                        lastWidth = width;
                        lastHeight = height;
                    }
                    
                    if (debounceTimer) clearTimeout(debounceTimer);
                    isProcessing = true;
                    debounceTimer = setTimeout(() => {
                        applyCompactLabels(container);
                        // Also check parent containers
                        const parent = container.closest('.smart-label-scope');
                        if (parent && parent !== container) {
                            applyCompactLabels(parent);
                        }
                        isProcessing = false;
                    }, 200); // Increased debounce time to prevent rapid toggling
                };
                
                // STEP 4: Performance guardrails - Don't observe toolbar containers
                // Toolbar sizing is handled by data-toolbar-mode attribute, not ResizeObserver
                // This prevents flicker loops and performance issues
                const isToolbarContainer = container.closest('#topToolbar') !== null;
                
                if (isToolbarContainer) {
                    // Skip ResizeObserver for toolbar - data-toolbar-mode handles sizing
                    return; // Don't observe toolbar containers at all
                }
                
                // For non-toolbar containers, set up ResizeObserver normally
                const observer = new ResizeObserver(debouncedApply);
                observer.observe(container);
                observers.set(container, observer);
                
                // Store initial dimensions
                const rect = container.getBoundingClientRect();
                lastWidth = rect.width;
                lastHeight = rect.height;
                
                // Initial check with immediate execution (skip if already calculated)
                if (!skipInitialCheck) {
                    applyCompactLabels(container);
                }
            });
            
            // Clear initialization flag after a longer delay to ensure everything is stable
            if (isInitializing) {
                setTimeout(() => {
                    isInitializing = false;
                }, 1000); // Increased to 1 second
            }
            
            // Setup buttons that get created dynamically by toolbar initialization
            setTimeout(() => {
                // Load Project button (created by reparent)
                const loadBtn = document.getElementById('loadProject');
                if (loadBtn) {
                    wrapSmartLabel(loadBtn, 'Load Project', 'Load');
                }
                
                // Save Project button (created dynamically)
                const saveBtn = document.getElementById('saveProjectTop');
                if (saveBtn) {
                    wrapSmartLabel(saveBtn, 'Save Project', 'Save');
                    // Make it visually distinct from bottom save button
                    saveBtn.style.background = '#3b82f6'; // Blue instead of green
                    saveBtn.style.borderColor = '#2563eb';
                    saveBtn.style.fontWeight = '700';
                    saveBtn.style.fontSize = '14px';
                    saveBtn.style.padding = '8px 16px';
                }
                
                // Immediate check for all containers (skip if already calculated)
                if (!skipInitialCheck) {
                containers.forEach(container => {
                    applyCompactLabels(container);
                });
                
                // Additional check after a short delay to ensure everything is rendered
                setTimeout(() => {
                    containers.forEach(container => {
                        applyCompactLabels(container);
                    });
                }, 100);
                }
            }, 150);
            
            // Global function to update drawing mode toggle labels
            window.updateDrawingModeLabels = function(mode) {
                const toggle = document.getElementById('drawingModeToggle');
                if (!toggle) return;
                
                const longSpan = toggle.querySelector('.label-long');
                const shortSpan = toggle.querySelector('.label-short');
                
                if (mode === true || mode === 'freehand') {
                    const longText = 'Freehand';
                    const shortText = 'Free';
                    if (longSpan) longSpan.textContent = longText;
                    if (shortSpan) shortSpan.textContent = shortText;
                    toggle.setAttribute('title', longText);
                    toggle.setAttribute('aria-label', longText);
                } else if (mode === 'curved') {
                    const longText = 'Curved Line';
                    const shortText = 'Curved';
                    if (longSpan) longSpan.textContent = longText;
                    if (shortSpan) shortSpan.textContent = shortText;
                    toggle.setAttribute('title', longText);
                    toggle.setAttribute('aria-label', longText);
                } else {
                    // Straight mode (false or 'straight')
                    const longText = 'Straight Line';
                    const shortText = 'Straight';
                    if (longSpan) longSpan.textContent = longText;
                    if (shortSpan) shortSpan.textContent = shortText;
                    toggle.setAttribute('title', longText);
                    toggle.setAttribute('aria-label', longText);
                }
                
                // Re-check container after label change
                const container = toggle.closest('.smart-label-scope');
                if (container) applyCompactLabels(container);
            };
            
            // Store observers for cleanup if needed
            window.smartLabelObservers = observers;
        }

        // New UI functionality for modular panels and capture frame
        document.addEventListener('DOMContentLoaded', () => {
            // 1. Initialize top toolbar structure first (so elements are in place)
            initializeTopToolbar();
            
            // 2. Toolbar-ready should already be added (done in inline script before DOMContentLoaded)
            // Just ensure it's set and mark as stable after initialization
            const topToolbar = document.getElementById('topToolbar');
            const toolbarWrap = document.querySelector('.toolbar-wrap');
            if (topToolbar && toolbarWrap) {
                // Ensure toolbar-ready is set
                topToolbar.classList.add('toolbar-ready');
                toolbarWrap.classList.add('toolbar-ready');
            }
            
            // 3. Calculate layout AFTER toolbar initialization completes (use RAF to ensure DOM is ready)
            requestAnimationFrame(() => {
                const doLayoutCalculation = () => {
                    // Force a layout calculation to ensure all styles are applied
                    const toolbarWrap = document.querySelector('.toolbar-wrap');
                    if (toolbarWrap) {
                        void toolbarWrap.offsetWidth; // Force layout
                    }
                    
                    // Now calculate layout (toolbar is already visible, but we need to stabilize it)
                    calculateInitialToolbarLayout();
                    
                    // 4. Setup smart labels (skip initial check since we already calculated)
                    initSmartLabels(true); // Pass true to skip initial check
                };
                
                // Wait for fonts to load to ensure accurate text measurements
                if (document.fonts && document.fonts.ready) {
                    // Check if fonts are already loaded
                    if (document.fonts.status === 'loaded') {
                        doLayoutCalculation();
                    } else {
                        document.fonts.ready.then(doLayoutCalculation);
                    }
                } else {
                    // Fallback if fonts API not available - use small delay
                    setTimeout(doLayoutCalculation, 50);
                }
            });
            
            // Setup quick save hover menu after toolbar initialization (with small delay)
            setTimeout(setupQuickSaveHover, 100);
            
            // (Sketchbook toggle removed per request)
            // Panel visibility toggles
            const strokePanel = document.getElementById('strokePanel');
            const imagePanel = document.getElementById('imagePanel');
            const captureOverlay = document.getElementById('captureOverlay');
            const captureFrame = document.getElementById('captureFrame');
            // Per-image capture frame storage and helpers
            window.captureFrameByLabel = window.captureFrameByLabel || {};
            function buildCaptureFrameRecord(rect) {
                const winW = Math.max(window.innerWidth, 1);
                const winH = Math.max(window.innerHeight, 1);
                return {
                    left: Math.round(rect.left),
                    top: Math.round(rect.top),
                    width: Math.round(rect.width),
                    height: Math.round(rect.height),
                    windowWidth: winW,
                    windowHeight: winH,
                    relativeLeft: rect.left / winW,
                    relativeTop: rect.top / winH,
                    relativeWidth: rect.width / winW,
                    relativeHeight: rect.height / winH
                };
            }
            function getCaptureFrameRectPixels() {
                const rect = captureFrame.getBoundingClientRect();
                return buildCaptureFrameRecord(rect);
            }
            function saveCurrentCaptureFrameForLabel(label) {
                if (!label) return;
                window.captureFrameByLabel[label] = getCaptureFrameRectPixels();
            }
            function resolveCaptureFrameRect(stored) {
                const winW = Math.max(window.innerWidth, 1);
                const winH = Math.max(window.innerHeight, 1);
                const targetAspect = 4 / 3;

                let fallbackWidth = Math.min(800, winW);
                let fallbackHeight = Math.round(fallbackWidth / targetAspect);
                if (fallbackHeight > winH) {
                    fallbackHeight = Math.min(600, winH);
                    fallbackWidth = Math.round(fallbackHeight * targetAspect);
                }

                const fallback = {
                    left: Math.max(0, Math.round((winW - fallbackWidth) / 2)),
                    top: Math.max(0, Math.round((winH - fallbackHeight) / 2)),
                    width: fallbackWidth,
                    height: fallbackHeight
                };
                if (!stored) return fallback;

                const baseW = stored.windowWidth || winW;
                const baseH = stored.windowHeight || winH;
                let width = Math.max(1, Math.round(
                    typeof stored.relativeWidth === 'number'
                        ? stored.relativeWidth * winW
                        : (stored.width ?? fallback.width)
                ));
                let height = Math.max(1, Math.round(
                    typeof stored.relativeHeight === 'number'
                        ? stored.relativeHeight * winH
                        : (stored.height ?? fallback.height)
                ));

                if (width / height > targetAspect) {
                    width = Math.round(height * targetAspect);
                } else {
                    height = Math.round(width / targetAspect);
                }

                const leftRatio = typeof stored.relativeLeft === 'number'
                    ? stored.relativeLeft
                    : (stored.left ?? fallback.left) / baseW;
                const topRatio = typeof stored.relativeTop === 'number'
                    ? stored.relativeTop
                    : (stored.top ?? fallback.top) / baseH;

                const maxLeft = Math.max(0, winW - width);
                const maxTop = Math.max(0, winH - height);

                return {
                    left: Math.min(maxLeft, Math.max(0, Math.round(leftRatio * winW))),
                    top: Math.min(maxTop, Math.max(0, Math.round(topRatio * winH))),
                    width: Math.min(width, winW),
                    height: Math.min(height, winH)
                };
            }
            function applyCaptureFrameForLabel(label) {
                const stored = window.captureFrameByLabel[label];
                const rect = resolveCaptureFrameRect(stored);
                captureFrame.style.left = `${rect.left}px`;
                captureFrame.style.top = `${rect.top}px`;
                captureFrame.style.width = `${rect.width}px`;
                captureFrame.style.height = `${rect.height}px`;

                if (label) {
                    window.captureFrameByLabel[label] = {
                        ...(stored || {}),
                        ...rect,
                        windowWidth: Math.max(window.innerWidth, 1),
                        windowHeight: Math.max(window.innerHeight, 1),
                        relativeLeft: rect.left / Math.max(window.innerWidth, 1),
                        relativeTop: rect.top / Math.max(window.innerHeight, 1),
                        relativeWidth: rect.width / Math.max(window.innerWidth, 1),
                        relativeHeight: rect.height / Math.max(window.innerHeight, 1)
                    };
                }
            }
            window.saveCurrentCaptureFrameForLabel = saveCurrentCaptureFrameForLabel;
            window.applyCaptureFrameForLabel = applyCaptureFrameForLabel;

            let captureFrameResizeRaf = null;
            window.addEventListener('resize', () => {
                if (captureFrameResizeRaf !== null) return;
                captureFrameResizeRaf = requestAnimationFrame(() => {
                    captureFrameResizeRaf = null;
                    const activeLabel = window.currentImageLabel;
                    if (typeof window.applyCaptureFrameForLabel === 'function') {
                        window.applyCaptureFrameForLabel(activeLabel);
                    }
                });
            });
            
            // Mobile toolbar expand/collapse functionality
            (function initToolbarToggle() {
                const toolbarWrap = document.querySelector('.toolbar-wrap');
                if (!toolbarWrap) return;
                
                function isMobileDevice() {
                    return window.innerWidth <= 768;
                }
                
                // Track if we've shown the initial glow (only once per page load)
                let hasShownInitialGlow = false;
                let wasScrollable = false;
                let wasExpanded = false;
                
                // Check if toolbar is scrollable (can be expanded)
                function checkIfExpandable() {
                    const isMobile = isMobileDevice();
                    const isExpanded = toolbarWrap.classList.contains('expanded');
                    
                    
                    if (!isMobile || isExpanded) {
                        toolbarWrap.removeAttribute('data-scrollable');
                        toolbarWrap.classList.remove('expandable');
                        // Don't reset flags when expanded - preserve state for when collapsed
                        if (!isMobile) {
                            hasShownInitialGlow = false;
                            wasScrollable = false;
                        }
                        wasExpanded = isExpanded;
                        return;
                    }
                    
                    // Check if content overflows
                    const isScrollable = toolbarWrap.scrollWidth > toolbarWrap.clientWidth;
                    const hadScrollable = toolbarWrap.hasAttribute('data-scrollable');
                    
                    
                    // Set data attribute for CSS hover detection
                    if (isScrollable) {
                        toolbarWrap.setAttribute('data-scrollable', 'true');
                        
                        // Show glow once when transitioning from non-scrollable to scrollable
                        // BUT only if we haven't shown it before AND we're not coming from expanded state
                        const shouldShowGlow = !wasScrollable && !hasShownInitialGlow && !wasExpanded;
                        
                        if (shouldShowGlow) {
                            // Remove inline style to allow animation
                            toolbarWrap.style.removeProperty('box-shadow');
                            toolbarWrap.classList.add('expandable');
                            hasShownInitialGlow = true;
                            
                            // Remove the class after animation completes and clear inline style
                            setTimeout(() => {
                                toolbarWrap.classList.remove('expandable');
                                // Clear inline style so hover can work
                                toolbarWrap.style.removeProperty('box-shadow');
                            }, 500);
                        } else {
                            // Only clear inline style if not hovering and not animating
                            if (!toolbarWrap.matches(':hover') && !toolbarWrap.classList.contains('expanded') && !toolbarWrap.classList.contains('expandable') && !toolbarWrap.classList.contains('tapped')) {
                                toolbarWrap.style.removeProperty('box-shadow');
                            }
                        }
                    } else {
                        toolbarWrap.removeAttribute('data-scrollable');
                        toolbarWrap.classList.remove('expandable');
                        // Reset glow flag when not scrollable (but preserve if we were expanded)
                        if (!wasExpanded) {
                            hasShownInitialGlow = false;
                        }
                    }
                    
                    // Update previous state
                    wasScrollable = isScrollable;
                    wasExpanded = isExpanded;
                }
                
                // Initial check and periodic checks
                setTimeout(() => {
                    checkIfExpandable();
                }, 500);
                
                // Only run periodic checks on mobile (where expand/collapse matters)
                const checkInterval = isMobileDevice() ? setInterval(() => {
                    checkIfExpandable();
                }, 2000) : null;
                
                // Clean up interval if not needed
                if (!checkInterval && !isMobileDevice()) {
                    // On desktop, only check once after initial setup
                    setTimeout(() => {
                        checkIfExpandable();
                    }, 1000);
                }
                
                // Also check on scroll
                toolbarWrap.addEventListener('scroll', () => {
                    clearTimeout(checkIfExpandable.timeout);
                    checkIfExpandable.timeout = setTimeout(() => {
                        checkIfExpandable();
                    }, 300);
                });
                
                function handleToolbarTap(e) {
                    if (!isMobileDevice()) {
                        return;
                    }
                    
                    // Only process if the event target is the toolbar or a child of the toolbar
                    const target = e.target;
                    if (!toolbarWrap.contains(target) && target !== toolbarWrap) {
                        return; // Not a toolbar event, let it pass through
                    }
                    
                    const rect = toolbarWrap.getBoundingClientRect();
                    const tapY = e.clientY || (e.changedTouches && e.changedTouches[0]?.clientY) || 0;
                    const tapX = e.clientX || (e.changedTouches && e.changedTouches[0]?.clientX) || 0;
                    
                    // Check if tap is in the bottom 12px of the toolbar
                    const bottomThreshold = 12;
                    const isBottomTap = tapY >= rect.bottom - bottomThreshold && tapY <= rect.bottom;
                    
                    // Also check if tap is on the toolbar itself (not on a button)
                    const isToolbarArea = tapY >= rect.top && tapY <= rect.bottom && 
                                         tapX >= rect.left && tapX <= rect.right;
                    
                    // Don't toggle if clicking on a button or input
                    const isInteractiveElement = target.tagName === 'BUTTON' || 
                                                target.tagName === 'INPUT' || 
                                                target.closest('button') || 
                                                target.closest('input') ||
                                                target.closest('.color-swatches');
                    
                    
                    if (isBottomTap && isToolbarArea && !isInteractiveElement) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const wasExpanded = toolbarWrap.classList.contains('expanded');
                        
                        // Add glow animation on tap
                        toolbarWrap.classList.remove('tapped');
                        // Remove inline style to allow animation
                        toolbarWrap.style.removeProperty('box-shadow');
                        void toolbarWrap.offsetWidth; // Force reflow
                        toolbarWrap.classList.add('tapped');
                        
                        // Remove tapped class after animation and clear inline style
                        setTimeout(() => {
                            toolbarWrap.classList.remove('tapped');
                            // Clear inline style so hover can work
                            toolbarWrap.style.removeProperty('box-shadow');
                        }, 1000);
                        
                        toolbarWrap.classList.toggle('expanded');
                        
                        // Update topToolbar height
                        const topToolbar = document.getElementById('topToolbar');
                        if (topToolbar) {
                            if (toolbarWrap.classList.contains('expanded')) {
                                topToolbar.style.height = 'auto';
                                topToolbar.style.maxHeight = 'calc(5 * (32px + 6px) + 16px)'; // 5 rows + padding
                            } else {
                                topToolbar.style.height = '48px';
                                topToolbar.style.maxHeight = 'none';
                                // Remove animation classes and clear inline style
                                toolbarWrap.classList.remove('expandable', 'tapped');
                                // Add no-glow class to prevent hover glow from persisting
                                toolbarWrap.classList.add('no-glow');
                                // Temporarily remove data-scrollable to clear any hover glow
                                toolbarWrap.removeAttribute('data-scrollable');
                                toolbarWrap.style.removeProperty('box-shadow');
                                // Force clear any glow immediately
                                toolbarWrap.style.boxShadow = 'none';
                                
                                // Check if mouse is already outside the toolbar (not hovering)
                                const isCurrentlyHovered = toolbarWrap.matches(':hover');
                                
                                // If mouse is already outside, remove no-glow immediately
                                if (!isCurrentlyHovered) {
                                    setTimeout(() => {
                                        toolbarWrap.classList.remove('no-glow');
                                    }, 100); // Small delay to ensure collapse animation completes
                                } else {
                                    // Remove no-glow class when mouse leaves (to allow hover glow again)
                                    const removeNoGlowOnLeave = () => {
                                        if (toolbarWrap.classList.contains('no-glow')) {
                                            toolbarWrap.classList.remove('no-glow');
                                        }
                                    };
                                    toolbarWrap.addEventListener('mouseleave', removeNoGlowOnLeave, { once: true });
                                    
                                    // Also remove after a delay as fallback (for touch devices or if mouseleave doesn't fire)
                                    setTimeout(() => {
                                        if (toolbarWrap.classList.contains('no-glow')) {
                                            toolbarWrap.classList.remove('no-glow');
                                            toolbarWrap.removeEventListener('mouseleave', removeNoGlowOnLeave);
                                        }
                                    }, 1000);
                                }
                            }
                        }
                        
                        // Recheck expandability after toggle
                        setTimeout(() => {
                            // Double-check glow is cleared after collapse
                            if (!toolbarWrap.classList.contains('expanded')) {
                                toolbarWrap.style.boxShadow = 'none';
                                toolbarWrap.style.removeProperty('box-shadow');
                                // Don't remove data-scrollable if no-glow is active (it will prevent glow anyway)
                                if (!toolbarWrap.classList.contains('no-glow')) {
                                    toolbarWrap.removeAttribute('data-scrollable');
                                }
                                // Force reflow to ensure CSS applies
                                void toolbarWrap.offsetWidth;
                            }
                            checkIfExpandable();
                        }, 150);
                    }
                }
                
                // Add event listeners for both click and touch
                toolbarWrap.addEventListener('click', handleToolbarTap);
                toolbarWrap.addEventListener('touchend', handleToolbarTap);
                
                // Handle window resize
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        if (!isMobileDevice() && toolbarWrap.classList.contains('expanded')) {
                            toolbarWrap.classList.remove('expanded');
                            const topToolbar = document.getElementById('topToolbar');
                            if (topToolbar) {
                                topToolbar.style.height = '48px';
                                topToolbar.style.maxHeight = 'none';
                            }
                        }
                        checkIfExpandable();
                    }, 150);
                });
                
                // Cleanup interval on page unload
                window.addEventListener('beforeunload', () => {
                    clearInterval(checkInterval);
                });
            })();
            
            // Enhanced panel toggle functionality with minimize-to-header behavior
            function createPanelToggle(panelId, contentId, buttonId) {
                const panel = document.getElementById(panelId);
                const content = document.getElementById(contentId);
                const button = document.getElementById(buttonId);
                const icon = button?.querySelector('svg');
                
                if (!panel || !content || !button || !icon) return;
                
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Use the specified content element
                    const body = content;
                    const isMinimized = body.classList.contains('hidden');
                    
                    // Special handling for imagePanel: ensure navigation container stays visible
                    if (panelId === 'imagePanel') {
                        const navContainer = document.getElementById('navigation-container');
                        const miniStepper = document.getElementById('mini-stepper');
                        if (navContainer) {
                            // Explicitly ensure navigation container stays visible
                            navContainer.style.display = 'block';
                            navContainer.style.visibility = 'visible';
                            navContainer.style.opacity = '1';
                            navContainer.style.pointerEvents = 'auto';
                        }
                        if (miniStepper) {
                            miniStepper.style.display = 'flex';
                            miniStepper.style.visibility = 'visible';
                            miniStepper.style.opacity = '1';
                            miniStepper.style.pointerEvents = 'auto';
                        }
                    }
                    
                    if (isMinimized) {
                        // Expand panel
                        // starting from hidden (max-height:0), set explicit height to animate open
                        body.classList.remove('hidden');
                        body.style.maxHeight = body.scrollHeight + 'px';
                        // after transition completes, allow natural growth
                        const onEnd = () => {
                            body.style.maxHeight = 'none';
                            body.removeEventListener('transitionend', onEnd);
                        };
                        body.addEventListener('transitionend', onEnd);
                        icon.style.transform = 'rotate(0deg)';
                        panel.classList.remove('minimized');
                        panel.setAttribute('aria-expanded', 'true');
                    } else {
                        // Minimize panel
                        // if maxHeight is none (auto), set current height to enable smooth collapse
                        if (!body.style.maxHeight || body.style.maxHeight === 'none') {
                            body.style.maxHeight = body.scrollHeight + 'px';
                            // force reflow
                            void body.offsetHeight;
                        }
                        // add hidden to animate to max-height:0 via CSS
                        body.classList.add('hidden');
                        icon.style.transform = 'rotate(-90deg)';
                        panel.classList.add('minimized');
                        panel.setAttribute('aria-expanded', 'false');
                        
                        // For imagePanel, ensure navigation stays visible after collapse
                        if (panelId === 'imagePanel') {
                            const navContainer = document.getElementById('navigation-container');
                            const miniStepper = document.getElementById('mini-stepper');
                            if (navContainer) {
                                navContainer.style.display = 'block';
                                navContainer.style.visibility = 'visible';
                                navContainer.style.opacity = '1';
                            }
                            if (miniStepper) {
                                miniStepper.style.display = 'flex';
                                miniStepper.style.visibility = 'visible';
                                miniStepper.style.opacity = '1';
                            }
                        }
                    }
                });
            }
            
            // Apply toggle functionality to all panels (default open for Stroke & Images)
            createPanelToggle('projectPanel', 'projectPanelContent', 'toggleProjectPanel');
            createPanelToggle('toolsPanel', 'toolsPanelContent', 'toggleToolsPanel');
            createPanelToggle('strokePanel', 'elementsBody', 'toggleStrokePanel');
            createPanelToggle('imagePanel', 'imagePanelContent', 'toggleImagePanel');
            createPanelToggle('canvasControls', 'canvasControlsContent', 'toggleCanvasControls');

            // Ensure Vectors and tags and Images are open by default on desktop, closed on mobile
            // Run immediately and also after a short delay to catch any late initialization
            (function expandByDefault() {
                function isMobileDevice() {
                    return window.innerWidth <= 768;
                }
                
                function ensurePanelsExpanded() {
                    const strokePanel = document.getElementById('strokePanel');
                    const imagePanel = document.getElementById('imagePanel');
                const strokeContent = document.getElementById('elementsBody');
                const imageContent = document.getElementById('imagePanelContent');
                    const isMobile = isMobileDevice();
                    
                    if (!strokePanel || !imagePanel) {
                        return;
                    }
                    
                    // On mobile: start minimized (closed), on desktop: start expanded (open)
                    if (isMobile) {
                        // Mobile: minimize panels by default
                        strokePanel.classList.remove('expanded');
                        strokePanel.classList.add('minimized');
                        strokePanel.setAttribute('data-mobile-state', 'minimized');
                        strokePanel.setAttribute('aria-expanded', 'false');
                        strokePanel.style.display = 'none'; // Hide on mobile when minimized
                        
                        imagePanel.classList.remove('expanded');
                        imagePanel.classList.add('minimized');
                        imagePanel.setAttribute('data-mobile-state', 'minimized');
                        imagePanel.setAttribute('aria-expanded', 'false');
                        imagePanel.style.display = 'none'; // Hide on mobile when minimized
                        
                        // Hide content on mobile when minimized
                        if (strokeContent) {
                            strokeContent.classList.add('hidden');
                        }
                        if (imageContent) {
                            imageContent.classList.add('hidden');
                }
                    } else {
                        // Desktop: expand panels by default
                        strokePanel.classList.remove('minimized', 'expanded');
                        strokePanel.setAttribute('data-mobile-state', 'expanded');
                        strokePanel.setAttribute('aria-expanded', 'true');
                        strokePanel.style.display = 'flex';
                        
                        imagePanel.classList.remove('minimized', 'expanded');
                        imagePanel.setAttribute('data-mobile-state', 'expanded');
                        imagePanel.setAttribute('aria-expanded', 'true');
                        imagePanel.style.display = 'flex';
                        
                        // Aggressively ensure content is visible on desktop
                        if (strokeContent) {
                            strokeContent.classList.remove('hidden');
                            strokeContent.style.maxHeight = 'none';
                            strokeContent.style.display = '';
                            strokeContent.style.visibility = '';
                            strokeContent.style.opacity = '';
                        }
                        if (imageContent) {
                            imageContent.classList.remove('hidden');
                            imageContent.style.maxHeight = 'none';
                            imageContent.style.display = '';
                            imageContent.style.visibility = '';
                            imageContent.style.opacity = '';
                        }
                    }
                
                // Mark panels as loaded to enable transitions after initial render
                strokePanel.setAttribute('data-loaded', 'true');
                imagePanel.setAttribute('data-loaded', 'true');
                if (strokeContent) strokeContent.setAttribute('data-loaded', 'true');
                if (imageContent) imageContent.setAttribute('data-loaded', 'true');
                    
                }
                
                // Run immediately
                ensurePanelsExpanded();
                
                // Also run after a short delay to catch any late initialization
                setTimeout(ensurePanelsExpanded, 50);
                setTimeout(ensurePanelsExpanded, 200);
            })();

            // Mobile panel toggle icons functionality
            function isMobileDevice() {
                return window.innerWidth <= 768;
            }

            function initializePanelToggleIcons() {
                const strokePanel = document.getElementById('strokePanel');
                const imagePanel = document.getElementById('imagePanel');
                const strokeIcon = document.getElementById('strokePanelIcon');
                const imageIcon = document.getElementById('imagePanelIcon');

                if (!strokePanel || !imagePanel || !strokeIcon || !imageIcon) {
                    console.warn('Panel toggle icons or panels not found');
                    return;
                }

                // Initialize panel states - start minimized on mobile, expanded on desktop
                const isMobile = isMobileDevice();
                if (!strokePanel.getAttribute('data-mobile-state')) {
                    strokePanel.setAttribute('data-mobile-state', isMobile ? 'minimized' : 'expanded');
                }
                if (!imagePanel.getAttribute('data-mobile-state')) {
                    imagePanel.setAttribute('data-mobile-state', isMobile ? 'minimized' : 'expanded');
                }

                // Sync icon visual state with panel state
                function syncIconState(panel, icon) {
                    icon.classList.remove('minimized', 'expanded');
                    panel.classList.remove('minimized', 'expanded');

                    const isOpen = panel.getAttribute('data-mobile-state') === 'expanded';
                    if (isOpen) {
                        icon.classList.add('expanded');
                        panel.classList.add('expanded');
                        panel.style.display = 'flex';
                        // Ensure panel content is visible
                        const contentId = panel.id === 'strokePanel' ? 'elementsBody' : 'imagePanelContent';
                        const content = document.getElementById(contentId);
                        if (content) {
                            content.classList.remove('hidden');
                            content.style.maxHeight = 'none';
                        }
                    } else {
                        icon.classList.add('minimized');
                        panel.classList.add('minimized');
                        // On mobile, hide the panel when minimized
                        if (isMobileDevice()) {
                            panel.style.display = 'none';
                        }
                    }
                }

                // Toggle panel on icon click
                function setupIconToggle(panel, icon) {
                    icon.addEventListener('click', (e) => {
                        if (!isMobileDevice()) return;
                        e.stopPropagation();

                        const isCurrentlyOpen = panel.getAttribute('data-mobile-state') === 'expanded';
                        panel.setAttribute('data-mobile-state', isCurrentlyOpen ? 'minimized' : 'expanded');
                        syncIconState(panel, icon);
                    });
                }

                // Show/hide icons and panels based on device type
                function updatePanelVisibility() {
                    const isMobile = isMobileDevice();

                    // On desktop, always show panels and ensure content is visible
                    if (!isMobile) {
                        strokePanel.style.display = 'flex';
                        imagePanel.style.display = 'flex';
                        // Hide icons on desktop
                        strokeIcon.style.display = 'none';
                        imageIcon.style.display = 'none';
                        // Ensure content is visible on desktop
                        const strokeContent = document.getElementById('elementsBody');
                        const imageContent = document.getElementById('imagePanelContent');
                        if (strokeContent) {
                            strokeContent.classList.remove('hidden');
                            strokeContent.style.maxHeight = 'none';
                        }
                        if (imageContent) {
                            imageContent.classList.remove('hidden');
                            imageContent.style.maxHeight = 'none';
                        }
                    } else {
                        // On mobile, show icons with smooth fade-in
                        strokeIcon.style.display = 'flex';
                        imageIcon.style.display = 'flex';
                        // Fade in icons smoothly
                        requestAnimationFrame(() => {
                            strokeIcon.style.opacity = '1';
                            imageIcon.style.opacity = '1';
                        });
                        // Sync panel state with icons
                        syncIconState(strokePanel, strokeIcon);
                        syncIconState(imagePanel, imageIcon);
                    }
                }

                // Initialize
                setupIconToggle(strokePanel, strokeIcon);
                setupIconToggle(imagePanel, imageIcon);
                updatePanelVisibility();

                // Update on window resize
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(updatePanelVisibility, 150);
                });
            }

            // Initialize panel toggle icons after a short delay to ensure DOM is ready
            setTimeout(initializePanelToggleIcons, 100);

            // removed elements resize handle wiring

            // Set up Vectors and tags panel button functionality
            const selectAllStrokesBtn = document.getElementById('selectAllStrokesBtn');
            const showAllMeasurementsBtn = document.getElementById('showAllMeasurementsBtn');

            // Select/Deselect All Strokes functionality
            if (selectAllStrokesBtn) {
                let allSelected = false; // Start with deselect all (false)
                selectAllStrokesBtn.addEventListener('click', () => {
                    const checkboxes = document.querySelectorAll('#strokeVisibilityControls input[type="checkbox"]');
                    allSelected = !allSelected;
                    
                    checkboxes.forEach(checkbox => {
                        if (checkbox.checked !== allSelected) {
                            checkbox.click(); // Use click to trigger the existing event handlers
                        }
                    });
                    
                    // Update button text
                    selectAllStrokesBtn.textContent = allSelected ? 'Deselect All' : 'Select All';
                    selectAllStrokesBtn.title = allSelected ? 'Deselect all elements' : 'Select all elements';
                });
            }

            // Show All Measurements functionality
            if (showAllMeasurementsBtn) {
                showAllMeasurementsBtn.addEventListener('click', () => {
                    if (typeof window.generateMeasurementsList === 'function') {
                        window.generateMeasurementsList();
                    }
                });
            }
            
            // View Submitted Measurements functionality
            const viewSubmittedMeasurementsBtn = document.getElementById('viewSubmittedMeasurementsBtn');
            if (viewSubmittedMeasurementsBtn) {
                viewSubmittedMeasurementsBtn.addEventListener('click', () => {
                    if (typeof window.viewSubmittedMeasurements === 'function') {
                        window.viewSubmittedMeasurements();
                    } else {
                        console.error('viewSubmittedMeasurements function not found');
                    }
                });
            }

            // Simplified Tag System
            let tagMode = 'letters+numbers'; // 'letters' or 'letters+numbers'
            
            // Helper function to find next available letter (A, B, C...)
            function findNextAvailableLetter() {
                const currentImageLabel = window.currentImageLabel || 'default';
                const lineStrokes = window.lineStrokesByImage?.[currentImageLabel] || [];
                const existingTags = lineStrokes.filter(Boolean);
                
                // Extract all letters that have been used (from both A and A1 patterns)
                const usedLetters = new Set();
                for (const tag of existingTags) {
                    if (/^[A-Z]/.test(tag)) {
                        usedLetters.add(tag[0]); // Get the first letter
                    }
                }
                
                // Find the first unused letter
                for (let i = 0; i < 26; i++) {
                    const letter = String.fromCharCode(65 + i); // A=65, B=66, etc.
                    if (!usedLetters.has(letter)) {
                        return letter;
                    }
                }
                
                // If all letters A-Z are used, start over at A
                return 'A';
            }
            
            // Helper function to find next available letter+number (A1, A2, A3...)
            function findNextAvailableLetterNumber() {
                const currentImageLabel = window.currentImageLabel || 'default';
                const lineStrokes = window.lineStrokesByImage?.[currentImageLabel] || [];
                const existingTags = lineStrokes.filter(Boolean);
                
                // Extract all base tags (A1, A2, etc.) and track the highest per letter
                const letterCounts = new Map();
                
                for (const tag of existingTags) {
                    // Handle both A1 and A1(1) patterns
                    const match = tag.match(/^([A-Z])(\d+)(?:\((\d+)\))?$/);
                    if (match) {
                        const letter = match[1];
                        const number = parseInt(match[2]);
                        const currentMax = letterCounts.get(letter) || 0;
                        letterCounts.set(letter, Math.max(currentMax, number));
                    }
                }
                
                // Find the next available tag
                for (let letter = 'A'; letter <= 'Z'; letter = String.fromCharCode(letter.charCodeAt(0) + 1)) {
                    const maxNumber = letterCounts.get(letter) || 0;
                    const nextNumber = maxNumber + 1;
                    
                    if (nextNumber <= 9) {
                        return letter + nextNumber;
                    }
                }
                
                // If we've exhausted all possibilities up to Z9, start over at A1
                return 'A1';
            }

            // Tag Mode Toggle functionality
            const tagModeToggle = document.getElementById('tagModeToggle');
            if (tagModeToggle) {
                tagModeToggle.addEventListener('click', () => {
                    const oldMode = tagMode;
                    tagMode = tagMode === 'letters' ? 'letters+numbers' : 'letters';
                    tagModeToggle.textContent = tagMode === 'letters' ? 'Letters Only' : 'Letters + Numbers';
                    
                    // Automatically set the next appropriate tag when switching modes
                    const currentImageLabel = window.currentImageLabel || 'default';
                    window.labelsByImage = window.labelsByImage || {};
                    
                    if (tagMode === 'letters') {
                        // Switching to letters only - find next available letter
                        const nextLetter = findNextAvailableLetter();
                        window.labelsByImage[currentImageLabel] = nextLetter;
                        console.log(`[tagModeToggle] Switched to letters mode, next tag: ${nextLetter}`);
                    } else {
                        // Switching to letters+numbers - find next available letter+number
                        const nextLetterNumber = findNextAvailableLetterNumber();
                        window.labelsByImage[currentImageLabel] = nextLetterNumber;
                        console.log(`[tagModeToggle] Switched to letters+numbers mode, next tag: ${nextLetterNumber}`);
                    }
                    
                    updateNextTagDisplay();
                });
            }

            // Calculate next tag based on current mode and existing tags
            function calculateNextTag() {
                console.log('[calculateNextTag] Called with tagMode:', tagMode);
                const currentImageLabel = window.currentImageLabel || 'default';
                const lineStrokes = window.lineStrokesByImage?.[currentImageLabel] || [];
                const existingTags = lineStrokes.filter(Boolean);
                
                console.log('[calculateNextTag] Current image:', currentImageLabel, 'existing tags:', existingTags);
                
                if (existingTags.length === 0) {
                    const result = tagMode === 'letters' ? 'A' : 'A1';
                    console.log('[calculateNextTag] No existing tags, returning:', result);
                    return result;
                }
                
                // Extract all base tags (without suffixes)
                const baseTags = new Set();
                
                for (const tag of existingTags) {
                    if (tagMode === 'letters') {
                        if (/^[A-Z]$/.test(tag)) {
                            baseTags.add(tag);
                        }
                    } else {
                        // Handle both A1 and A1(1), A1(2) patterns
                        const match = tag.match(/^([A-Z]\d+)(?:\((\d+)\))?$/);
                        if (match) {
                            const baseTag = match[1];
                            baseTags.add(baseTag);
                        }
                    }
                }
                
                if (baseTags.size === 0) {
                    // No valid tags found, start fresh
                    const result = tagMode === 'letters' ? 'A' : 'A1';
                    console.log('[calculateNextTag] No valid tags found, returning:', result);
                    return result;
                }
                
                // Sort tags properly for alphanumeric comparison
                const sortedBaseTags = Array.from(baseTags).sort((a, b) => {
                    if (tagMode === 'letters') {
                        // Simple alphabetic sort for letter-only mode
                        return a.localeCompare(b);
                    } else {
                        // Alphanumeric sort: compare letter first, then number
                        const matchA = a.match(/^([A-Z])(\d+)$/);
                        const matchB = b.match(/^([A-Z])(\d+)$/);
                        
                        if (!matchA || !matchB) return a.localeCompare(b);
                        
                        const [, letterA, numA] = matchA;
                        const [, letterB, numB] = matchB;
                        
                        // Compare letters first
                        if (letterA !== letterB) {
                            return letterA.localeCompare(letterB);
                        }
                        
                        // If same letter, compare numbers numerically
                        return parseInt(numA) - parseInt(numB);
                    }
                });
                
                console.log('[calculateNextTag] Sorted tags:', sortedBaseTags);
                
                if (tagMode === 'letters') {
                    // Letters only mode: Check for gaps first
                    for (let i = 0; i < sortedBaseTags.length - 1; i++) {
                        const currentLetter = sortedBaseTags[i][0];
                        const nextLetter = sortedBaseTags[i + 1][0];
                        const expectedNext = String.fromCharCode(currentLetter.charCodeAt(0) + 1);
                        
                        if (expectedNext !== nextLetter && expectedNext <= 'Z') {
                            console.log('[calculateNextTag] Letters mode, found gap:', expectedNext);
                            return expectedNext;
                        }
                    }
                    
                    // No gaps, increment from last
                    const lastLetter = sortedBaseTags[sortedBaseTags.length - 1][0];
                    const nextLetter = String.fromCharCode(lastLetter.charCodeAt(0) + 1);
                    
                    if (nextLetter > 'Z') {
                        console.log('[calculateNextTag] Letters mode, wrapped to A');
                        return 'A';
                    }
                    
                    console.log('[calculateNextTag] Letters mode, next:', nextLetter);
                    return nextLetter;
                } else {
                    // Letters + numbers mode: Check for gaps first
                    for (let i = 0; i < sortedBaseTags.length; i++) {
                        const match = sortedBaseTags[i].match(/^([A-Z])(\d+)$/);
                        if (!match) continue;
                        
                        const [, letter, number] = match;
                        const num = parseInt(number);
                        
                        // Check if this is the first tag with this letter
                        if (i === 0 || sortedBaseTags[i - 1][0] !== letter) {
                            // If it doesn't start at 1, fill from 1
                            if (num > 1) {
                                const result = letter + '1';
                                console.log('[calculateNextTag] Numbers mode, found gap at start:', result);
                                return result;
                            }
                        }
                        
                        // Check for gaps within the same letter
                        if (i < sortedBaseTags.length - 1) {
                            const nextMatch = sortedBaseTags[i + 1].match(/^([A-Z])(\d+)$/);
                            if (nextMatch) {
                                const [, nextLetter, nextNumber] = nextMatch;
                                const nextNum = parseInt(nextNumber);
                                
                                // If same letter, check for gap
                                if (letter === nextLetter && nextNum > num + 1) {
                                    const result = letter + (num + 1);
                                    console.log('[calculateNextTag] Numbers mode, found gap:', result);
                                    return result;
                                }
                            }
                        }
                    }
                    
                    // No gaps, increment from last
                    const lastBaseTag = sortedBaseTags[sortedBaseTags.length - 1];
                    const match = lastBaseTag.match(/^([A-Z])(\d+)$/);
                    if (match) {
                        const [, letter, number] = match;
                        const nextNumber = parseInt(number) + 1;
                        
                        // Check if we need to move to the next letter
                        if (nextNumber > 9) {
                            const nextLetter = String.fromCharCode(letter.charCodeAt(0) + 1);
                            if (nextLetter > 'Z') {
                                console.log('[calculateNextTag] Numbers mode, wrapped to A1');
                                return 'A1';
                            }
                            const result = nextLetter + '1';
                            console.log('[calculateNextTag] Numbers mode, exceeded 9, next:', result);
                            return result;
                        }
                        
                        const result = letter + nextNumber;
                        console.log('[calculateNextTag] Numbers mode, next:', result);
                        return result;
                    } else {
                        console.log('[calculateNextTag] Unexpected tag format, returning A1');
                        return 'A1';
                    }
                }
            }

            // Calculate the next tag after a specific tag (for manual tag setting)
            // This increments without gap-filling to preserve user intent
            function calculateNextTagFrom(tag) {
                const mode = typeof tagMode === 'string' ? tagMode : 'letters+numbers';
                
                if (mode === 'letters') {
                    // Just increment the letter
                    const nextLetter = String.fromCharCode(tag.charCodeAt(0) + 1);
                    return nextLetter > 'Z' ? 'A' : nextLetter;
                } else {
                    // Letters + numbers mode
                    const match = tag.match(/^([A-Z])(\d+)$/);
                    if (!match) return 'A1';
                    
                    const [, letter, number] = match;
                    const nextNumber = parseInt(number) + 1;
                    
                    if (nextNumber > 9) {
                        // Wrap to next letter
                        const nextLetter = String.fromCharCode(letter.charCodeAt(0) + 1);
                        if (nextLetter > 'Z') {
                            return 'A1'; // Wrap around
                        }
                        return nextLetter + '1';
                    }
                    
                    return letter + nextNumber;
                }
            }

            // Calculate the next tag after a specific tag (simple increment, no gap-filling)
            function calculateNextTagFrom(tag) {
                const mode = typeof tagMode === 'string' ? tagMode : 'letters+numbers';
                
                if (mode === 'letters') {
                    // Just increment the letter
                    const nextLetter = String.fromCharCode(tag.charCodeAt(0) + 1);
                    return nextLetter > 'Z' ? 'A' : nextLetter;
                } else {
                    // Letters + numbers mode
                    const match = tag.match(/^([A-Z])(\d+)$/);
                    if (!match) return 'A1';
                    
                    const [, letter, number] = match;
                    const nextNumber = parseInt(number) + 1;
                    
                    if (nextNumber > 9) {
                        // Wrap to next letter
                        const nextLetter = String.fromCharCode(letter.charCodeAt(0) + 1);
                        if (nextLetter > 'Z') {
                            return 'A1'; // Wrap around
                        }
                        return nextLetter + '1';
                    }
                    
                    return letter + nextNumber;
                }
            }

            // Update the next tag display
            function updateNextTagDisplay() {
                const nextTagDisplay = document.getElementById('nextTagDisplay');
                if (nextTagDisplay) {
                    const currentImageLabel = window.currentImageLabel || 'default';
                    
                    // Priority: 1) labelsByImage (immediate next), 2) manualTagByImage (manual sequence), 3) calculateNextTag (gap-filling)
                    let nextTag;
                    if (window.labelsByImage && window.labelsByImage[currentImageLabel]) {
                        nextTag = window.labelsByImage[currentImageLabel];
                        console.log('[updateNextTagDisplay] Using labelsByImage:', nextTag);
                    } else if (window.manualTagByImage && window.manualTagByImage[currentImageLabel]) {
                        // We're in a manual sequence - use the manual flag value
                        nextTag = window.manualTagByImage[currentImageLabel];
                        console.log('[updateNextTagDisplay] Using manualTagByImage:', nextTag);
                    } else {
                        // Normal gap-filling mode
                        nextTag = calculateNextTag();
                        console.log('[updateNextTagDisplay] Using calculateNextTag (gap-filling):', nextTag);
                    }
                    
                    nextTagDisplay.textContent = nextTag;
                }
            }

            // Initialize next tag display
            updateNextTagDisplay();

            // Make functions available globally for paint.js to call
            window.updateNextTagDisplay = updateNextTagDisplay;
            window.calculateNextTag = calculateNextTag;
            window.calculateNextTagFrom = calculateNextTagFrom;
            console.log('[index.html] Made calculateNextTag available globally:', typeof window.calculateNextTag);
            
            // Allow user to set the next tag directly by typing in the display
            const nextTagEl = document.getElementById('nextTagDisplay');
            
            // Store original value when user starts editing
            let originalTagValue = '';
            
            nextTagEl?.addEventListener('focus', (e) => {
                originalTagValue = e.target.textContent.trim();
                // Select all text for easy replacement
                const range = document.createRange();
                range.selectNodeContents(e.target);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            });
            
            // Handle Enter key to commit changes
            nextTagEl?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur(); // Trigger validation via blur
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    e.target.textContent = originalTagValue;
                    e.target.blur();
                }
            });
            
            // Validate and save on blur
            nextTagEl?.addEventListener('blur', (e) => {
                const mode = typeof tagMode === 'string' ? tagMode : 'letters+numbers';
                const currentImageLabel = window.currentImageLabel || 'default';
                const input = e.target.textContent.trim().toUpperCase();
                
                // If empty or unchanged, restore original
                if (!input || input === originalTagValue) {
                    e.target.textContent = originalTagValue;
                    return;
                }
                
                const valid = mode === 'letters'
                    ? /^[A-Z]$/.test(input)
                    : /^[A-Z]\d+$/.test(input);

                if (!valid) {
                    // Show error briefly and restore original
                    e.target.textContent = ' Invalid';
                    e.target.classList.add('text-red-600');
                    setTimeout(() => {
                        e.target.textContent = originalTagValue;
                        e.target.classList.remove('text-red-600');
                    }, 1000);
                    return;
                }

                // Ensure labelsByImage exists, then set the next tag seed
                window.labelsByImage = window.labelsByImage || {};
                window.labelsByImage[currentImageLabel] = input;
                
                // Set flag to indicate this was a manual tag (not auto-calculated)
                // This tells the system to increment from this tag, not use gap-filling
                window.manualTagByImage = window.manualTagByImage || {};
                window.manualTagByImage[currentImageLabel] = input;
                
                e.target.textContent = input;
                console.log('[nextTagDisplay] Updated next tag to:', input, '(manual override)');
            });
            
            // Capture frame lock functionality
            let isCaptureLocked = true; // Start locked for minimal appearance
            
            // Initialize capture frame on load
            updateCaptureFrameLockState();
            
            // Lock/unlock button functionality
            const lockButton = document.getElementById('captureLockButton');
            lockButton?.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleCaptureLock();
            });
            
            // Keyboard shortcut for lock/unlock (L key) - ignore when typing in inputs/textareas/selects or contenteditable
            document.addEventListener('keydown', (e) => {
                const target = e.target;
                const isTyping = target && (
                    target.tagName === 'INPUT' ||
                    target.tagName === 'TEXTAREA' ||
                    target.tagName === 'SELECT' ||
                    target.isContentEditable
                );
                if (isTyping) return;
                if (e.key && e.key.toLowerCase() === 'l') {
                    e.preventDefault();
                    toggleCaptureLock();
                }
            });
            
            function toggleCaptureLock() {
                isCaptureLocked = !isCaptureLocked;
                updateCaptureFrameLockState();
                showLockPopup();
            }
            
            function showLockPopup() {
                const popup = document.getElementById('lockPopup');
                const icon = document.getElementById('lockPopupIcon');
                const text = document.getElementById('lockPopupText');
                
                if (isCaptureLocked) {
                    text.textContent = 'Locked';
                    icon.innerHTML = '<path d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"></path>';
                } else {
                    text.textContent = 'Unlocked';
                    icon.innerHTML = '<path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z"></path>';
                }
                
                popup.classList.add('show');
                setTimeout(() => {
                    popup.classList.remove('show');
                }, 1500);
            }
            
            function updateCaptureFrameLockState() {
                const lockButton = document.getElementById('captureLockButton');
                const instructions = document.getElementById('unlockInstructions');
                const applyAllButton = document.getElementById('applyFitAll');
                
                if (isCaptureLocked) {
                    captureFrame.classList.add('locked');
                    captureFrame.classList.remove('unlocked');
                    lockButton.classList.add('locked');
                    lockButton.title = 'Unlock frame (L)';
                    instructions.classList.add('hidden');
                    
                    // Hide Apply All button for safety
                    if (applyAllButton) {
                        applyAllButton.style.display = 'none';
                    }
                    
                    // Use white overlay outside the frame for clarity
                    captureFrame.style.boxShadow = '0 0 0 2000px rgba(255,255,255,1)';
                    
                    // Enable pointer events for lock button only
                    captureFrame.style.pointerEvents = 'none';
                    lockButton.style.pointerEvents = 'auto';
                } else {
                    captureFrame.classList.remove('locked');
                    captureFrame.classList.add('unlocked');
                    lockButton.classList.remove('locked');
                    lockButton.title = 'Lock frame (L)';
                    instructions.classList.remove('hidden');
                    
                    // Show Apply All button when unlocked
                    if (applyAllButton) {
                        applyAllButton.style.display = 'inline-block';
                    }
                    
                    // Remove overlay when unlocked for transparent background while adjusting
                    captureFrame.style.boxShadow = 'none';
                    
                    // Enable pointer events for dragging and resizing
                    captureFrame.style.pointerEvents = 'auto';
                    lockButton.style.pointerEvents = 'auto';
                }
            }
            
            
            // Color picker functionality
            const colorButtons = document.querySelectorAll('[data-color]');
            colorButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all buttons
                    colorButtons.forEach(btn => btn.classList.remove('active'));
                    // Add active class to clicked button
                    button.classList.add('active');
                    // Update color picker value
                    const colorPicker = document.getElementById('colorPicker');
                    if (colorPicker) {
                        colorPicker.value = button.getAttribute('data-color');
                        // Trigger change event for existing functionality
                        colorPicker.dispatchEvent(new Event('change'));
                    }
                });
            });
            
            // Update active color button styling
            const style = document.createElement('style');
            style.textContent = `
                [data-color].active {
                    border-color: #374151 !important;
                    box-shadow: 0 0 0 2px white, 0 0 0 4px #374151 !important;
                    transform: scale(1.1);
                }
            `;
            document.head.appendChild(style);
            
            // Capture frame resize functionality
            let isResizing = false;
            let currentHandle = null;
            let startPos = { x: 0, y: 0 };
            let startRect = { x: 0, y: 0, width: 0, height: 0 };
            
            const resizeHandles = document.querySelectorAll('.resize-handle');
            resizeHandles.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    // Don't allow resizing when locked
                    if (isCaptureLocked) return;
                    
                    e.preventDefault();
                    isResizing = true;
                    currentHandle = handle.getAttribute('data-direction');
                    startPos = { x: e.clientX, y: e.clientY };
                    
                    const rect = captureFrame.getBoundingClientRect();
                    startRect = {
                        x: rect.left,
                        y: rect.top,
                        width: rect.width,
                        height: rect.height
                    };
                    
                    document.addEventListener('mousemove', handleResize);
                    document.addEventListener('mouseup', stopResize);
                });
            });
            
            function handleResize(e) {
                if (!isResizing || !currentHandle) return;
                
                const deltaX = e.clientX - startPos.x;
                const deltaY = e.clientY - startPos.y;
                
                let newX = startRect.x;
                let newY = startRect.y;
                let newWidth = startRect.width;
                let newHeight = startRect.height;
                
                // Handle different resize directions
                switch (currentHandle) {
                    case 'nw':
                        newX = startRect.x + deltaX;
                        newY = startRect.y + deltaY;
                        newWidth = startRect.width - deltaX;
                        newHeight = startRect.height - deltaY;
                        break;
                    case 'n':
                        newY = startRect.y + deltaY;
                        newHeight = startRect.height - deltaY;
                        break;
                    case 'ne':
                        newY = startRect.y + deltaY;
                        newWidth = startRect.width + deltaX;
                        newHeight = startRect.height - deltaY;
                        break;
                    case 'e':
                        newWidth = startRect.width + deltaX;
                        break;
                    case 'se':
                        newWidth = startRect.width + deltaX;
                        newHeight = startRect.height + deltaY;
                        break;
                    case 's':
                        newHeight = startRect.height + deltaY;
                        break;
                    case 'sw':
                        newX = startRect.x + deltaX;
                        newWidth = startRect.width - deltaX;
                        newHeight = startRect.height + deltaY;
                        break;
                    case 'w':
                        newX = startRect.x + deltaX;
                        newWidth = startRect.width - deltaX;
                        break;
                }
                
                // Apply minimum size constraints
                const minSize = 100;
                if (newWidth < minSize) {
                    if (currentHandle.includes('w')) newX = startRect.x + startRect.width - minSize;
                    newWidth = minSize;
                }
                if (newHeight < minSize) {
                    if (currentHandle.includes('n')) newY = startRect.y + startRect.height - minSize;
                    newHeight = minSize;
                }
                
                // Apply maximum size constraints (viewport bounds)
                const maxX = window.innerWidth - newWidth;
                const maxY = window.innerHeight - newHeight;
                newX = Math.max(0, Math.min(maxX, newX));
                newY = Math.max(0, Math.min(maxY, newY));
                
                // Update capture frame position and size
                captureFrame.style.left = newX + 'px';
                captureFrame.style.top = newY + 'px';
                captureFrame.style.width = newWidth + 'px';
                captureFrame.style.height = newHeight + 'px';
                
            }
            
            function stopResize() {
                isResizing = false;
                currentHandle = null;
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
                // Save per-image frame when resizing ends
                if (typeof window.currentImageLabel !== 'undefined') {
                    saveCurrentCaptureFrameForLabel(window.currentImageLabel);
                    
                    // Store the frame dimensions as a ratio of canvas size
                    const canvas = document.getElementById('canvas');
                    const frameRect = captureFrame.getBoundingClientRect();
                    
                    if (!window.manualFrameRatios) {
                        window.manualFrameRatios = {};
                    }
                    
                    window.manualFrameRatios[window.currentImageLabel] = {
                        widthRatio: frameRect.width / canvas.clientWidth,
                        heightRatio: frameRect.height / canvas.clientHeight,
                        leftRatio: frameRect.left / canvas.clientWidth,
                        topRatio: frameRect.top / canvas.clientHeight
                    };
                    
                    console.log(`[FRAME] Saved ${window.currentImageLabel} frame ratios: ${(window.manualFrameRatios[window.currentImageLabel].widthRatio * 100).toFixed(1)}% width, ${(window.manualFrameRatios[window.currentImageLabel].heightRatio * 100).toFixed(1)}% height`);
                }
            }
            
            // Optimized capture frame dragging - 1:1 movement with no lag
            let isCaptureDragging = false;
            let captureDragOffset = { x: 0, y: 0 };
            let lastCaptureMousePos = { x: 0, y: 0 };
            let captureRafId = null;
            
            captureFrame.addEventListener('mousedown', (e) => {
                // Don't drag if locked, clicking on handles, or buttons
                if (isCaptureLocked || e.target.classList.contains('resize-handle') || e.target.closest('button')) {
                    return;
                }
                
                // Allow Shift+click to pass through for canvas dragging
                if (e.shiftKey) {
                    return;
                }
                
                e.preventDefault();
                e.stopPropagation();
                
                isCaptureDragging = true;
                
                const rect = captureFrame.getBoundingClientRect();
                captureDragOffset.x = e.clientX - rect.left;
                captureDragOffset.y = e.clientY - rect.top;
                
                // Add dragging class for no transitions
                captureFrame.classList.add('dragging');
                
                document.addEventListener('mousemove', handleCaptureDrag, { passive: true });
                document.addEventListener('mouseup', stopCaptureDrag);
            });
            
            function handleCaptureDrag(e) {
                if (!isCaptureDragging || isCaptureLocked) return;
                
                // Store mouse position for RAF
                lastCaptureMousePos.x = e.clientX;
                lastCaptureMousePos.y = e.clientY;
                
                // Cancel previous RAF if still pending
                if (captureRafId) {
                    cancelAnimationFrame(captureRafId);
                }
                
                // Schedule position update for next frame
                captureRafId = requestAnimationFrame(updateCapturePosition);
            }
            
            function updateCapturePosition() {
                if (!isCaptureDragging) return;
                
                const newX = Math.max(0, Math.min(window.innerWidth - captureFrame.offsetWidth, lastCaptureMousePos.x - captureDragOffset.x));
                const newY = Math.max(0, Math.min(window.innerHeight - captureFrame.offsetHeight, lastCaptureMousePos.y - captureDragOffset.y));
                
                // Apply position immediately
                captureFrame.style.left = newX + 'px';
                captureFrame.style.top = newY + 'px';
                
                
                captureRafId = null;
            }
            
            function stopCaptureDrag() {
                if (!isCaptureDragging) return;
                
                isCaptureDragging = false;
                
                // Cancel any pending RAF
                if (captureRafId) {
                    cancelAnimationFrame(captureRafId);
                    captureRafId = null;
                }
                
                // Remove dragging class
                captureFrame.classList.remove('dragging');
                
                document.removeEventListener('mousemove', handleCaptureDrag);
                document.removeEventListener('mouseup', stopCaptureDrag);
                // Save per-image frame when dragging ends
                if (typeof window.currentImageLabel !== 'undefined') {
                    saveCurrentCaptureFrameForLabel(window.currentImageLabel);
                }
            }
            
            // Optimized draggable functionality - 1:1 mouse movement with requestAnimationFrame
            function makeDraggable(element, handle) {
                let isDragging = false;
                let dragOffset = { x: 0, y: 0 };
                let lastMousePos = { x: 0, y: 0 };
                let rafId = null;
                let elementWidth, elementHeight; // Cache dimensions
                
                handle.addEventListener('mousedown', (e) => {
                    // Don't start drag if clicking on buttons or inputs
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.closest('button')) {
                        return;
                    }
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isDragging = true;
                    
                    // Simplified position setup - get current position directly
                    const rect = element.getBoundingClientRect();
                    
                    // Calculate offset from mouse to element's current position
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    // Cache element dimensions to avoid repeated DOM queries
                    elementWidth = element.offsetWidth;
                    elementHeight = element.offsetHeight;
                    
                    // Set initial position and prepare for dragging
                    element.style.position = 'fixed';
                    element.style.left = rect.left + 'px';
                    element.style.top = rect.top + 'px';
                    element.style.transform = 'none';
                    
                    // Clear conflicting positioning styles when dragging starts
                    element.style.bottom = 'auto';
                    element.style.right = 'auto';
                    
                    // Add visual feedback immediately
                    element.classList.add('dragging');
                    document.body.style.userSelect = 'none';
                    
                    document.addEventListener('mousemove', onMouseMove, { passive: true });
                    document.addEventListener('mouseup', stopDrag);
                });
                
                function onMouseMove(e) {
                    if (!isDragging) return;
                    
                    // Store mouse position for RAF
                    lastMousePos.x = e.clientX;
                    lastMousePos.y = e.clientY;
                    
                    // Cancel previous RAF if still pending
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                    }
                    
                    // Schedule position update for next frame
                    rafId = requestAnimationFrame(updatePosition);
                }
                
                function updatePosition() {
                    if (!isDragging) return;
                    
                    // Calculate new position from mouse minus offset
                    const newX = Math.max(0, Math.min(window.innerWidth - elementWidth, lastMousePos.x - dragOffset.x));
                    const newY = Math.max(0, Math.min(window.innerHeight - elementHeight, lastMousePos.y - dragOffset.y));
                    
                    // Apply position immediately using left/top for immediate visual feedback
                    element.style.left = newX + 'px';
                    element.style.top = newY + 'px';
                    
                    rafId = null;
                }
                
                function stopDrag(e) {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    
                    // Cancel any pending RAF
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                        rafId = null;
                    }
                    
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', stopDrag);
                    
                    // Reset visual feedback
                    element.classList.remove('dragging');
                    document.body.style.userSelect = '';
                }
            }
            
            // Make all floating panels draggable by their headers
            const floatingPanels = document.querySelectorAll('.floating-panel');
            floatingPanels.forEach(panel => {
                const header = panel.querySelector('.cursor-move');
                if (header) {
                    header.style.cursor = 'move';
                    makeDraggable(panel, header);
                }
            });
            
            // Scale dropdown functionality
            const scaleButton = document.getElementById('scaleButton');
            const scaleDropdown = document.getElementById('scaleDropdown');
            
            if (scaleButton && scaleDropdown) {
                scaleButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // Position the dropdown relative to the button with boundary checks
                    const buttonRect = scaleButton.getBoundingClientRect();
                    const dropdownWidth = 80; // min-width from CSS
                    const dropdownHeight = 320; // approximate height for all options
                    
                    let left = buttonRect.left;
                    let top = buttonRect.bottom + 2;
                    
                    // Check right boundary
                    if (left + dropdownWidth > window.innerWidth) {
                        left = buttonRect.right - dropdownWidth;
                    }
                    
                    // Check left boundary
                    if (left < 0) {
                        left = 0;
                    }
                    
                    // Check bottom boundary - show above button if no room below
                    if (top + dropdownHeight > window.innerHeight) {
                        top = buttonRect.top - dropdownHeight - 2;
                    }
                    
                    // Check top boundary
                    if (top < 0) {
                        top = buttonRect.bottom + 2; // fallback to below button
                    }
                    
                    scaleDropdown.style.left = left + 'px';
                    scaleDropdown.style.top = top + 'px';
                    
                    scaleDropdown.classList.toggle('hidden');
                });
                
                document.addEventListener('click', () => {
                    scaleDropdown.classList.add('hidden');
                });
                
                scaleDropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                // Handle scale option selection
                const scaleOptions = scaleDropdown.querySelectorAll('.scale-option');
                scaleOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        const scale = option.dataset.scale;
                        const percentage = Math.round(parseFloat(scale) * 100);
                        scaleButton.innerHTML = `${percentage}% <svg class="inline w-3 h-3 -mt-0.5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M5.25 7.5l4.5 4.5 4.5-4.5H5.25z"/></svg>`;
                        scaleDropdown.classList.add('hidden');
                    });
                });
            }
            
            // Custom dash controls functionality
            const dashStyleSelect = document.getElementById('dashStyleSelect');
            const customDashControls = document.getElementById('customDashControls');
            
            if (dashStyleSelect && customDashControls) {
                dashStyleSelect.addEventListener('change', () => {
                    if (dashStyleSelect.value === 'custom') {
                        customDashControls.classList.remove('hidden');
                        customDashControls.classList.add('flex');
                    } else {
                        customDashControls.classList.add('hidden');
                        customDashControls.classList.remove('flex');
                    }
                });
            }
            
            // Enhanced Image Gallery with Horizontal Scroll Navigation
            let currentImageIndex = 0;
            let imageGalleryData = [];
            let intersectionObserver = null;
            
            // Initialize image gallery functionality
            function initializeImageGallery() {
                const imageGallery = document.getElementById('imageGallery');
                const imageDots = document.getElementById('imageDots');
                const prevButton = document.getElementById('prevImage');
                const nextButton = document.getElementById('nextImage');
                const imagePosition = document.getElementById('imagePosition');
                const imageCounter = document.getElementById('imageCounter');
                
                if (!imageGallery) return;
                
                // Navigation button functionality
                prevButton?.addEventListener('click', () => navigateToImage(currentImageIndex - 1));
                nextButton?.addEventListener('click', () => navigateToImage(currentImageIndex + 1));
                
                // Intersection Observer for active image detection
                intersectionObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const imageIndex = parseInt(entry.target.dataset.imageIndex);
                            if (!isNaN(imageIndex)) {
                                updateActiveImage(imageIndex);
                            }
                        }
                    });
                }, {
                    root: imageGallery,
                    threshold: 0.6,
                    rootMargin: '0px'
                });
                
                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    // Don't process arrow keys if user is typing in an input field
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        return;
                    }
                    
                    // Don't process if user is editing a contentEditable element
                    if (e.target.isContentEditable || 
                        e.target.classList.contains('stroke-name') || 
                        e.target.classList.contains('stroke-measurement')) {
                        return;
                    }
                    
                    // Only handle keyboard navigation if image panel is visible
                    if (!document.getElementById('imagePanel').classList.contains('hidden')) {
                        if (e.key === 'ArrowLeft') {
                            e.preventDefault();
                            navigateToImage(currentImageIndex - 1);
                        } else if (e.key === 'ArrowRight') {
                            e.preventDefault();
                            navigateToImage(currentImageIndex + 1);
                        }
                    }
                });

                // Canvas Controls: wire rotate/flip buttons to current image
                const rotateLeftCtrl = document.getElementById('rotateLeftCtrl');
                const rotateRightCtrl = document.getElementById('rotateRightCtrl');
                function getCurrentImageIndex() {
                    const label = window.paintApp?.state?.currentImageLabel;
                    if (!label) return currentImageIndex || 0;
                    const idx = imageGalleryData.findIndex(i => (i.label || i.original?.label) === label);
                    return idx >= 0 ? idx : (currentImageIndex || 0);
                }
                function rotateFallback(deg) {
                    const label = window.paintApp?.state?.currentImageLabel || 'blank_canvas';
                    const c = document.getElementById('canvas');
                    const w = c?.width || 800;
                    const h = c?.height || 600;
                    if (typeof window.transformImageData === 'function') {
                        window.transformImageData(label, 'rotate', deg, w, h);
                        if (window.redrawCanvasWithVisibility) window.redrawCanvasWithVisibility();
                    }
                }
                rotateLeftCtrl?.addEventListener('click', () => {
                    const idx = getCurrentImageIndex();
                    if (imageGalleryData[idx]) {
                        window.rotateImage?.(idx, -90);
                    } else {
                        rotateFallback(-90);
                    }
                });
                rotateRightCtrl?.addEventListener('click', () => {
                    const idx = getCurrentImageIndex();
                    if (imageGalleryData[idx]) {
                        window.rotateImage?.(idx, 90);
                    } else {
                        rotateFallback(90);
                    }
                });

                // Name/type inputs wiring
                const nameInput = document.getElementById('imageNameInput');
                const typeSelect = document.getElementById('imageTypeSelect');
                nameInput?.addEventListener('change', (e) => {
                    const val = e.target.value || '';
                    const idx = currentImageIndex;
                    if (imageGalleryData[idx]) {
                        imageGalleryData[idx].name = val;
                        // Update caption under the thumbnail (if present)
                        const gallery = document.getElementById('imageGallery');
                        const card = gallery?.children[idx];
                        const caption = card?.querySelector('.thumb-caption');
                        if (caption) caption.textContent = val;
                    }
                });
                typeSelect?.addEventListener('change', (e) => {
                    const val = e.target.value || '';
                    const idx = currentImageIndex;
                    if (imageGalleryData[idx]) {
                        imageGalleryData[idx].original = imageGalleryData[idx].original || {};
                        imageGalleryData[idx].original.type = val;
                    }
                });
            }
            
            // Add image to gallery
            function addImageToGallery(imageData, index) {
                console.log(`[Gallery] Adding image to gallery at index ${index}:`, imageData);
                
                const imageGallery = document.getElementById('imageGallery');
                const imageDots = document.getElementById('imageDots');
                
                if (!imageGallery || !imageDots) {
                    console.error('[Gallery] imageGallery or imageDots element not found');
                    return;
                }
                
                // Handle different image data formats from external scripts
                let imageSrc, imageName;
                if (typeof imageData === 'string') {
                    // Simple string URL
                    imageSrc = imageData;
                    imageName = `Image ${index + 1}`;
                } else if (imageData && typeof imageData === 'object') {
                    // Object with src/url and name properties
                    imageSrc = imageData.src || imageData.url || imageData.dataUrl || imageData.blob;
                    imageName = imageData.name || imageData.filename || imageData.title || `Image ${index + 1}`;
                } else {
                    console.warn('[Gallery] Invalid image data format:', imageData);
                    return;
                }
                
                // Create image thumbnail
                const thumbnail = document.createElement('div');
                thumbnail.className = 'image-thumbnail';
                thumbnail.dataset.imageIndex = index;
                thumbnail.style.backgroundImage = `url(${imageSrc})`;
                thumbnail.title = imageName;
                thumbnail.draggable = true;
                
                // Remove overlay label; use minimal caption below instead
                
                // Add hover controls (delete only)
                const controls = createThumbnailControls(index);
                // Strip rotate/flip from controls
                controls.querySelectorAll('.rotate-btn, .flip-btn').forEach(el => el.remove());
                thumbnail.appendChild(controls);
                
                // Add all event listeners using helper function
                addThumbnailEventListeners(thumbnail, index);
                
                // Wrap thumbnail in a small card with optional caption
                const card = document.createElement('div');
                card.className = 'flex flex-col items-center gap-1';
                card.appendChild(thumbnail);
                // Compute caption; hide for blank canvas
                let displayName = '';
                try {
                    if (!(originalData && originalData.isBlankCanvas)) {
                        const lbl = originalData?.label;
                        if (lbl && typeof window.getTagBasedFilename === 'function') {
                            const base = lbl.split('_')[0];
                            displayName = window.getTagBasedFilename(lbl, base) || imageName || '';
                        } else {
                            displayName = imageName || '';
                        }
                    }
                } catch (e) { displayName = imageName || ''; }
                const caption = document.createElement('div');
                caption.className = 'thumb-caption text-[11px] text-slate-500 font-medium truncate max-w-[120px]';
                caption.textContent = displayName || '';
                card.appendChild(caption);
                if (displayName) thumbnail.title = displayName; else thumbnail.removeAttribute('title');
                imageGallery.appendChild(card);
                console.log(`[Gallery] Created thumbnail element:`, thumbnail);
                console.log(`[Gallery] Gallery element children count:`, imageGallery.children.length);
                
                // Create navigation dot
                const dot = document.createElement('div');
                dot.className = 'nav-dot';
                dot.dataset.imageIndex = index;
                dot.addEventListener('click', () => navigateToImage(index));
                imageDots.appendChild(dot);
                
                // Observe thumbnail for intersection
                if (intersectionObserver) {
                    intersectionObserver.observe(thumbnail);
                }
                
                // Store normalized image data
                // Handle cases where imageData already has an 'original' property to avoid nesting
                let originalData = imageData;
                if (imageData && imageData.original && typeof imageData.original === 'object') {
                    // If imageData already has an original property, use that instead
                    originalData = imageData.original;
                    console.log('[Gallery] Using nested original data to avoid double nesting');
                }
                
                const normalizedData = {
                    src: imageSrc,
                    name: imageName,
                    original: originalData
                };
                
                // Update gallery data
                imageGalleryData[index] = normalizedData;
                updateGalleryControls();
                
                // Trigger mini-stepper update if function exists
                // This ensures the bottom navigation shows all images
                if (typeof updatePills === 'function') {
                    setTimeout(() => {
                        try {
                            updatePills();
                            console.log('[Gallery] Updated mini-stepper pills');
                        } catch (e) {
                            console.warn('[Gallery] Error updating pills:', e);
                        }
                    }, 100);
                }
                if (typeof updateActivePill === 'function') {
                    setTimeout(() => {
                        try {
                            updateActivePill();
                            console.log('[Gallery] Updated active pill');
                        } catch (e) {
                            console.warn('[Gallery] Error updating active pill:', e);
                        }
                    }, 150);
                }
                
                console.log('[Gallery] Added image:', normalizedData);
                
                // Ensure the image panel is visible when adding any image
                const imagePanel = document.getElementById('imagePanel');
                const imagePanelContent = document.getElementById('imagePanelContent');
                if (imagePanel) {
                    // Remove any hidden classes
                    imagePanel.classList.remove('hidden');
                    
                    // Ensure the content is also visible (not collapsed)
                    if (imagePanelContent) {
                        imagePanelContent.classList.remove('hidden');
                        
                        // Ensure content has proper max-height for expansion
                        if (imagePanelContent.style.maxHeight === '0px' || imagePanelContent.style.maxHeight === '0') {
                            imagePanelContent.style.maxHeight = 'none';
                        }
                    }
                    
                    // Don't set display:block as it can interfere with drag positioning
                    // The panel is visible by default; just ensure no hidden class
                    // On mobile, respect the user's toggle state - don't force the panel open
                    if (imagePanel.style.display === 'none' && !isMobileDevice()) {
                        imagePanel.style.display = '';
                    }
                    
                    // Ensure the panel is positioned within the visible viewport
                    // This fixes the issue where the panel might be off-screen after drag operations
                    const rect = imagePanel.getBoundingClientRect();
                    const windowWidth = window.innerWidth;
                    const windowHeight = window.innerHeight;
                    
                    // Check if panel is completely off-screen or has invalid dimensions
                    const isOffScreen = rect.right < 0 || rect.left > windowWidth || 
                                       rect.bottom < 0 || rect.top > windowHeight;
                    const hasInvalidSize = rect.width === 0 || rect.height === 0;
                    
                    // Also check if panel is mostly off-screen (more than 80% hidden)
                    const visibleWidth = Math.max(0, Math.min(rect.right, windowWidth) - Math.max(rect.left, 0));
                    const visibleHeight = Math.max(0, Math.min(rect.bottom, windowHeight) - Math.max(rect.top, 0));
                    const visibleArea = visibleWidth * visibleHeight;
                    const totalArea = rect.width * rect.height;
                    const isMostlyHidden = totalArea > 0 && (visibleArea / totalArea) < 0.2;
                    
                    if (isOffScreen || hasInvalidSize || isMostlyHidden) {
                        console.log('[Gallery] Panel is off-screen or invalid, resetting position');
                        
                        // Reset to default position (right side, vertically centered)
                        imagePanel.style.position = 'fixed';
                        imagePanel.style.right = '1rem';
                        imagePanel.style.left = 'auto';
                        imagePanel.style.top = 'clamp(1rem, 50vh - 20rem, calc(100vh - 40rem - 1rem))';
                        imagePanel.style.bottom = 'auto';
                        imagePanel.style.transform = '';
                    }
                }
            }

            // Expose a lightweight compat hook for module-based uploads
            window.addImageToGalleryCompat = function addImageToGalleryCompat(imageData) {
                const index = imageGalleryData.length;
                addImageToGallery(imageData, index);
            };
            
            // Navigate to specific image
            function navigateToImage(index) {
                const imageGallery = document.getElementById('imageGallery');
                if (!imageGallery || index < 0 || index >= imageGalleryData.length) return;
                
                const targetThumbnail = imageGallery.querySelector(`[data-image-index="${index}"]`);
                if (targetThumbnail) {
                    targetThumbnail.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest',
                        inline: 'center'
                    });
                }
                
                // Get the image data and find corresponding legacy image
                const imageData = imageGalleryData[index];
                if (imageData && imageData.original && imageData.original.label) {
                    const label = imageData.original.label;
                    console.log(`[Gallery] Switching to image with label: ${label}`);
                    
                    // Try to switch using new ProjectManager system first
                    if (window.projectManager && typeof window.projectManager.switchView === 'function') {
                        window.projectManager.switchView(label);
                        console.log(`[Gallery] Called projectManager.switchView(${label})`);
                    } else if (window.switchToImage && typeof window.switchToImage === 'function') {
                        // Fallback to legacy system
                        window.switchToImage(label);
                        console.log(`[Gallery] Called switchToImage(${label})`);
                    } else {
                        console.warn('[Gallery] No image switching function available');
                    }
                }
                
                updateActiveImage(index);

                // Update image name/type inputs to match current image
                const nameInput = document.getElementById('imageNameInput');
                const typeSelect = document.getElementById('imageTypeSelect');
                const data = imageGalleryData[index];
                if (nameInput && data) nameInput.value = data.name || '';
                if (typeSelect && data && data.original && data.original.type) typeSelect.value = data.original.type; else if (typeSelect) typeSelect.value = '';
            }
            
            // Reorder images in the gallery
            function reorderImages(fromIndex, toIndex) {
                console.log(`[Gallery] Reordering image from ${fromIndex} to ${toIndex}`);
                
                // Reorder the data array
                const movedImage = imageGalleryData.splice(fromIndex, 1)[0];
                imageGalleryData.splice(toIndex, 0, movedImage);
                
                // Rebuild the gallery UI
                rebuildGalleryUI();
                
                // Update active image index if needed
                if (currentImageIndex === fromIndex) {
                    currentImageIndex = toIndex;
                } else if (currentImageIndex > fromIndex && currentImageIndex <= toIndex) {
                    currentImageIndex--;
                } else if (currentImageIndex < fromIndex && currentImageIndex >= toIndex) {
                    currentImageIndex++;
                }
                
                updateActiveImage(currentImageIndex);
            }
            
            // Rebuild the entire gallery UI after reordering
            function rebuildGalleryUI() {
                const imageGallery = document.getElementById('imageGallery');
                const imageDots = document.getElementById('imageDots');
                
                if (!imageGallery || !imageDots) return;
                
                // Clear existing thumbnails and dots
                imageGallery.innerHTML = '';
                imageDots.innerHTML = '';
                
                // Rebuild with new order
                imageGalleryData.forEach((imageData, index) => {
                    // Create thumbnail
                    const thumbnail = document.createElement('div');
                    thumbnail.className = 'image-thumbnail';
                    thumbnail.dataset.imageIndex = index;
                    thumbnail.style.backgroundImage = `url(${imageData.src})`;
                    thumbnail.title = imageData.name;
                    thumbnail.draggable = true;
                    
                    // Add hover controls (delete only)
                    const controls = createThumbnailControls(index);
                    // Strip rotate/flip from controls
                    controls.querySelectorAll('.rotate-btn, .flip-btn').forEach(el => el.remove());
                    thumbnail.appendChild(controls);
                    
                    // Add all event listeners (click, drag, etc.)
                    addThumbnailEventListeners(thumbnail, index);
                    
                    imageGallery.appendChild(thumbnail);
                    
                    // Create dot
                    const dot = document.createElement('div');
                    dot.className = 'nav-dot';
                    dot.dataset.imageIndex = index;
                    dot.addEventListener('click', () => navigateToImage(index));
                    imageDots.appendChild(dot);
                    
                    // Observe for intersection
                    if (intersectionObserver) {
                        intersectionObserver.observe(thumbnail);
                    }
                });
                
                updateGalleryControls();
            }
            
            // Create thumbnail control buttons (delete only)
            function createThumbnailControls(index) {
                const controlsContainer = document.createElement('div');
                
                // Delete control (separate, top-left)
                const deleteControl = document.createElement('div');
                deleteControl.className = 'delete-control';
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'control-btn delete-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.title = 'Delete image';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteImage(index);
                });
                
                deleteControl.appendChild(deleteBtn);
                controlsContainer.appendChild(deleteControl);
                
                return controlsContainer;
            }
            
            // Helper function to add all event listeners to a thumbnail
            function addThumbnailEventListeners(thumbnail, index) {
                // Click handler - switch to the image using ProjectManager
                thumbnail.addEventListener('click', () => {
                    const imageData = imageGalleryData[index];
                    if (imageData && imageData.original && imageData.original.label) {
                        const label = imageData.original.label;
                        console.log(`[Gallery] Thumbnail clicked, switching to label: ${label}`);
                        
                        // Use ProjectManager to switch views
                        if (window.projectManager && typeof window.projectManager.switchView === 'function') {
                            window.projectManager.switchView(label);
                        } else {
                            // Fallback to gallery navigation
                    navigateToImage(index);
                        }
                    } else {
                        // Fallback to gallery navigation if no label
                        navigateToImage(index);
                    }
                });
                
                // Drag and drop handlers
                thumbnail.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', index);
                    thumbnail.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                thumbnail.addEventListener('dragend', () => {
                    thumbnail.classList.remove('dragging');
                    // Clear scroll interval when drag ends
                    if (window.dragScrollInterval) {
                        clearInterval(window.dragScrollInterval);
                        window.dragScrollInterval = null;
                    }
                });
                
                thumbnail.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    thumbnail.classList.add('drag-over');
                });
                
                thumbnail.addEventListener('dragleave', () => {
                    thumbnail.classList.remove('drag-over');
                });
                
                thumbnail.addEventListener('drop', (e) => {
                    e.preventDefault();
                    thumbnail.classList.remove('drag-over');
                    
                    // Clear scroll interval when drop happens
                    if (window.dragScrollInterval) {
                        clearInterval(window.dragScrollInterval);
                        window.dragScrollInterval = null;
                    }
                    
                    const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const targetIndex = index;
                    
                    if (draggedIndex !== targetIndex) {
                        reorderImages(draggedIndex, targetIndex);
                    }
                });
            }
            
            // Delete image function
            function deleteImage(index) {
                if (confirm(`Delete "${imageGalleryData[index]?.name}"?`)) {
                    console.log(`[Gallery] Deleting image at index ${index}`);
                    
                    // Remove from data array
                    imageGalleryData.splice(index, 1);
                    
                    // Rebuild UI
                    rebuildGalleryUI();
                    
                    // Adjust current index if needed
                    if (currentImageIndex >= index) {
                        currentImageIndex = Math.max(0, currentImageIndex - 1);
                    }
                    
                    // Update active image
                    if (imageGalleryData.length > 0) {
                        updateActiveImage(Math.min(currentImageIndex, imageGalleryData.length - 1));
                    }
                }
            }
            
            // Rotate image function
            window.rotateImage = function rotateImage(index, degrees) {
                console.log(`[Gallery] Rotating image ${index} by ${degrees}`);
                
                const imageData = imageGalleryData[index];
                if (!imageData) return;
                
                // Apply rotation using Canvas
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas dimensions based on rotation
                    if (Math.abs(degrees) === 90 || Math.abs(degrees) === 270) {
                        canvas.width = img.height;
                        canvas.height = img.width;
                    } else {
                        canvas.width = img.width;
                        canvas.height = img.height;
                    }
                    
                    // Rotate and draw
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate((degrees * Math.PI) / 180);
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    
                    // Update image data
                    const newSrc = canvas.toDataURL();
                    imageData.src = newSrc;
                    
                    // Update thumbnail background
                    const thumbnail = document.querySelector(`[data-image-index="${index}"]`);
                    if (thumbnail) {
                        thumbnail.style.backgroundImage = `url(${newSrc})`;
                    }
                    
                    // Update the actual canvas image if this is the current image
                    if (imageData.original && imageData.original.label) {
                        const label = imageData.original.label;
                        
                        // Get canvas dimensions instead of raw image dimensions
                        // This is critical - paint.js coordinates are relative to canvas, not original image!
                        const canvas = document.getElementById('canvas');
                        if (!canvas) {
                            console.error('[Transform] Canvas element not found!');
                            return;
                        }
                        
                        // Use actual canvas coordinate space dimensions
                        let canvasWidth = canvas.width;
                        let canvasHeight = canvas.height;
                        
                        console.log(`[Transform] Using canvas dimensions: ${canvasWidth}x${canvasHeight} instead of image: ${img.naturalWidth}x${img.naturalHeight}`);
                        
                        // Clear stored centroid if canvas dimensions changed (for screen size changes)
                        if (window.originalDrawingCentroids && window.originalDrawingCentroids[label]) {
                            if (!window.lastCanvasDimensions) window.lastCanvasDimensions = {};
                            const lastDims = window.lastCanvasDimensions[label];
                            if (lastDims && (lastDims.width !== canvasWidth || lastDims.height !== canvasHeight)) {
                                delete window.originalDrawingCentroids[label];
                                console.log(`[Transform] Cleared stored centroid for ${label} - canvas size changed from ${lastDims.width}x${lastDims.height} to ${canvasWidth}x${canvasHeight}`);
                            }
                            window.lastCanvasDimensions[label] = { width: canvasWidth, height: canvasHeight };
                        }
                        
                        // For rotations, we might need to swap canvas dimensions too
                        let transformWidth = canvasWidth;
                        let transformHeight = canvasHeight;
                        
                        if (Math.abs(degrees) === 90 || Math.abs(degrees) === 270) {
                            // For blank canvas, keep original dimensions to rotate "in place"
                            // For real images, swap dimensions to match the rotated coordinate space
                            if (imageData.original && imageData.original.isBlankCanvas) {
                                console.log(`[Transform] Keeping canvas dimensions for blank canvas rotation: ${transformWidth}x${transformHeight}`);
                            } else {
                                // After rotation, the canvas coordinate space also changes
                                transformWidth = canvasHeight;  // Width becomes height
                                transformHeight = canvasWidth;  // Height becomes width
                                console.log(`[Transform] Swapped canvas dimensions for rotation: ${transformWidth}x${transformHeight}`);
                            }
                        }
                        
                        // Transform all coordinate-based data using IMAGE dimensions (not canvas)
                        // Paint.js stores coordinates in image-relative space, not canvas space
                        // For blank canvas, use canvas dimensions since there's no actual image
                        let rotateWidth, rotateHeight;
                        if (imageData.original && imageData.original.isBlankCanvas) {
                            const canvas = document.getElementById('canvas');
                            rotateWidth = canvas ? canvas.width : 800;
                            rotateHeight = canvas ? canvas.height : 800;
                            console.log(`[Transform] Using canvas dimensions for blank canvas: ${rotateWidth}x${rotateHeight}`);
                        } else {
                            rotateWidth = img.naturalWidth;
                            rotateHeight = img.naturalHeight;
                        }
                        // Debug: Check paint.js current state
                        if (window.paintApp && window.paintApp.state) {
                            console.log(`[Transform] Paint.js current image label: ${window.paintApp.state.currentImageLabel}`);
                        }
                        
                        console.log(`[Transform] About to call transformImageData with label: ${label}, degrees: ${degrees}, dimensions: ${rotateWidth}x${rotateHeight}`);
                        transformImageData(label, 'rotate', degrees, rotateWidth, rotateHeight);
                        // Update the paint.js image data (skip for blank canvas as there's no actual image)
                        if (!imageData.original?.isBlankCanvas) {
                            if (window.originalImages && window.originalImages[label]) {
                                window.originalImages[label] = newSrc;
                            }
                            
                            // Update the canvas if this is the currently displayed image
                            if (window.paintApp && window.paintApp.state.currentImageLabel === label) {
                                console.log(`[Gallery] Updating canvas with rotated image for ${label}`);
                                updateCanvasWithNewImage(newSrc);
                            }
                        } else {
                            console.log('[Transform] Skipping image update for blank canvas - only transforming drawing data');
                            
                            // For blank canvas, just redraw the existing strokes with transformed coordinates
                            if (window.redrawCanvasWithVisibility) {
                                window.redrawCanvasWithVisibility();
                            } else if (window.drawAllStrokes) {
                                window.drawAllStrokes();
                            }
                        }
                    }
                    
                    console.log(`[Gallery] Image ${index} rotated ${degrees}`);
                };
                img.crossOrigin = 'anonymous';
                img.src = imageData.src;
            }
            
            // Flip image function
            function flipImage(index, direction) {
                console.log(`[Gallery] Flipping image ${index} ${direction}`);
                
                const imageData = imageGalleryData[index];
                if (!imageData) return;
                
                // Apply flip using Canvas
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // Apply flip transformation
                    if (direction === 'horizontal') {
                        ctx.scale(-1, 1);
                        ctx.drawImage(img, -canvas.width, 0);
                    } else if (direction === 'vertical') {
                        ctx.scale(1, -1);
                        ctx.drawImage(img, 0, -canvas.height);
                    }
                    
                    // Update image data
                    const newSrc = canvas.toDataURL();
                    imageData.src = newSrc;
                    
                    // Update thumbnail background
                    const thumbnail = document.querySelector(`[data-image-index="${index}"]`);
                    if (thumbnail) {
                        thumbnail.style.backgroundImage = `url(${newSrc})`;
                    }
                    
                    // Update the actual canvas image if this is the current image
                    if (imageData.original && imageData.original.label) {
                        const label = imageData.original.label;
                        
                        // Get canvas dimensions for coordinate transformation  
                        // Paint.js coordinates are relative to canvas, not original image!
                        const canvas = document.getElementById('canvas');
                        if (!canvas) {
                            console.error('[Transform] Canvas element not found!');
                            return;
                        }
                        
                        // Use actual canvas coordinate space dimensions
                        const canvasWidth = canvas.width;
                        const canvasHeight = canvas.height;
                        
                        console.log(`[Transform] Using canvas dimensions for flip: ${canvasWidth}x${canvasHeight}`);
                        
                        // Transform all coordinate-based data using IMAGE dimensions (not canvas)  
                        // Paint.js stores coordinates in image-relative space, not canvas space
                        // For blank canvas, use canvas dimensions since there's no actual image
                        let flipWidth, flipHeight;
                        if (imageData.original && imageData.original.isBlankCanvas) {
                            flipWidth = canvasWidth;
                            flipHeight = canvasHeight;
                            console.log(`[Transform] Using canvas dimensions for blank canvas flip: ${flipWidth}x${flipHeight}`);
                        } else {
                            flipWidth = img.naturalWidth;
                            flipHeight = img.naturalHeight;
                        }
                        transformImageData(label, 'flip', direction, flipWidth, flipHeight);
                        // Update the paint.js image data (skip for blank canvas as there's no actual image)
                        if (!imageData.original?.isBlankCanvas) {
                            if (window.originalImages && window.originalImages[label]) {
                                window.originalImages[label] = newSrc;
                            }
                            
                            // Update the canvas if this is the currently displayed image
                            if (window.paintApp && window.paintApp.state.currentImageLabel === label) {
                                console.log(`[Gallery] Updating canvas with flipped image for ${label}`);
                                updateCanvasWithNewImage(newSrc);
                            }
                        } else {
                            console.log('[Transform] Skipping image update for blank canvas flip - only transforming drawing data');
                            
                            // For blank canvas, just redraw the existing strokes with transformed coordinates
                            if (window.redrawCanvasWithVisibility) {
                                window.redrawCanvasWithVisibility();
                            } else if (window.drawAllStrokes) {
                                window.drawAllStrokes();
                            }
                        }
                    }
                    
                    console.log(`[Gallery] Image ${index} flipped ${direction}`);
                };
                img.crossOrigin = 'anonymous';
                img.src = imageData.src;
            }
            
            // Test function to validate coordinate transformations
            function testCoordinateTransformations() {
                console.log('=== Testing Coordinate Transformations ===');
                
                // Get actual canvas dimensions dynamically
                const canvas = document.getElementById('canvas');
                const canvasWidth = canvas ? canvas.width : 1920;
                const canvasHeight = canvas ? canvas.height : 945;
                
                console.log(`[Test] Using actual canvas dimensions: ${canvasWidth}x${canvasHeight}`);
                
                // Test corner points that were previously going out of bounds
                const testPoints = [
                    {x: 100, y: 100, label: 'top-left area'},
                    {x: 1800, y: 100, label: 'top-right area'}, 
                    {x: 100, y: 800, label: 'bottom-left area'},
                    {x: 1800, y: 800, label: 'bottom-right area'},
                    {x: 960, y: 472.5, label: 'center'}
                ];
                
                let allTestsPassed = true;
                
                testPoints.forEach(point => {
                    console.log(`\nTesting ${point.label} at (${point.x}, ${point.y}):`);
                    
                    // Test 90 rotation
                    const rotated90 = rotateCoordinates(point.x, point.y, 90, canvasWidth, canvasHeight);
                    console.log(`  90 rotation: (${rotated90.x.toFixed(1)}, ${rotated90.y.toFixed(1)})`);
                    
                    // Test 180 rotation  
                    const rotated180 = rotateCoordinates(point.x, point.y, 180, canvasWidth, canvasHeight);
                    console.log(`  180 rotation: (${rotated180.x.toFixed(1)}, ${rotated180.y.toFixed(1)})`);
                    
                    // Test horizontal flip
                    const flippedH = flipCoordinates(point.x, point.y, 'horizontal', canvasWidth, canvasHeight);
                    console.log(`  Horizontal flip: (${flippedH.x.toFixed(1)}, ${flippedH.y.toFixed(1)})`);
                    
                    // Test vertical flip
                    const flippedV = flipCoordinates(point.x, point.y, 'vertical', canvasWidth, canvasHeight);
                    console.log(`  Vertical flip: (${flippedV.x.toFixed(1)}, ${flippedV.y.toFixed(1)})`);
                    
                    // Verify all results are within bounds (for 90: width becomes height)
                    const bounds90 = rotated90.x >= 0 && rotated90.x <= canvasHeight && rotated90.y >= 0 && rotated90.y <= canvasWidth;
                    const bounds180 = rotated180.x >= 0 && rotated180.x <= canvasWidth && rotated180.y >= 0 && rotated180.y <= canvasHeight;
                    const boundsFlipH = flippedH.x >= 0 && flippedH.x <= canvasWidth && flippedH.y >= 0 && flippedH.y <= canvasHeight;
                    const boundsFlipV = flippedV.x >= 0 && flippedV.x <= canvasWidth && flippedV.y >= 0 && flippedV.y <= canvasHeight;
                    
                    console.log(`  Within bounds: 90=${bounds90}, 180=${bounds180}, H-flip=${boundsFlipH}, V-flip=${boundsFlipV}`);
                    
                    if (!bounds90 || !bounds180 || !boundsFlipH || !boundsFlipV) {
                        allTestsPassed = false;
                        console.error(`   BOUNDARY TEST FAILED for ${point.label}`);
                    }
                });
                
                if (allTestsPassed) {
                    console.log('\n All coordinate transformation tests PASSED - boundary constraints working correctly');
                } else {
                    console.error('\n Some coordinate transformation tests FAILED - boundary constraints need adjustment');
                }
                
                console.log('=== Transformation Test Complete ===');
                return allTestsPassed;
            }

            // Transform offset vectors (relative to anchor points) for rotation/flip
            // Offsets are ALWAYS rotated as pure vectors around origin (0,0) - no center logic
            function rotateOffsetVector(x, y, degrees) {
                // Pure vector rotation: O' = R(degrees) * O
                // For -90: (x,y)  (y,-x), e.g., (-710,-427.5)  (-427.5,710)
                const radians = (degrees * Math.PI) / 180;
                const cos = Math.cos(radians);
                const sin = Math.sin(radians);
                
                const rotatedX = x * cos - y * sin;
                const rotatedY = x * sin + y * cos;
                
                console.log(`[Transform] Vector rotation: (${x.toFixed(1)}, ${y.toFixed(1)})  (${rotatedX.toFixed(1)}, ${rotatedY.toFixed(1)}) by ${degrees}`);
                
                return {
                    x: rotatedX,
                    y: rotatedY
                };
            }
            
            function flipOffsetVector(x, y, direction) {
                if (direction === 'horizontal') {
                    return { x: -x, y: y };  // Flip X offset
                } else if (direction === 'vertical') {
                    return { x: x, y: -y };  // Flip Y offset
                }
                return { x, y };
            }
            
            // Get stroke midpoint from vector data in image space
            function getStrokeMidpointImageSpace(vectorStrokesSource, imageLabel, strokeLabel) {
                const vectorData = vectorStrokesSource[imageLabel][strokeLabel];
                if (!vectorData || !vectorData.points || vectorData.points.length === 0) {
                    console.warn(`[Transform] No vector data found for stroke ${strokeLabel}`);
                    return { x: 0, y: 0 };
                }
                
                const midpointIndex = Math.floor(vectorData.points.length / 2);
                const midpoint = vectorData.points[midpointIndex];
                return { x: midpoint.x, y: midpoint.y };
            }
            
            // Rotate a point around a center point
            function rotatePoint(point, center, degrees) {
                const radians = (degrees * Math.PI) / 180;
                const cos = Math.cos(radians);
                const sin = Math.sin(radians);
                
                const dx = point.x - center.x;
                const dy = point.y - center.y;
                
                return {
                    x: center.x + (dx * cos - dy * sin),
                    y: center.y + (dx * sin + dy * cos)
                };
            }

            // Coordinate transformation functions for image rotate/flip
            function rotateCoordinates(x, y, degrees, imageWidth, imageHeight, customCenter = null, keepDimensions = false) {
                let centerX, centerY;
                
                if (customCenter) {
                    centerX = customCenter.x;
                    centerY = customCenter.y;
                    console.log(`[Transform] Using drawing centroid (${centerX.toFixed(1)}, ${centerY.toFixed(1)}) for blank canvas`);
                } else {
                    centerX = imageWidth / 2;
                    centerY = imageHeight / 2;
                    console.log(`[Transform] Using canvas center (${centerX}, ${centerY})`);
                }
                
                console.log(`[Transform] Rotating point (${x}, ${y}) around center (${centerX.toFixed(1)}, ${centerY.toFixed(1)}) by ${degrees}`);
                
                // Translate to origin (relative to center)
                const translatedX = x - centerX;
                const translatedY = y - centerY;
                
                // Convert degrees to radians
                const radians = (degrees * Math.PI) / 180;
                const cos = Math.cos(radians);
                const sin = Math.sin(radians);
                
                // Apply rotation matrix
                const rotatedX = translatedX * cos - translatedY * sin;
                const rotatedY = translatedX * sin + translatedY * cos;
                
                // For 90 and 270 rotations, dimensions swap
                let newCenterX, newCenterY;
                if (Math.abs(degrees) === 90 || Math.abs(degrees) === 270) {
                    // For blank canvas, keep the same rotation center to avoid orbital motion
                    if (customCenter) {
                        // Keep the drawing centroid as rotation center
                        newCenterX = centerX;
                        newCenterY = centerY;
                        console.log(`[Transform] Keeping rotation center (${newCenterX.toFixed(1)}, ${newCenterY.toFixed(1)}) for blank canvas 90/270 rotation`);
                    } else {
                        // For regular images, swap center with dimensions
                        newCenterX = imageHeight / 2;  // New width is old height
                        newCenterY = imageWidth / 2;   // New height is old width
                    }
                } else {
                    newCenterX = centerX;
                    newCenterY = centerY;
                }
                
                // Translate back from new center
                let finalX = rotatedX + newCenterX;
                let finalY = rotatedY + newCenterY;
                
                // Get the final canvas dimensions (after potential rotation)
                let finalWidth, finalHeight;
                if (keepDimensions || !(Math.abs(degrees) === 90 || Math.abs(degrees) === 270)) {
                    // Keep original dimensions for blank canvas or non-90/270 rotations
                    finalWidth = imageWidth;
                    finalHeight = imageHeight;
                } else {
                    // Swap dimensions for regular image 90/270 rotations
                    finalWidth = imageHeight;
                    finalHeight = imageWidth;
                }
                
                // For blank canvas, skip bounds clamping to prevent shape distortion during rotation
                if (!keepDimensions) {
                    // Constrain coordinates to stay within canvas bounds (0 to width-1, 0 to height-1)
                    finalX = Math.max(0, Math.min(finalWidth - 1, finalX));
                    finalY = Math.max(0, Math.min(finalHeight - 1, finalY));
                }
                
                console.log(`[Transform] Final coordinates: (${finalX}, ${finalY}) [bounds: ${finalWidth}x${finalHeight}]`);
                
                return {
                    x: finalX,
                    y: finalY
                };
            }
            
            function flipCoordinates(x, y, direction, imageWidth, imageHeight) {
                let finalX = x, finalY = y;
                
                if (direction === 'horizontal') {
                    finalX = imageWidth - x;
                } else if (direction === 'vertical') {
                    finalY = imageHeight - y;
                }
                
                // Apply boundary constraints (0 to width-1, 0 to height-1)
                finalX = Math.max(0, Math.min(imageWidth - 1, finalX));
                finalY = Math.max(0, Math.min(imageHeight - 1, finalY));
                
                return { 
                    x: finalX, 
                    y: finalY 
                };
            }
            
            // Calculate the centroid (center of mass) of all drawn strokes
            function calculateDrawingCentroid(vectorStrokesByImage, imageLabel) {
                const vectorStrokes = vectorStrokesByImage[imageLabel];
                if (!vectorStrokes || Object.keys(vectorStrokes).length === 0) {
                    return null;
                }
                
                let totalX = 0, totalY = 0, totalPoints = 0;
                
                Object.values(vectorStrokes).forEach(stroke => {
                    if (stroke.points && stroke.points.length > 0) {
                        stroke.points.forEach(point => {
                            totalX += point.x;
                            totalY += point.y;
                            totalPoints++;
                        });
                    }
                });
                
                if (totalPoints === 0) return null;
                
                const centroid = {
                    x: totalX / totalPoints,
                    y: totalY / totalPoints
                };
                
                console.log(`[Transform] Drawing centroid: (${centroid.x.toFixed(1)}, ${centroid.y.toFixed(1)}) from ${totalPoints} points`);
                return centroid;
            }
            
            // Transform all stroke and label data for an image
            window.transformImageData = function transformImageData(imageLabel, transformType, transformValue, imageWidth, imageHeight) {
                console.log(`[Transform] ===== TRANSFORMING DATA =====`);
                console.log(`[Transform] Image: ${imageLabel}, Type: ${transformType} ${transformValue}`);
                console.log(`[Transform] Using IMAGE dimensions: ${imageWidth} x ${imageHeight}`);
                
                // Debug: Check both global state and paintApp state
                if (window.paintApp && window.paintApp.state) {
                    console.log(`[Transform] Paint.js current image label: ${window.paintApp.state.currentImageLabel}`);
                    console.log(`[Transform] Paint.js vectorStrokesByImage keys:`, Object.keys(window.paintApp.state.vectorStrokesByImage || {}));
                }
                
                // Debug: Check what data exists for this image label
                if (window.vectorStrokesByImage) {
                    console.log(`[Transform] Available vectorStrokesByImage labels:`, Object.keys(window.vectorStrokesByImage));
                    if (window.vectorStrokesByImage[imageLabel]) {
                        console.log(`[Transform] Found ${Object.keys(window.vectorStrokesByImage[imageLabel]).length} strokes for label ${imageLabel}`);
                    } else {
                        console.log(`[Transform] No strokes found for label ${imageLabel}`);
                    }
                } else {
                    console.log(`[Transform] Global vectorStrokesByImage is undefined!`);
                }
                
                // Try paint.js state if global variables are empty
                let vectorStrokesSource = window.vectorStrokesByImage;
                let labelPositionsSource = window.customLabelPositions;
                let labelOffsetsSource = window.calculatedLabelOffsets;
                
                console.log(`[DEBUG] Initial sources - vectorStrokesSource:`, !!vectorStrokesSource, 'labelPositionsSource:', !!labelPositionsSource, 'labelOffsetsSource:', !!labelOffsetsSource);
                
                if (window.paintApp && window.paintApp.state) {
                    if (!vectorStrokesSource || !vectorStrokesSource[imageLabel]) {
                        vectorStrokesSource = window.paintApp.state.vectorStrokesByImage;
                        console.log(`[Transform] Using paint.js state vectorStrokesByImage instead`);
                    }
                    if (!labelPositionsSource || !labelPositionsSource[imageLabel]) {
                        labelPositionsSource = window.paintApp.state.customLabelPositions;
                        console.log(`[Transform] Using paint.js state customLabelPositions instead`);
                    }
                    if (!labelOffsetsSource || !labelOffsetsSource[imageLabel]) {
                        labelOffsetsSource = window.paintApp.state.calculatedLabelOffsets;
                        console.log(`[Transform] Using paint.js state calculatedLabelOffsets instead`);
                    }
                }
                
                // Calculate the rotation center
                let rotationCenter = null;
                // Treat as blank-like when no bitmap exists for this label or label is explicitly 'blank_canvas'
                const isBlankCanvas = (imageLabel === 'blank_canvas') || !(window.originalImages && window.originalImages[imageLabel]);
                if (transformType === 'rotate' && vectorStrokesSource) {
                    // For blank canvas, rotate around the actual drawing center (fallback to canvas center if no strokes)
                    if (isBlankCanvas) {
                        // Initialize original centroid storage if it doesn't exist
                        if (!window.originalDrawingCentroids) {
                            window.originalDrawingCentroids = {};
                        }
                        
                        // Store the original centroid on first rotation, then reuse it
                        if (!window.originalDrawingCentroids[imageLabel]) {
                            window.originalDrawingCentroids[imageLabel] = calculateDrawingCentroid(vectorStrokesSource, imageLabel);
                            console.log(`[Transform] Storing original drawing centroid for ${imageLabel}:`, window.originalDrawingCentroids[imageLabel]);
                            
                            // Also store the canvas dimensions when we store the centroid
                            const canvas = document.getElementById('canvas');
                            if (canvas) {
                                if (!window.lastCanvasDimensions) window.lastCanvasDimensions = {};
                                window.lastCanvasDimensions[imageLabel] = { width: canvas.width, height: canvas.height };
                                console.log(`[Transform] Stored canvas dimensions for ${imageLabel}: ${canvas.width}x${canvas.height}`);
                            }
                        }
                        
                        rotationCenter = window.originalDrawingCentroids[imageLabel] || { x: imageWidth / 2, y: imageHeight / 2 };
                        console.log(`[Transform] Using stored centroid or canvas center for ${imageLabel}:`, rotationCenter);
                    } else {
                        // For regular images, rotate strokes around the image center to match bitmap rotation
                        rotationCenter = null;
                        console.log(`[Transform] Using image center for rotation of ${imageLabel}`);
                    }
                }

                // Record rotation metadata for testing harness
                if (transformType === 'rotate') {
                    // Determine real image label used by state (avoid 'blank_canvas' leaks)
                    const realImageLabel = window.currentImageLabel || imageLabel;
                    
                    // Store rotation metadata with normalized delta and canvas coordinates
                    if (!window.lastRotationMeta) window.lastRotationMeta = {};
                    
                    // For regular images (rotationCenter = null), use image center
                    const centerToRecord = rotationCenter || { x: imageWidth / 2, y: imageHeight / 2 };
                    
                    window.lastRotationMeta[realImageLabel] = {
                        centerCanvas: { x: centerToRecord.x, y: centerToRecord.y },
                        delta: window.normalizeDelta ? window.normalizeDelta((transformValue * Math.PI) / 180) : ((transformValue * Math.PI) / 180)
                    };
                    console.log(`[Transform] Recorded rotation meta for ${realImageLabel}: center=(${centerToRecord.x.toFixed(1)}, ${centerToRecord.y.toFixed(1)}), delta=${transformValue}`);
                }
                
                // Transform vector strokes
                if (vectorStrokesSource && vectorStrokesSource[imageLabel]) {
                    const vectorStrokes = vectorStrokesSource[imageLabel];
                    console.log(`[Transform] Processing ${Object.keys(vectorStrokes).length} vector strokes:`, Object.keys(vectorStrokes));
                    
                    Object.keys(vectorStrokes).forEach(strokeLabel => {
                        const strokeData = vectorStrokes[strokeLabel];
                        if (strokeData && strokeData.points) {
                            console.log(`[Transform] Stroke ${strokeLabel}: ${strokeData.points.length} points`);
                            console.log(`[Transform] Before:`, strokeData.points.slice(0, 2)); // Show first 2 points
                            
                            strokeData.points = strokeData.points.map(point => {
                                if (transformType === 'rotate') {
                                    return rotateCoordinates(point.x, point.y, transformValue, imageWidth, imageHeight, rotationCenter, isBlankCanvas);
                                } else if (transformType === 'flip') {
                                    return flipCoordinates(point.x, point.y, transformValue, imageWidth, imageHeight);
                                }
                                return point;
                            });
                            
                            console.log(`[Transform] After:`, strokeData.points.slice(0, 2)); // Show first 2 transformed points
                        }
                    });
                    console.log(`[Transform] Updated ${Object.keys(vectorStrokes).length} vector strokes`);
                }
                
                // Transform custom label positions for rotations - maintain exact positioning
                // User-positioned labels should stay at the same relative position after rotation
                if (transformType === 'rotate') {
                    const allCustomTransformSources = [
                        window.customLabelPositions,
                        window.paintApp?.state?.customLabelPositions
                    ].filter(Boolean);
                    
                    allCustomTransformSources.forEach(source => {
                        if (source && source[imageLabel]) {
                            console.log(`[Transform] Rotating custom label positions for ${imageLabel}`);
                            Object.keys(source[imageLabel]).forEach(strokeLabel => {
                                const offset = source[imageLabel][strokeLabel];
                                if (offset && typeof offset.x === 'number' && typeof offset.y === 'number') {
                                    console.log(`[Transform] Before rotation - ${strokeLabel}: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)})`);
                                    const rotated = rotateCoordinates(offset.x, offset.y, transformValue, imageWidth, imageHeight, rotationCenter, isBlankCanvas);
                                    offset.x = rotated.x;
                                    offset.y = rotated.y;
                                    console.log(`[Transform] After rotation - ${strokeLabel}: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)})`);
                                }
                            });
                        }
                    });
                }
                
                // Transform absolute tag positions for rotations - maintain exact positioning
                if (transformType === 'rotate') {
                    const allAbsoluteTransformSources = [
                        window.customLabelAbsolutePositions,
                        window.paintApp?.state?.customLabelAbsolutePositions
                    ].filter(Boolean);
                    
                    allAbsoluteTransformSources.forEach(source => {
                        if (source && source[imageLabel]) {
                            console.log(`[Transform] Rotating absolute tag positions for ${imageLabel}`);
                            Object.keys(source[imageLabel]).forEach(strokeLabel => {
                                const absPos = source[imageLabel][strokeLabel];
                                if (absPos && typeof absPos.x === 'number' && typeof absPos.y === 'number') {
                                    console.log(`[Transform] Before rotation - ${strokeLabel} absolute: (${absPos.x.toFixed(1)}, ${absPos.y.toFixed(1)})`);
                                    const rotated = rotateCoordinates(absPos.x, absPos.y, transformValue, imageWidth, imageHeight, rotationCenter, isBlankCanvas);
                                    absPos.x = rotated.x;
                                    absPos.y = rotated.y;
                                    console.log(`[Transform] After rotation - ${strokeLabel} absolute: (${absPos.x.toFixed(1)}, ${absPos.y.toFixed(1)})`);
                                }
                            });
                        }
                    });
                }
                
                // Transform calculated label offsets using simple vector rotation
                // This maintains proper positioning during rotations without accumulating errors
                if (labelOffsetsSource && labelOffsetsSource[imageLabel] && transformType === 'rotate') {
                    const labelOffsets = labelOffsetsSource[imageLabel];
                    console.log(`[Transform] Transforming ${Object.keys(labelOffsets).length} calculated label offsets for rotation`);
                    
                    // Transform each label offset as a vector relative to the stroke's anchor point
                    Object.keys(labelOffsets).forEach(labelKey => {
                        const offset = labelOffsets[labelKey];
                        if (offset && typeof offset.x === 'number' && typeof offset.y === 'number') {
                            // Transform the offset vector using pure rotation (no translation)
                            // Offsets are relative vectors that should rotate around origin (0,0)
                            const rotatedOffset = rotateOffsetVector(offset.x, offset.y, transformValue);
                            labelOffsets[labelKey] = rotatedOffset;
                            console.log(`[Transform] Transformed label offset ${labelKey}: (${offset.x.toFixed(1)}, ${offset.y.toFixed(1)})  (${rotatedOffset.x.toFixed(1)}, ${rotatedOffset.y.toFixed(1)})`);
                        }
                    });
                    console.log(`[Transform] Transformed ${Object.keys(labelOffsets).length} calculated label offsets`);
                }
                
                // NEW RELATIVE POSITIONING SYSTEM: Use relative positions to recalculate absolute positions after rotation
                console.log(`[REL-TRANSFORM] Using relative positioning system for rotation-resistant custom labels`);
                
                if (transformType === 'rotate' && window.customLabelRelativePositions && window.customLabelRelativePositions[imageLabel]) {
                    const relativePositions = window.customLabelRelativePositions[imageLabel];
                    const strokeLabels = Object.keys(relativePositions);
                    console.log(`[REL-TRANSFORM] Found ${strokeLabels.length} relative positions to recalculate:`, strokeLabels);
                    
                    // Initialize absolute position storage if needed
                    if (!window.customLabelPositions[imageLabel]) {
                        window.customLabelPositions[imageLabel] = {};
                    }
                    
                    let updatedPositions = 0;
                    strokeLabels.forEach(strokeLabel => {
                        const relativePos = relativePositions[strokeLabel];
                        if (relativePos && typeof relativePos.percentageAlongLine === 'number' && typeof relativePos.perpendicularDistance === 'number') {
                            // Recalculate absolute position from relative position after stroke rotation
                            const newAbsoluteOffset = window.convertRelativeToAbsolutePosition(strokeLabel, relativePos, imageLabel);
                            if (newAbsoluteOffset) {
                                window.customLabelPositions[imageLabel][strokeLabel] = newAbsoluteOffset;
                                updatedPositions++;
                                console.log(`[REL-TRANSFORM] Recalculated ${strokeLabel}: ${(relativePos.percentageAlongLine * 100).toFixed(1)}% + ${relativePos.perpendicularDistance.toFixed(1)}px  (${newAbsoluteOffset.x.toFixed(1)}, ${newAbsoluteOffset.y.toFixed(1)})`);
                            } else {
                                console.warn(`[REL-TRANSFORM] Failed to recalculate position for ${strokeLabel}`);
                            }
                        }
                    });
                    
                    console.log(`[REL-TRANSFORM] Successfully recalculated ${updatedPositions}/${strokeLabels.length} custom positions using relative positioning`);
                } else {
                    console.log(`[REL-TRANSFORM] No relative positions found for ${imageLabel} or not a rotation transform`);
                    
                    // Fallback: Clear absolute positions for non-rotation transforms to force recalculation
                    if (transformType !== 'rotate' && window.customLabelPositions && window.customLabelPositions[imageLabel]) {
                        const customPositions = window.customLabelPositions[imageLabel];
                        const strokeLabels = Object.keys(customPositions);
                        console.log(`[REL-TRANSFORM] Clearing ${strokeLabels.length} absolute custom positions for ${transformType} - will be recalculated`);
                        
                        strokeLabels.forEach(strokeLabel => {
                            delete customPositions[strokeLabel];
                        });
                    }
                }
                
                if (transformType !== 'rotate' && labelOffsetsSource && labelOffsetsSource[imageLabel]) {
                    // For non-rotation transforms (flip), clear offsets to force recalculation
                    const labelOffsets = labelOffsetsSource[imageLabel];
                    console.log(`[Transform] Clearing ${Object.keys(labelOffsets).length} calculated label offsets for ${transformType}`);
                    
                    Object.keys(labelOffsets).forEach(labelKey => {
                        delete labelOffsets[labelKey];
                    });
                    console.log(`[Transform] Cleared calculated label offsets - will be recalculated on next draw`);
                }
                
                // Update image dimensions if rotating by 90/270 degrees
                // Skip dimension swapping for blank-like images (no real bitmap to swap)
                if (transformType === 'rotate' && (Math.abs(transformValue) === 90 || Math.abs(transformValue) === 270)) {
                    // Treat as blank-like when no bitmap exists for this label or label is explicitly 'blank_canvas'
                    const isBlankCanvas = (imageLabel === 'blank_canvas') || !(window.originalImages && window.originalImages[imageLabel]);
                    
                    if (!isBlankCanvas && window.originalImageDimensions && window.originalImageDimensions[imageLabel]) {
                        const dims = window.originalImageDimensions[imageLabel];
                        window.originalImageDimensions[imageLabel] = {
                            width: dims.height,
                            height: dims.width
                        };
                        console.log(`[Transform] Swapped image dimensions: ${dims.width}x${dims.height}  ${dims.height}x${dims.width}`);
                    } else if (isBlankCanvas) {
                        console.log(`[Transform] Skipping dimension swap for blank-like canvas (${imageLabel})`);
                    }
                }

                // Update rotation stamps and cumulative rotation for custom labels persistence
                if (transformType === 'rotate') {
                    // 1) Determine real image label used by state (avoid 'blank_canvas' leaks)
                    const img = window.currentImageLabel || imageLabel;

                    // 2) Rotation delta already known (transformValue in degrees); normalize it in radians
                    const deltaRadians = (transformValue * Math.PI) / 180;
                    const normalizedDelta = window.normalizeDelta ? window.normalizeDelta(deltaRadians) : deltaRadians;

                    // 3) Update per-stroke rotation stamps for custom offsets
                    if (!window.customLabelOffsetsRotationByImageAndStroke) {
                        window.customLabelOffsetsRotationByImageAndStroke = {};
                    }
                    if (!window.customLabelOffsetsRotationByImageAndStroke[img]) {
                        window.customLabelOffsetsRotationByImageAndStroke[img] = {};
                    }

                    // Update stamps for all strokes that have custom offsets
                    if (window.customLabelPositions && window.customLabelPositions[img]) {
                        Object.keys(window.customLabelPositions[img]).forEach(stroke => {
                            const lastStamp = window.customLabelOffsetsRotationByImageAndStroke[img][stroke] || 0;
                            const newStamp = window.normalizeDelta ? window.normalizeDelta(lastStamp + normalizedDelta) : (lastStamp + normalizedDelta);
                            window.customLabelOffsetsRotationByImageAndStroke[img][stroke] = newStamp;
                        });
                    }

                    // 4) Advance image cumulative rotation so future sync math remains aligned
                    if (!window.imageRotationByLabel) {
                        window.imageRotationByLabel = {};
                    }
                    const currentRotation = window.imageRotationByLabel[img] || 0;
                    window.imageRotationByLabel[img] = window.normalizeDelta ? window.normalizeDelta(currentRotation + normalizedDelta) : (currentRotation + normalizedDelta);

                    console.log(`[Transform] Updated rotation state for ${img}: delta=${(transformValue)}, cumulative=${(window.imageRotationByLabel[img] * 180 / Math.PI).toFixed(1)}`);
                }
            }
            
            // Helper function to update canvas with new image data
            function updateCanvasWithNewImage(newImageSrc) {
                try {
                    const img = new Image();
                    img.onload = function() {
                        const canvas = document.getElementById('canvas');
                        if (canvas) {
                            const ctx = canvas.getContext('2d');
                            
                            console.log(`[Canvas] Updating canvas (${canvas.width}x${canvas.height}) with new image (${img.width}x${img.height})`);
                            
                            // Clear canvas
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            // Get current scale and position from paint.js
                            const currentLabel = window.paintApp?.state?.currentImageLabel || window.currentImageLabel;
                            const scale = window.imageScaleByLabel?.[currentLabel] || 1.0;
                            const position = window.imagePositionByLabel?.[currentLabel] || { x: 0, y: 0 };
                            
                            console.log(`[Canvas] Using scale: ${scale}, position: (${position.x}, ${position.y})`);
                            
                            // Calculate scaled dimensions and positioning
                            const scaledWidth = img.width * scale;
                            const scaledHeight = img.height * scale;
                            const x = (canvas.width - scaledWidth) / 2 + position.x;
                            const y = (canvas.height - scaledHeight) / 2 + position.y;
                            
                            // Draw image with proper scaling and positioning
                            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                            
                            // Trigger paint.js to redraw strokes if available
                            if (window.redrawCanvasWithVisibility) {
                                window.redrawCanvasWithVisibility();
                            } else if (window.drawAllStrokes) {
                                window.drawAllStrokes();
                            }
                            
                            console.log('[Gallery] Canvas updated with new image using paint.js scale/position');
                        }
                    };
                    img.crossOrigin = 'anonymous';
                    img.src = newImageSrc;
                } catch (error) {
                    console.error('[Gallery] Error updating canvas:', error);
                }
            }
            
            // Update active image highlighting
            function updateActiveImage(index) {
                currentImageIndex = index;
                
                // Update thumbnail highlighting
                document.querySelectorAll('.image-thumbnail').forEach((thumb, idx) => {
                    thumb.classList.toggle('active', idx === index);
                });
                
                // Update navigation dots
                document.querySelectorAll('.nav-dot').forEach((dot, idx) => {
                    dot.classList.toggle('active', idx === index);
                });
                
                // Sync inputs to current image
                const data = imageGalleryData[index];
                const nameEl = document.getElementById('imageNameInput');
                const typeEl = document.getElementById('imageTypeSelect');
                if (nameEl && data) nameEl.value = data.name || '';
                if (typeEl && data && data.original) typeEl.value = data.original.type || '';
                
                updateGalleryControls();
            }
            
            // Update gallery controls and counters
            function updateGalleryControls() {
                const prevButton = document.getElementById('prevImage');
                const nextButton = document.getElementById('nextImage');
                const imagePosition = document.getElementById('imagePosition');
                const imageCounter = document.getElementById('imageCounter');
                
                const totalImages = imageGalleryData.length;
                
                if (prevButton && nextButton) {
                    prevButton.disabled = currentImageIndex <= 0;
                    nextButton.disabled = currentImageIndex >= totalImages - 1;
                }
                
                if (imagePosition) {
                    imagePosition.textContent = `${currentImageIndex + 1} / ${totalImages}`;
                }
                
                if (imageCounter) {
                    imageCounter.textContent = totalImages > 0 ? `${totalImages} images` : '';
                }
            }
            
            // Clear image gallery
            function clearImageGallery() {
                const imageGallery = document.getElementById('imageGallery');
                const imageDots = document.getElementById('imageDots');
                
                if (imageGallery) imageGallery.innerHTML = '';
                if (imageDots) imageDots.innerHTML = '';
                
                imageGalleryData = [];
                currentImageIndex = 0;
                updateGalleryControls();
            }
            
            // Initialize gallery on page load
            initializeImageGallery();
            
            // Reveal UI once initialization is complete
            document.documentElement.classList.remove('app-loading');
            
            // Toolbar visibility is handled by CSS via toolbar-ready class
            // No need to set inline styles here
            
            // Store reference to original addImageToSidebar if it exists
            const originalAddImageToSidebar = window.addImageToSidebar;
            
            // Enhanced compatibility function that works with both new and old formats
            // NOTE: This is replaced by the [HOOK] wrapper when paint.js loads
            window.addImageToSidebar = function(imageUrl, label, filename) {
                console.log('[COMPAT] addImageToSidebar called with:', { imageUrl: imageUrl?.substring?.(0, 50) || imageUrl, label, filename });
                
                // Call original function first if it exists (for backwards compatibility)
                if (originalAddImageToSidebar && typeof originalAddImageToSidebar === 'function') {
                    try {
                        originalAddImageToSidebar.apply(this, arguments);
                        
                        // Verify imageList was updated
                        const imageList = document.getElementById('imageList');
                        if (imageList) {
                            const containers = imageList.querySelectorAll('.image-container');
                            console.log(`[COMPAT] imageList has ${containers.length} containers after original function`);
                        }
                    } catch (error) {
                        console.warn('[COMPAT] Original addImageToSidebar failed:', error);
                    }
                } else {
                    console.warn('[COMPAT] No original addImageToSidebar function available');
                }
                
                // Add to new gallery
                if (imageUrl) {
                    const index = imageGalleryData.length;
                    const imageData = {
                        src: imageUrl,
                        url: imageUrl,
                        name: filename || label || `Image ${index + 1}`,
                        label: label,
                        filename: filename
                    };
                    
                    addImageToGallery(imageData, index);
                    console.log('[COMPAT] Added to new gallery at index', index, 'Total images now:', imageGalleryData.length);
                    
                    return index;
                } else {
                    console.warn('[COMPAT] No valid imageUrl provided');
                    return -1;
                }
            };
            
            window.switchToImage = function(imageIndexOrLabel) {
                // If it's a number, treat as gallery index
                if (typeof imageIndexOrLabel === 'number') {
                    navigateToImage(imageIndexOrLabel);
                    console.log('[COMPAT] Switched to image index:', imageIndexOrLabel);
                } 
                // If it's a string (label), use ProjectManager
                else if (typeof imageIndexOrLabel === 'string') {
                    const label = imageIndexOrLabel;
                    console.log('[COMPAT] Switched to image label:', label);
                    
                    // Try ProjectManager first
                    if (window.projectManager && typeof window.projectManager.switchView === 'function') {
                        window.projectManager.switchView(label);
                    } 
                    // Fallback to legacy system
                    else if (window.switchToImageLegacy && typeof window.switchToImageLegacy === 'function') {
                        window.switchToImageLegacy(label);
                    } else {
                        console.warn('[COMPAT] No switchToImage implementation available');
                    }
                }
            };
            
            // Legacy image list compatibility
            window.updateImageList = function() {
                // This function exists for compatibility but the new gallery handles updates automatically
                console.log('[COMPAT] updateImageList called - handled by new gallery system');
            };
            
            // Clear images function
            window.clearImageSidebar = function() {
                clearImageGallery();
                console.log('[COMPAT] Cleared image sidebar');
            };
            
            console.log('[INIT] Image gallery and compatibility functions initialized');
            
            // Setup container-level drag auto-scroll
            const imageListContainer = document.getElementById('imageList');
            if (imageListContainer) {
                imageListContainer.addEventListener('dragover', (e) => {
                    const rect = imageListContainer.getBoundingClientRect();
                    const scrollThreshold = 80; // Distance from edge to trigger scroll
                    const scrollSpeed = 10; // Pixels per scroll
                    const mouseY = e.clientY;
                    
                    // Clear any existing scroll interval
                    if (window.dragScrollInterval) {
                        clearInterval(window.dragScrollInterval);
                        window.dragScrollInterval = null;
                    }
                    
                    // Check if near top edge
                    if (mouseY - rect.top < scrollThreshold && mouseY > rect.top) {
                        let scrolling = true;
                        const scroll = () => {
                            if (!scrolling) return;
                            imageListContainer.scrollBy(0, -scrollSpeed);
                            window.dragScrollFrame = requestAnimationFrame(scroll);
                        };
                        scrolling = true;
                        window.dragScrollFrame = requestAnimationFrame(scroll);
                    }
                    // Check if near bottom edge
                    else if (rect.bottom - mouseY < scrollThreshold && mouseY < rect.bottom) {
                        let scrolling = true;
                        const scroll = () => {
                            if (!scrolling) return;
                            imageListContainer.scrollBy(0, scrollSpeed);
                            window.dragScrollFrame = requestAnimationFrame(scroll);
                        };
                        scrolling = true;
                        window.dragScrollFrame = requestAnimationFrame(scroll);
                    }
                });
                
                // Clear scroll animation when drag ends anywhere
                const stopScrolling = () => {
                    if (window.dragScrollInterval) {
                        clearInterval(window.dragScrollInterval);
                        window.dragScrollInterval = null;
                    }
                    if (window.dragScrollFrame) {
                        cancelAnimationFrame(window.dragScrollFrame);
                        window.dragScrollFrame = null;
                    }
                };

                imageListContainer.addEventListener('drop', stopScrolling);
                
                imageListContainer.addEventListener('dragleave', (e) => {
                    // Only clear if leaving the container entirely
                    if (e.target === imageListContainer) {
                        stopScrolling();
                    }
                });
            }
            
            // Debug function to inspect paint.js state
            window.debugPaintState = function() {
                console.log('=== PAINT.JS STATE DEBUG ===');
                
                if (window.paintApp && window.paintApp.state) {
                    console.log('Current image label:', window.paintApp.state.currentImageLabel);
                    console.log('Paint app state keys:', Object.keys(window.paintApp.state));
                }
                
                if (window.vectorStrokesByImage) {
                    const labels = Object.keys(window.vectorStrokesByImage);
                    console.log('vectorStrokesByImage labels:', labels);
                    labels.forEach(label => {
                        const strokes = window.vectorStrokesByImage[label];
                        console.log(`  ${label}: ${Object.keys(strokes || {}).length} strokes`);
                    });
                } else {
                    console.log('vectorStrokesByImage not found');
                }
                
                if (window.customLabelPositions) {
                    const labels = Object.keys(window.customLabelPositions);
                    console.log('customLabelPositions labels:', labels);
                } else {
                    console.log('customLabelPositions not found');
                }
                
                console.log('imageGalleryData length:', imageGalleryData.length);
                console.log('currentImageIndex:', currentImageIndex);
                if (imageGalleryData[currentImageIndex]) {
                    console.log('Current image:', imageGalleryData[currentImageIndex].name, imageGalleryData[currentImageIndex].original?.label);
                    console.log('Full current image data:', JSON.stringify(imageGalleryData[currentImageIndex], null, 2));
                }
                
                // Also debug all gallery images
                console.log('All gallery images:');
                imageGalleryData.forEach((img, index) => {
                    console.log(`  [${index}] ${img.name}: label=${img.original?.label}, isBlankCanvas=${img.original?.isBlankCanvas}`);
                });
            };
            
            // Test function to add mock drawing data for blank canvas
            window.addTestTriangle = function() {
                // Try to get the actual current image label from gallery
                let targetLabel = 'blank_canvas'; // fallback
                if (imageGalleryData[currentImageIndex]?.original?.label) {
                    targetLabel = imageGalleryData[currentImageIndex].original.label;
                }
                const paintLabel = window.paintApp?.state?.currentImageLabel;
                
                console.log(`[Test] Gallery current index: ${currentImageIndex}`);
                console.log(`[Test] Gallery target label: ${targetLabel}`);
                console.log(`[Test] Paint.js current label: ${paintLabel}`);
                console.log(`[Test] Adding test triangle to label: ${targetLabel}`);
                
                // Mock stroke data for a simple triangle
                const mockStroke = {
                    points: [
                        { x: 300, y: 200 },  // Top point
                        { x: 200, y: 400 },  // Bottom left
                        { x: 400, y: 400 },  // Bottom right
                        { x: 300, y: 200 }   // Back to top
                    ],
                    color: '#ff0000',
                    thickness: 3,
                    type: 'freehand'
                };
                
                // Add to both global and paint.js state
                if (window.vectorStrokesByImage) {
                    if (!window.vectorStrokesByImage[targetLabel]) {
                        window.vectorStrokesByImage[targetLabel] = {};
                    }
                    window.vectorStrokesByImage[targetLabel]['test_triangle'] = mockStroke;
                }
                
                if (window.paintApp?.state?.vectorStrokesByImage) {
                    if (!window.paintApp.state.vectorStrokesByImage[targetLabel]) {
                        window.paintApp.state.vectorStrokesByImage[targetLabel] = {};
                    }
                    window.paintApp.state.vectorStrokesByImage[targetLabel]['test_triangle'] = mockStroke;
                }
                
                // Also switch paint.js to the correct label if it's not already there
                if (paintLabel !== targetLabel && window.switchToImage) {
                    console.log(`[Test] Switching paint.js from '${paintLabel}' to '${targetLabel}'`);
                    window.switchToImage(targetLabel);
                }
                
                console.log(`[Test] Added test triangle. Use debugPaintState() to verify.`);
                
                // Redraw if function exists
                if (window.redrawCanvasWithVisibility) {
                    window.redrawCanvasWithVisibility();
                }
            };
            
            // Note: Stored centroid system removed - blank canvas now uses fixed canvas center
            
            // Test function to try rotating the current image
            window.testRotate = function() {
                console.log(`[Test] Testing rotation on current image (index ${currentImageIndex})`);
                if (currentImageIndex >= 0 && currentImageIndex < imageGalleryData.length) {
                    const imageData = imageGalleryData[currentImageIndex];
                    console.log(`[Test] Rotating image: ${imageData.name}`);
                    rotateImage(currentImageIndex, 90);
                } else {
                    console.log(`[Test] Invalid image index: ${currentImageIndex}`);
                }
            };
            
            // Hook into addImageToSidebar after external scripts load
            let hookAttempts = 0;
            const maxHookAttempts = 50;
            
            function attemptHook() {
                hookAttempts++;
                
                // Check if paint.js has loaded and defined its own addImageToSidebar
                if (window.addImageToSidebar && typeof window.addImageToSidebar === 'function') {
                    console.log('[HOOK] Found original addImageToSidebar from paint.js, hooking into it...');
                    console.log('[HOOK] Function source preview:', window.addImageToSidebar.toString().substring(0, 200));
                    
                    // Store the original function
                    const paintJsAddImageToSidebar = window.addImageToSidebar;
                    
                    // Create our intercepting function
                    window.addImageToSidebar = function(imageUrl, label, filename) {
                        console.log('[HOOK] Intercepted addImageToSidebar call:', { imageUrl: imageUrl?.substring?.(0, 50) || imageUrl, label, filename });
                        
                        // Ensure imageList exists before calling original function
                        const imageList = document.getElementById('imageList');
                        if (!imageList) {
                            console.error('[HOOK] imageList element not found!');
                        }
                        
                        // Call the original paint.js function
                        let result;
                        try {
                            result = paintJsAddImageToSidebar.apply(this, arguments);
                            
                            // Verify the container was added for this specific label
                            const imageListAfter = document.getElementById('imageList');
                            if (imageListAfter) {
                                const containers = imageListAfter.querySelectorAll('.image-container');
                                const containerForLabel = imageListAfter.querySelector(`[data-label="${label}"]`);
                                console.log(`[HOOK] imageList now has ${containers.length} containers after addImageToSidebar`);
                                
                                // If no container exists for this label, create one manually
                                if (!containerForLabel && imageUrl && label) {
                                    console.warn(`[HOOK] No container found for label "${label}", creating one manually`);
                                    const container = document.createElement('button');
                                    container.type = 'button';
                                    container.draggable = true;
                                    container.className = 'image-container group w-full text-left relative flex items-center gap-3 p-3 rounded-xl hover:bg-slate-50 transition-colors snap-center';
                                    container.dataset.label = label;
                                    container.dataset.originalImageUrl = imageUrl;
                                    
                                    const img = document.createElement('img');
                                    img.src = imageUrl;
                                    img.className = 'pasted-image w-full h-40 rounded-lg object-contain bg-slate-100 shadow-sm';
                                    img.alt = `${label} view`;
                                    
                                    container.appendChild(img);

                                    // Add delete button
                                    const deleteBtn = document.createElement('button');
                                    deleteBtn.className = 'delete-image-btn opacity-0 group-hover:opacity-100 transition-opacity';
                                    deleteBtn.title = 'Delete image';
                                    deleteBtn.textContent = '';
                                    // Inline styles to match reference
                                    deleteBtn.style.cssText = 'position: absolute; top: 6px; right: 6px; cursor: pointer; background: rgba(255, 255, 255, 0.9); border: 1px solid rgb(204, 204, 204); border-radius: 50%; width: 20px; height: 20px; font-size: 12px; font-weight: bold; font-family: Arial, sans-serif; display: flex; align-items: center; justify-content: center; z-index: 10; color: rgb(102, 102, 102); line-height: 1; padding: 0px; margin: 0px; text-align: center;';
                                    
                                    deleteBtn.addEventListener('click', (e) => {
                                        e.stopPropagation();
                                        if (confirm('Delete this image?')) {
                                            container.remove();
                                            if (window.projectManager && typeof window.projectManager.deleteImage === 'function') {
                                                window.projectManager.deleteImage(label);
                                            }
                                            
                                            // Update pills
                                            if (typeof updatePills === 'function') updatePills();
                                            if (typeof updateActivePill === 'function') updateActivePill();
                                            if (typeof updateImageListPadding === 'function') updateImageListPadding();
                                        }
                                    });
                                    
                                    container.appendChild(deleteBtn);

                                    container.onclick = () => {
                                        if (window.projectManager && typeof window.projectManager.switchView === 'function') {
                                            window.projectManager.switchView(label);
                                        }
                                        // Scroll this container to center
                                        container.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                                        
                                        // Temporarily disable scroll-driven switching to prevent fighting
                                        window.__imageListProgrammaticScrollUntil = Date.now() + 500;
                                    };
                                    
                                    imageListAfter.appendChild(container);
                                    console.log(`[HOOK] Manually added container to imageList for label "${label}"`);

                                    if (typeof window.ensureImageListObserver === 'function') {
                                        window.ensureImageListObserver();
                                    } else {
                                        window.__pendingImageListObserverInit = true;
                                    }
                                    
                                    if (typeof updateImageListPadding === 'function') {
                                        updateImageListPadding();
                                    }
                                    
                                    // Initialize observer if not already done, or observe this new container
                                    if (typeof initImageListCenteringObserver === 'function') {
                                        // Initialize observer if it doesn't exist yet
                                        if (!window.__imageListCenteringObserver) {
                                            initImageListCenteringObserver();
                                        }
                                        // Observer will automatically pick up new containers via MutationObserver
                                        // But we can also explicitly observe this one immediately
                                        if (window.__imageListCenteringObserver) {
                                            window.__imageListCenteringObserver.observe(container);
                                        }
                                    }
                                    
                                    // Center the newly added image and switch to it if it's the first image
                                    setTimeout(() => {
                                        const allContainers = Array.from(imageListAfter.querySelectorAll('.image-container'));
                                        const isFirst = allContainers.length === 1 && allContainers[0] === container;
                                        
                                        if (isFirst) {
                                            console.log(`[HOOK] First image "${label}" added, centering and switching to it`);
                                            
                                            // Center the container
                                            window.__imageListProgrammaticScrollUntil = Date.now() + 1000;
                                            container.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                                            
                                            // Switch to this view
                                            if (window.projectManager && typeof window.projectManager.switchView === 'function') {
                                                window.projectManager.switchView(label);
                                            }
                                        }
                                        
                                        // Trigger mini-stepper update after adding to sidebar
                                        if (typeof updatePills === 'function') {
                                            updatePills();
                                        }
                                        if (typeof updateActivePill === 'function') {
                                            updateActivePill();
                                        }
                                    }, 100);
                                } else if (containerForLabel) {
                                    console.log(`[HOOK] Container for label "${label}" already exists in imageList`);
                                    
                                    // Update pills only, don't switch views for existing containers
                                    setTimeout(() => {
                                        if (typeof updatePills === 'function') {
                                            updatePills();
                                        }
                                        if (typeof updateActivePill === 'function') {
                                            updateActivePill();
                                        }
                                    }, 100);

                                    if (typeof updateImageListPadding === 'function') {
                                        updateImageListPadding();
                                    }
                                }
                            } else if (!imageListAfter) {
                                console.error('[HOOK] imageList element not found after addImageToSidebar call!');
                            }
                        } catch (error) {
                            console.error('[HOOK] Error calling original addImageToSidebar:', error);
                            // Don't throw - try to continue with gallery addition
                        }
                        
                        // Add to our new gallery
                        if (imageUrl) {
                            const index = imageGalleryData.length;
                            const imageData = {
                                src: imageUrl,
                                url: imageUrl,
                                name: filename || label || `Image ${index + 1}`,
                                label: label,
                                filename: filename
                            };
                            
                            addImageToGallery(imageData, index);
                            console.log('[HOOK] Added to new gallery at index', index);
                        }
                        
                        return result;
                    };
                    
                    console.log('[HOOK] Successfully hooked addImageToSidebar');
                    return true;
                } else if (hookAttempts < maxHookAttempts) {
                    if (window.__DEBUG__) console.log('[HOOK] Attempt', hookAttempts, '- addImageToSidebar not ready yet:', typeof window.addImageToSidebar);
                    setTimeout(attemptHook, 100);
                } else {
                    if (window.__DEBUG__) console.warn('[HOOK] Max attempts reached, could not hook addImageToSidebar');
                    console.warn('[HOOK] Final state - addImageToSidebar:', typeof window.addImageToSidebar, window.addImageToSidebar ? 'exists' : 'undefined');
                }
            }
            
            // Start attempting to hook after a short delay
            setTimeout(attemptHook, 500);
            
            // Function to sync existing legacy images to new gallery
            function syncLegacyImagesToGallery() {
                const imageList = document.getElementById('imageList');
                if (!imageList) {
                    console.log('[SYNC] ERROR: No imageList element found');
                    return;
                }
                
                const imageContainers = imageList.querySelectorAll('.image-container');
                console.log(`[SYNC] Processing ${imageContainers.length} legacy images`);
                
                let newImagesAdded = 0;
                
                imageContainers.forEach((container, index) => {
                    const img = container.querySelector('img');
                    const labelDiv = container.querySelector('.image-label');
                    const label = container.dataset.label;
                    
                    if (img && img.src) {
                        const imageData = {
                            src: img.src,
                            url: img.src,
                            name: labelDiv ? labelDiv.textContent : label || `Image ${index + 1}`,
                            label: label,
                            filename: labelDiv ? labelDiv.textContent : undefined
                        };
                        
                        // Check if this image is already in the gallery
                        const existingIndex = imageGalleryData.findIndex(item => item.src === img.src);
                        
                        if (existingIndex === -1) {
                            addImageToGallery(imageData, imageGalleryData.length);
                            console.log(`[SYNC]  Added: ${imageData.name}`);
                            newImagesAdded++;
                        }
                    }
                });
                
                if (newImagesAdded > 0) {
                    console.log(`[SYNC] Added ${newImagesAdded} new images. Total: ${imageGalleryData.length}`);
                }

                if (typeof updateImageListPadding === 'function') {
                    updateImageListPadding();
                }
            }
            
            // Function to clear demo images
            function clearDemoImages() {
                console.log('[DEMO] Clearing demo images...');
                imageGalleryData = imageGalleryData.filter(item => !item.name?.includes('Demo Image') && !item.name?.includes('Blank Canvas'));
                
                // Manually update the gallery UI instead of calling undefined function
                const gallery = document.getElementById('imageGallery');
                const dots = document.getElementById('imageDots');
                
                if (gallery) {
                    // Remove demo image thumbnails
                    const demoThumbnails = gallery.querySelectorAll('.image-thumbnail');
                    demoThumbnails.forEach(thumb => {
                        const overlay = thumb.querySelector('.image-overlay');
                        if (overlay && (overlay.textContent.includes('Demo Image') || overlay.textContent.includes('Blank Canvas'))) {
                            thumb.remove();
                        }
                    });
                }
                
                if (dots) {
                    // Clear demo dots
                    const demoDots = dots.querySelectorAll('.nav-dot');
                    demoDots.forEach(dot => dot.remove());
                }
                
                // Update counter if function exists
                if (typeof updateImageCounter === 'function') {
                    updateImageCounter();
                } else {
                    // Update counter manually
                    const counter = document.getElementById('imageCounter');
                    if (counter) {
                        counter.textContent = imageGalleryData.length > 0 ? `${imageGalleryData.length} images` : '';
                    }
                }
                console.log('[DEMO] Demo images cleared, remaining images:', imageGalleryData.length);
            }
            
            // Removed manual sync button - syncing is now automatic
            
            // Test the gallery with some demo images after everything loads
            setTimeout(() => {
                console.log('[INIT] ===== Initial gallery setup =====');
                console.log('[INIT] imageGalleryData before sync:', imageGalleryData.length);
                
                // First, sync any existing legacy images
                console.log('[INIT] Step 1: Syncing existing legacy images...');
                syncLegacyImagesToGallery();
                
                console.log('[INIT] imageGalleryData after sync:', imageGalleryData.length);
                
                // Check if we have any real images (non-demo)
                const realImagesCount = imageGalleryData.filter(item => !item.name?.includes('Demo Image') && !item.name?.includes('Blank Canvas')).length;
                console.log('[INIT] Real images found:', realImagesCount);
                
                // Do not add demo/blank images; keep gallery empty until user adds/loads
                console.log(`[INIT] Skipping demo images. Real count: ${realImagesCount}`);
                
                // Test the addImageToSidebar function to see if hooking works
                if (window.addImageToSidebar) {
                    console.log('[TEST] addImageToSidebar function is available');
                } else {
                    console.log('[TEST] addImageToSidebar not available yet');
                }
                
                console.log('[INIT] ===== Initial setup complete =====');
                
                // Initialize image list centering observer (if function exists and imageList has containers)
                const imageList = document.getElementById('imageList');
                if (imageList && imageList.querySelectorAll('.image-container').length > 0) {
                    if (typeof initImageListCenteringObserver === 'function') {
                        initImageListCenteringObserver();
                    } else {
                        console.warn('[INIT] initImageListCenteringObserver not available yet, will initialize when images are added');
                    }
                } else {
                    console.log('[INIT] No images yet, observer will initialize when first image is added');
                }
                
                // Ensure we always start with the first image
                if (imageList) {
                    const firstContainer = imageList.querySelector('.image-container');
                    if (firstContainer) {
                        const firstLabel = firstContainer.dataset.label;
                        if (firstLabel) {
                            console.log('[INIT] Centering and selecting first image:', firstLabel);
                            
                            // Center the first container
                            window.__imageListProgrammaticScrollUntil = Date.now() + 1000;
                            firstContainer.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                            
                            // Switch to the first image view
                    setTimeout(() => {
                                if (window.projectManager && typeof window.projectManager.switchView === 'function') {
                                    window.projectManager.switchView(firstLabel);
                                }
                                
                                // Update pills
                                if (typeof updatePills === 'function') {
                                    updatePills();
                                }
                                if (typeof updateActivePill === 'function') {
                                    updateActivePill();
                                }
                            }, 300);
                        }
                    }
                    
                    if (typeof updateImageListPadding === 'function') {
                        updateImageListPadding();
                    }
                }
            }, 2000);
            
            // Track last known legacy count to avoid unnecessary syncs
            let lastLegacyCount = 0;
            
            // Also set up a periodic sync to catch any images that get added later (less frequent)
            // Only run when tab is visible to reduce performance impact
            let syncInterval;
            const startSyncInterval = () => {
                syncInterval = setInterval(() => {
                    // Skip if tab is not visible
                    if (document.hidden) return;
                    
                    const currentLegacyCount = document.getElementById('imageList')?.querySelectorAll('.image-container').length || 0;
                    const currentRealImagesCount = imageGalleryData.filter(item => !item.name?.includes('Demo Image') && !item.name?.includes('Blank Canvas')).length;
                    
                    // Only sync if there's actually a change in legacy count
                    if (currentLegacyCount > lastLegacyCount) {
                        console.log('[PERIODIC] New legacy images detected, syncing...');
                        console.log(`[PERIODIC] Legacy: ${currentLegacyCount} (was ${lastLegacyCount}), Gallery real: ${currentRealImagesCount}`);
                        
                        // No demo images are used anymore; skip clearing
                        
                        syncLegacyImagesToGallery();
                        
                        // Don't automatically switch views during periodic sync
                        // Let ProjectManager handle view switching based on user interaction
                        // Only update pills to reflect new images
                        if (typeof updatePills === 'function') {
                            setTimeout(() => {
                                updatePills();
                                if (typeof updateActivePill === 'function') {
                                    updateActivePill();
                                }
                            }, 100);

                                    if (typeof window.ensureImageListObserver === 'function') {
                                        window.ensureImageListObserver();
                                    } else {
                                        window.__pendingImageListObserverInit = true;
                                    }
                        }
                        
                        lastLegacyCount = currentLegacyCount;
                    }
                }, 3000);  // Check every 3 seconds instead of 2
            };
            
            // Start interval and handle visibility changes
            startSyncInterval();
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    clearInterval(syncInterval);
                } else {
                    startSyncInterval();
                }
            });
        });

        // View Measurements toggle functionality
        document.addEventListener('DOMContentLoaded', () => {
            // View Measurements toggle functionality
            const viewMeasurementsToggle = document.getElementById('viewMeasurementsToggle');
            if (viewMeasurementsToggle) {
                let measurementsVisible = true; // Default state

                const updateToggleAppearance = () => {
                    if (measurementsVisible) {
                        viewMeasurementsToggle.classList.remove('bg-gray-500', 'text-white');
                        viewMeasurementsToggle.classList.add('bg-blue-500', 'text-white');
                        viewMeasurementsToggle.textContent = 'Show Labels';
                        viewMeasurementsToggle.title = 'Hide measurement labels';
                    } else {
                        viewMeasurementsToggle.classList.remove('bg-blue-500', 'text-white');
                        viewMeasurementsToggle.classList.add('bg-gray-500', 'text-white');
                        viewMeasurementsToggle.textContent = 'Hide Labels';
                        viewMeasurementsToggle.title = 'Show measurement labels';
                    }
                };

                viewMeasurementsToggle.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent panel dragging
                    measurementsVisible = !measurementsVisible;
                    updateToggleAppearance();

                    // Toggle all measurement labels visibility
                    if (window.strokeLabelVisibility && window.currentImageLabel) {
                        const imageLabels = window.strokeLabelVisibility[window.currentImageLabel];
                        if (imageLabels) {
                            for (const strokeLabel in imageLabels) {
                                window.strokeLabelVisibility[window.currentImageLabel][strokeLabel] = measurementsVisible;
                            }
                        }
                    }

                    // Update all label toggle buttons in the stroke list
                    const labelToggleBtns = document.querySelectorAll('.stroke-label-toggle');
                    labelToggleBtns.forEach(btn => {
                        btn.innerHTML = measurementsVisible ? '' : '  ';
                        btn.title = measurementsVisible ? 'Hide Label' : 'Show Label';
                    });

                    // Redraw canvas to apply changes
                    if (typeof window.redrawCanvasWithVisibility === 'function') {
                        window.redrawCanvasWithVisibility();
                    }
                });

                // Set initial appearance
                updateToggleAppearance();
            }
        });
    </script>
    
    <!-- Scale Dropdown - positioned outside panel hierarchy -->
    <div id="scaleDropdown" class="fixed bg-white border border-gray-300 rounded shadow-lg hidden max-h-64 overflow-y-auto" style="z-index: 9999; min-width: 80px;">
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.1">10%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.15">15%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.2">20%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.25">25%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.33">33%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.5">50%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.67">67%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.75">75%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.8">80%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.9">90%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm bg-blue-50" data-scale="1" data-default="true">100%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.1">110%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.25">125%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.5">150%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.75">175%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="2">200%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="2.5">250%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="3">300%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="4">400%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="5">500%</div>
    </div>

    <script>console.log('[INDEX] before paint.js'); window.onerror=(m,s,l,c,e)=>console.error('[INDEX] onerror',m,s,l,c,e);</script>
    <script>(function(){try{window.NEXT_PUBLIC_REMBG_SAFESHIM='1';}catch(_){}})();</script>
    <!-- New coordinate system scripts -->
    <script src="js/transform.js?v=20250820123456"></script>
    <script src="js/geometry.js?v=20250820123456"></script>
    <script src="js/migration.js?v=20250820123456"></script>

    <!-- Load AI Export Module before paint.js -->
    <script type="module">
        try {
            console.log('[AI Export] Starting to load AI export module...');
            const module = await import('./js/ai-export.js');
            console.log('[AI Export] Module loaded, exports:', Object.keys(module));
            
            const { exportAIEnhancedSVG, assistMeasurement, enhanceAnnotations } = module;
            
            // Make functions available globally
            window.exportAIEnhancedSVG = exportAIEnhancedSVG;
            window.assistMeasurement = assistMeasurement;
            window.enhanceAnnotations = enhanceAnnotations;
            
            // Initialize AI exports storage
            if (!window.aiExports) {
                window.aiExports = {};
            }
            
            console.log('[AI Export] Functions loaded and available globally');
            console.log('[AI Export] window.exportAIEnhancedSVG:', typeof window.exportAIEnhancedSVG);
        } catch (error) {
            console.error('[AI Export] Failed to load AI export module:', error);
            console.error('[AI Export] Error stack:', error.stack);
            // Create stub functions to prevent errors
            window.exportAIEnhancedSVG = () => Promise.reject(new Error('AI Export module failed to load: ' + error.message));
            window.assistMeasurement = () => Promise.reject(new Error('AI Export module failed to load: ' + error.message));
            window.enhanceAnnotations = () => Promise.reject(new Error('AI Export module failed to load: ' + error.message));
        }
    </script>

    <!-- Fabric.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    
    <!-- New Modules -->
    <script type="module" src="js/modules/main.js"></script>

    <!-- Legacy Scripts (Commented out for refactor) -->
    <!-- <script src="js/paint.js?v=20250912134000"></script> -->
    <!-- <script src="js/project-manager.js?v=20250912113000"></script> -->
    <!-- <script src="js/tag-manager.js?v=20250912113000"></script> -->

    <!-- Minimal Numeric Pill Strip Implementation -->
    <script>
        function updateImageListPadding() {
            const imageList = document.getElementById('imageList');
            if (!imageList) return;

            const sampleContainer = imageList.querySelector('.image-container');
            if (!sampleContainer) {
                // Fall back to default padding if no samples
                imageList.style.paddingTop = 'calc(30vh - 5rem)';
                imageList.style.paddingBottom = 'calc(30vh - 5rem)';
                return;
            }

            const listHeight = imageList.getBoundingClientRect().height;
            const itemHeight = sampleContainer.getBoundingClientRect().height;

            if (!listHeight || !itemHeight) return;

            const padding = Math.max(0, (listHeight / 2) - (itemHeight / 2));

            imageList.style.paddingTop = `${padding}px`;
            imageList.style.paddingBottom = `${padding}px`;
        }
        window.updateImageListPadding = updateImageListPadding;

        let __imageListPaddingResizeTimeout = null;
        window.addEventListener('resize', () => {
            if (__imageListPaddingResizeTimeout) {
                clearTimeout(__imageListPaddingResizeTimeout);
            }
            __imageListPaddingResizeTimeout = setTimeout(() => {
                __imageListPaddingResizeTimeout = null;
                updateImageListPadding();
            }, 150);
        });

        const SCROLL_SELECT_STORAGE_KEY = 'scrollSelectEnabled';
        const SCROLL_SWITCH_DEBOUNCE_MS = 70;

        function loadScrollSelectState() {
            try {
                const stored = localStorage.getItem(SCROLL_SELECT_STORAGE_KEY);
                if (stored === null) return true;
                return stored === 'true';
            } catch (error) {
                return true;
            }
        }

        function persistScrollSelectState(enabled) {
            try {
                localStorage.setItem(SCROLL_SELECT_STORAGE_KEY, String(enabled));
            } catch (error) {
                // Ignore storage errors (e.g., private mode)
            }
        }

        function setScrollSelectEnabled(enabled, source = 'auto') {
            window.scrollToSelectEnabled = enabled;
            persistScrollSelectState(enabled);
            console.debug(`[ScrollSelect] Mode set to ${enabled ? 'AUTO' : 'MANUAL'} (source: ${source})`);
            if (document?.body) {
                document.body.setAttribute('data-scroll-select', enabled ? 'auto' : 'manual');
            }
            const modeLabel = document.getElementById('scrollSelectModeLabel');
            if (modeLabel) {
                modeLabel.textContent = enabled ? 'Auto' : 'Manual';
                modeLabel.classList.toggle('text-blue-600', enabled);
                modeLabel.classList.toggle('text-slate-500', !enabled);
            }
            const toggle = document.getElementById('scrollSelectToggle');
            if (toggle) {
                toggle.checked = enabled;
            }
        }

        function isScrollSelectEnabled() {
            return window.scrollToSelectEnabled !== false;
        }

        const MIN_CENTER_TOLERANCE = 8;
        const MAX_CENTER_TOLERANCE = 48;

        function getListCenterMetrics(listRect) {
            if (!listRect) {
                return { center: 0, tolerance: MIN_CENTER_TOLERANCE };
            }
            const center = listRect.top + listRect.height / 2;
            const tolerance = Math.max(
                MIN_CENTER_TOLERANCE,
                Math.min(MAX_CENTER_TOLERANCE, listRect.height * 0.04)
            );
            return { center, tolerance };
        }

        function getAlignedImageContainer(imageList) {
            if (!imageList) return null;
            const listRect = imageList.getBoundingClientRect();
            if (!listRect || !listRect.height) return null;
            const { center, tolerance } = getListCenterMetrics(listRect);
            let closest = null;
            let closestDistance = Infinity;
            imageList.querySelectorAll('.image-container').forEach(container => {
                const rect = container.getBoundingClientRect();
                if (!rect || rect.height === 0) return;
                const containerCenter = rect.top + rect.height / 2;
                const distance = Math.abs(containerCenter - center);
                const isVisible = rect.bottom > listRect.top && rect.top < listRect.bottom;
                if (isVisible && distance < closestDistance) {
                    closestDistance = distance;
                    closest = container;
                }
            });
            if (closest && closestDistance <= tolerance) {
                console.debug(`[ScrollSelect] Candidate ${closest.dataset.label} within tolerance (${closestDistance.toFixed(1)} <= ${tolerance.toFixed(1)})`);
                return {
                    container: closest,
                    distance: closestDistance,
                    tolerance,
                    center
                };
            }
            if (closest) {
                console.debug(`[ScrollSelect] No centered thumbnail (best ${closest.dataset.label} at ${closestDistance.toFixed(1)}px, tolerance ${tolerance.toFixed(1)}px)`);
            } else {
                console.debug('[ScrollSelect] No thumbnail candidates found while scanning list');
            }
            return null;
        }

        function syncSelectionToCenteredThumbnail() {
            if (!isScrollSelectEnabled()) return;
            const imageList = document.getElementById('imageList');
            if (!imageList) return;
            const alignedInfo = getAlignedImageContainer(imageList);
            if (!alignedInfo) return;
            const { container: aligned, distance, tolerance } = alignedInfo;
            const label = aligned.dataset.label;
            console.debug(`[ScrollSelect] Centered thumbnail ${label} (distance ${distance.toFixed(1)}px / tolerance ${tolerance.toFixed(1)}px)`);
            if (label && window.projectManager && typeof window.projectManager.switchView === 'function' && window.projectManager.currentViewId !== label) {
                console.debug(`[ScrollSelect] syncSelectionToCenteredThumbnail switching to ${label}`);
                window.projectManager.switchView(label);
                setTimeout(() => {
                    if (typeof window.updateActivePill === 'function') {
                        window.updateActivePill();
                    }
                }, 30);
            }
        }
        window.syncSelectionToCenteredThumbnail = syncSelectionToCenteredThumbnail;

        function initScrollSelectToggle() {
            const initial = loadScrollSelectState();
            setScrollSelectEnabled(initial, 'init');
            const toggle = document.getElementById('scrollSelectToggle');
            if (toggle) {
                toggle.addEventListener('change', () => {
                    setScrollSelectEnabled(toggle.checked, 'toggle');
                    if (toggle.checked) {
                        updateImageListPadding();
                        syncSelectionToCenteredThumbnail();
                    }
                });
            }
        }

        initScrollSelectToggle();

        if (typeof window.__miniStepperProgrammaticScrollUntil !== 'number') {
            window.__miniStepperProgrammaticScrollUntil = 0;
        }

        (function initMiniStepper() {
            // Configuration
            const cfg = {
                activeClasses: "bg-slate-900 text-white scale-105 shadow-md",
                inactiveClasses: "bg-white text-slate-600 border border-slate-300",
                pillSize: "w-8 h-8",
                threshold: 0.3
            };

            window.updateActiveImageInSidebar = function() {
                const imageList = document.getElementById('imageList');
                if (!imageList) return;

                const currentViewId = window.projectManager?.currentViewId;
                if (!currentViewId) return;

                const containers = imageList.querySelectorAll('.image-container');
                containers.forEach(container => {
                    const isActive = container.dataset.label === currentViewId;
                    
                    // Toggle active class
                    container.classList.toggle('active', isActive);
                    container.setAttribute('aria-selected', isActive);
                    
                    // Visual styling for active state
                    if (isActive) {
                        container.classList.add('bg-slate-50', 'ring-1', 'ring-slate-200');
                    } else {
                        container.classList.remove('bg-slate-50', 'ring-1', 'ring-slate-200');
                    }
                });
            };

            function updateActivePill() {
                // Update sidebar active state as well
                if (typeof window.updateActiveImageInSidebar === 'function') {
                    window.updateActiveImageInSidebar();
                }

                // Get current label from ProjectManager if available, otherwise fallback to legacy
                const currentLabel = window.projectManager?.currentViewId || window.currentImageLabel || window.paintApp?.state?.currentImageLabel;
                if (!currentLabel) return;
                
                const stepper = document.getElementById('mini-stepper');
                const stepButtons = Array.from(stepper?.querySelectorAll('button[data-target]') || []);
                let activeButton = null;
                
                stepButtons.forEach(btn => {
                    const isActive = btn.dataset.target === currentLabel;
                    if (isActive) {
                        btn.classList.remove(...cfg.inactiveClasses.split(' '));
                        btn.classList.add(...cfg.activeClasses.split(' '));
                        btn.setAttribute('aria-current', 'true');
                        activeButton = btn;
                    } else {
                        btn.classList.remove(...cfg.activeClasses.split(' '));
                        btn.classList.add(...cfg.inactiveClasses.split(' '));
                        btn.removeAttribute('aria-current');
                    }
                });
                
                // Auto-scroll the active pill to center
                if (activeButton && stepper) {
                        const stepperRect = stepper.getBoundingClientRect();
                        const btnRect = activeButton.getBoundingClientRect();
                        const delta = (btnRect.left - stepperRect.left) + (btnRect.width / 2) - (stepperRect.width / 2);
                        if (Math.abs(delta) > 1) {
                            window.__miniStepperProgrammaticScrollUntil = Date.now() + 400;
                        stepper.scrollBy({ left: delta, behavior: 'smooth' });
                    }
                }
                }

            window.updateActivePill = updateActivePill;

            // Track which image container is centered in the sidebar and switch to that image
            // Initialize observer only once - guard against multiple initializations
            function initImageListCenteringObserver() {
                // If observer already exists, don't reinitialize
                if (window.__imageListCenteringObserver) {
                    console.log('[ImageList] Observer already initialized, skipping');
                    return;
                }
                
                const imageList = document.getElementById('imageList');
                if (!imageList) {
                    console.warn('[ImageList] imageList element not found, cannot initialize observer');
                    return;
                }
                
                console.log('[ImageList] Initializing centering observer');

                if (typeof updateImageListPadding === 'function') {
                    updateImageListPadding();
                }
                
                // Debounce to avoid rapid switching
                let switchTimeout = null;
                const debouncedSwitch = (label, reason = 'unknown') => {
                    if (!isScrollSelectEnabled()) return;
                    if (switchTimeout) clearTimeout(switchTimeout);
                    switchTimeout = setTimeout(() => {
                        if (!isScrollSelectEnabled()) return;
                        // Skip if this is a programmatic scroll
                        if (window.__imageListProgrammaticScrollUntil && Date.now() < window.__imageListProgrammaticScrollUntil) {
                            return;
                        }
                        
                        if (label && window.projectManager && window.projectManager.currentViewId !== label) {
                            console.log(`[ScrollSelect] ${reason} requesting switch to ${label}`);
                            const switchResult = window.projectManager.switchView(label);
                            Promise.resolve(switchResult).then(() => {
                                if (typeof window.updateActivePill === 'function') {
                                    setTimeout(() => window.updateActivePill(), 30);
                                }
                            });
                        }
                    }, SCROLL_SWITCH_DEBOUNCE_MS);
                };
                
                // Function to find which container is closest to center
                const findCenteredContainer = () => {
                    const info = getAlignedImageContainer(imageList);
                    return info ? info.container : null;
                };
                
                // Use IntersectionObserver with a center-focused rootMargin
                const imageObserver = new IntersectionObserver((entries) => {
                    // Skip if this is a programmatic scroll
                    if (window.__imageListProgrammaticScrollUntil && Date.now() < window.__imageListProgrammaticScrollUntil) {
                        return;
                    }
                    
                    const alignedInfo = getAlignedImageContainer(imageList);
                    if (!alignedInfo) return;
                    const { container: alignedContainer, distance, tolerance } = alignedInfo;
                    
                    const matchesObserver = entries.some(entry => entry.target === alignedContainer && entry.intersectionRatio > 0.1);
                    if (matchesObserver) {
                        const label = alignedContainer.dataset.label;
                        if (label) {
                            console.log(`[ImageList] IntersectionObserver confirmed centered image: ${label} (distance ${distance.toFixed(1)} / tol ${tolerance.toFixed(1)})`);
                            debouncedSwitch(label, 'observer');
                        }
                    } else {
                        const label = alignedContainer.dataset.label;
                        if (label) {
                            console.log(`[ImageList] Fallback detected centered image: ${label} (distance ${distance.toFixed(1)} / tol ${tolerance.toFixed(1)})`);
                            debouncedSwitch(label, 'observer-fallback');
                        }
                    }
                }, {
                    root: imageList,
                    rootMargin: '-40% 0px -40% 0px', // Create a center zone (20% top/bottom margin = 60% center zone)
                    threshold: [0.1, 0.3, 0.5, 0.7, 1.0]
                });
                
                // Also listen to scroll events for manual scrolling and scroll-snap completion
                let scrollTimeout = null;
                let lastScrollTop = imageList.scrollTop;
                let scrollEndTimeout = null;
                
                const handleScrollEnd = () => {
                    // Skip if this is a programmatic scroll
                    if (window.__imageListProgrammaticScrollUntil && Date.now() < window.__imageListProgrammaticScrollUntil) {
                        return;
                    }
                    
                    const closest = findCenteredContainer();
                    if (closest && isScrollSelectEnabled()) {
                        const label = closest.dataset.label;
                        if (label) {
                            console.log(`[ImageList] Scroll ended, centered image: ${label}`);
                            debouncedSwitch(label, 'scroll-end');
                        }
                    }
                    
                    syncSelectionToCenteredThumbnail();
                };
                
                // Track scroll state for better snap detection
                let isScrolling = false;
                let scrollCheckInterval = null;
                
                imageList.addEventListener('scroll', () => {
                    // Skip if this is a programmatic scroll
                    if (window.__imageListProgrammaticScrollUntil && Date.now() < window.__imageListProgrammaticScrollUntil) {
                        return;
                    }
                    
                    // Mark as scrolling
                    if (!isScrolling) {
                        isScrolling = true;
                    }
                    
                    // Clear any pending timeouts
                    if (scrollTimeout) clearTimeout(scrollTimeout);
                    if (scrollEndTimeout) clearTimeout(scrollEndTimeout);
                    
                    // Detect when scrolling has stopped (for scroll-snap completion)
                    const currentScrollTop = imageList.scrollTop;
                    const scrollChanged = currentScrollTop !== lastScrollTop;
                    lastScrollTop = currentScrollTop;
                    
                    if (scrollChanged) {
                        // While scrolling, continuously check for snap completion
                        scrollTimeout = setTimeout(() => {
                            // Check if scroll position has stabilized (snap completed)
                            const newScrollTop = imageList.scrollTop;
                            if (newScrollTop === lastScrollTop) {
                                isScrolling = false;
                                // Scroll has stopped, check for centered container after snap
                                setTimeout(() => {
                                    handleScrollEnd();
                                }, 100); // Allow time for scroll-snap to complete
                            } else {
                                // Still scrolling, check again
                                lastScrollTop = newScrollTop;
                                scrollTimeout = setTimeout(() => {
                                    handleScrollEnd();
                                }, 50);
                            }
                        }, 100);
                    }
                }, { passive: true });
                
                // Listen for scrollend event (if browser supports it) for immediate detection
                if ('onscrollend' in window) {
                    imageList.addEventListener('scrollend', () => {
                        // Skip if this is a programmatic scroll
                        if (window.__imageListProgrammaticScrollUntil && Date.now() < window.__imageListProgrammaticScrollUntil) {
                            return;
                        }
                        
                        // Clear any pending timeouts
                        if (scrollTimeout) clearTimeout(scrollTimeout);
                        if (scrollEndTimeout) clearTimeout(scrollEndTimeout);
                        
                        // Immediately check which image is centered after scroll-snap
                        setTimeout(() => {
                            handleScrollEnd();
                        }, 50); // Small delay to ensure DOM has updated
                    }, { passive: true });
                }
                
                // Observe all existing containers
                const observeContainers = () => {
                    const containers = imageList.querySelectorAll('.image-container');
                    containers.forEach(container => {
                        imageObserver.observe(container);
                    });
                };
                
                // Observe existing containers
                observeContainers();
                
                // Watch for new containers being added and observe them automatically
                const containerObserver = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === 1) { // Element node
                                // Check if it's an image container or contains one
                                const container = node.classList?.contains('image-container') 
                                    ? node 
                                    : node.querySelector?.('.image-container');
                                
                                if (container && container.classList?.contains('image-container')) {
                                    console.log(`[ImageList] New container detected, observing: ${container.dataset.label || 'unknown'}`);
                                    imageObserver.observe(container);

                                if (typeof updateImageListPadding === 'function') {
                                    updateImageListPadding();
                                }
                                }
                            }
                        });
                    });
                });
                
                containerObserver.observe(imageList, {
                    childList: true,
                    subtree: true
                });
                
                // Store observers for cleanup if needed
                window.__imageListCenteringObserver = imageObserver;
                window.__imageListContainerObserver = containerObserver;
                
                console.log('[ImageList] Observer initialized successfully');
            }

            function ensureImageListObserver() {
                if (window.__imageListCenteringObserver) {
                    return;
                }
                const imageList = document.getElementById('imageList');
                if (!imageList) return;
                const hasThumb = !!imageList.querySelector('.image-container');
                if (hasThumb) {
                    console.log('[ImageList] Auto-starting centering observer (content detected)');
                    initImageListCenteringObserver();
                    return;
                }
                if (!window.__imageListObserverBootstrap) {
                    window.__imageListObserverBootstrap = new MutationObserver(() => {
                        if (imageList.querySelector('.image-container')) {
                            console.log('[ImageList] Detected first thumbnail, starting centering observer');
                            if (window.__imageListObserverBootstrap) {
                                window.__imageListObserverBootstrap.disconnect();
                                window.__imageListObserverBootstrap = null;
                            }
                            initImageListCenteringObserver();
                        }
                    });
                    window.__imageListObserverBootstrap.observe(imageList, { childList: true });
                    console.log('[ImageList] Waiting for thumbnails to bootstrap centering observer');
                }
            }
            window.ensureImageListObserver = ensureImageListObserver;
            if (window.__pendingImageListObserverInit) {
                delete window.__pendingImageListObserverInit;
                ensureImageListObserver();
            }
            
            // Track which pill is centered and switch to that image
            function initPillCenteringObserver(stepButtons) {
                if (stepButtons.length === 0) return;
                
                const stepper = document.getElementById('mini-stepper');
                if (!stepper) return;
                
                // Debounce to avoid rapid switching
                let switchTimeout = null;
                const debouncedSwitch = (label, reason = 'mini-stepper') => {
                    if (!isScrollSelectEnabled()) return;
                    if (window.__miniStepperProgrammaticScrollUntil && Date.now() < window.__miniStepperProgrammaticScrollUntil) {
                        return;
                    }
                    if (switchTimeout) clearTimeout(switchTimeout);
                    switchTimeout = setTimeout(() => {
                        if (!isScrollSelectEnabled()) return;
                        if (window.__miniStepperProgrammaticScrollUntil && Date.now() < window.__miniStepperProgrammaticScrollUntil) {
                            return;
                        }
                        if (label && window.projectManager && window.projectManager.currentViewId !== label) {
                            console.log(`[ScrollSelect] ${reason} requesting switch to ${label}`);
                            window.projectManager.switchView(label);
                        }
                    }, 150); // Small delay to avoid rapid switching
                };
                
                // Function to find which pill is closest to center
                const findCenteredPill = () => {
                    const stepperRect = stepper.getBoundingClientRect();
                    const stepperCenter = stepperRect.left + stepperRect.width / 2;
                    
                    let closestPill = null;
                    let closestDistance = Infinity;
                    const tolerance = Math.max(8, Math.min(40, stepperRect.width * 0.05));
                    
                    stepButtons.forEach(btn => {
                        const btnRect = btn.getBoundingClientRect();
                        const btnCenter = btnRect.left + btnRect.width / 2;
                        const distance = Math.abs(btnCenter - stepperCenter);
                        
                        // Only consider pills that are at least partially visible
                        if (btnRect.right > stepperRect.left && btnRect.left < stepperRect.right) {
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestPill = btn;
                            }
                        }
                    });
                    
                    if (closestPill && closestDistance <= tolerance) {
                        return closestPill;
                    }
                    return null;
                };
                
                // Use IntersectionObserver with a center-focused rootMargin
                // This creates a "center zone" that pills must intersect
                const pillObserver = new IntersectionObserver((entries) => {
                    // Find pills that intersect the center zone
                    const centeredPills = entries.filter(entry => entry.intersectionRatio > 0.3);
                    
                    if (centeredPills.length > 0) {
                        // Find the one closest to center
                        const centeredPill = centeredPills.reduce((best, current) => {
                            const stepperRect = stepper.getBoundingClientRect();
                            const stepperCenter = stepperRect.left + stepperRect.width / 2;
                            const bestCenter = Math.abs(best.boundingClientRect.left + best.boundingClientRect.width / 2 - stepperCenter);
                            const currentCenter = Math.abs(current.boundingClientRect.left + current.boundingClientRect.width / 2 - stepperCenter);
                            return currentCenter < bestCenter ? current : best;
                        });
                        
                        const label = centeredPill.target.dataset.target;
                        if (label) {
                            debouncedSwitch(label, 'mini-stepper-observer');
                        }
                    } else {
                        // Fallback: find closest pill if none intersect center zone
                        const closest = findCenteredPill();
                        if (closest) {
                            const label = closest.dataset.target;
                            if (label) {
                                debouncedSwitch(label, 'mini-stepper-fallback');
                            }
                        }
                    }
                }, {
                    root: stepper,
                    rootMargin: '-40% 0px -40% 0px', // Create a center zone (20% top/bottom margin = 60% center zone)
                    threshold: [0.1, 0.3, 0.5, 0.7, 1.0]
                });
                
                // Also listen to scroll events for manual scrolling
                let scrollTimeout = null;
                stepper.addEventListener('scroll', () => {
                    if (window.__miniStepperProgrammaticScrollUntil && Date.now() < window.__miniStepperProgrammaticScrollUntil) {
                        return;
                    }
                    if (scrollTimeout) clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                        const closest = findCenteredPill();
                        if (closest) {
                            const label = closest.dataset.target;
                            if (label) {
                                debouncedSwitch(label, 'mini-stepper-scroll');
                            }
                        }
                    }, 100);
                }, { passive: true });
                
                // Observe all pills
                stepButtons.forEach(btn => {
                    pillObserver.observe(btn);
                });
                
                // Store observer for cleanup if needed
                window.__pillCenteringObserver = pillObserver;
            }

            function getImageContainers() {
                // Use window.originalImages as the source of truth for which images exist
                // This ensures we can detect images even when the panel is collapsed
                const imageLabelsFromState = window.originalImages ? Object.keys(window.originalImages).filter(label => 
                    !label.includes('Demo') && !label.includes('Blank')
                ) : [];
                
                // If we have state, use it as the primary source and find matching containers
                if (imageLabelsFromState.length > 0) {
                    const imagePanelContent = document.getElementById('imagePanelContent');
                    const imagePanel = document.getElementById('imagePanel');
                    const isPanelCollapsed = (imagePanelContent && imagePanelContent.classList.contains('hidden')) ||
                                           (imagePanel && imagePanel.classList.contains('minimized')) ||
                                           (imagePanel && imagePanel.style.display === 'none');
                    
                    // Map each label to its container, preferring visible ones
                    const labelToContainer = new Map();
                    
                    // First, try to find containers in the expected locations
                    const imageList = document.getElementById('imageList');
                    const imageGallery = document.getElementById('imageGallery');
                    
                    // Collect all potential containers
                    const allContainers = [];
                    if (imageList) {
                        allContainers.push(...Array.from(imageList.querySelectorAll('.image-container, .image-thumbnail')));
                    }
                    if (imageGallery) {
                        allContainers.push(...Array.from(imageGallery.querySelectorAll('.image-container, .image-thumbnail')));
                    }
                    
                    // Also search broadly if needed
                    if (allContainers.length === 0) {
                        allContainers.push(...Array.from(document.querySelectorAll('.image-container, .image-thumbnail')));
                    }
                    
                    // Map labels to containers, preferring visible ones
                    imageLabelsFromState.forEach(label => {
                        // Find all containers with this label
                        const matchingContainers = allContainers.filter(container => {
                            const cLabel = container.dataset?.label || container.getAttribute('title') || container.dataset?.imageIndex || container.id;
                            return cLabel === label;
                        });
                        
                        if (matchingContainers.length > 0) {
                            // Prefer visible containers, but if panel is collapsed, accept any
                            const visible = matchingContainers.find(c => c.offsetWidth > 0 && c.offsetHeight > 0);
                            const container = visible || (isPanelCollapsed ? matchingContainers[0] : null);
                            
                            if (container && !labelToContainer.has(label)) {
                                labelToContainer.set(label, container);
                            }
                        }
                    });
                    
                    // Return containers in the order of imageLabelsFromState, deduplicated
                    // If panel is collapsed and we have state but no containers, return empty array
                    // updatePills() will handle creating virtual containers from state
                    const result = [];
                    const seenContainers = new Set();
                    
                    imageLabelsFromState.forEach(label => {
                        const container = labelToContainer.get(label);
                        if (container && !seenContainers.has(container)) {
                            seenContainers.add(container);
                            result.push(container);
                        }
                    });
                    
                    // If we have state but no containers found (panel closed), return empty array
                    // This will trigger the fallback in updatePills() to use state directly
                    return result;
                }
                
                // Fallback: if no state, use the old method but deduplicate
                const imageList = document.getElementById('imageList');
                const imageGallery = document.getElementById('imageGallery');

                let containers = [];

                if (imageList) {
                    const listContainers = Array.from(imageList.querySelectorAll('.image-container, .image-thumbnail'));
                    containers.push(...listContainers);
                }

                if (imageGallery) {
                    const galleryContainers = Array.from(imageGallery.querySelectorAll('.image-container, .image-thumbnail'));
                    containers.push(...galleryContainers);
                }

                // Filter to valid image containers and deduplicate by label
                const imagePanelContent = document.getElementById('imagePanelContent');
                const isPanelCollapsed = imagePanelContent && imagePanelContent.classList.contains('hidden');
                
                const labelToContainer = new Map();
                const seenContainers = new Set();
                
                containers.forEach(container => {
                    const label = container.dataset?.label || container.getAttribute('title') || container.dataset?.imageIndex || container.id;
                    const isVisible = container.offsetWidth > 0 && container.offsetHeight > 0;
                    const isSidebarContainer = container.classList && container.classList.contains('image-container');

                    // Accept if valid and (visible OR panel collapsed)
                    const isValid = label && !label.includes('Demo') && !label.includes('Blank') &&
                                   (isVisible || isPanelCollapsed) &&
                                   (isSidebarContainer || container.tagName === 'IMG' || container.dataset?.src);
                    
                    if (isValid && !seenContainers.has(container)) {
                        // Prefer visible containers for each label
                        if (!labelToContainer.has(label) || isVisible) {
                            labelToContainer.set(label, container);
                        }
                        seenContainers.add(container);
                    }
                });
                
                // Return deduplicated containers
                return Array.from(labelToContainer.values());
            }

            function positionNavigationContainer() {
                const frameCapture = document.getElementById('frame-capture');
                const navContainer = document.getElementById('navigation-container');

                if (!frameCapture || !navContainer) {
                    return;
                }

                // Position the navigation container directly under frame-capture
                const frameRect = frameCapture.getBoundingClientRect();
                navContainer.style.position = 'fixed';
                navContainer.style.bottom = '0';
                navContainer.style.left = '0';
                navContainer.style.right = '0';
                navContainer.style.width = '100%';
                navContainer.style.zIndex = '5000';

            }

            function updatePills() {
                const stepper = document.getElementById('mini-stepper');

                if (!stepper) {
                    return []; // Return empty array instead of undefined
                }

                let imageLabels = [];

                // Primary source: actual sidebar thumbnail order
                const imageList = document.getElementById('imageList');
                if (imageList) {
                    const seenLabels = new Set();
                    imageLabels = Array.from(imageList.querySelectorAll('.image-container'))
                        .map(container => container.dataset?.label?.trim())
                        .filter(label => {
                            if (!label || label.includes('Demo') || label.includes('Blank')) return false;
                            if (seenLabels.has(label)) return false;
                            seenLabels.add(label);
                            return true;
                        });
                }

                // Fallback to ProjectManager views if sidebar empty (e.g., before DOM sync)
                if (imageLabels.length === 0 && window.projectManager && window.projectManager.views) {
                    imageLabels = Object.keys(window.projectManager.views)
                        .filter(viewId => {
                            const view = window.projectManager.views[viewId];
                            return view && view.image && !viewId.includes('Demo') && !viewId.includes('Blank');
                        })
                        .sort((a, b) => {
                            const preference = ['front', 'side', 'back', 'cushion'];
                            const aIdx = preference.indexOf(a);
                            const bIdx = preference.indexOf(b);
                            if (aIdx !== -1 && bIdx !== -1) return aIdx - bIdx;
                            if (aIdx !== -1) return -1;
                            if (bIdx !== -1) return 1;
                            return a.localeCompare(b);
                        });
                }
                
                // Fallback to gallery data
                if (imageLabels.length === 0 && typeof imageGalleryData !== 'undefined' && imageGalleryData.length > 0) {
                    const seenLabels = new Set();
                    imageLabels = imageGalleryData
                        .filter(item => {
                            const label = item?.original?.label || item?.label;
                            if (!label || label.includes('Demo') || label.includes('Blank')) return false;
                            if (seenLabels.has(label)) return false; // Deduplicate
                            seenLabels.add(label);
                            return true;
                        })
                        .map(item => item?.original?.label || item?.label)
                        .filter(Boolean);
                }
                
                // Final fallback to DOM containers (legacy helper)
                if (imageLabels.length === 0) {
                    const imageContainers = getImageContainers();
                    const seenLabels = new Set();
                    imageLabels = imageContainers
                        .map(container => {
                            const label = container.dataset?.label || container.getAttribute('title') || container.dataset?.imageIndex || container.id;
                            return label;
                        })
                        .filter(label => {
                            if (!label || label.includes('Demo') || label.includes('Blank')) return false;
                            if (seenLabels.has(label)) return false;
                            seenLabels.add(label);
                            return true;
                        });
                }

                if (imageLabels.length === 0) {
                    stepper.innerHTML = '<li class="px-4 py-2 text-slate-500 text-sm">No images yet</li>';
                    // Ensure base classes are applied even when empty
                    stepper.className = 'flex gap-3 px-4 py-3 overflow-x-auto snap-x snap-mandatory justify-center items-center min-h-[60px]';
                    return []; // Return empty array instead of undefined
                }

                // Ensure stepper has base classes
                stepper.className = 'flex gap-3 px-4 py-3 overflow-x-auto snap-x snap-mandatory justify-center items-center min-h-[60px]';

                // Build pills for each unique image label
                const pillsHTML = imageLabels.map((label, idx) => {
                    const n = idx + 1;
                    return `
                        <li class="snap-center">
                            <button
                                type="button"
                                class="step w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium transition-all duration-200 bg-white text-slate-600 border border-slate-300 hover:bg-slate-900 hover:text-white hover:scale-105 hover:shadow-md focus:outline-none focus:ring-2 focus:ring-slate-500"
                                aria-label="Go to ${label}"
                                data-target="${label}"
                                data-index="${idx}">
                                ${n}
                            </button>
                        </li>`;
                }).join('');

                stepper.innerHTML = pillsHTML;

                const stepButtons = Array.from(stepper.querySelectorAll('button[data-target]'));


                // Initialise states - all start as inactive
                stepButtons.forEach(btn => {
                    btn.classList.add(...cfg.inactiveClasses.split(' '));
                });
                
                // Update active state immediately after creating pills
                setTimeout(() => updateActivePill(), 100);

                // Initialize pill centering observer to track which pill is centered
                initPillCenteringObserver(stepButtons);

                // Click to switch to image and center the pill
                stepButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const label = btn.dataset.target;
                        const stepper = document.getElementById('mini-stepper');
                        
                        if (!stepper) return;
                        
                        // First, center the pill in the stepper
                        const stepperRect = stepper.getBoundingClientRect();
                        const btnRect = btn.getBoundingClientRect();
                        const delta = (btnRect.left - stepperRect.left) + (btnRect.width / 2) - (stepperRect.width / 2);
                        stepper.scrollBy({ left: delta, behavior: 'smooth' });
                        
                        // Then switch to the image
                        if (window.switchToImage && typeof window.switchToImage === 'function') {
                            try {
                                window.switchToImage(label);
                                
                                // Also scroll the sidebar to center the corresponding thumbnail
                                const list = document.getElementById('imageList');
                                if (list) {
                                    const container = list.querySelector(`.image-container[data-label="${label}"]`);
                                    if (container) {
                                        const listRect = list.getBoundingClientRect();
                                        const elRect = container.getBoundingClientRect();
                                        const delta = (elRect.top - listRect.top) + (elRect.height / 2) - (listRect.height / 2);
                                        // Suppress scroll-driven switching during this smooth scroll
                                    window.__imageListProgrammaticScrollUntil = Date.now() + 500;
                                        list.scrollBy({ top: delta, behavior: 'smooth' });
                                    }
                                }
                                
                                // Update active state immediately
                                setTimeout(() => updateActivePill(), 50);
                                // Dispatch event
                                window.dispatchEvent(new CustomEvent('mini-step-click', { detail: { label, index: btn.dataset.index } }));
                                console.debug(`[ScrollSelect] mini-step click switched to ${label}`);
                            } catch (error) {
                                console.error('[MiniStepper] Error switching to image:', label, error);
                            }
                        } else {
                            console.error('[MiniStepper] switchToImage function not available');
                        }
                    });

                    // Keyboard activation
                    btn.addEventListener('keydown', e => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            btn.click();
                        }
                    });
                });

                return stepButtons;
            }

            function initIntersectionObserver(stepButtons) {
                if (stepButtons.length === 0) return;

                const io = new IntersectionObserver(entries => {
                    // Find the image container with the highest intersection ratio
                    const imageEntries = entries.filter(entry => {
                        // Convert className to string (it might be a DOMTokenList)
                        const className = (typeof entry.target.className === 'string') ? entry.target.className : (entry.target.className ? entry.target.className.toString() : '');
                        const id = entry.target.id || '';
                        const hasImageData = entry.target.dataset && (entry.target.dataset.label || entry.target.dataset.imageIndex || entry.target.dataset.src);

                        return (
                            className.includes('image') ||
                            id.includes('image') ||
                            hasImageData ||
                            entry.target.tagName === 'IMG' ||
                            (entry.target.style && entry.target.style.backgroundImage && (
                                entry.target.style.backgroundImage.includes('data:image') ||
                                entry.target.style.backgroundImage.includes('blob:') ||
                                entry.target.style.backgroundImage.includes('http')
                            ))
                        );
                    });
                    if (imageEntries.length === 0) return;

                    let best = imageEntries.reduce((a, b) => a.intersectionRatio > b.intersectionRatio ? a : b);
                    const label = best.target.dataset?.label || best.target.getAttribute('title') || best.target.dataset?.imageIndex || best.target.id || `Image ${Array.from(best.target.parentNode?.children || []).indexOf(best.target)}`;

                    if (!label) return;

                    // Update UI
                    stepButtons.forEach(b => {
                        const active = b.dataset.target === label;
                        b.classList.toggle('aria-current', active);

                        if (active) {
                            b.setAttribute('aria-current', 'true');
                            b.classList.remove(...cfg.inactiveClasses.split(' '));
                            b.classList.add(...cfg.activeClasses.split(' '));
                            b.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
                        } else {
                            b.removeAttribute('aria-current');
                            b.classList.remove(...cfg.activeClasses.split(' '));
                            b.classList.add(...cfg.inactiveClasses.split(' '));
                        }
                    });

                    // Dispatch event for external listeners
                    window.dispatchEvent(new CustomEvent('mini-step-change', { detail: { label, index: best.target.dataset?.imageIndex || best.target.dataset?.index } }));
                }, { threshold: [cfg.threshold], rootMargin: '-50% 0px -50% 0px' });

                // Observe all image containers
                getImageContainers().forEach(container => {
                    io.observe(container);
                });
            }

            // Initialize when DOM is ready and wait for paint.js to load
            function initializeWhenReady() {
                if (typeof window.switchToImage === 'function') {
                    initialize();
                } else {
                    setTimeout(initializeWhenReady, 500);
                }
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeWhenReady);
            } else {
                initializeWhenReady();
            }

        ensureImageListObserver();

            function initialize() {
                positionNavigationContainer();

                // Initial update
                const stepButtons = updatePills();
                initIntersectionObserver(stepButtons);
                
                // Update active pill immediately
                updateActivePill();

                // Set up periodic updates to handle dynamically added images (optimized with requestAnimationFrame)
                let ticking = false;
                const checkForChanges = () => {
                    if (ticking) return;
                    ticking = true;
                    requestAnimationFrame(() => {
                        positionNavigationContainer();
                        const currentButtons = Array.from(document.querySelectorAll('#mini-stepper button[data-target]'));
                        const currentContainers = getImageContainers();
                        if (currentButtons.length !== currentContainers.length) {
                            // Clean up old observer if it exists
                            if (window.__pillCenteringObserver) {
                                window.__pillCenteringObserver.disconnect();
                            }
                            const newButtons = updatePills();
                            initIntersectionObserver(newButtons);
                            // Re-initialize pill centering observer
                            initPillCenteringObserver(newButtons);
                        }
                        // Update active pill on each check
                        updateActivePill();
                        ticking = false;
                    });
                };
                setInterval(checkForChanges, 2000); // Check less frequently (every 2 seconds)
            }

            // Reduced motion preference
            if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                // Adjust behaviors for reduced motion
                document.querySelectorAll('#mini-stepper .step').forEach(btn => {
                    btn.style.transition = 'none';
                });
            }

            // Example listeners for external integration
            window.addEventListener('mini-step-change', e => {
                // Event fired when active image changes
            });

            window.addEventListener('mini-step-click', e => {
                // Event fired when image pill is clicked
            });
        })();
    </script>

    <!-- AI Preview Modal -->
    <div id="aiPreviewModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg p-6 max-w-4xl w-full max-h-[90vh] overflow-auto m-4">
            <h2 class="text-xl font-bold mb-4">AI SVG Preview</h2>
            <div id="aiPreviewContainer" class="border border-gray-300 rounded mb-4 relative bg-gray-50 min-h-[400px] flex items-center justify-center">
                <!-- SVG overlay will be inserted here -->
                <p class="text-gray-400">Loading preview...</p>
            </div>
            <div class="flex gap-2 flex-wrap">
                <button id="aiAccept" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors">Accept</button>
                <button id="aiSaveToProject" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors">Save to Project</button>
                <button id="aiDownloadSVG" class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors">Download SVG</button>
                <button id="aiDownloadPNG" class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors">Download PNG</button>
                <button id="aiCancel" class="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 transition-colors">Cancel</button>
            </div>
        </div>
    </div>

    <!-- AI Calibration Dialog -->
    <dialog id="ai-calibration-dialog" class="backdrop:bg-black backdrop:bg-opacity-50 bg-white rounded-2xl shadow-2xl border-0 p-0 max-w-md w-full">
        <div class="p-6">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-bold text-slate-800">AI Calibration</h3>
                <button onclick="document.getElementById('ai-calibration-dialog').close()" class="text-slate-400 hover:text-slate-600 text-xl">&times;</button>
            </div>
            
            <div class="mb-4">
                <p class="text-sm text-slate-600 mb-2">AI detected the overall width as:</p>
                <div class="bg-slate-100 rounded-lg p-3 text-center">
                    <span id="detected-width-pixels" class="text-lg font-semibold text-slate-800">0px</span>
                </div>
            </div>
            
            <form id="calibration-form" onsubmit="handleCalibrationSubmit(event)">
                <div class="mb-4">
                    <label for="real-width" class="block text-sm font-semibold text-slate-700 mb-2">Real width:</label>
                    <input type="number" id="real-width" name="real-width" step="0.1" min="0.1" max="1000" 
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-purple-500" 
                           placeholder="Enter real width" required>
                </div>
                
                <div class="mb-6">
                    <label for="unit" class="block text-sm font-semibold text-slate-700 mb-2">Unit:</label>
                    <select id="unit" name="unit" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-purple-500">
                        <option value="cm">Centimeters (cm)</option>
                        <option value="mm">Millimeters (mm)</option>
                        <option value="in">Inches (in)</option>
                    </select>
                </div>
                
                <div class="flex gap-3">
                    <button type="submit" class="flex-1 px-4 py-2 bg-purple-500 hover:bg-purple-600 text-white font-semibold rounded-lg transition-colors">
                        Generate
                    </button>
                    <button type="button" onclick="document.getElementById('ai-calibration-dialog').close()" 
                            class="flex-1 px-4 py-2 bg-gray-300 hover:bg-gray-400 text-gray-700 font-semibold rounded-lg transition-colors">
                        Cancel
                    </button>
                </div>
            </form>
        </div>
    </dialog>

    <!-- AI Preview Modal -->
    <dialog id="ai-preview-modal" class="backdrop:bg-black backdrop:bg-opacity-50 bg-white rounded-2xl shadow-2xl border-0 p-0 max-w-2xl w-full">
        <div class="p-6">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-bold text-slate-800">AI Dimension Preview</h3>
                <button onclick="document.getElementById('ai-preview-modal').close()" class="text-slate-400 hover:text-slate-600 text-xl">&times;</button>
            </div>
            
            <div class="mb-4">
                <div id="ai-status-text" class="text-sm text-slate-600 mb-3">Calibrated: 1 cm = 0 px</div>
                <div id="ai-dimension-summary" class="bg-slate-50 rounded-lg p-4 space-y-2">
                    <!-- Dimension summary will be populated here -->
                </div>
            </div>
            
            <div class="flex gap-3">
                <button onclick="handlePreviewAction('accept')" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg transition-colors">
                    Accept
                </button>
                <button onclick="handlePreviewAction('save')" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-lg transition-colors">
                    Save to Project
                </button>
                <button onclick="handlePreviewAction('download-svg')" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white font-semibold rounded-lg transition-colors">
                    Download SVG
                </button>
                <button onclick="handlePreviewAction('cancel')" class="px-4 py-2 bg-gray-300 hover:bg-gray-400 text-gray-700 font-semibold rounded-lg transition-colors">
                    Cancel
                </button>
            </div>
        </div>
    </dialog>

    <!-- Load AI Integration Module -->
    <script src="js/ai-integration.js"></script>
    
    <script>
        // Enhanced status message with loading support
        window.showStatusMessage = function(message, type = 'info') {
            // Get or create status element
            let statusElement = document.getElementById('statusMessage');
            if (!statusElement) {
                statusElement = document.createElement('div');
                statusElement.id = 'statusMessage';
                statusElement.style.cssText = `
                    position: fixed;
                    bottom: 80px; /* Moved up to avoid bottom navigation */
                    left: 50%;
                    transform: translateX(-50%);
                    padding: 12px 24px;
                    border-radius: 50px;
                    color: white;
                    font-weight: 500;
                    font-size: 14px;
                    z-index: 9999;
                    opacity: 0;
                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    max-width: 80%;
                    text-align: center;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    backdrop-filter: blur(8px);
                `;
                document.body.appendChild(statusElement);
            }
            
            // Reset any previous styles
            statusElement.className = '';
            statusElement.innerHTML = ''; // Clear content
            
            // Set content based on type
            if (type === 'loading') {
                // Spinner SVG
                const spinner = document.createElement('div');
                spinner.innerHTML = `<svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>`;
                statusElement.appendChild(spinner.firstChild);
                
                const text = document.createElement('span');
                text.textContent = message;
                statusElement.appendChild(text);
                
                statusElement.style.backgroundColor = 'rgba(59, 130, 246, 0.9)'; // Blue for loading
            } else {
                statusElement.textContent = message;
                
                // Set color based on message type
                switch (type) {
                    case 'success':
                        statusElement.style.backgroundColor = 'rgba(34, 197, 94, 0.95)'; // Green
                        break;
                    case 'error':
                        statusElement.style.backgroundColor = 'rgba(239, 68, 68, 0.95)'; // Red
                        break;
                    case 'info':
                    default:
                        statusElement.style.backgroundColor = 'rgba(31, 41, 55, 0.95)'; // Dark Gray
                        break;
                }
            }
            
            // Show
            requestAnimationFrame(() => {
                statusElement.style.opacity = '1';
                statusElement.style.transform = 'translateX(-50%) translateY(0)';
            });
            
            // Clear existing timer
            if (statusElement.timer) {
                clearTimeout(statusElement.timer);
                statusElement.timer = null;
            }
            
            // Hide after timeout (longer for loading, or manual clear)
            if (type !== 'loading') {
                statusElement.timer = setTimeout(() => {
                    statusElement.style.opacity = '0';
                    statusElement.style.transform = 'translateX(-50%) translateY(10px)';
                }, 4000);
            }
        };
        
        // Helper to hide status message manually (useful for finishing loading states)
        window.hideStatusMessage = function() {
            const statusElement = document.getElementById('statusMessage');
            if (statusElement) {
                statusElement.style.opacity = '0';
                statusElement.style.transform = 'translateX(-50%) translateY(10px)';
            }
        };
    </script>

</body>
</html>
