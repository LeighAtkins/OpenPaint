<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenPaint</title>
    <script>
        // Toolbar initialization - MUST run first to set data-toolbar-mode before CSS renders
        (function() {
            document.documentElement.classList.add('app-loading');
            const windowWidth = window.innerWidth || 1920;
            const isMobile = windowWidth <= 768;
            const toolbarMode = isMobile ? 'compact' : 'full';
            document.documentElement.setAttribute('data-toolbar-mode', toolbarMode);
            document.documentElement.setAttribute('data-toolbar-initial', toolbarMode);
        })();
    </script>
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/tailwind.build.css" />
    <script>
        // Suppress autofill extension errors
        window.addEventListener('error', (event) => {
            if (event.message && event.message.includes('autofill.bundle.js')) {
                event.preventDefault();
                return false;
            }
        });
    </script>
    
    <!-- Loading optimization and debug gate -->
    
    
    <script>
        // STEP 3: JS fallback - Re-check sizing after fonts load and on resize
        // This updates the global data-toolbar-mode attribute (no DOM rewrites)
        (function() {
            let resizeTimer = null;
            let isCalculating = false;
            
            const calculateToolbarMode = () => {
                // Prevent concurrent calculations
                if (isCalculating) return;
                isCalculating = true;
                
                const toolbarWrap = document.getElementById('toolbarWrap') || document.querySelector('.toolbar-wrap');
                if (!toolbarWrap) {
                    isCalculating = false;
                    return;
                }
                
                const windowWidth = window.innerWidth;
                const isMobile = windowWidth <= 768;
                
                // Desktop: always use full mode
                if (!isMobile) {
                    document.documentElement.setAttribute('data-toolbar-mode', 'full');
                    isCalculating = false;
                    return;
                }
                
                // Mobile: Measure if compact is needed
                // Temporarily set to full mode for measurement
                document.documentElement.setAttribute('data-toolbar-mode', 'full');
                
                // Force layout calculation
                void toolbarWrap.offsetWidth;
                
                // Measure if content overflows
                const toolbarWidth = toolbarWrap.clientWidth;
                const toolbarScrollWidth = toolbarWrap.scrollWidth;
                const needsCompact = toolbarScrollWidth > toolbarWidth;
                
                // Set the correct mode based on measurement
                document.documentElement.setAttribute('data-toolbar-mode', needsCompact ? 'compact' : 'full');
                
                isCalculating = false;
            };
            
            // Calculate immediately when toolbar exists
            const initCalculation = () => {
                const toolbarWrap = document.getElementById('toolbarWrap') || document.querySelector('.toolbar-wrap');
                if (toolbarWrap) {
                    calculateToolbarMode();
                } else if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initCalculation);
                } else {
                    setTimeout(initCalculation, 0);
                }
            };
            
            // Start calculation
            initCalculation();
            
            // Recalculate after fonts load (for accurate text measurement)
            if (document.fonts && document.fonts.ready) {
                document.fonts.ready.then(() => {
                    setTimeout(calculateToolbarMode, 50);
                });
            }
            
            // Recalculate on window resize (throttled)
            window.addEventListener('resize', () => {
                if (resizeTimer) clearTimeout(resizeTimer);
                resizeTimer = setTimeout(calculateToolbarMode, 150);
            });
        })();
    </script>
</head>
<body class="bg-gray-50 h-screen overflow-hidden" data-heic-worker-url="https://openpaint-heic-converter.sofapaint-api.workers.dev">
    <!-- Top Toolbar -->
    <div id="topToolbar">
        <div class="toolbar-wrap smart-label-scope" id="toolbarWrap">
            <div id="tbLeft" class="group-gap smart-label-scope">
                <!-- Pre-populated toolbar content to prevent flash -->
                <button id="paste" class="tbtn" title="Upload Images" aria-label="Upload Images">
                    <span class="label-long">Upload Images</span><span class="label-short">Upload</span>
                </button>
                <button id="clear" class="tbtn">Clear</button>
                <button id="drawingModeToggle" class="tbtn straight-mode" title="Straight Line" aria-label="Straight Line">
                    <span class="label-long">Straight Line</span><span class="label-short">Straight</span>
                </button>
                <button id="textModeToggle" class="tbtn" title="Text Tool" aria-label="Text Tool">
                    <span class="label-long">Text</span><span class="label-short">Text</span>
                </button>
                <div class="color-swatches">
                    <button class="active tbtn" data-color="#3b82f6" style="background-color: #3b82f6; box-shadow: 0 0 10px rgba(59, 130, 246, 0.6);" title="Bright Blue"></button>
                    <button data-color="#22c55e" style="background-color: #22c55e; box-shadow: 0 0 10px rgba(34, 197, 94, 0.6);" title="Bright Green" class="tbtn"></button>
                    <button data-color="#ef4444" style="background-color: #ef4444; box-shadow: 0 0 10px rgba(239, 68, 68, 0.6);" title="Bright Red" class="tbtn"></button>
                    <button data-color="#f59e0b" style="background-color: #f59e0b; box-shadow: 0 0 10px rgba(245, 158, 11, 0.6);" title="Bright Yellow" class="tbtn"></button>
                    <button data-color="#a855f7" style="background-color: #a855f7; box-shadow: 0 0 10px rgba(168, 85, 247, 0.6);" title="Bright Purple" class="tbtn"></button>
                    <button data-color="#1f2937" style="background-color: #1f2937;" title="Dark Gray" class="tbtn"></button>
                    <button data-color="#ffffff" style="background-color: rgb(255, 255, 255); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); border: 1px solid #ccc;" title="White" class="tbtn"></button>
                    <button data-color="#10b981" style="background-color: #10b981; box-shadow: 0 0 10px rgba(16, 185, 129, 0.6);" title="Bright Emerald" class="tbtn"></button>
                </div>
                <input
                    type="range"
                    id="brushSize"
                    class="h-2 rounded-lg appearance-none cursor-pointer slider"
                    min="1"
                    max="50"
                    value="5"
                    style="width: 120px; margin: 0;"
                />
                <button id="arrowStartBtn" class="tbtn icon-btn" title="Start Arrow">‚óÄ</button>
                <button id="arrowEndBtn" class="tbtn icon-btn" title="End Arrow">‚ñ∂</button>
                <button id="dottedBtn" class="tbtn" title="Line Style"><svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round"></line></svg></button>
                <button id="undoBtn" class="tbtn icon-btn" title="Undo">‚Ü∫</button>
                <button id="redoBtn" class="tbtn icon-btn" title="Redo">‚Üª</button>
            </div>
            <div id="tbCenter" class="group-gap"></div>
            <div id="tbRight" class="group-gap smart-label-scope">
                <input type="text" id="projectName" placeholder="Project Name" value="New Sofa" class="tinput" data-sharkid="__1">
                <button id="loadProject" title="Load Project" class="tbtn" aria-label="Load Project">
                    <span class="label-long">Load Project</span><span class="label-short">Load</span>
                </button>
                <button id="removeBgClientTop" class="tbtn" title="Remove background using server">Remove BG</button>
                <button id="exportAISVG" class="tbtn" title="AI SVG Export" aria-label="AI SVG Export" style="background: #8b5cf6; border-color: #7c3aed;">
                    <span class="label-long">AI SVG Export</span><span class="label-short">AI SVG</span>
                </button>
                <button id="saveProjectTop" class="tbtn" title="Save Project" aria-label="Save Project">
                    <span class="label-long">Save Project</span><span class="label-short">Save</span>
                </button>
                <button id="unitToggleBtn" class="tbtn" title="Toggle units">inches</button>
                    </div>
                </div>
    </div>
    
    <script>
        // Mark toolbar as ready - size should already be calculated by previous script
        (function() {
            const markToolbarReady = () => {
                try {
                    const topToolbar = document.getElementById('topToolbar');
                    const toolbarWrap = document.getElementById('toolbarWrap') || document.querySelector('.toolbar-wrap');
                    
                    if (topToolbar && toolbarWrap) {
                        // Toolbar size should already be set by the calculation script
                        // Just mark it as ready to make it visible
                        topToolbar.classList.add('toolbar-ready');
                        toolbarWrap.classList.add('toolbar-ready');
                        // Toolbar is now ready - CSS will make it visible
                        window.__toolbarReady = true;
                    }
                } catch(e) {
                    console.error('[TOOLBAR-INIT] Error marking toolbar ready:', e);
                }
            };
            
            // Try immediately
            markToolbarReady();
            
            // Also try on DOMContentLoaded
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', markToolbarReady);
            } else {
                setTimeout(markToolbarReady, 0);
            }
        })();
    </script>

    <!-- Fullscreen Canvas -->
    <canvas id="canvas"></canvas>

    <!-- Main Content Container for Frame Capture -->
    <div id="frame-capture" class="w-full">
        <!-- Content will be dynamically generated based on images -->
        <div id="frame-content" class="min-h-screen flex items-center justify-center">
            <div class="text-center p-8">
                <h1 class="text-4xl font-bold text-slate-800 mb-4">OpenPaint Frame Capture</h1>
                <p class="text-slate-600">Images will appear here as you add them to your project</p>
            </div>
        </div>
    </div>
    <script>
        (function () {
            const frameCapture = document.getElementById('frame-capture');
            if (!frameCapture) return;

            function toggleFramePlaceholder() {
                const hasImages = window.originalImages && Object.keys(window.originalImages).length > 0;
                frameCapture.classList.toggle('hidden', !!hasImages);
            }

            window.__hideFrameCapture = toggleFramePlaceholder;

            if (document.readyState === 'complete') {
                toggleFramePlaceholder();
            } else {
                window.addEventListener('load', toggleFramePlaceholder, { once: true });
            }
        })();
    </script>

    <!-- Minimal Numeric Pill Strip Navigation - Positioned under frame capture -->
    <div id="navigation-container" class="w-full" style="background: white; border-top: 1px solid #cbd5e1; position: relative; z-index: 10; display: block;">
        <nav aria-label="Image quick nav" class="w-full">
            <ol id="mini-stepper" class="flex gap-3 px-4 py-3 overflow-x-auto snap-x snap-mandatory justify-center items-center min-h-[60px]">
                <!-- Pills will be generated by JavaScript -->
            </ol>
        </nav>
    </div>
    
    <!-- Project Header Panel -->
    <div id="projectPanel" class="floating-panel fixed top-4 right-4 z-30 rounded-2xl w-80 transition-all duration-300">
        <div class="flex items-center justify-between p-4 cursor-move border-b border-gray-200/50">
            <h3 class="text-base font-bold text-slate-800">Project Settings</h3>
            <button id="toggleProjectPanel" class="text-slate-500 hover:text-slate-700 hover:bg-slate-100 rounded-lg p-1.5 transition-all duration-200 transform hover:scale-110" title="Minimize/Expand Panel">
                <svg class="w-5 h-5 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
        </div>
        <div id="projectPanelContent" class="p-3 transition-all duration-300">
            <div class="flex flex-col gap-3">
                <!-- Project Info -->
                <div class="flex flex-col gap-3">
                    <input 
                        type="text" 
                        id="projectName" 
                        placeholder="Project Name" 
                        value="New Sofa" 
                        class="px-3 py-2.5 border border-gray-300 rounded-xl text-sm bg-white w-full focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200 shadow-sm"
                    >
                    <div class="flex items-center gap-3">
                        <label for="unitSelector" class="text-sm font-semibold text-slate-700 w-14">Units:</label>
                        <select 
                            id="unitSelector" 
                            onchange="updateMeasurementDisplay()" 
                            class="px-3 py-2.5 border border-gray-300 rounded-xl text-sm bg-white flex-1 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200 shadow-sm"
                        >
                            <option value="inch">inches</option>
                            <option value="cm">cm</option>
                        </select>
                    </div>
                    
                    <!-- Hidden inputs for functionality -->
                    <div id="measurementInput" class="hidden">
                        <div id="inchInputs" class="flex items-center gap-2">
                            <input type="number" id="inchWhole" min="0" value="0" class="w-16 px-2 py-1 border border-gray-300 rounded text-sm">
                            <select id="inchFraction" class="px-2 py-1 border border-gray-300 rounded text-sm">
                                <option value="0">0</option>
                                <option value="0.125">1/8</option>
                                <option value="0.25">1/4</option>
                                <option value="0.375">3/8</option>
                                <option value="0.5">1/2</option>
                                <option value="0.625">5/8</option>
                                <option value="0.75">3/4</option>
                                <option value="0.875">7/8</option>
                            </select>
                        </div>
                        <div id="cmInputs" class="hidden">
                            <input type="number" id="cmValue" min="0" step="0.1" value="0.0" class="w-16 px-2 py-1 border border-gray-300 rounded text-sm">
                        </div>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="panel-divider pt-3 mt-2 space-y-2">
                    <!-- Load Project button -->
                    <div class="flex justify-center">
                        <button id="loadProject" title="Load project from ZIP file" class="px-4 py-2 bg-white border border-gray-300 text-slate-700 text-xs font-semibold rounded-xl hover:bg-slate-50 transition-all">Load Project</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Drawing Tools Panel -->
    <div id="toolsPanel" class="floating-panel fixed top-4 left-4 z-30 rounded-2xl transition-all duration-300">
        <div class="flex items-center justify-between p-4 cursor-move border-b border-gray-200/50">
            <h3 class="text-base font-bold text-slate-800">Drawing Tools</h3>
            <button id="toggleToolsPanel" class="text-slate-500 hover:text-slate-700 hover:bg-slate-100 rounded-lg p-1.5 transition-all duration-200 transform hover:scale-110" title="Minimize/Expand Panel">
                <svg class="w-5 h-5 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
        </div>
        <div id="toolsPanelContent" class="p-4 transition-all duration-300 smart-label-scope">
            <div class="flex flex-col gap-4">
                <!-- Primary Tools -->
                <div class="flex items-center gap-3">
                    <button id="clear" class="px-4 py-2.5 bg-danger-500 hover:bg-danger-600 active:bg-danger-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95">Clear</button>
                    <button id="paste" class="px-4 py-2.5 bg-primary-500 hover:bg-primary-600 active:bg-primary-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95" title="Upload Images" aria-label="Upload Images">
                        <span class="label-long">Upload Images</span><span class="label-short">Upload</span>
                    </button>
                    <button id="save" class="px-4 py-2.5 bg-success-500 hover:bg-success-600 active:bg-success-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95">Save Current</button>
                    <button id="copy" class="px-4 py-2.5 bg-primary-500 hover:bg-primary-600 active:bg-primary-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95" title="Copy image to clipboard (cropped to frame)" aria-label="Copy Image">Copy</button>
                </div>
                
                <!-- AI Tools -->
                <div class="flex items-center gap-3">
                    <button id="generateSofaBasics" class="px-4 py-2.5 bg-purple-500 hover:bg-purple-600 active:bg-purple-700 text-white text-sm font-semibold rounded-xl shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-105 active:scale-95" title="Generate AI Sofa Dimensions" aria-label="Generate AI Sofa Dimensions">
                        <span class="label-long">ü§ñ Generate Sofa Basics</span><span class="label-short">AI Basics</span>
                    </button>
                </div>
                
                <!-- Color Palette -->
                <div class="flex items-center gap-3">
                    <span class="text-sm font-semibold text-slate-700">Color:</span>
                    <div class="flex gap-2">
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110 active" data-color="#3b82f6" style="background-color: #3b82f6; box-shadow: 0 0 10px rgba(59, 130, 246, 0.6);" title="Bright Blue"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#22c55e" style="background-color: #22c55e; box-shadow: 0 0 10px rgba(34, 197, 94, 0.6);" title="Bright Green"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#ef4444" style="background-color: #ef4444; box-shadow: 0 0 10px rgba(239, 68, 68, 0.6);" title="Bright Red"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#f59e0b" style="background-color: #f59e0b; box-shadow: 0 0 10px rgba(245, 158, 11, 0.6);" title="Bright Yellow"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#a855f7" style="background-color: #a855f7; box-shadow: 0 0 10px rgba(168, 85, 247, 0.6);" title="Bright Purple"></button>
                        <button class="w-10 h-10 rounded-full border-2 border-white shadow-lg hover:shadow-xl transition-all duration-200 transform hover:scale-110" data-color="#1f2937" style="background-color: #1f2937;" title="Dark Gray"></button>
                    </div>
                    <input type="color" id="colorPicker" value="#3b82f6" class="hidden">
                </div>
                
                <!-- Drawing Mode & Controls -->
                <div class="flex items-center gap-4">
                    <button id="drawingModeToggle" class="px-4 py-2.5 bg-white border-2 border-success-500 text-success-600 text-sm font-semibold rounded-xl hover:bg-success-50 hover:border-success-600 active:bg-success-100 transition-all duration-200 transform hover:scale-105 active:scale-95 straight-mode shadow-sm" title="Straight Line" aria-label="Straight Line">
                        <span class="label-long">Straight Line</span><span class="label-short">Straight</span>
                    </button>
                    <button id="textModeToggle" class="px-4 py-2.5 bg-white border-2 border-slate-400 text-slate-700 text-sm font-semibold rounded-xl hover:bg-slate-50 hover:border-slate-500 active:bg-slate-100 transition-all duration-200 transform hover:scale-105 active:scale-95 shadow-sm" title="Text Tool" aria-label="Text Tool">
                        <span class="label-long">Text</span><span class="label-short">Text</span>
                    </button>
                    
                </div>
                
                <!-- Arrow & Line Style Controls -->
                <div class="flex items-center gap-4">
                    <div id="arrowControls" class="flex items-center gap-3">
                        <span class="text-sm font-semibold text-slate-700">Arrows:</span>
                        <button id="startArrow" class="px-3 py-2 bg-slate-100 hover:bg-slate-200 active:bg-slate-300 text-slate-700 text-sm font-medium rounded-lg transition-all duration-200 transform hover:scale-105 active:scale-95 shadow-sm" title="Toggle start arrow">‚óÄ</button>
                        <button id="endArrow" class="px-3 py-2 bg-slate-100 hover:bg-slate-200 active:bg-slate-300 text-slate-700 text-sm font-medium rounded-lg transition-all duration-200 transform hover:scale-105 active:scale-95 shadow-sm" title="Toggle end arrow">‚ñ∂</button>
                    </div>
                    <div id="dashControls" class="flex items-center gap-3">
                        <span class="text-sm font-semibold text-slate-700">Style:</span>
                        <select id="dashStyleSelect" class="px-3 py-2 border border-gray-300 rounded-xl text-sm bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200 shadow-sm">
                            <option value="solid">Solid</option>
                            <option value="dotted">Dotted</option>
                            <option value="small">Small Dash</option>
                            <option value="medium">Medium Dash</option>
                            <option value="large">Large Dash</option>
                            <option value="dot-dash">Dot-Dash</option>
                            <option value="custom">Custom</option>
                        </select>
                        <div id="customDashControls" class="hidden items-center gap-2">
                            <input type="number" id="dashLengthInput" min="1" max="50" value="5" class="w-16 px-2 py-1.5 border border-gray-300 rounded-lg text-xs focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200" title="Dash length">
                            <span class="text-xs text-slate-500">/</span>
                            <input type="number" id="gapLengthInput" min="1" max="50" value="5" class="w-16 px-2 py-1.5 border border-gray-300 rounded-lg text-xs focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500 transition-all duration-200" title="Gap length">
                        </div>
                    </div>
                </div>
                
                <!-- Stroke Counter -->
                <div class="text-sm text-gray-600 font-medium">
                    <span id="strokeCounter">Lines: 0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Vectors and Tags Panel -->
    <div id="strokePanel" class="floating-panel fixed left-4 z-30 rounded-2xl w-64 transition-all duration-300 overflow-hidden" style="top: clamp(1rem, 50vh - 20rem, calc(100vh - 40rem - 1rem)); max-height: min(40rem, calc(100vh - 2rem));">
        <div id="elementsHeader" class="flex items-center justify-between p-3 cursor-move border-b border-gray-200/50 bg-white rounded-t-2xl">
            <div class="flex items-center gap-2">
                <h3 class="text-sm font-semibold text-slate-800">Elements</h3>
                <button id="viewMeasurementsToggle" title="Toggle measurement labels display" class="px-2 py-1 text-xs bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-all font-medium">
                    Show Labels
                </button>
            </div>
            <button id="toggleStrokePanel" class="text-slate-500 hover:text-slate-700 rounded-lg p-1 transition-all" title="Minimize/Expand Panel">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
        </div>
        <!-- Panel Body (collapsible) -->
        <div id="elementsBody" role="region" aria-labelledby="elementsHeader">
        <div id="elementsControls" class="px-3 pt-3 pb-1 border-b border-gray-100">
            <div class="flex gap-2 mb-2">
                <button id="selectAllStrokesBtn" title="Select/Deselect all elements" class="flex-1 px-2 py-1 text-xs bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg transition-all font-medium">
                    Deselect All
                </button>
                <button id="showAllMeasurementsBtn" title="Show all measurements in a list" class="flex-1 px-2 py-1 text-xs bg-green-100 hover:bg-green-200 text-green-700 rounded-lg transition-all font-medium">
                    Show List
                </button>
                <button id="viewSubmittedMeasurementsBtn" title="View submitted measurements from shared projects" class="flex-1 px-2 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 rounded-lg transition-all font-medium">
                    View Submitted
                </button>
            </div>
            <div class="flex gap-2 mb-2">
                <div class="flex-1 px-2 py-1 text-xs bg-gray-50 border border-gray-200 rounded-lg">
                    <div class="text-gray-500 text-xs mb-1">Next Tag:</div>
                    <div id="nextTagDisplay" 
                         contenteditable="true" 
                         spellcheck="false"
                         class="font-semibold text-blue-600 cursor-text hover:bg-blue-50 px-1 py-0.5 rounded outline-none focus:ring-2 focus:ring-blue-300" 
                         title="Type to set next tag">A</div>
                </div>
            </div>
            <div class="flex gap-2 flex-wrap items-center">
                <button id="tagModeToggle" title="Toggle between letters only and letters with numbers" class="px-2 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 rounded-lg transition-all font-medium">
                    Letters + Numbers
                </button>
                <label class="flex items-center gap-1 text-xs bg-slate-50 border border-slate-200 px-2 py-1 rounded-lg">
                    <input id="toggleShowMeasurements" type="checkbox" class="accent-blue-600" checked>
                    Show measurements
                </label>
                <button id="toggleReviewOnly" title="Show only measurements under review" class="px-2 py-1 text-xs bg-slate-50 border border-slate-200 rounded-lg hover:bg-slate-100 transition-colors">
                    Review only
                </button>
                <div class="flex items-center gap-1 text-xs bg-slate-50 border border-slate-200 px-2 py-1 rounded-lg">
                    <span class="text-slate-600">Tag Size:</span>
                    <button id="decreaseAllTagSize" title="Decrease tag size for all tags on this image" class="w-5 h-5 bg-white border border-slate-300 rounded hover:bg-slate-50 flex items-center justify-center text-slate-600 hover:text-slate-800 transition-colors">‚àí</button>
                    <span id="currentTagSize" class="text-slate-700 font-medium min-w-[2ch] text-center">20</span>
                    <button id="increaseAllTagSize" title="Increase tag size for all tags on this image" class="w-5 h-5 bg-white border border-slate-300 rounded hover:bg-slate-50 flex items-center justify-center text-slate-600 hover:text-slate-800 transition-colors">+</button>
                </div>
                <button id="unitToggleBtnSecondary" class="px-2 py-1 text-xs bg-white border border-gray-300 rounded-lg hover:bg-gray-50" title="Toggle units">inches</button>
                <button id="labelShapeToggleBtn" class="px-2 py-1 text-xs bg-white border border-gray-300 rounded-lg hover:bg-gray-50" title="Toggle tag shape" aria-pressed="true">‚ñ†</button>
            </div>
        </div>
        <div id="strokeVisibilityControls" class="px-3 pt-2 pb-2 overflow-y-auto overflow-x-hidden" style="box-sizing: border-box;"></div>
        </div>
    </div>

    <!-- Image Gallery Panel -->
    <div id="imagePanel" class="floating-panel fixed right-4 z-30 rounded-2xl w-72 transition-all duration-300 overflow-hidden" style="top: clamp(1rem, 50vh - 20rem, calc(100vh - 40rem - 1rem)); max-height: min(40rem, calc(100vh - 2rem));">
        <div id="imagePanelHeader" class="flex items-center justify-between p-3 cursor-move border-b border-gray-200/50 bg-white rounded-t-2xl">
            <h3 class="text-sm font-semibold text-slate-800">Images</h3>
            <div class="flex items-center gap-2">
                <label class="flex items-center gap-1 text-[11px] font-medium text-slate-600 bg-slate-100 border border-slate-200 rounded-lg px-2 py-1 select-none" title="Toggle whether scrolling selects images automatically">
                    <input type="checkbox" id="scrollSelectToggle" class="accent-blue-600" checked>
                    <span>Scroll selects</span>
                    <span class="text-[10px] uppercase tracking-wide text-blue-600" id="scrollSelectModeLabel">Auto</span>
                </label>
                <button id="toggleImagePanel" class="text-slate-500 hover:text-slate-700 rounded-lg p-1 transition-all" title="Minimize/Expand Panel">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </button>
            </div>
        </div>
        <!-- Name/title box outside the scroll area (always visible at top of images panel) -->
        <div class="px-3 bg-white border-b border-slate-200 py-2">
            <label for="currentImageNameBox" class="block text-[10px] text-slate-500 mb-1">Image name</label>
            <input id="currentImageNameBox" type="text" class="w-full px-2 py-1 border border-slate-300 rounded-md text-[12px] focus:outline-none focus:ring-2 focus:ring-primary-300" placeholder="Rename current image" />
        </div>
        <div id="imagePanelContent" class="p-3 transition-all duration-300" style="position: relative;">
            <!-- Legacy image list for backwards compatibility -->
                <div id="imageList" class="space-y-4 mb-0 h-[60vh] overflow-y-auto overflow-x-hidden pr-0 snap-y snap-mandatory scroll-smooth" style="padding-top: calc(30vh - 5rem); padding-bottom: calc(30vh - 5rem);"></div>

            <!-- Snap guide line -->
            <div class="pointer-events-none absolute left-0 right-0 top-1/2 -translate-y-1/2 border-t border-slate-300/70"></div>

            
            
            <!-- Gallery (disabled in vertical list mode) -->
            <div class="mb-4 hidden">
                <div id="imageGallery" class="hidden"></div>
                <div id="imageDots" class="hidden"></div>
            </div>
            
            <!-- Image meta removed (name/type inputs no longer used) -->

            <!-- Navigation controls removed -->
        </div>
    </div>

    <!-- Mobile panel toggle icons (outside panels to avoid overflow clipping) -->
    <div id="strokePanelIcon" class="panel-toggle-icon" data-panel="strokePanel" style="display: none; opacity: 0;">‚úèÔ∏è</div>
    <div id="imagePanelIcon" class="panel-toggle-icon" data-panel="imagePanel" style="display: none; opacity: 0;">üñºÔ∏è</div>

    <!-- Capture Frame -->
    <div id="captureOverlay" class="fixed inset-0 pointer-events-none" style="z-index: 15;">
        <!-- Capture frame -->
        <div id="captureFrame" class="capture-frame absolute border-2 border-gray-400 bg-transparent" style="left: calc(50% - 400px); top: calc(50% - 300px); width: 800px; height: 600px; pointer-events: none;">
            <!-- Lock button -->
            <button id="captureLockButton" class="absolute -bottom-8 -right-8 w-8 h-8 bg-white border border-gray-300 rounded shadow-md hover:bg-gray-50 transition-colors flex items-center justify-center text-gray-600" title="Lock/Unlock frame (L)">
                <!-- Locked icon -->
                <svg class="locked-icon w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"></path>
                </svg>
                <!-- Unlocked icon -->
                <svg class="unlocked-icon w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z"></path>
                </svg>
            </button>
            
            <!-- Resize handles (hidden when locked) -->
            <div class="resize-handles">
                <div class="resize-handle w-3 h-3 -top-1 -left-1 bg-white border border-blue-400 rounded-sm" style="cursor: nw-resize;" data-direction="nw"></div>
                <div class="resize-handle w-3 h-3 -top-1 left-1/2 -translate-x-1/2 bg-white border border-blue-400 rounded-sm" style="cursor: n-resize;" data-direction="n"></div>
                <div class="resize-handle w-3 h-3 -top-1 -right-1 bg-white border border-blue-400 rounded-sm" style="cursor: ne-resize;" data-direction="ne"></div>
                <div class="resize-handle w-3 h-3 top-1/2 -translate-y-1/2 -right-1 bg-white border border-blue-400 rounded-sm" style="cursor: e-resize;" data-direction="e"></div>
                <div class="resize-handle w-3 h-3 -bottom-1 -right-1 bg-white border border-blue-400 rounded-sm" style="cursor: se-resize;" data-direction="se"></div>
                <div class="resize-handle w-3 h-3 -bottom-1 left-1/2 -translate-x-1/2 bg-white border border-blue-400 rounded-sm" style="cursor: s-resize;" data-direction="s"></div>
                <div class="resize-handle w-3 h-3 -bottom-1 -left-1 bg-white border border-blue-400 rounded-sm" style="cursor: sw-resize;" data-direction="sw"></div>
                <div class="resize-handle w-3 h-3 top-1/2 -translate-y-1/2 -left-1 bg-white border border-blue-400 rounded-sm" style="cursor: w-resize;" data-direction="w"></div>
            </div>
        </div>
    </div>
    
    <!-- Instruction Text for Unlocked Mode -->
    <div id="unlockInstructions" class="fixed top-4 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-80 text-white px-4 py-2 rounded-lg shadow-xl hidden backdrop-blur-sm z-40">
        <div class="text-sm font-medium text-center">
            Press <kbd class="px-1 py-0.5 bg-white bg-opacity-20 rounded text-xs">L</kbd> or click lock icon to exit positioning mode
        </div>
    </div>
    
    <!-- macOS Style Lock Popup -->
    <div id="lockPopup" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-80 text-white px-4 py-2 rounded-lg shadow-xl hidden transition-all duration-200 backdrop-blur-sm" style="z-index: 50;">
        <div class="flex items-center gap-2">
            <svg id="lockPopupIcon" class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"></path>
            </svg>
            <span id="lockPopupText">Locked</span>
        </div>
    </div>

    <!-- Canvas Controls (Bottom Panel) -->
    <div id="canvasControls" class="floating-panel fixed rounded-2xl px-3 py-2 transition-all duration-300" style="bottom: 4rem; left: 50%; transform: translateX(-50%); z-index: 10000; display: block;">
        <div id="canvasControlsContent" class="flex items-center gap-2 text-sm smart-label-scope">
            <button id="copyCanvasBtn" class="flex items-center gap-1 px-3 py-1 bg-blue-600 hover:bg-blue-700 active:bg-blue-800 text-white text-xs rounded-lg shadow-sm hover:shadow-md transition-all duration-200 transform hover:scale-[1.02] active:scale-95" title="Copy image to clipboard" aria-label="Copy Image">
                <svg class="w-3.5 h-3.5 opacity-90" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M16 1H4a2 2 0 00-2 2v12h2V3h12V1zm3 4H8a2 2 0 00-2 2v14a2 2 0 002 2h11a2 2 0 002-2V7a2 2 0 00-2-2zm0 16H8V7h11v14z"></path></svg>
                <span class="label-long">Copy Image</span>
                <span class="label-short">Copy</span>
            </button>
            <select id="fitModeSelect" class="px-2 py-1 border border-gray-300 rounded-lg bg-white focus:outline-none hover:bg-gray-50">
                <option value="fit-width" selected>Fit Width</option>
                <option value="fit-height">Fit Height</option>
                <option value="fit-canvas">Fit Canvas</option>
                <option value="actual-size">Actual Size</option>
            </select>
            <button id="scaleButton" class="px-2 py-1 bg-white border border-gray-300 rounded-lg text-sm font-medium hover:bg-gray-50" aria-haspopup="listbox" aria-expanded="false" type="button">100% <svg class="inline w-3 h-3 -mt-0.5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M5.25 7.5l4.5 4.5 4.5-4.5H5.25z"/></svg></button>
            <div class="flex items-center gap-1 ml-2">
                <button id="rotateLeftCtrl" class="px-2 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg hover:bg-slate-50" title="Rotate 90¬∞ CCW">‚Ü∂</button>
                <button id="rotateRightCtrl" class="px-2 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg hover:bg-slate-50" title="Rotate 90¬∞ CW">‚Ü∑</button>
            </div>

            <!-- Share/Update next to Copy/Save -->
            <button id="shareProjectBtn" class="px-3 py-1 bg-white border border-gray-300 text-slate-700 text-xs rounded-lg shadow-sm hover:shadow-md hover:bg-slate-50 transition-all duration-200 transform hover:scale-[1.02] active:scale-95" title="Create shareable URL for customer measurements">
                Share
            </button>
            

            <!-- Quick Save with hover menu -->
            <div id="quickSave" class="relative ml-2">
                <button id="quickSaveBtn" class="px-3 py-1 bg-green-600 hover:bg-green-700 text-white text-xs rounded-lg">
                    Save
                </button>
                <div id="quickSaveMenu"
                     class="hidden absolute bottom-full mb-1 left-0 bg-white border border-gray-200 rounded-xl shadow-lg min-w-[120px]"
                     style="white-space: nowrap; z-index: 5000;">
                    <button class="block w-full text-left px-3 py-2 text-xs hover:bg-slate-50 rounded-t-xl transition-colors" data-action="pdf">Save as PDF</button>
                    <button class="block w-full text-left px-3 py-2 text-xs hover:bg-slate-50 rounded-b-xl transition-colors" data-action="multiple">Save Multiple</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Status message element for notifications -->
    <div id="statusMessage"></div>
    
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <!-- New UI Controller Script -->
    <script>
        // Initialize top toolbar - now works with pre-populated content
        function initializeTopToolbar() {
            const left = document.getElementById('tbLeft');
            const center = document.getElementById('tbCenter');
            const right = document.getElementById('tbRight');
            const bottom = document.getElementById('canvasControlsContent') || center;

            // Helper functions
            const setUniform = el => {
                if (!el) return;
                // Do not apply text-input styling to range sliders; it breaks their visuals
                if (el.tagName === 'INPUT' && el.type === 'range') return;
                el.classList.add(el.tagName === 'SELECT' ? 'tselect' : el.tagName === 'INPUT' ? 'tinput' : 'tbtn');
            };
            
            const reparent = (id, target, beforeSetup) => {
                const el = document.getElementById(id);
                if (!el) return null;
                beforeSetup?.(el);
                target.appendChild(el);
                setUniform(el);
                return el;
            };

            // Since toolbar is now pre-populated, we just need to ensure proper styling
            // and wire up any missing functionality
            const ensureUniformStyling = () => {
                const buttons = left.querySelectorAll('button, input, select');
                buttons.forEach(setUniform);
            };
            
            ensureUniformStyling();

            // Color swatches are now pre-populated, just need to wire up functionality
            const colorButtons = left.querySelectorAll('[data-color]');
            colorButtons.forEach(button => {
                if (!button.__boundColor) {
                    button.__boundColor = true;
                    button.addEventListener('click', () => {
                        document.querySelectorAll('[data-color].active').forEach(b=>b.classList.remove('active'));
                        button.classList.add('active');
                        const hex = button.getAttribute('data-color');
                        const cp = document.getElementById('colorPicker');
                        if (cp && hex) {
                            cp.value = hex;
                            cp.dispatchEvent(new Event('change'));
                        }
                        const bs = document.getElementById('brushSize');
                        if (bs && hex) bs.style.setProperty('--accent', hex);
                    });
                }
            });
            
            // Hide the color picker since we're using swatches
            const colorInput = document.getElementById('colorPicker');
            if (colorInput) colorInput.classList.add('hidden');

            // Arrow and line style controls are now pre-populated, just need to wire up functionality
            const arrowStartBtn = document.getElementById('arrowStartBtn');
            const arrowEndBtn = document.getElementById('arrowEndBtn');
            const dottedBtn = document.getElementById('dottedBtn');
            
            const setLineStyleIcon = (style) => {
                if (!dottedBtn) return;
                const svgSolid = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>';
                const svgSmall = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="4 4"/></svg>';
                const svgMedium = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="7 5"/></svg>';
                const svgLarge = '<svg width="34" height="12" viewBox="0 0 34 12" aria-hidden="true"><line x1="2" y1="6" x2="32" y2="6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="11 7"/></svg>';
                dottedBtn.innerHTML = style === 'small' ? svgSmall : style === 'medium' ? svgMedium : style === 'large' ? svgLarge : svgSolid;
            };
            setLineStyleIcon('solid');

            // Wire controls to UI state in paint.js
            const setActive = (el, on) => el.classList.toggle('active', !!on);
            const syncFromState = () => {
                try {
                    const as = window.paintApp?.uiState?.arrowSettings;
                    const ds = window.paintApp?.uiState?.dashSettings;
                    setActive(arrowStartBtn, as?.startArrow);
                    setActive(arrowEndBtn, as?.endArrow);
                    setLineStyleIcon(ds?.style || 'solid');
                    // Sync label shape toggle visual state
                    const state = window.paintApp?.state || {};
                    const shape = state.labelShape || 'square';
                    // Note: shapeSquareBtn and shapeCircleBtn were removed, using single toggle button instead
                } catch {}
            };
            syncFromState();
            
            arrowStartBtn.addEventListener('click', () => {
                try {
                    const as = window.paintApp.uiState.arrowSettings;
                    as.startArrow = !as.startArrow;
                    // Apply to stroke in edit mode if any
                    const edited = window.selectedStrokeInEditMode;
                    const img = window.currentImageLabel;
                    if (edited && img && window.vectorStrokesByImage?.[img]?.[edited]) {
                        const v = window.vectorStrokesByImage[img][edited];
                        v.arrowSettings = v.arrowSettings || { arrowSize: as.arrowSize, arrowStyle: as.arrowStyle, startArrow: false, endArrow: false };
                        v.arrowSettings.startArrow = as.startArrow;
                        // Ensure curved lines switch type appropriately
                        if (typeof window.updateStrokeTypeBasedOnArrows === 'function') {
                            window.updateStrokeTypeBasedOnArrows(v);
                        } else {
                            const hasArrows = !!(v.arrowSettings.startArrow || v.arrowSettings.endArrow);
                            if (v.type === 'curved' && hasArrows) v.type = 'curved-arrow';
                            if (v.type === 'curved-arrow' && !hasArrows) v.type = 'curved';
                        }
                        window.saveState?.(true, false, false);
                        window.redrawCanvasWithVisibility?.();
                    }
                    syncFromState();
                } catch {}
            });
            arrowEndBtn.addEventListener('click', () => {
                try {
                    const as = window.paintApp.uiState.arrowSettings;
                    as.endArrow = !as.endArrow;
                    // Apply to stroke in edit mode if any
                    const edited = window.selectedStrokeInEditMode;
                    const img = window.currentImageLabel;
                    if (edited && img && window.vectorStrokesByImage?.[img]?.[edited]) {
                        const v = window.vectorStrokesByImage[img][edited];
                        v.arrowSettings = v.arrowSettings || { arrowSize: as.arrowSize, arrowStyle: as.arrowStyle, startArrow: false, endArrow: false };
                        v.arrowSettings.endArrow = as.endArrow;
                        // Ensure curved lines switch type appropriately
                        if (typeof window.updateStrokeTypeBasedOnArrows === 'function') {
                            window.updateStrokeTypeBasedOnArrows(v);
                        } else {
                            const hasArrows = !!(v.arrowSettings.startArrow || v.arrowSettings.endArrow);
                            if (v.type === 'curved' && hasArrows) v.type = 'curved-arrow';
                            if (v.type === 'curved-arrow' && !hasArrows) v.type = 'curved';
                        }
                        window.saveState?.(true, false, false);
                        window.redrawCanvasWithVisibility?.();
                    }
                    syncFromState();
                } catch {}
            });
            dottedBtn.addEventListener('click', () => {
                try {
                    const ds = window.paintApp.uiState.dashSettings;
                    // Cycle: solid -> small -> medium -> large -> solid
                    const next = { 'solid': 'small', 'small': 'medium', 'medium': 'large', 'large': 'solid' };
                    ds.style = next[ds.style] || 'small';
                    ds.enabled = ds.style !== 'solid';
                    // Compute dash pattern immediately (mirror paint.js getDashPattern)
                    const computePattern = (style, dashLen, gapLen, lineWidth = 1) => {
                        const baseScale = Math.max(2, lineWidth * 0.8);
                        switch (style) {
                            case 'small': return [6 * baseScale, 4 * baseScale];
                            case 'medium': return [12 * baseScale, 8 * baseScale];
                            case 'large': return [20 * baseScale, 12 * baseScale];
                            case 'dot-dash': return [4 * baseScale, 6 * baseScale, 12 * baseScale, 6 * baseScale];
                            case 'custom': return [dashLen * baseScale, gapLen * baseScale];
                            default: return [];
                        }
                    };
                    const brush = document.getElementById('brushSize');
                    const size = parseInt(brush?.value || '5') || 5;
                    ds.pattern = computePattern(ds.style, ds.dashLength, ds.gapLength, size);
                    // If editing a stroke, also update it live
                    const edited = window.selectedStrokeInEditMode;
                    const img = window.currentImageLabel;
                    if (edited && img && window.vectorStrokesByImage?.[img]?.[edited]) {
                        const v = window.vectorStrokesByImage[img][edited];
                        const lw = parseInt(v.width || size) || size;
                        v.dashSettings = { ...ds, pattern: computePattern(ds.style, ds.dashLength, ds.gapLength, lw) };
                        window.saveState?.(true, false, false);
                        window.redrawCanvasWithVisibility?.();
                    }
                    setLineStyleIcon(ds.style);
                    syncFromState();
                } catch {}
            });

            // Undo / Redo buttons
            // Undo/Redo buttons are now pre-populated, just need to wire up functionality
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            if (undoBtn) {
                undoBtn.addEventListener('click', () => { 
                    if (typeof window.undo === 'function') window.undo(); 
                });
            }
            
            if (redoBtn) {
                redoBtn.addEventListener('click', () => { 
                    if (typeof window.redo === 'function') window.redo(); 
                });
            }

            // CENTER/BOTTOM: canvas view controls moved to bottom
            reparent('fitModeSelect', bottom);
            reparent('rotateLeftCtrl', bottom, el => { 
                el.classList.add('icon-btn', 'tbtn'); 
                el.title = 'Rotate Left'; 
                el.textContent = '‚Ü∂'; 
            });
            reparent('rotateRightCtrl', bottom, el => { 
                el.classList.add('icon-btn', 'tbtn'); 
                el.title = 'Rotate Right'; 
                el.textContent = '‚Ü∑'; 
            });
            reparent('scaleButton', bottom);
            syncFromState();

            // RIGHT: project settings are now pre-populated, just need to wire up functionality
            const saveProjectTop = document.getElementById('saveProjectTop');
            const shareProjectBtn = document.getElementById('shareProjectBtn');
            const updateShareBtn = document.getElementById('updateShareBtn');
            
            if (saveProjectTop) {
                saveProjectTop.addEventListener('click', () => {
                    if (window.projectManager?.saveProject) window.projectManager.saveProject();
                });
            }
            
            if (shareProjectBtn) {
                shareProjectBtn.addEventListener('click', () => {
                    if (window.shareProject) window.shareProject();
                });
            }
            
            if (updateShareBtn) {
                updateShareBtn.addEventListener('click', () => {
                    if (window.updateSharedProject) window.updateSharedProject();
                });
            }

            // Unit toggle button is now pre-populated, just need to wire up functionality
            const unitToggle = document.getElementById('unitToggleBtn');
            const unitSel = document.getElementById('unitSelector');
            const unitToggleSecondary = document.getElementById('unitToggleBtnSecondary');
            
            const getUnitLabel = () => (unitSel?.value === 'inch' ? 'inches' : 'cm');
            const toggleUnits = () => {
                if (!unitSel) return;
                unitSel.value = unitSel.value === 'inch' ? 'cm' : 'inch';
                const label = getUnitLabel();
                if (unitToggle) unitToggle.textContent = label;
                if (unitToggleSecondary) unitToggleSecondary.textContent = label;
                if (typeof updateMeasurementDisplay === 'function') {
                    updateMeasurementDisplay();
                } else if (unitSel.onchange) {
                    unitSel.onchange();
                }
            };

            if (unitToggle && unitSel) {
                unitToggle.textContent = getUnitLabel();
                unitToggle.addEventListener('click', toggleUnits);
                // Hide the original select (kept for compatibility)
                unitSel.style.display = 'none';
            }

            if (unitToggleSecondary && unitSel) {
                unitToggleSecondary.textContent = getUnitLabel();
                unitToggleSecondary.addEventListener('click', toggleUnits);
            }

            // Elements panel single-button shape toggle wiring
            const labelShapeToggleBtn = document.getElementById('labelShapeToggleBtn');
            const applyShape = (val) => {
                if (window.paintApp?.state) window.paintApp.state.labelShape = val;
                if (window.redrawCanvasWithVisibility) window.redrawCanvasWithVisibility();
            };
            if (labelShapeToggleBtn) {
                const syncShapeBtn = () => {
                    const shape = (window.paintApp?.state?.labelShape) || 'square';
                    const isSquare = shape !== 'circle';
                    labelShapeToggleBtn.textContent = isSquare ? '‚ñ†' : '‚óè';
                    labelShapeToggleBtn.setAttribute('aria-pressed', String(isSquare));
                };
                labelShapeToggleBtn.addEventListener('click', () => {
                    const shape = (window.paintApp?.state?.labelShape) || 'square';
                    applyShape(shape === 'circle' ? 'square' : 'circle');
                    syncShapeBtn();
                });
                syncShapeBtn();
            }

            // Auto-update shared project when state saves (debounced)
            if (window.updateSharedProject && window.saveState && !window.__autoUpdateSharePatched) {
                window.__autoUpdateSharePatched = true;
                const originalSaveState = window.saveState;
                let updateTimer = null;
                window.saveState = function() {
                    const result = originalSaveState.apply(this, arguments);
                    clearTimeout(updateTimer);
                    updateTimer = setTimeout(() => {
                        try { window.updateSharedProject(); } catch {}
                    }, 600);
                    return result;
                };
            }

            // Hide legacy panels after moving controls (keep in DOM to preserve any lookups)
            document.getElementById('toolsPanel')?.classList.add('hidden');
            document.getElementById('projectPanel')?.classList.add('hidden');
            const cc = document.getElementById('canvasControls');
            if (cc) { cc.classList.remove('hidden'); cc.style.display='block'; }

            // Add body padding to prevent toolbar overlap
            document.body.style.paddingTop = '48px';
        }

        // Setup quick save hover menu functionality
        function setupQuickSaveHover() {
            // Quick Save hover menu (bottom panel)
            const quickSave = document.getElementById('quickSave');
            const quickSaveBtn = document.getElementById('quickSaveBtn');
            const quickSaveMenu = document.getElementById('quickSaveMenu');

            console.log('Setting up quick save hover:', { quickSave, quickSaveBtn, quickSaveMenu });

            if (quickSave && quickSaveBtn && quickSaveMenu) {
                // Click: Save current image (reuses existing 'save' button)
                quickSaveBtn.addEventListener('click', () => {
                    console.log('Quick save clicked');
                    const saveButton = document.getElementById('save');
                    if (saveButton) saveButton.click();
                });

                let hideTimer = null;
                const showMenu = () => {
                    if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
                    quickSaveMenu.classList.remove('hidden');
                };
                const scheduleHide = () => {
                    if (hideTimer) clearTimeout(hideTimer);
                    hideTimer = setTimeout(() => {
                        quickSaveMenu.classList.add('hidden');
                        hideTimer = null;
                    }, 200); // small delay prevents flicker when moving cursor to menu
                };

                // Hover to show menu on the trigger container
                quickSave.addEventListener('mouseenter', showMenu);
                quickSave.addEventListener('mouseleave', scheduleHide);

                // Keep the menu open while hovering the menu; hide after leaving it
                quickSaveMenu.addEventListener('mouseenter', showMenu);
                quickSaveMenu.addEventListener('mouseleave', scheduleHide);

                // Menu actions
                quickSaveMenu.addEventListener('click', (e) => {
                    const item = e.target.closest('[data-action]');
                    if (!item) return;
                    const action = item.dataset.action;
                    console.log('Quick save menu action:', action);

                    if (action === 'pdf') {
                        const projectName = document.getElementById('projectName')?.value || 'Untitled Project';
                        if (typeof window.showPDFExportDialog === 'function') {
                            window.showPDFExportDialog(projectName);
                        }
                    } else if (action === 'multiple') {
                        if (typeof window.saveAllImages === 'function') {
                            window.saveAllImages();
                        }
                    }
                });
                console.log('Quick save hover menu setup complete');
            } else {
                console.error('Quick save elements not found:', { quickSave, quickSaveBtn, quickSaveMenu });
            }
        }

        // Extracted helper function to check if container needs compact mode
        // NOTE: Toolbar containers are now handled by data-toolbar-mode attribute
        // This function only applies to non-toolbar smart-label-scope containers
        const compactStateCache = new Map(); // Track previous state to prevent thrashing
        
            function applyCompactLabels(container) {
                if (!container) return;
                
                // Skip toolbar containers - they're handled by data-toolbar-mode
                if (container.closest('#topToolbar')) {
                    return;
                }
                
                // Check if we're on desktop - never add compact class on desktop
                const isMobile = window.innerWidth <= 768;
                
                // Skip smart labels on desktop - always show full labels
                if (!isMobile) {
                    container.classList.remove('compact');
                    return;
                }
                
                // Simpler, more reliable overflow detection with hysteresis
                const containerWidth = container.clientWidth;
                const containerScrollWidth = container.scrollWidth;
                
                // Add 2px threshold to prevent rapid toggling near the boundary
                const threshold = 2;
                const needsCompact = containerScrollWidth > (containerWidth + threshold);
                const wasCompact = container.classList.contains('compact');
                const cachedState = compactStateCache.get(container);
                
                // Only toggle if state actually changed and difference is significant
                if (needsCompact !== wasCompact) {
                    // Check if we're near the boundary - if so, keep current state to prevent thrashing
                    const nearBoundary = Math.abs(containerScrollWidth - containerWidth) < threshold * 2;
                    if (nearBoundary && cachedState === wasCompact) {
                        // Near boundary and state hasn't changed - keep current state
                        return;
                    }
                    
                    // Update state
                    if (needsCompact) {
                        container.classList.add('compact');
                    } else {
                        container.classList.remove('compact');
                    }
                    compactStateCache.set(container, needsCompact);
                }
        }

        // Pre-calculate toolbar layout before making it visible
        // NOTE: Toolbar label sizing is now handled by data-toolbar-mode attribute
        // This function now only handles final layout stabilization
        function calculateInitialToolbarLayout() {
            const toolbarWrap = document.querySelector('.toolbar-wrap');
            if (!toolbarWrap) {
                return;
            }
            
            // Toolbar mode should already be set by the earlier script
            // Just ensure layout is stable
            
            // Force initial layout calculation to ensure all styles are applied
            void toolbarWrap.offsetWidth;
            
            // Final layout stabilization - force calculation on all toolbar elements
            const allButtons = toolbarWrap.querySelectorAll('button, input, select');
            allButtons.forEach(el => {
                void el.offsetWidth; // Force layout calculation
            });
            
            // One final layout calculation to ensure everything is stable
            void toolbarWrap.offsetWidth;
            
            // Toolbar-ready class should already be added (done earlier to prevent opacity transitions)
            // But ensure it's set here as well for consistency
            const topToolbar = document.getElementById('topToolbar');
            if (topToolbar && !topToolbar.classList.contains('toolbar-ready')) {
                topToolbar.classList.add('toolbar-ready');
            }
            if (!toolbarWrap.classList.contains('toolbar-ready')) {
                toolbarWrap.classList.add('toolbar-ready');
            }
            
            // After layout is stable, enable smooth transitions
            setTimeout(() => {
                if (topToolbar) {
                    topToolbar.classList.add('toolbar-stable');
                }
                if (toolbarWrap) {
                    toolbarWrap.classList.add('toolbar-stable');
                }
            }, 100);
        }

        // Smart label system for responsive button text
        function initSmartLabels(skipInitialCheck = false) {
            // Helper to wrap button with smart label spans
            function wrapSmartLabel(buttonEl, longText, shortText) {
                if (!buttonEl || buttonEl.querySelector('.label-long')) return; // Already wrapped
                
                buttonEl.innerHTML = `<span class="label-long">${longText}</span><span class="label-short">${shortText}</span>`;
                buttonEl.setAttribute('title', longText);
                buttonEl.setAttribute('aria-label', longText);
            }
            
            // Setup ResizeObserver for each smart-label-scope container
            const containers = document.querySelectorAll('.smart-label-scope');
            const observers = new Map();
            
            // Flag to prevent ResizeObserver from firing during initial setup
            let isInitializing = !skipInitialCheck;
            const initStartTime = Date.now();
            
            containers.forEach(container => {
                let debounceTimer = null;
                let lastWidth = 0;
                let lastHeight = 0;
                let isProcessing = false; // Prevent concurrent processing
                
                const debouncedApply = (entries) => {
                    // Skip if we're still initializing or already processing
                    if (isInitializing || isProcessing) return;
                    
                    // Check if enough time has passed since initialization started
                    const timeSinceInit = Date.now() - initStartTime;
                    if (timeSinceInit < 800) return; // Wait 800ms before allowing ResizeObserver to fire
                    
                    // Check if size actually changed significantly (prevent micro-adjustments)
                    const entry = entries && entries[0];
                    if (entry) {
                        const { width, height } = entry.contentRect;
                        const widthDiff = Math.abs(width - lastWidth);
                        const heightDiff = Math.abs(height - lastHeight);
                        
                        // Only process if change is significant (more than 2px to prevent micro-adjustments)
                        if (widthDiff < 2 && heightDiff < 2) {
                            return;
                        }
                        
                        lastWidth = width;
                        lastHeight = height;
                    }
                    
                    if (debounceTimer) clearTimeout(debounceTimer);
                    isProcessing = true;
                    debounceTimer = setTimeout(() => {
                        applyCompactLabels(container);
                        // Also check parent containers
                        const parent = container.closest('.smart-label-scope');
                        if (parent && parent !== container) {
                            applyCompactLabels(parent);
                        }
                        isProcessing = false;
                    }, 200); // Increased debounce time to prevent rapid toggling
                };
                
                // STEP 4: Performance guardrails - Don't observe toolbar containers
                // Toolbar sizing is handled by data-toolbar-mode attribute, not ResizeObserver
                // This prevents flicker loops and performance issues
                const isToolbarContainer = container.closest('#topToolbar') !== null;
                
                if (isToolbarContainer) {
                    // Skip ResizeObserver for toolbar - data-toolbar-mode handles sizing
                    return; // Don't observe toolbar containers at all
                }
                
                // For non-toolbar containers, set up ResizeObserver normally
                const observer = new ResizeObserver(debouncedApply);
                observer.observe(container);
                observers.set(container, observer);
                
                // Store initial dimensions
                const rect = container.getBoundingClientRect();
                lastWidth = rect.width;
                lastHeight = rect.height;
                
                // Initial check with immediate execution (skip if already calculated)
                if (!skipInitialCheck) {
                    applyCompactLabels(container);
                }
            });
            
            // Clear initialization flag after a longer delay to ensure everything is stable
            if (isInitializing) {
                setTimeout(() => {
                    isInitializing = false;
                }, 1000); // Increased to 1 second
            }
            
            // Setup buttons that get created dynamically by toolbar initialization
            setTimeout(() => {
                // Load Project button (created by reparent)
                const loadBtn = document.getElementById('loadProject');
                if (loadBtn) {
                    wrapSmartLabel(loadBtn, 'Load Project', 'Load');
                }
                
                // Save Project button (created dynamically)
                const saveBtn = document.getElementById('saveProjectTop');
                if (saveBtn) {
                    wrapSmartLabel(saveBtn, 'Save Project', 'Save');
                    // Make it visually distinct from bottom save button
                    saveBtn.style.background = '#3b82f6'; // Blue instead of green
                    saveBtn.style.borderColor = '#2563eb';
                    saveBtn.style.fontWeight = '700';
                    saveBtn.style.fontSize = '14px';
                    saveBtn.style.padding = '8px 16px';
                }
                
                // Immediate check for all containers (skip if already calculated)
                if (!skipInitialCheck) {
                containers.forEach(container => {
                    applyCompactLabels(container);
                });
                
                // Additional check after a short delay to ensure everything is rendered
                setTimeout(() => {
                    containers.forEach(container => {
                        applyCompactLabels(container);
                    });
                }, 100);
                }
            }, 150);
            
            // Global function to update drawing mode toggle labels
            window.updateDrawingModeLabels = function(mode) {
                const toggle = document.getElementById('drawingModeToggle');
                if (!toggle) return;
                
                const longSpan = toggle.querySelector('.label-long');
                const shortSpan = toggle.querySelector('.label-short');
                
                if (mode === true || mode === 'freehand') {
                    const longText = 'Freehand';
                    const shortText = 'Free';
                    if (longSpan) longSpan.textContent = longText;
                    if (shortSpan) shortSpan.textContent = shortText;
                    toggle.setAttribute('title', longText);
                    toggle.setAttribute('aria-label', longText);
                } else if (mode === 'curved') {
                    const longText = 'Curved Line';
                    const shortText = 'Curved';
                    if (longSpan) longSpan.textContent = longText;
                    if (shortSpan) shortSpan.textContent = shortText;
                    toggle.setAttribute('title', longText);
                    toggle.setAttribute('aria-label', longText);
                } else {
                    // Straight mode (false or 'straight')
                    const longText = 'Straight Line';
                    const shortText = 'Straight';
                    if (longSpan) longSpan.textContent = longText;
                    if (shortSpan) shortSpan.textContent = shortText;
                    toggle.setAttribute('title', longText);
                    toggle.setAttribute('aria-label', longText);
                }
                
                // Re-check container after label change
                const container = toggle.closest('.smart-label-scope');
                if (container) applyCompactLabels(container);
            };
            
            // Store observers for cleanup if needed
            window.smartLabelObservers = observers;
        }

        // New UI functionality for modular panels and capture frame
        document.addEventListener('DOMContentLoaded', () => {
            // 1. Initialize top toolbar structure first (so elements are in place)
            initializeTopToolbar();
            
            // 2. Toolbar-ready should already be added (done in inline script before DOMContentLoaded)
            // Just ensure it's set and mark as stable after initialization
            const topToolbar = document.getElementById('topToolbar');
            const toolbarWrap = document.querySelector('.toolbar-wrap');
            if (topToolbar && toolbarWrap) {
                // Ensure toolbar-ready is set
                topToolbar.classList.add('toolbar-ready');
                toolbarWrap.classList.add('toolbar-ready');
            }
            
            // 3. Calculate layout AFTER toolbar initialization completes (use RAF to ensure DOM is ready)
            requestAnimationFrame(() => {
                const doLayoutCalculation = () => {
                    // Force a layout calculation to ensure all styles are applied
                    const toolbarWrap = document.querySelector('.toolbar-wrap');
                    if (toolbarWrap) {
                        void toolbarWrap.offsetWidth; // Force layout
                    }
                    
                    // Now calculate layout (toolbar is already visible, but we need to stabilize it)
                    calculateInitialToolbarLayout();
                    
                    // 4. Setup smart labels (skip initial check since we already calculated)
                    initSmartLabels(true); // Pass true to skip initial check
                };
                
                // Wait for fonts to load to ensure accurate text measurements
                if (document.fonts && document.fonts.ready) {
                    // Check if fonts are already loaded
                    if (document.fonts.status === 'loaded') {
                        doLayoutCalculation();
                    } else {
                        document.fonts.ready.then(doLayoutCalculation);
                    }
                } else {
                    // Fallback if fonts API not available - use small delay
                    setTimeout(doLayoutCalculation, 50);
                }
            });
            
            // Setup quick save hover menu after toolbar initialization (with small delay)
            setTimeout(setupQuickSaveHover, 100);
            
            // (Sketchbook toggle removed per request)
            // Panel visibility toggles
            const strokePanel = document.getElementById('strokePanel');
            const imagePanel = document.getElementById('imagePanel');
            const captureOverlay = document.getElementById('captureOverlay');
            const captureFrame = document.getElementById('captureFrame');
            // Per-image capture frame storage and helpers
            window.captureFrameByLabel = window.captureFrameByLabel || {};
            function buildCaptureFrameRecord(rect) {
                const winW = Math.max(window.innerWidth, 1);
                const winH = Math.max(window.innerHeight, 1);
                return {
                    left: Math.round(rect.left),
                    top: Math.round(rect.top),
                    width: Math.round(rect.width),
                    height: Math.round(rect.height),
                    windowWidth: winW,
                    windowHeight: winH,
                    relativeLeft: rect.left / winW,
                    relativeTop: rect.top / winH,
                    relativeWidth: rect.width / winW,
                    relativeHeight: rect.height / winH
                };
            }
            function getCaptureFrameRectPixels() {
                const rect = captureFrame.getBoundingClientRect();
                return buildCaptureFrameRecord(rect);
            }
            function saveCurrentCaptureFrameForLabel(label) {
                if (!label) return;
                window.captureFrameByLabel[label] = getCaptureFrameRectPixels();
            }
            function resolveCaptureFrameRect(stored) {
                const winW = Math.max(window.innerWidth, 1);
                const winH = Math.max(window.innerHeight, 1);
                const targetAspect = 4 / 3;

                let fallbackWidth = Math.min(800, winW);
                let fallbackHeight = Math.round(fallbackWidth / targetAspect);
                if (fallbackHeight > winH) {
                    fallbackHeight = Math.min(600, winH);
                    fallbackWidth = Math.round(fallbackHeight * targetAspect);
                }

                const fallback = {
                    left: Math.max(0, Math.round((winW - fallbackWidth) / 2)),
                    top: Math.max(0, Math.round((winH - fallbackHeight) / 2)),
                    width: fallbackWidth,
                    height: fallbackHeight
                };
                if (!stored) return fallback;

                const baseW = stored.windowWidth || winW;
                const baseH = stored.windowHeight || winH;
                let width = Math.max(1, Math.round(
                    typeof stored.relativeWidth === 'number'
                        ? stored.relativeWidth * winW
                        : (stored.width ?? fallback.width)
                ));
                let height = Math.max(1, Math.round(
                    typeof stored.relativeHeight === 'number'
                        ? stored.relativeHeight * winH
                        : (stored.height ?? fallback.height)
                ));

                if (width / height > targetAspect) {
                    width = Math.round(height * targetAspect);
                } else {
                    height = Math.round(width / targetAspect);
                }

                const leftRatio = typeof stored.relativeLeft === 'number'
                    ? stored.relativeLeft
                    : (stored.left ?? fallback.left) / baseW;
                const topRatio = typeof stored.relativeTop === 'number'
                    ? stored.relativeTop
                    : (stored.top ?? fallback.top) / baseH;

                const maxLeft = Math.max(0, winW - width);
                const maxTop = Math.max(0, winH - height);

                return {
                    left: Math.min(maxLeft, Math.max(0, Math.round(leftRatio * winW))),
                    top: Math.min(maxTop, Math.max(0, Math.round(topRatio * winH))),
                    width: Math.min(width, winW),
                    height: Math.min(height, winH)
                };
            }
            function applyCaptureFrameForLabel(label) {
                const stored = window.captureFrameByLabel[label];
                const rect = resolveCaptureFrameRect(stored);
                captureFrame.style.left = `${rect.left}px`;
                captureFrame.style.top = `${rect.top}px`;
                captureFrame.style.width = `${rect.width}px`;
                captureFrame.style.height = `${rect.height}px`;

                if (label) {
                    window.captureFrameByLabel[label] = {
                        ...(stored || {}),
                        ...rect,
                        windowWidth: Math.max(window.innerWidth, 1),
                        windowHeight: Math.max(window.innerHeight, 1),
                        relativeLeft: rect.left / Math.max(window.innerWidth, 1),
                        relativeTop: rect.top / Math.max(window.innerHeight, 1),
                        relativeWidth: rect.width / Math.max(window.innerWidth, 1),
                        relativeHeight: rect.height / Math.max(window.innerHeight, 1)
                    };
                }
            }
            window.saveCurrentCaptureFrameForLabel = saveCurrentCaptureFrameForLabel;
            window.applyCaptureFrameForLabel = applyCaptureFrameForLabel;

            let captureFrameResizeRaf = null;
            window.addEventListener('resize', () => {
                if (captureFrameResizeRaf !== null) return;
                captureFrameResizeRaf = requestAnimationFrame(() => {
                    captureFrameResizeRaf = null;
                    const activeLabel = window.currentImageLabel;
                    if (typeof window.applyCaptureFrameForLabel === 'function') {
                        window.applyCaptureFrameForLabel(activeLabel);
                    }
                });
            });
            
            // Mobile toolbar expand/collapse functionality
            (function initToolbarToggle() {
                const toolbarWrap = document.querySelector('.toolbar-wrap');
                if (!toolbarWrap) return;
                
                function isMobileDevice() {
                    return window.innerWidth <= 768;
                }
                
                // Track if we've shown the initial glow (only once per page load)
                let hasShownInitialGlow = false;
                let wasScrollable = false;
                let wasExpanded = false;
                
                // Check if toolbar is scrollable (can be expanded)
                function checkIfExpandable() {
                    const isMobile = isMobileDevice();
                    const isExpanded = toolbarWrap.classList.contains('expanded');
                    
                    
                    if (!isMobile || isExpanded) {
                        toolbarWrap.removeAttribute('data-scrollable');
                        toolbarWrap.classList.remove('expandable');
                        // Don't reset flags when expanded - preserve state for when collapsed
                        if (!isMobile) {
                            hasShownInitialGlow = false;
                            wasScrollable = false;
                        }
                        wasExpanded = isExpanded;
                        return;
                    }
                    
                    // Check if content overflows
                    const isScrollable = toolbarWrap.scrollWidth > toolbarWrap.clientWidth;
                    const hadScrollable = toolbarWrap.hasAttribute('data-scrollable');
                    
                    
                    // Set data attribute for CSS hover detection
                    if (isScrollable) {
                        toolbarWrap.setAttribute('data-scrollable', 'true');
                        
                        // Show glow once when transitioning from non-scrollable to scrollable
                        // BUT only if we haven't shown it before AND we're not coming from expanded state
                        const shouldShowGlow = !wasScrollable && !hasShownInitialGlow && !wasExpanded;
                        
                        if (shouldShowGlow) {
                            // Remove inline style to allow animation
                            toolbarWrap.style.removeProperty('box-shadow');
                            toolbarWrap.classList.add('expandable');
                            hasShownInitialGlow = true;
                            
                            // Remove the class after animation completes and clear inline style
                            setTimeout(() => {
                                toolbarWrap.classList.remove('expandable');
                                // Clear inline style so hover can work
                                toolbarWrap.style.removeProperty('box-shadow');
                            }, 500);
                        } else {
                            // Only clear inline style if not hovering and not animating
                            if (!toolbarWrap.matches(':hover') && !toolbarWrap.classList.contains('expanded') && !toolbarWrap.classList.contains('expandable') && !toolbarWrap.classList.contains('tapped')) {
                                toolbarWrap.style.removeProperty('box-shadow');
                            }
                        }
                    } else {
                        toolbarWrap.removeAttribute('data-scrollable');
                        toolbarWrap.classList.remove('expandable');
                        // Reset glow flag when not scrollable (but preserve if we were expanded)
                        if (!wasExpanded) {
                            hasShownInitialGlow = false;
                        }
                    }
                    
                    // Update previous state
                    wasScrollable = isScrollable;
                    wasExpanded = isExpanded;
                }
                
                // Initial check and periodic checks
                setTimeout(() => {
                    checkIfExpandable();
                }, 500);
                
                // Only run periodic checks on mobile (where expand/collapse matters)
                const checkInterval = isMobileDevice() ? setInterval(() => {
                    checkIfExpandable();
                }, 2000) : null;
                
                // Clean up interval if not needed
                if (!checkInterval && !isMobileDevice()) {
                    // On desktop, only check once after initial setup
                    setTimeout(() => {
                        checkIfExpandable();
                    }, 1000);
                }
                
                // Also check on scroll
                toolbarWrap.addEventListener('scroll', () => {
                    clearTimeout(checkIfExpandable.timeout);
                    checkIfExpandable.timeout = setTimeout(() => {
                        checkIfExpandable();
                    }, 300);
                });
                
                function handleToolbarTap(e) {
                    if (!isMobileDevice()) {
                        return;
                    }
                    
                    // Only process if the event target is the toolbar or a child of the toolbar
                    const target = e.target;
                    if (!toolbarWrap.contains(target) && target !== toolbarWrap) {
                        return; // Not a toolbar event, let it pass through
                    }
                    
                    const rect = toolbarWrap.getBoundingClientRect();
                    const tapY = e.clientY || (e.changedTouches && e.changedTouches[0]?.clientY) || 0;
                    const tapX = e.clientX || (e.changedTouches && e.changedTouches[0]?.clientX) || 0;
                    
                    // Check if tap is in the bottom 12px of the toolbar
                    const bottomThreshold = 12;
                    const isBottomTap = tapY >= rect.bottom - bottomThreshold && tapY <= rect.bottom;
                    
                    // Also check if tap is on the toolbar itself (not on a button)
                    const isToolbarArea = tapY >= rect.top && tapY <= rect.bottom && 
                                         tapX >= rect.left && tapX <= rect.right;
                    
                    // Don't toggle if clicking on a button or input
                    const isInteractiveElement = target.tagName === 'BUTTON' || 
                                                target.tagName === 'INPUT' || 
                                                target.closest('button') || 
                                                target.closest('input') ||
                                                target.closest('.color-swatches');
                    
                    
                    if (isBottomTap && isToolbarArea && !isInteractiveElement) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const wasExpanded = toolbarWrap.classList.contains('expanded');
                        
                        // Add glow animation on tap
                        toolbarWrap.classList.remove('tapped');
                        // Remove inline style to allow animation
                        toolbarWrap.style.removeProperty('box-shadow');
                        void toolbarWrap.offsetWidth; // Force reflow
                        toolbarWrap.classList.add('tapped');
                        
                        // Remove tapped class after animation and clear inline style
                        setTimeout(() => {
                            toolbarWrap.classList.remove('tapped');
                            // Clear inline style so hover can work
                            toolbarWrap.style.removeProperty('box-shadow');
                        }, 1000);
                        
                        toolbarWrap.classList.toggle('expanded');
                        
                        // Update topToolbar height
                        const topToolbar = document.getElementById('topToolbar');
                        if (topToolbar) {
                            if (toolbarWrap.classList.contains('expanded')) {
                                topToolbar.style.height = 'auto';
                                topToolbar.style.maxHeight = 'calc(5 * (32px + 6px) + 16px)'; // 5 rows + padding
                            } else {
                                topToolbar.style.height = '48px';
                                topToolbar.style.maxHeight = 'none';
                                // Remove animation classes and clear inline style
                                toolbarWrap.classList.remove('expandable', 'tapped');
                                // Add no-glow class to prevent hover glow from persisting
                                toolbarWrap.classList.add('no-glow');
                                // Temporarily remove data-scrollable to clear any hover glow
                                toolbarWrap.removeAttribute('data-scrollable');
                                toolbarWrap.style.removeProperty('box-shadow');
                                // Force clear any glow immediately
                                toolbarWrap.style.boxShadow = 'none';
                                
                                // Check if mouse is already outside the toolbar (not hovering)
                                const isCurrentlyHovered = toolbarWrap.matches(':hover');
                                
                                // If mouse is already outside, remove no-glow immediately
                                if (!isCurrentlyHovered) {
                                    setTimeout(() => {
                                        toolbarWrap.classList.remove('no-glow');
                                    }, 100); // Small delay to ensure collapse animation completes
                                } else {
                                    // Remove no-glow class when mouse leaves (to allow hover glow again)
                                    const removeNoGlowOnLeave = () => {
                                        if (toolbarWrap.classList.contains('no-glow')) {
                                            toolbarWrap.classList.remove('no-glow');
                                        }
                                    };
                                    toolbarWrap.addEventListener('mouseleave', removeNoGlowOnLeave, { once: true });
                                    
                                    // Also remove after a delay as fallback (for touch devices or if mouseleave doesn't fire)
                                    setTimeout(() => {
                                        if (toolbarWrap.classList.contains('no-glow')) {
                                            toolbarWrap.classList.remove('no-glow');
                                            toolbarWrap.removeEventListener('mouseleave', removeNoGlowOnLeave);
                                        }
                                    }, 1000);
                                }
                            }
                        }
                        
                        // Recheck expandability after toggle
                        setTimeout(() => {
                            // Double-check glow is cleared after collapse
                            if (!toolbarWrap.classList.contains('expanded')) {
                                toolbarWrap.style.boxShadow = 'none';
                                toolbarWrap.style.removeProperty('box-shadow');
                                // Don't remove data-scrollable if no-glow is active (it will prevent glow anyway)
                                if (!toolbarWrap.classList.contains('no-glow')) {
                                    toolbarWrap.removeAttribute('data-scrollable');
                                }
                                // Force reflow to ensure CSS applies
                                void toolbarWrap.offsetWidth;
                            }
                            checkIfExpandable();
                        }, 150);
                    }
                }
                
                // Add event listeners for both click and touch
                toolbarWrap.addEventListener('click', handleToolbarTap);
                toolbarWrap.addEventListener('touchend', handleToolbarTap);
                
                // Handle window resize
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        if (!isMobileDevice() && toolbarWrap.classList.contains('expanded')) {
                            toolbarWrap.classList.remove('expanded');
                            const topToolbar = document.getElementById('topToolbar');
                            if (topToolbar) {
                                topToolbar.style.height = '48px';
                                topToolbar.style.maxHeight = 'none';
                            }
                        }
                        checkIfExpandable();
                    }, 150);
                });
                
                // Cleanup interval on page unload
                window.addEventListener('beforeunload', () => {
                    clearInterval(checkInterval);
                });
            })();
            
            // Enhanced panel toggle functionality with minimize-to-header behavior
            function createPanelToggle(panelId, contentId, buttonId) {
                const panel = document.getElementById(panelId);
                const content = document.getElementById(contentId);
                const button = document.getElementById(buttonId);
                const icon = button?.querySelector('svg');
                
                if (!panel || !content || !button || !icon) return;
                
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Use the specified content element
                    const body = content;
                    const isMinimized = body.classList.contains('hidden');
                    
                    // Special handling for imagePanel: ensure navigation container stays visible
                    if (panelId === 'imagePanel') {
                        const navContainer = document.getElementById('navigation-container');
                        const miniStepper = document.getElementById('mini-stepper');
                        if (navContainer) {
                            // Explicitly ensure navigation container stays visible
                            navContainer.style.display = 'block';
                            navContainer.style.visibility = 'visible';
                            navContainer.style.opacity = '1';
                            navContainer.style.pointerEvents = 'auto';
                        }
                        if (miniStepper) {
                            miniStepper.style.display = 'flex';
                            miniStepper.style.visibility = 'visible';
                            miniStepper.style.opacity = '1';
                            miniStepper.style.pointerEvents = 'auto';
                        }
                    }
                    
                    if (isMinimized) {
                        // Expand panel
                        // starting from hidden (max-height:0), set explicit height to animate open
                        body.classList.remove('hidden');
                        body.style.maxHeight = body.scrollHeight + 'px';
                        // after transition completes, allow natural growth
                        const onEnd = () => {
                            body.style.maxHeight = 'none';
                            body.removeEventListener('transitionend', onEnd);
                        };
                        body.addEventListener('transitionend', onEnd);
                        icon.style.transform = 'rotate(0deg)';
                        panel.classList.remove('minimized');
                        panel.setAttribute('aria-expanded', 'true');
                    } else {
                        // Minimize panel
                        // if maxHeight is none (auto), set current height to enable smooth collapse
                        if (!body.style.maxHeight || body.style.maxHeight === 'none') {
                            body.style.maxHeight = body.scrollHeight + 'px';
                            // force reflow
                            void body.offsetHeight;
                        }
                        // add hidden to animate to max-height:0 via CSS
                        body.classList.add('hidden');
                        icon.style.transform = 'rotate(-90deg)';
                        panel.classList.add('minimized');
                        panel.setAttribute('aria-expanded', 'false');
                        
                        // For imagePanel, ensure navigation stays visible after collapse
                        if (panelId === 'imagePanel') {
                            const navContainer = document.getElementById('navigation-container');
                            const miniStepper = document.getElementById('mini-stepper');
                            if (navContainer) {
                                navContainer.style.display = 'block';
                                navContainer.style.visibility = 'visible';
                                navContainer.style.opacity = '1';
                            }
                            if (miniStepper) {
                                miniStepper.style.display = 'flex';
                                miniStepper.style.visibility = 'visible';
                                miniStepper.style.opacity = '1';
                            }
                        }
                    }
                });
            }
            
            // Apply toggle functionality to all panels (default open for Stroke & Images)
            createPanelToggle('projectPanel', 'projectPanelContent', 'toggleProjectPanel');
            createPanelToggle('toolsPanel', 'toolsPanelContent', 'toggleToolsPanel');
            createPanelToggle('strokePanel', 'elementsBody', 'toggleStrokePanel');
            createPanelToggle('imagePanel', 'imagePanelContent', 'toggleImagePanel');
            createPanelToggle('canvasControls', 'canvasControlsContent', 'toggleCanvasControls');

            // Ensure Vectors and tags and Images are open by default on desktop, closed on mobile
            // Run immediately and also after a short delay to catch any late initialization
            (function expandByDefault() {
                function isMobileDevice() {
                    return window.innerWidth <= 768;
                }
                
                function ensurePanelsExpanded() {
                    const strokePanel = document.getElementById('strokePanel');
                    const imagePanel = document.getElementById('imagePanel');
                const strokeContent = document.getElementById('elementsBody');
                const imageContent = document.getElementById('imagePanelContent');
                    const isMobile = isMobileDevice();
                    
                    if (!strokePanel || !imagePanel) {
                        return;
                    }
                    
                    // On mobile: start minimized (closed), on desktop: start expanded (open)
                    if (isMobile) {
                        // Mobile: minimize panels by default
                        strokePanel.classList.remove('expanded');
                        strokePanel.classList.add('minimized');
                        strokePanel.setAttribute('data-mobile-state', 'minimized');
                        strokePanel.setAttribute('aria-expanded', 'false');
                        strokePanel.style.display = 'none'; // Hide on mobile when minimized
                        
                        imagePanel.classList.remove('expanded');
                        imagePanel.classList.add('minimized');
                        imagePanel.setAttribute('data-mobile-state', 'minimized');
                        imagePanel.setAttribute('aria-expanded', 'false');
                        imagePanel.style.display = 'none'; // Hide on mobile when minimized
                        
                        // Hide content on mobile when minimized
                        if (strokeContent) {
                            strokeContent.classList.add('hidden');
                        }
                        if (imageContent) {
                            imageContent.classList.add('hidden');
                }
                    } else {
                        // Desktop: expand panels by default
                        strokePanel.classList.remove('minimized', 'expanded');
                        strokePanel.setAttribute('data-mobile-state', 'expanded');
                        strokePanel.setAttribute('aria-expanded', 'true');
                        strokePanel.style.display = 'flex';
                        
                        imagePanel.classList.remove('minimized', 'expanded');
                        imagePanel.setAttribute('data-mobile-state', 'expanded');
                        imagePanel.setAttribute('aria-expanded', 'true');
                        imagePanel.style.display = 'flex';
                        
                        // Aggressively ensure content is visible on desktop
                        if (strokeContent) {
                            strokeContent.classList.remove('hidden');
                            strokeContent.style.maxHeight = 'none';
                            strokeContent.style.display = '';
                            strokeContent.style.visibility = '';
                            strokeContent.style.opacity = '';
                        }
                        if (imageContent) {
                            imageContent.classList.remove('hidden');
                            imageContent.style.maxHeight = 'none';
                            imageContent.style.display = '';
                            imageContent.style.visibility = '';
                            imageContent.style.opacity = '';
                        }
                    }
                
                // Mark panels as loaded to enable transitions after initial render
                strokePanel.setAttribute('data-loaded', 'true');
                imagePanel.setAttribute('data-loaded', 'true');
                if (strokeContent) strokeContent.setAttribute('data-loaded', 'true');
                if (imageContent) imageContent.setAttribute('data-loaded', 'true');
                    
                }
                
                // Run immediately
                ensurePanelsExpanded();
                
                // Also run after a short delay to catch any late initialization
                setTimeout(ensurePanelsExpanded, 50);
                setTimeout(ensurePanelsExpanded, 200);
            })();

            // Mobile panel toggle icons functionality
            function isMobileDevice() {
                return window.innerWidth <= 768;
            }

            function initializePanelToggleIcons() {
                const strokePanel = document.getElementById('strokePanel');
                const imagePanel = document.getElementById('imagePanel');
                const strokeIcon = document.getElementById('strokePanelIcon');
                const imageIcon = document.getElementById('imagePanelIcon');

                if (!strokePanel || !imagePanel || !strokeIcon || !imageIcon) {
                    console.warn('Panel toggle icons or panels not found');
                    return;
                }

                // Initialize panel states - start minimized on mobile, expanded on desktop
                const isMobile = isMobileDevice();
                if (!strokePanel.getAttribute('data-mobile-state')) {
                    strokePanel.setAttribute('data-mobile-state', isMobile ? 'minimized' : 'expanded');
                }
                if (!imagePanel.getAttribute('data-mobile-state')) {
                    imagePanel.setAttribute('data-mobile-state', isMobile ? 'minimized' : 'expanded');
                }

                // Sync icon visual state with panel state
                function syncIconState(panel, icon) {
                    icon.classList.remove('minimized', 'expanded');
                    panel.classList.remove('minimized', 'expanded');

                    const isOpen = panel.getAttribute('data-mobile-state') === 'expanded';
                    if (isOpen) {
                        icon.classList.add('expanded');
                        panel.classList.add('expanded');
                        panel.style.display = 'flex';
                        // Ensure panel content is visible
                        const contentId = panel.id === 'strokePanel' ? 'elementsBody' : 'imagePanelContent';
                        const content = document.getElementById(contentId);
                        if (content) {
                            content.classList.remove('hidden');
                            content.style.maxHeight = 'none';
                        }
                    } else {
                        icon.classList.add('minimized');
                        panel.classList.add('minimized');
                        // On mobile, hide the panel when minimized
                        if (isMobileDevice()) {
                            panel.style.display = 'none';
                        }
                    }
                }

                // Toggle panel on icon click
                function setupIconToggle(panel, icon) {
                    icon.addEventListener('click', (e) => {
                        if (!isMobileDevice()) return;
                        e.stopPropagation();

                        const isCurrentlyOpen = panel.getAttribute('data-mobile-state') === 'expanded';
                        panel.setAttribute('data-mobile-state', isCurrentlyOpen ? 'minimized' : 'expanded');
                        syncIconState(panel, icon);
                    });
                }

                // Show/hide icons and panels based on device type
                function updatePanelVisibility() {
                    const isMobile = isMobileDevice();

                    // On desktop, always show panels and ensure content is visible
                    if (!isMobile) {
                        strokePanel.style.display = 'flex';
                        imagePanel.style.display = 'flex';
                        // Hide icons on desktop
                        strokeIcon.style.display = 'none';
                        imageIcon.style.display = 'none';
                        // Ensure content is visible on desktop
                        const strokeContent = document.getElementById('elementsBody');
                        const imageContent = document.getElementById('imagePanelContent');
                        if (strokeContent) {
                            strokeContent.classList.remove('hidden');
                            strokeContent.style.maxHeight = 'none';
                        }
                        if (imageContent) {
                            imageContent.classList.remove('hidden');
                            imageContent.style.maxHeight = 'none';
                        }
                    } else {
                        // On mobile, show icons with smooth fade-in
                        strokeIcon.style.display = 'flex';
                        imageIcon.style.display = 'flex';
                        // Fade in icons smoothly
                        requestAnimationFrame(() => {
                            strokeIcon.style.opacity = '1';
                            imageIcon.style.opacity = '1';
                        });
                        // Sync panel state with icons
                        syncIconState(strokePanel, strokeIcon);
                        syncIconState(imagePanel, imageIcon);
                    }
                }

                // Initialize
                setupIconToggle(strokePanel, strokeIcon);
                setupIconToggle(imagePanel, imageIcon);
                updatePanelVisibility();

                // Update on window resize
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(updatePanelVisibility, 150);
                });
            }

            // Initialize panel toggle icons after a short delay to ensure DOM is ready
            setTimeout(initializePanelToggleIcons, 100);

            // removed elements resize handle wiring

            // Set up Vectors and tags panel button functionality
            const selectAllStrokesBtn = document.getElementById('selectAllStrokesBtn');
            const showAllMeasurementsBtn = document.getElementById('showAllMeasurementsBtn');

            // Select/Deselect All Strokes functionality
            if (selectAllStrokesBtn) {
                let allSelected = false; // Start with deselect all (false)
                selectAllStrokesBtn.addEventListener('click', () => {
                    const checkboxes = document.querySelectorAll('#strokeVisibilityControls input[type="checkbox"]');
                    allSelected = !allSelected;
                    
                    checkboxes.forEach(checkbox => {
                        if (checkbox.checked !== allSelected) {
                            checkbox.click(); // Use click to trigger the existing event handlers
                        }
                    });
                    
                    // Update button text
                    selectAllStrokesBtn.textContent = allSelected ? 'Deselect All' : 'Select All';
                    selectAllStrokesBtn.title = allSelected ? 'Deselect all elements' : 'Select all elements';
                });
            }

            // Show All Measurements functionality
            if (showAllMeasurementsBtn) {
                showAllMeasurementsBtn.addEventListener('click', () => {
                    if (typeof window.generateMeasurementsList === 'function') {
                        window.generateMeasurementsList();
                    }
                });
            }
            
            // View Submitted Measurements functionality
            const viewSubmittedMeasurementsBtn = document.getElementById('viewSubmittedMeasurementsBtn');
            if (viewSubmittedMeasurementsBtn) {
                viewSubmittedMeasurementsBtn.addEventListener('click', () => {
                    if (typeof window.viewSubmittedMeasurements === 'function') {
                        window.viewSubmittedMeasurements();
                    } else {
                        console.error('viewSubmittedMeasurements function not found');
                    }
                });
            }

            // Simplified Tag System
            let tagMode = 'letters+numbers'; // 'letters' or 'letters+numbers'
            
            // Helper function to find next available letter (A, B, C...)
            function findNextAvailableLetter() {
                const currentImageLabel = window.currentImageLabel || 'default';
                const lineStrokes = window.lineStrokesByImage?.[currentImageLabel] || [];
                const existingTags = lineStrokes.filter(Boolean);
                
                // Extract all letters that have been used (from both A and A1 patterns)
                const usedLetters = new Set();
                for (const tag of existingTags) {
                    if (/^[A-Z]/.test(tag)) {
                        usedLetters.add(tag[0]); // Get the first letter
                    }
                }
                
                // Find the first unused letter
                for (let i = 0; i < 26; i++) {
                    const letter = String.fromCharCode(65 + i); // A=65, B=66, etc.
                    if (!usedLetters.has(letter)) {
                        return letter;
                    }
                }
                
                // If all letters A-Z are used, start over at A
                return 'A';
            }
            
            // Helper function to find next available letter+number (A1, A2, A3...)
            function findNextAvailableLetterNumber() {
                const currentImageLabel = window.currentImageLabel || 'default';
                const lineStrokes = window.lineStrokesByImage?.[currentImageLabel] || [];
                const existingTags = lineStrokes.filter(Boolean);
                
                // Extract all base tags (A1, A2, etc.) and track the highest per letter
                const letterCounts = new Map();
                
                for (const tag of existingTags) {
                    // Handle both A1 and A1(1) patterns
                    const match = tag.match(/^([A-Z])(\d+)(?:\((\d+)\))?$/);
                    if (match) {
                        const letter = match[1];
                        const number = parseInt(match[2]);
                        const currentMax = letterCounts.get(letter) || 0;
                        letterCounts.set(letter, Math.max(currentMax, number));
                    }
                }
                
                // Find the next available tag
                for (let letter = 'A'; letter <= 'Z'; letter = String.fromCharCode(letter.charCodeAt(0) + 1)) {
                    const maxNumber = letterCounts.get(letter) || 0;
                    const nextNumber = maxNumber + 1;
                    
                    if (nextNumber <= 9) {
                        return letter + nextNumber;
                    }
                }
                
                // If we've exhausted all possibilities up to Z9, start over at A1
                return 'A1';
            }

            // Tag Mode Toggle functionality
            const tagModeToggle = document.getElementById('tagModeToggle');
            if (tagModeToggle) {
                tagModeToggle.addEventListener('click', () => {
                    const oldMode = tagMode;
                    tagMode = tagMode === 'letters' ? 'letters+numbers' : 'letters';
                    tagModeToggle.textContent = tagMode === 'letters' ? 'Letters Only' : 'Letters + Numbers';
                    
                    // Automatically set the next appropriate tag when switching modes
                    const currentImageLabel = window.currentImageLabel || 'default';
                    window.labelsByImage = window.labelsByImage || {};
                    
                    if (tagMode === 'letters') {
                        // Switching to letters only - find next available letter
                        const nextLetter = findNextAvailableLetter();
                        window.labelsByImage[currentImageLabel] = nextLetter;
                        console.log(`[tagModeToggle] Switched to letters mode, next tag: ${nextLetter}`);
                    } else {
                        // Switching to letters+numbers - find next available letter+number
                        const nextLetterNumber = findNextAvailableLetterNumber();
                        window.labelsByImage[currentImageLabel] = nextLetterNumber;
                        console.log(`[tagModeToggle] Switched to letters+numbers mode, next tag: ${nextLetterNumber}`);
                    }
                    
                    updateNextTagDisplay();
                });
            }

            // Calculate next tag based on current mode and existing tags
            function calculateNextTag() {
                console.log('[calculateNextTag] Called with tagMode:', tagMode);
                const currentImageLabel = window.currentImageLabel || 'default';
                const lineStrokes = window.lineStrokesByImage?.[currentImageLabel] || [];
                const existingTags = lineStrokes.filter(Boolean);
                
                console.log('[calculateNextTag] Current image:', currentImageLabel, 'existing tags:', existingTags);
                
                if (existingTags.length === 0) {
                    const result = tagMode === 'letters' ? 'A' : 'A1';
                    console.log('[calculateNextTag] No existing tags, returning:', result);
                    return result;
                }
                
                // Extract all base tags (without suffixes)
                const baseTags = new Set();
                
                for (const tag of existingTags) {
                    if (tagMode === 'letters') {
                        if (/^[A-Z]$/.test(tag)) {
                            baseTags.add(tag);
                        }
                    } else {
                        // Handle both A1 and A1(1), A1(2) patterns
                        const match = tag.match(/^([A-Z]\d+)(?:\((\d+)\))?$/);
                        if (match) {
                            const baseTag = match[1];
                            baseTags.add(baseTag);
                        }
                    }
                }
                
                if (baseTags.size === 0) {
                    // No valid tags found, start fresh
                    const result = tagMode === 'letters' ? 'A' : 'A1';
                    console.log('[calculateNextTag] No valid tags found, returning:', result);
                    return result;
                }
                
                // Sort tags properly for alphanumeric comparison
                const sortedBaseTags = Array.from(baseTags).sort((a, b) => {
                    if (tagMode === 'letters') {
                        // Simple alphabetic sort for letter-only mode
                        return a.localeCompare(b);
                    } else {
                        // Alphanumeric sort: compare letter first, then number
                        const matchA = a.match(/^([A-Z])(\d+)$/);
                        const matchB = b.match(/^([A-Z])(\d+)$/);
                        
                        if (!matchA || !matchB) return a.localeCompare(b);
                        
                        const [, letterA, numA] = matchA;
                        const [, letterB, numB] = matchB;
                        
                        // Compare letters first
                        if (letterA !== letterB) {
                            return letterA.localeCompare(letterB);
                        }
                        
                        // If same letter, compare numbers numerically
                        return parseInt(numA) - parseInt(numB);
                    }
                });
                
                console.log('[calculateNextTag] Sorted tags:', sortedBaseTags);
                
                if (tagMode === 'letters') {
                    // Letters only mode: Check for gaps first
                    for (let i = 0; i < sortedBaseTags.length - 1; i++) {
                        const currentLetter = sortedBaseTags[i][0];
                        const nextLetter = sortedBaseTags[i + 1][0];
                        const expectedNext = String.fromCharCode(currentLetter.charCodeAt(0) + 1);
                        
                        if (expectedNext !== nextLetter && expectedNext <= 'Z') {
                            console.log('[calculateNextTag] Letters mode, found gap:', expectedNext);
                            return expectedNext;
                        }
                    }
                    
                    // No gaps, increment from last
                    const lastLetter = sortedBaseTags[sortedBaseTags.length - 1][0];
                    const nextLetter = String.fromCharCode(lastLetter.charCodeAt(0) + 1);
                    
                    if (nextLetter > 'Z') {
                        console.log('[calculateNextTag] Letters mode, wrapped to A');
                        return 'A';
                    }
                    
                    console.log('[calculateNextTag] Letters mode, next:', nextLetter);
                    return nextLetter;
                } else {
                    // Letters + numbers mode: Check for gaps first
                    for (let i = 0; i < sortedBaseTags.length; i++) {
                        const match = sortedBaseTags[i].match(/^([A-Z])(\d+)$/);
                        if (!match) continue;
                        
                        const [, letter, number] = match;
                        const num = parseInt(number);
                        
                        // Check if this is the first tag with this letter
                        if (i === 0 || sortedBaseTags[i - 1][0] !== letter) {
                            // If it doesn't start at 1, fill from 1
                            if (num > 1) {
                                const result = letter + '1';
                                console.log('[calculateNextTag] Numbers mode, found gap at start:', result);
                                return result;
                            }
                        }
                        
                        // Check for gaps within the same letter
                        if (i < sortedBaseTags.length - 1) {
                            const nextMatch = sortedBaseTags[i + 1].match(/^([A-Z])(\d+)$/);
                            if (nextMatch) {
                                const [, nextLetter, nextNumber] = nextMatch;
                                const nextNum = parseInt(nextNumber);
                                
                                // If same letter, check for gap
                                if (letter === nextLetter && nextNum > num + 1) {
                                    const result = letter + (num + 1);
                                    console.log('[calculateNextTag] Numbers mode, found gap:', result);
                                    return result;
                                }
                            }
                        }
                    }
                    
                    // No gaps, increment from last
                    const lastBaseTag = sortedBaseTags[sortedBaseTags.length - 1];
                    const match = lastBaseTag.match(/^([A-Z])(\d+)$/);
                    if (match) {
                        const [, letter, number] = match;
                        const nextNumber = parseInt(number) + 1;
                        
                        // Check if we need to move to the next letter
                        if (nextNumber > 9) {
                            const nextLetter = String.fromCharCode(letter.charCodeAt(0) + 1);
                            if (nextLetter > 'Z') {
                                console.log('[calculateNextTag] Numbers mode, wrapped to A1');
                                return 'A1';
                            }
                            const result = nextLetter + '1';
                            console.log('[calculateNextTag] Numbers mode, exceeded 9, next:', result);
                            return result;
                        }
                        
                        const result = letter + nextNumber;
                        console.log('[calculateNextTag] Numbers mode, next:', result);
                        return result;
                    } else {
                        console.log('[calculateNextTag] Unexpected tag format, returning A1');
                        return 'A1';
                    }
                }
            }

            // Calculate the next tag after a specific tag (for manual tag setting)
            // This increments without gap-filling to preserve user intent
            function calculateNextTagFrom(tag) {
                const mode = typeof tagMode === 'string' ? tagMode : 'letters+numbers';
                
                if (mode === 'letters') {
                    // Just increment the letter
                    const nextLetter = String.fromCharCode(tag.charCodeAt(0) + 1);
                    return nextLetter > 'Z' ? 'A' : nextLetter;
                } else {
                    // Letters + numbers mode
                    const match = tag.match(/^([A-Z])(\d+)$/);
                    if (!match) return 'A1';
                    
                    const [, letter, number] = match;
                    const nextNumber = parseInt(number) + 1;
                    
                    if (nextNumber > 9) {
                        // Wrap to next letter
                        const nextLetter = String.fromCharCode(letter.charCodeAt(0) + 1);
                        if (nextLetter > 'Z') {
                            return 'A1'; // Wrap around
                        }
                        return nextLetter + '1';
                    }
                    
                    return letter + nextNumber;
                }
            }

            // Calculate the next tag after a specific tag (simple increment, no gap-filling)
            function calculateNextTagFrom(tag) {
                const mode = typeof tagMode === 'string' ? tagMode : 'letters+numbers';
                
                if (mode === 'letters') {
                    // Just increment the letter
                    const nextLetter = String.fromCharCode(tag.charCodeAt(0) + 1);
                    return nextLetter > 'Z' ? 'A' : nextLetter;
                } else {
                    // Letters + numbers mode
                    const match = tag.match(/^([A-Z])(\d+)$/);
                    if (!match) return 'A1';
                    
                    const [, letter, number] = match;
                    const nextNumber = parseInt(number) + 1;
                    
                    if (nextNumber > 9) {
                        // Wrap to next letter
                        const nextLetter = String.fromCharCode(letter.charCodeAt(0) + 1);
                        if (nextLetter > 'Z') {
                            return 'A1'; // Wrap around
                        }
                        return nextLetter + '1';
                    }
                    
                    return letter + nextNumber;
                }
            }

            // Update the next tag display
            function updateNextTagDisplay() {
                const nextTagDisplay = document.getElementById('nextTagDisplay');
                if (nextTagDisplay) {
                    const currentImageLabel = window.currentImageLabel || 'default';
                    
                    // Priority: 1) labelsByImage (immediate next), 2) manualTagByImage (manual sequence), 3) calculateNextTag (gap-filling)
                    let nextTag;
                    if (window.labelsByImage && window.labelsByImage[currentImageLabel]) {
                        nextTag = window.labelsByImage[currentImageLabel];
                        console.log('[updateNextTagDisplay] Using labelsByImage:', nextTag);
                    } else if (window.manualTagByImage && window.manualTagByImage[currentImageLabel]) {
                        // We're in a manual sequence - use the manual flag value
                        nextTag = window.manualTagByImage[currentImageLabel];
                        console.log('[updateNextTagDisplay] Using manualTagByImage:', nextTag);
                    } else {
                        // Normal gap-filling mode
                        nextTag = calculateNextTag();
                        console.log('[updateNextTagDisplay] Using calculateNextTag (gap-filling):', nextTag);
                    }
                    
                    nextTagDisplay.textContent = nextTag;
                }
            }

            // Initialize next tag display
            updateNextTagDisplay();

            // Make functions available globally for paint.js to call
            window.updateNextTagDisplay = updateNextTagDisplay;
            window.calculateNextTag = calculateNextTag;
            window.calculateNextTagFrom = calculateNextTagFrom;
            console.log('[index.html] Made calculateNextTag available globally:', typeof window.calculateNextTag);
            
            // Allow user to set the next tag directly by typing in the display
            const nextTagEl = document.getElementById('nextTagDisplay');
            
            // Store original value when user starts editing
            let originalTagValue = '';
            
            nextTagEl?.addEventListener('focus', (e) => {
                originalTagValue = e.target.textContent.trim();
                // Select all text for easy replacement
                const range = document.createRange();
                range.selectNodeContents(e.target);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            });
            
            // Handle Enter key to commit changes
            nextTagEl?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur(); // Trigger validation via blur
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    e.target.textContent = originalTagValue;
                    e.target.blur();
                }
            });
            
            // Validate and save on blur
            nextTagEl?.addEventListener('blur', (e) => {
                const mode = typeof tagMode === 'string' ? tagMode : 'letters+numbers';
                const currentImageLabel = window.currentImageLabel || 'default';
                const input = e.target.textContent.trim().toUpperCase();
                
                // If empty or unchanged, restore original
                if (!input || input === originalTagValue) {
                    e.target.textContent = originalTagValue;
                    return;
                }
                
                const valid = mode === 'letters'
                    ? /^[A-Z]$/.test(input)
                    : /^[A-Z]\d+$/.test(input);

                if (!valid) {
                    // Show error briefly and restore original
                    e.target.textContent = '‚ùå Invalid';
                    e.target.classList.add('text-red-600');
                    setTimeout(() => {
                        e.target.textContent = originalTagValue;
                        e.target.classList.remove('text-red-600');
                    }, 1000);
                    return;
                }

                // Ensure labelsByImage exists, then set the next tag seed
                window.labelsByImage = window.labelsByImage || {};
                window.labelsByImage[currentImageLabel] = input;
                
                // Set flag to indicate this was a manual tag (not auto-calculated)
                // This tells the system to increment from this tag, not use gap-filling
                window.manualTagByImage = window.manualTagByImage || {};
                window.manualTagByImage[currentImageLabel] = input;
                
                e.target.textContent = input;
                console.log('[nextTagDisplay] Updated next tag to:', input, '(manual override)');
            });
            
            // Capture frame lock functionality
            let isCaptureLocked = true; // Start locked for minimal appearance
            
            // Initialize capture frame on load
            updateCaptureFrameLockState();
            
            // Lock/unlock button functionality
            const lockButton = document.getElementById('captureLockButton');
            lockButton?.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleCaptureLock();
            });
            
            // Keyboard shortcut for lock/unlock (L key) - ignore when typing in inputs/textareas/selects or contenteditable
            document.addEventListener('keydown', (e) => {
                const target = e.target;
                const isTyping = target && (
                    target.tagName === 'INPUT' ||
                    target.tagName === 'TEXTAREA' ||
                    target.tagName === 'SELECT' ||
                    target.isContentEditable
                );
                if (isTyping) return;
                if (e.key && e.key.toLowerCase() === 'l') {
                    e.preventDefault();
                    toggleCaptureLock();
                }
            });
            
            function toggleCaptureLock() {
                isCaptureLocked = !isCaptureLocked;
                updateCaptureFrameLockState();
                showLockPopup();
            }
            
            function showLockPopup() {
                const popup = document.getElementById('lockPopup');
                const icon = document.getElementById('lockPopupIcon');
                const text = document.getElementById('lockPopupText');
                
                if (isCaptureLocked) {
                    text.textContent = 'Locked';
                    icon.innerHTML = '<path d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"></path>';
                } else {
                    text.textContent = 'Unlocked';
                    icon.innerHTML = '<path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z"></path>';
                }
                
                popup.classList.add('show');
                setTimeout(() => {
                    popup.classList.remove('show');
                }, 1500);
            }
            
            function updateCaptureFrameLockState() {
                const lockButton = document.getElementById('captureLockButton');
                const instructions = document.getElementById('unlockInstructions');
                const applyAllButton = document.getElementById('applyFitAll');
                
                if (isCaptureLocked) {
                    captureFrame.classList.add('locked');
                    captureFrame.classList.remove('unlocked');
                    lockButton.classList.add('locked');
                    lockButton.title = 'Unlock frame (L)';
                    instructions.classList.add('hidden');
                    
                    // Hide Apply All button for safety
                    if (applyAllButton) {
                        applyAllButton.style.display = 'none';
                    }
                    
                    // Use white overlay outside the frame for clarity
                    captureFrame.style.boxShadow = '0 0 0 2000px rgba(255,255,255,1)';
                    
                    // Enable pointer events for lock button only
                    captureFrame.style.pointerEvents = 'none';
                    lockButton.style.pointerEvents = 'auto';
                } else {
                    captureFrame.classList.remove('locked');
                    captureFrame.classList.add('unlocked');
                    lockButton.classList.remove('locked');
                    lockButton.title = 'Lock frame (L)';
                    instructions.classList.remove('hidden');
                    
                    // Show Apply All button when unlocked
                    if (applyAllButton) {
                        applyAllButton.style.display = 'inline-block';
                    }
                    
                    // Remove overlay when unlocked for transparent background while adjusting
                    captureFrame.style.boxShadow = 'none';
                    
                    // Enable pointer events for dragging and resizing
                    captureFrame.style.pointerEvents = 'auto';
                    lockButton.style.pointerEvents = 'auto';
                }
            }
            
            
            // Color picker functionality
            const colorButtons = document.querySelectorAll('[data-color]');
            colorButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Remove active class from all buttons
                    colorButtons.forEach(btn => btn.classList.remove('active'));
                    // Add active class to clicked button
                    button.classList.add('active');
                    // Update color picker value
                    const colorPicker = document.getElementById('colorPicker');
                    if (colorPicker) {
                        colorPicker.value = button.getAttribute('data-color');
                        // Trigger change event for existing functionality
                        colorPicker.dispatchEvent(new Event('change'));
                    }
                });
            });
            
            // Update active color button styling
            const style = document.createElement('style');
            style.textContent = `
                [data-color].active {
                    border-color: #374151 !important;
                    box-shadow: 0 0 0 2px white, 0 0 0 4px #374151 !important;
                    transform: scale(1.1);
                }
            `;
            document.head.appendChild(style);
            
            // Capture frame resize functionality
            let isResizing = false;
            let currentHandle = null;
            let startPos = { x: 0, y: 0 };
            let startRect = { x: 0, y: 0, width: 0, height: 0 };
            
            const resizeHandles = document.querySelectorAll('.resize-handle');
            resizeHandles.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    // Don't allow resizing when locked
                    if (isCaptureLocked) return;
                    
                    e.preventDefault();
                    isResizing = true;
                    currentHandle = handle.getAttribute('data-direction');
                    startPos = { x: e.clientX, y: e.clientY };
                    
                    const rect = captureFrame.getBoundingClientRect();
                    startRect = {
                        x: rect.left,
                        y: rect.top,
                        width: rect.width,
                        height: rect.height
                    };
                    
                    document.addEventListener('mousemove', handleResize);
                    document.addEventListener('mouseup', stopResize);
                });
            });
            
            function handleResize(e) {
                if (!isResizing || !currentHandle) return;
                
                const deltaX = e.clientX - startPos.x;
                const deltaY = e.clientY - startPos.y;
                
                let newX = startRect.x;
                let newY = startRect.y;
                let newWidth = startRect.width;
                let newHeight = startRect.height;
                
                // Handle different resize directions
                switch (currentHandle) {
                    case 'nw':
                        newX = startRect.x + deltaX;
                        newY = startRect.y + deltaY;
                        newWidth = startRect.width - deltaX;
                        newHeight = startRect.height - deltaY;
                        break;
                    case 'n':
                        newY = startRect.y + deltaY;
                        newHeight = startRect.height - deltaY;
                        break;
                    case 'ne':
                        newY = startRect.y + deltaY;
                        newWidth = startRect.width + deltaX;
                        newHeight = startRect.height - deltaY;
                        break;
                    case 'e':
                        newWidth = startRect.width + deltaX;
                        break;
                    case 'se':
                        newWidth = startRect.width + deltaX;
                        newHeight = startRect.height + deltaY;
                        break;
                    case 's':
                        newHeight = startRect.height + deltaY;
                        break;
                    case 'sw':
                        newX = startRect.x + deltaX;
                        newWidth = startRect.width - deltaX;
                        newHeight = startRect.height + deltaY;
                        break;
                    case 'w':
                        newX = startRect.x + deltaX;
                        newWidth = startRect.width - deltaX;
                        break;
                }
                
                // Apply minimum size constraints
                const minSize = 100;
                if (newWidth < minSize) {
                    if (currentHandle.includes('w')) newX = startRect.x + startRect.width - minSize;
                    newWidth = minSize;
                }
                if (newHeight < minSize) {
                    if (currentHandle.includes('n')) newY = startRect.y + startRect.height - minSize;
                    newHeight = minSize;
                }
                
                // Apply maximum size constraints (viewport bounds)
                const maxX = window.innerWidth - newWidth;
                const maxY = window.innerHeight - newHeight;
                newX = Math.max(0, Math.min(maxX, newX));
                newY = Math.max(0, Math.min(maxY, newY));
                
                // Update capture frame position and size
                captureFrame.style.left = newX + 'px';
                captureFrame.style.top = newY + 'px';
                captureFrame.style.width = newWidth + 'px';
                captureFrame.style.height = newHeight + 'px';
                
            }
            
            function stopResize() {
                isResizing = false;
                currentHandle = null;
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
                // Save per-image frame when resizing ends
                if (typeof window.currentImageLabel !== 'undefined') {
                    saveCurrentCaptureFrameForLabel(window.currentImageLabel);
                    
                    // Store the frame dimensions as a ratio of canvas size
                    const canvas = document.getElementById('canvas');
                    const frameRect = captureFrame.getBoundingClientRect();
                    
                    if (!window.manualFrameRatios) {
                        window.manualFrameRatios = {};
                    }
                    
                    window.manualFrameRatios[window.currentImageLabel] = {
                        widthRatio: frameRect.width / canvas.clientWidth,
                        heightRatio: frameRect.height / canvas.clientHeight,
                        leftRatio: frameRect.left / canvas.clientWidth,
                        topRatio: frameRect.top / canvas.clientHeight
                    };
                    
                    console.log(`[FRAME] Saved ${window.currentImageLabel} frame ratios: ${(window.manualFrameRatios[window.currentImageLabel].widthRatio * 100).toFixed(1)}% width, ${(window.manualFrameRatios[window.currentImageLabel].heightRatio * 100).toFixed(1)}% height`);
                }
            }
            
            // Optimized capture frame dragging - 1:1 movement with no lag
            let isCaptureDragging = false;
            let captureDragOffset = { x: 0, y: 0 };
            let lastCaptureMousePos = { x: 0, y: 0 };
            let captureRafId = null;
            
            captureFrame.addEventListener('mousedown', (e) => {
                // Don't drag if locked, clicking on handles, or buttons
                if (isCaptureLocked || e.target.classList.contains('resize-handle') || e.target.closest('button')) {
                    return;
                }
                
                // Allow Shift+click to pass through for canvas dragging
                if (e.shiftKey) {
                    return;
                }
                
                e.preventDefault();
                e.stopPropagation();
                
                isCaptureDragging = true;
                
                const rect = captureFrame.getBoundingClientRect();
                captureDragOffset.x = e.clientX - rect.left;
                captureDragOffset.y = e.clientY - rect.top;
                
                // Add dragging class for no transitions
                captureFrame.classList.add('dragging');
                
                document.addEventListener('mousemove', handleCaptureDrag, { passive: true });
                document.addEventListener('mouseup', stopCaptureDrag);
            });
            
            function handleCaptureDrag(e) {
                if (!isCaptureDragging || isCaptureLocked) return;
                
                // Store mouse position for RAF
                lastCaptureMousePos.x = e.clientX;
                lastCaptureMousePos.y = e.clientY;
                
                // Cancel previous RAF if still pending
                if (captureRafId) {
                    cancelAnimationFrame(captureRafId);
                }
                
                // Schedule position update for next frame
                captureRafId = requestAnimationFrame(updateCapturePosition);
            }
            
            function updateCapturePosition() {
                if (!isCaptureDragging) return;
                
                const newX = Math.max(0, Math.min(window.innerWidth - captureFrame.offsetWidth, lastCaptureMousePos.x - captureDragOffset.x));
                const newY = Math.max(0, Math.min(window.innerHeight - captureFrame.offsetHeight, lastCaptureMousePos.y - captureDragOffset.y));
                
                // Apply position immediately
                captureFrame.style.left = newX + 'px';
                captureFrame.style.top = newY + 'px';
                
                
                captureRafId = null;
            }
            
            function stopCaptureDrag() {
                if (!isCaptureDragging) return;
                
                isCaptureDragging = false;
                
                // Cancel any pending RAF
                if (captureRafId) {
                    cancelAnimationFrame(captureRafId);
                    captureRafId = null;
                }
                
                // Remove dragging class
                captureFrame.classList.remove('dragging');
                
                document.removeEventListener('mousemove', handleCaptureDrag);
                document.removeEventListener('mouseup', stopCaptureDrag);
                // Save per-image frame when dragging ends
                if (typeof window.currentImageLabel !== 'undefined') {
                    saveCurrentCaptureFrameForLabel(window.currentImageLabel);
                }
            }
            
            // Optimized draggable functionality - 1:1 mouse movement with requestAnimationFrame
            function makeDraggable(element, handle) {
                let isDragging = false;
                let dragOffset = { x: 0, y: 0 };
                let lastMousePos = { x: 0, y: 0 };
                let rafId = null;
                let elementWidth, elementHeight; // Cache dimensions
                
                handle.addEventListener('mousedown', (e) => {
                    // Don't start drag if clicking on buttons or inputs
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.closest('button')) {
                        return;
                    }
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isDragging = true;
                    
                    // Simplified position setup - get current position directly
                    const rect = element.getBoundingClientRect();
                    
                    // Calculate offset from mouse to element's current position
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    // Cache element dimensions to avoid repeated DOM queries
                    elementWidth = element.offsetWidth;
                    elementHeight = element.offsetHeight;
                    
                    // Set initial position and prepare for dragging
                    element.style.position = 'fixed';
                    element.style.left = rect.left + 'px';
                    element.style.top = rect.top + 'px';
                    element.style.transform = 'none';
                    
                    // Clear conflicting positioning styles when dragging starts
                    element.style.bottom = 'auto';
                    element.style.right = 'auto';
                    
                    // Add visual feedback immediately
                    element.classList.add('dragging');
                    document.body.style.userSelect = 'none';
                    
                    document.addEventListener('mousemove', onMouseMove, { passive: true });
                    document.addEventListener('mouseup', stopDrag);
                });
                
                function onMouseMove(e) {
                    if (!isDragging) return;
                    
                    // Store mouse position for RAF
                    lastMousePos.x = e.clientX;
                    lastMousePos.y = e.clientY;
                    
                    // Cancel previous RAF if still pending
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                    }
                    
                    // Schedule position update for next frame
                    rafId = requestAnimationFrame(updatePosition);
                }
                
                function updatePosition() {
                    if (!isDragging) return;
                    
                    // Calculate new position from mouse minus offset
                    const newX = Math.max(0, Math.min(window.innerWidth - elementWidth, lastMousePos.x - dragOffset.x));
                    const newY = Math.max(0, Math.min(window.innerHeight - elementHeight, lastMousePos.y - dragOffset.y));
                    
                    // Apply position immediately using left/top for immediate visual feedback
                    element.style.left = newX + 'px';
                    element.style.top = newY + 'px';
                    
                    rafId = null;
                }
                
                function stopDrag(e) {
                    if (!isDragging) return;
                    
                    isDragging = false;
                    
                    // Cancel any pending RAF
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                        rafId = null;
                    }
                    
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', stopDrag);
                    
                    // Reset visual feedback
                    element.classList.remove('dragging');
                    document.body.style.userSelect = '';
                }
            }
            
            // Make all floating panels draggable by their headers
            const floatingPanels = document.querySelectorAll('.floating-panel');
            floatingPanels.forEach(panel => {
                const header = panel.querySelector('.cursor-move');
                if (header) {
                    header.style.cursor = 'move';
                    makeDraggable(panel, header);
                }
            });
            
            // Scale dropdown functionality
            const scaleButton = document.getElementById('scaleButton');
            const scaleDropdown = document.getElementById('scaleDropdown');
            
            if (scaleButton && scaleDropdown) {
                scaleButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // Position the dropdown relative to the button with boundary checks
                    const buttonRect = scaleButton.getBoundingClientRect();
                    const dropdownWidth = 80; // min-width from CSS
                    const dropdownHeight = 320; // approximate height for all options
                    
                    let left = buttonRect.left;
                    let top = buttonRect.bottom + 2;
                    
                    // Check right boundary
                    if (left + dropdownWidth > window.innerWidth) {
                        left = buttonRect.right - dropdownWidth;
                    }
                    
                    // Check left boundary
                    if (left < 0) {
                        left = 0;
                    }
                    
                    // Check bottom boundary - show above button if no room below
                    if (top + dropdownHeight > window.innerHeight) {
                        top = buttonRect.top - dropdownHeight - 2;
                    }
                    
                    // Check top boundary
                    if (top < 0) {
                        top = buttonRect.bottom + 2; // fallback to below button
                    }
                    
                    scaleDropdown.style.left = left + 'px';
                    scaleDropdown.style.top = top + 'px';
                    
                    scaleDropdown.classList.toggle('hidden');
                });
                
                document.addEventListener('click', () => {
                    scaleDropdown.classList.add('hidden');
                });
                
                scaleDropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                // Handle scale option selection
                const scaleOptions = scaleDropdown.querySelectorAll('.scale-option');
                scaleOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        const scale = option.dataset.scale;
                        const percentage = Math.round(parseFloat(scale) * 100);
                        scaleButton.innerHTML = `${percentage}% <svg class="inline w-3 h-3 -mt-0.5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M5.25 7.5l4.5 4.5 4.5-4.5H5.25z"/></svg>`;
                        scaleDropdown.classList.add('hidden');
                    });
                });
            }
            
            // Custom dash controls functionality
            const dashStyleSelect = document.getElementById('dashStyleSelect');
            const customDashControls = document.getElementById('customDashControls');
            
            if (dashStyleSelect && customDashControls) {
                dashStyleSelect.addEventListener('change', () => {
                    if (dashStyleSelect.value === 'custom') {
                        customDashControls.classList.remove('hidden');
                        customDashControls.classList.add('flex');
                    } else {
                        customDashControls.classList.add('hidden');
                        customDashControls.classList.remove('flex');
                    }
                });
            }

            // Enhanced Image Gallery (Moved to image-gallery.js)

            // Toolbar visibility is handled by CSS via toolbar-ready class
            // No need to set inline styles here

            // Store reference to original addImageToSidebar if it exists
            const originalAddImageToSidebar = window.addImageToSidebar;
            
            // Enhanced compatibility function that works with both new and old formats
            // NOTE: This is replaced by the [HOOK] wrapper when paint.js loads
            window.addImageToSidebar = function(imageUrl, label, filename) {
                console.log('[COMPAT] addImageToSidebar called with:', { imageUrl: imageUrl?.substring?.(0, 50) || imageUrl, label, filename });
                
                // Call original function first if it exists (for backwards compatibility)
                if (originalAddImageToSidebar && typeof originalAddImageToSidebar === 'function') {
                    try {
                        originalAddImageToSidebar.apply(this, arguments);
                        
                        // Verify imageList was updated
                        const imageList = document.getElementById('imageList');
                        if (imageList) {
                            const containers = imageList.querySelectorAll('.image-container');
                            console.log(`[COMPAT] imageList has ${containers.length} containers after original function`);
                        }
                    } catch (error) {
                        console.warn('[COMPAT] Original addImageToSidebar failed:', error);
                    }
                } else {
                    console.warn('[COMPAT] No original addImageToSidebar function available');
                }
                
                // Add to new gallery
                if (imageUrl) {
                    const index = imageGalleryData.length;
                    const imageData = {
                        src: imageUrl,
                        url: imageUrl,
                        name: filename || label || `Image ${index + 1}`,
                        label: label,
                        filename: filename
                    };
                    
                    addImageToGallery(imageData, index);
                    console.log('[COMPAT] Added to new gallery at index', index, 'Total images now:', imageGalleryData.length);
                    
                    return index;
                } else {
                    console.warn('[COMPAT] No valid imageUrl provided');
                    return -1;
                }
            };
            
            window.switchToImage = function(imageIndexOrLabel) {
                // If it's a number, treat as gallery index
                if (typeof imageIndexOrLabel === 'number') {
                    navigateToImage(imageIndexOrLabel);
                    console.log('[COMPAT] Switched to image index:', imageIndexOrLabel);
                } 
                // If it's a string (label), use ProjectManager
                else if (typeof imageIndexOrLabel === 'string') {
                    const label = imageIndexOrLabel;
                    console.log('[COMPAT] Switched to image label:', label);
                    
                    // Try ProjectManager first
                    if (window.projectManager && typeof window.projectManager.switchView === 'function') {
                        window.projectManager.switchView(label);
                    } 
                    // Fallback to legacy system
                    else if (window.switchToImageLegacy && typeof window.switchToImageLegacy === 'function') {
                        window.switchToImageLegacy(label);
                    } else {
                        console.warn('[COMPAT] No switchToImage implementation available');
                    }
                }
            };
            
            // Legacy image list compatibility
            window.updateImageList = function() {
                // This function exists for compatibility but the new gallery handles updates automatically
                console.log('[COMPAT] updateImageList called - handled by new gallery system');
            };
            
            // Clear images function
            window.clearImageSidebar = function() {
                clearImageGallery();
                console.log('[COMPAT] Cleared image sidebar');
            };
            
            console.log('[INIT] Image gallery and compatibility functions initialized');
            
            // Setup container-level drag auto-scroll
            const imageListContainer = document.getElementById('imageList');
            if (imageListContainer) {
                imageListContainer.addEventListener('dragover', (e) => {
                    const rect = imageListContainer.getBoundingClientRect();
                    const scrollThreshold = 80; // Distance from edge to trigger scroll
                    const scrollSpeed = 10; // Pixels per scroll
                    const mouseY = e.clientY;
                    
                    // Clear any existing scroll interval
                    if (window.dragScrollInterval) {
                        clearInterval(window.dragScrollInterval);
                        window.dragScrollInterval = null;
                    }
                    
                    // Check if near top edge
                    if (mouseY - rect.top < scrollThreshold && mouseY > rect.top) {
                        let scrolling = true;
                        const scroll = () => {
                            if (!scrolling) return;
                            imageListContainer.scrollBy(0, -scrollSpeed);
                            window.dragScrollFrame = requestAnimationFrame(scroll);
                        };
                        scrolling = true;
                        window.dragScrollFrame = requestAnimationFrame(scroll);
                    }
                    // Check if near bottom edge
                    else if (rect.bottom - mouseY < scrollThreshold && mouseY < rect.bottom) {
                        let scrolling = true;
                        const scroll = () => {
                            if (!scrolling) return;
                            imageListContainer.scrollBy(0, scrollSpeed);
                            window.dragScrollFrame = requestAnimationFrame(scroll);
                        };
                        scrolling = true;
                        window.dragScrollFrame = requestAnimationFrame(scroll);
                    }
                });
                
                // Clear scroll animation when drag ends anywhere
                const stopScrolling = () => {
                    if (window.dragScrollInterval) {
                        clearInterval(window.dragScrollInterval);
                        window.dragScrollInterval = null;
                    }
                    if (window.dragScrollFrame) {
                        cancelAnimationFrame(window.dragScrollFrame);
                        window.dragScrollFrame = null;
                    }
                };

                imageListContainer.addEventListener('drop', stopScrolling);
                
                imageListContainer.addEventListener('dragleave', (e) => {
                    // Only clear if leaving the container entirely
                    if (e.target === imageListContainer) {
                        stopScrolling();
                    }
                });
            }
            
            // Debug function to inspect paint.js state
            window.debugPaintState = function() {
                console.log('=== PAINT.JS STATE DEBUG ===');
                
                if (window.paintApp && window.paintApp.state) {
                    console.log('Current image label:', window.paintApp.state.currentImageLabel);
                    console.log('Paint app state keys:', Object.keys(window.paintApp.state));
                }
                
                if (window.vectorStrokesByImage) {
                    const labels = Object.keys(window.vectorStrokesByImage);
                    console.log('vectorStrokesByImage labels:', labels);
                    labels.forEach(label => {
                        const strokes = window.vectorStrokesByImage[label];
                        console.log(`  ${label}: ${Object.keys(strokes || {}).length} strokes`);
                    });
                } else {
                    console.log('vectorStrokesByImage not found');
                }
                
                if (window.customLabelPositions) {
                    const labels = Object.keys(window.customLabelPositions);
                    console.log('customLabelPositions labels:', labels);
                } else {
                    console.log('customLabelPositions not found');
                }
                
                console.log('imageGalleryData length:', imageGalleryData.length);
                console.log('currentImageIndex:', currentImageIndex);
                if (imageGalleryData[currentImageIndex]) {
                    console.log('Current image:', imageGalleryData[currentImageIndex].name, imageGalleryData[currentImageIndex].original?.label);
                    console.log('Full current image data:', JSON.stringify(imageGalleryData[currentImageIndex], null, 2));
                }
                
                // Also debug all gallery images
                console.log('All gallery images:');
                imageGalleryData.forEach((img, index) => {
                    console.log(`  [${index}] ${img.name}: label=${img.original?.label}, isBlankCanvas=${img.original?.isBlankCanvas}`);
                });
            };
            
            // Test function to add mock drawing data for blank canvas
            window.addTestTriangle = function() {
                // Try to get the actual current image label from gallery
                let targetLabel = 'blank_canvas'; // fallback
                if (imageGalleryData[currentImageIndex]?.original?.label) {
                    targetLabel = imageGalleryData[currentImageIndex].original.label;
                }
                const paintLabel = window.paintApp?.state?.currentImageLabel;
                
                console.log(`[Test] Gallery current index: ${currentImageIndex}`);
                console.log(`[Test] Gallery target label: ${targetLabel}`);
                console.log(`[Test] Paint.js current label: ${paintLabel}`);
                console.log(`[Test] Adding test triangle to label: ${targetLabel}`);
                
                // Mock stroke data for a simple triangle
                const mockStroke = {
                    points: [
                        { x: 300, y: 200 },  // Top point
                        { x: 200, y: 400 },  // Bottom left
                        { x: 400, y: 400 },  // Bottom right
                        { x: 300, y: 200 }   // Back to top
                    ],
                    color: '#ff0000',
                    thickness: 3,
                    type: 'freehand'
                };
                
                // Add to both global and paint.js state
                if (window.vectorStrokesByImage) {
                    if (!window.vectorStrokesByImage[targetLabel]) {
                        window.vectorStrokesByImage[targetLabel] = {};
                    }
                    window.vectorStrokesByImage[targetLabel]['test_triangle'] = mockStroke;
                }
                
                if (window.paintApp?.state?.vectorStrokesByImage) {
                    if (!window.paintApp.state.vectorStrokesByImage[targetLabel]) {
                        window.paintApp.state.vectorStrokesByImage[targetLabel] = {};
                    }
                    window.paintApp.state.vectorStrokesByImage[targetLabel]['test_triangle'] = mockStroke;
                }
                
                // Also switch paint.js to the correct label if it's not already there
                if (paintLabel !== targetLabel && window.switchToImage) {
                    console.log(`[Test] Switching paint.js from '${paintLabel}' to '${targetLabel}'`);
                    window.switchToImage(targetLabel);
                }
                
                console.log(`[Test] Added test triangle. Use debugPaintState() to verify.`);
                
                // Redraw if function exists
                if (window.redrawCanvasWithVisibility) {
                    window.redrawCanvasWithVisibility();
                }
            };
            
            // Note: Stored centroid system removed - blank canvas now uses fixed canvas center
            
            // Test function to try rotating the current image
            window.testRotate = function() {
                console.log(`[Test] Testing rotation on current image (index ${currentImageIndex})`);
                if (currentImageIndex >= 0 && currentImageIndex < imageGalleryData.length) {
                    const imageData = imageGalleryData[currentImageIndex];
                    console.log(`[Test] Rotating image: ${imageData.name}`);
                    rotateImage(currentImageIndex, 90);
                } else {
                    console.log(`[Test] Invalid image index: ${currentImageIndex}`);
                }
            };
            
            // Hook into addImageToSidebar after external scripts load
            let hookAttempts = 0;
            const maxHookAttempts = 50;
            
            function attemptHook() {
                hookAttempts++;
                
                // Check if paint.js has loaded and defined its own addImageToSidebar
                if (window.addImageToSidebar && typeof window.addImageToSidebar === 'function') {
                    console.log('[HOOK] Found original addImageToSidebar from paint.js, hooking into it...');
                    console.log('[HOOK] Function source preview:', window.addImageToSidebar.toString().substring(0, 200));
                    
                    // Store the original function
                    const paintJsAddImageToSidebar = window.addImageToSidebar;
                    
                    // Create our intercepting function
                    window.addImageToSidebar = function(imageUrl, label, filename) {
                        console.log('[HOOK] Intercepted addImageToSidebar call:', { imageUrl: imageUrl?.substring?.(0, 50) || imageUrl, label, filename });
                        
                        // Ensure imageList exists before calling original function
                        const imageList = document.getElementById('imageList');
                        if (!imageList) {
                            console.error('[HOOK] imageList element not found!');
                        }
                        
                        // Call the original paint.js function
                        let result;
                        try {
                            result = paintJsAddImageToSidebar.apply(this, arguments);
                            
                            // Verify the container was added for this specific label
                            const imageListAfter = document.getElementById('imageList');
                            if (imageListAfter) {
                                const containers = imageListAfter.querySelectorAll('.image-container');
                                const containerForLabel = imageListAfter.querySelector(`[data-label="${label}"]`);
                                console.log(`[HOOK] imageList now has ${containers.length} containers after addImageToSidebar`);
                                
                                // If no container exists for this label, create one manually
                                if (!containerForLabel && imageUrl && label) {
                                    console.warn(`[HOOK] No container found for label "${label}", creating one manually`);
                                    const container = document.createElement('button');
                                    container.type = 'button';
                                    container.draggable = true;
                                    container.className = 'image-container group w-full text-left relative flex items-center gap-3 p-3 rounded-xl hover:bg-slate-50 transition-colors snap-center';
                                    container.dataset.label = label;
                                    container.dataset.originalImageUrl = imageUrl;
                                    
                                    const img = document.createElement('img');
                                    img.src = imageUrl;
                                    img.className = 'pasted-image w-full h-40 rounded-lg object-contain bg-slate-100 shadow-sm';
                                    img.alt = `${label} view`;
                                    
                                    container.appendChild(img);

                                    // Add delete button
                                    const deleteBtn = document.createElement('button');
                                    deleteBtn.className = 'delete-image-btn opacity-0 group-hover:opacity-100 transition-opacity';
                                    deleteBtn.title = 'Delete image';
                                    deleteBtn.textContent = '√ó';
                                    // Inline styles to match reference
                                    deleteBtn.style.cssText = 'position: absolute; top: 6px; right: 6px; cursor: pointer; background: rgba(255, 255, 255, 0.9); border: 1px solid rgb(204, 204, 204); border-radius: 50%; width: 20px; height: 20px; font-size: 12px; font-weight: bold; font-family: Arial, sans-serif; display: flex; align-items: center; justify-content: center; z-index: 10; color: rgb(102, 102, 102); line-height: 1; padding: 0px; margin: 0px; text-align: center;';
                                    
                                    deleteBtn.addEventListener('click', (e) => {
                                        e.stopPropagation();
                                        if (confirm('Delete this image?')) {
                                            container.remove();
                                            if (window.projectManager && typeof window.projectManager.deleteImage === 'function') {
                                                window.projectManager.deleteImage(label);
                                            }
                                            
                                            // Update pills
                                            if (typeof updatePills === 'function') updatePills();
                                            if (typeof updateActivePill === 'function') updateActivePill();
                                            if (typeof updateImageListPadding === 'function') updateImageListPadding();
                                        }
                                    });
                                    
                                    container.appendChild(deleteBtn);

                                    container.onclick = () => {
                                        if (window.projectManager && typeof window.projectManager.switchView === 'function') {
                                            window.projectManager.switchView(label);
                                        }
                                        // Scroll this container to center
                                        container.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                                        
                                        // Temporarily disable scroll-driven switching to prevent fighting
                                        window.__imageListProgrammaticScrollUntil = Date.now() + 500;
                                    };
                                    
                                    imageListAfter.appendChild(container);
                                    console.log(`[HOOK] Manually added container to imageList for label "${label}"`);

                                    if (typeof window.ensureImageListObserver === 'function') {
                                        window.ensureImageListObserver();
                                    } else {
                                        window.__pendingImageListObserverInit = true;
                                    }
                                    
                                    if (typeof updateImageListPadding === 'function') {
                                        updateImageListPadding();
                                    }
                                    
                                    // Initialize observer if not already done, or observe this new container
                                    if (typeof initImageListCenteringObserver === 'function') {
                                        // Initialize observer if it doesn't exist yet
                                        if (!window.__imageListCenteringObserver) {
                                            initImageListCenteringObserver();
                                        }
                                        // Observer will automatically pick up new containers via MutationObserver
                                        // But we can also explicitly observe this one immediately
                                        if (window.__imageListCenteringObserver) {
                                            window.__imageListCenteringObserver.observe(container);
                                        }
                                    }
                                    
                                    // Center the newly added image and switch to it if it's the first image
                                    setTimeout(() => {
                                        const allContainers = Array.from(imageListAfter.querySelectorAll('.image-container'));
                                        const isFirst = allContainers.length === 1 && allContainers[0] === container;
                                        
                                        if (isFirst) {
                                            console.log(`[HOOK] First image "${label}" added, centering and switching to it`);
                                            
                                            // Center the container
                                            window.__imageListProgrammaticScrollUntil = Date.now() + 1000;
                                            container.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                                            
                                            // Switch to this view
                                            if (window.projectManager && typeof window.projectManager.switchView === 'function') {
                                                window.projectManager.switchView(label);
                                            }
                                        }
                                        
                                        // Trigger mini-stepper update after adding to sidebar
                                        if (typeof updatePills === 'function') {
                                            updatePills();
                                        }
                                        if (typeof updateActivePill === 'function') {
                                            updateActivePill();
                                        }
                                    }, 100);
                                } else if (containerForLabel) {
                                    console.log(`[HOOK] Container for label "${label}" already exists in imageList`);
                                    
                                    // Update pills only, don't switch views for existing containers
                                    setTimeout(() => {
                                        if (typeof updatePills === 'function') {
                                            updatePills();
                                        }
                                        if (typeof updateActivePill === 'function') {
                                            updateActivePill();
                                        }
                                    }, 100);

                                    if (typeof updateImageListPadding === 'function') {
                                        updateImageListPadding();
                                    }
                                }
                            } else if (!imageListAfter) {
                                console.error('[HOOK] imageList element not found after addImageToSidebar call!');
                            }
                        } catch (error) {
                            console.error('[HOOK] Error calling original addImageToSidebar:', error);
                            // Don't throw - try to continue with gallery addition
                        }
                        
                        // Add to our new gallery
                        if (imageUrl) {
                            const index = imageGalleryData.length;
                            const imageData = {
                                src: imageUrl,
                                url: imageUrl,
                                name: filename || label || `Image ${index + 1}`,
                                label: label,
                                filename: filename
                            };
                            
                            addImageToGallery(imageData, index);
                            console.log('[HOOK] Added to new gallery at index', index);
                        }
                        
                        return result;
                    };
                    
                    console.log('[HOOK] Successfully hooked addImageToSidebar');
                    return true;
                } else if (hookAttempts < maxHookAttempts) {
                    if (window.__DEBUG__) console.log('[HOOK] Attempt', hookAttempts, '- addImageToSidebar not ready yet:', typeof window.addImageToSidebar);
                    setTimeout(attemptHook, 100);
                } else {
                    if (window.__DEBUG__) console.warn('[HOOK] Max attempts reached, could not hook addImageToSidebar');
                    console.warn('[HOOK] Final state - addImageToSidebar:', typeof window.addImageToSidebar, window.addImageToSidebar ? 'exists' : 'undefined');
                }
            }
            
            // Start attempting to hook after a short delay
            setTimeout(attemptHook, 500);
            
            // Function to sync existing legacy images to new gallery
            function syncLegacyImagesToGallery() {
                const imageList = document.getElementById('imageList');
                if (!imageList) {
                    console.log('[SYNC] ERROR: No imageList element found');
                    return;
                }
                
                const imageContainers = imageList.querySelectorAll('.image-container');
                console.log(`[SYNC] Processing ${imageContainers.length} legacy images`);
                
                let newImagesAdded = 0;
                
                imageContainers.forEach((container, index) => {
                    const img = container.querySelector('img');
                    const labelDiv = container.querySelector('.image-label');
                    const label = container.dataset.label;
                    
                    if (img && img.src) {
                        const imageData = {
                            src: img.src,
                            url: img.src,
                            name: labelDiv ? labelDiv.textContent : label || `Image ${index + 1}`,
                            label: label,
                            filename: labelDiv ? labelDiv.textContent : undefined
                        };
                        
                        // Check if this image is already in the gallery
                        const existingIndex = imageGalleryData.findIndex(item => item.src === img.src);
                        
                        if (existingIndex === -1) {
                            addImageToGallery(imageData, imageGalleryData.length);
                            console.log(`[SYNC] ‚úì Added: ${imageData.name}`);
                            newImagesAdded++;
                        }
                    }
                });
                
                if (newImagesAdded > 0) {
                    console.log(`[SYNC] Added ${newImagesAdded} new images. Total: ${imageGalleryData.length}`);
                }

                if (typeof updateImageListPadding === 'function') {
                    updateImageListPadding();
                }
            }
            
            // Function to clear demo images
            function clearDemoImages() {
                console.log('[DEMO] Clearing demo images...');
                imageGalleryData = imageGalleryData.filter(item => !item.name?.includes('Demo Image') && !item.name?.includes('Blank Canvas'));
                
                // Manually update the gallery UI instead of calling undefined function
                const gallery = document.getElementById('imageGallery');
                const dots = document.getElementById('imageDots');
                
                if (gallery) {
                    // Remove demo image thumbnails
                    const demoThumbnails = gallery.querySelectorAll('.image-thumbnail');
                    demoThumbnails.forEach(thumb => {
                        const overlay = thumb.querySelector('.image-overlay');
                        if (overlay && (overlay.textContent.includes('Demo Image') || overlay.textContent.includes('Blank Canvas'))) {
                            thumb.remove();
                        }
                    });
                }
                
                if (dots) {
                    // Clear demo dots
                    const demoDots = dots.querySelectorAll('.nav-dot');
                    demoDots.forEach(dot => dot.remove());
                }
                
                // Update counter if function exists
                if (typeof updateImageCounter === 'function') {
                    updateImageCounter();
                } else {
                    // Update counter manually
                    const counter = document.getElementById('imageCounter');
                    if (counter) {
                        counter.textContent = imageGalleryData.length > 0 ? `${imageGalleryData.length} images` : '';
                    }
                }
                console.log('[DEMO] Demo images cleared, remaining images:', imageGalleryData.length);
            }
            
            // Removed manual sync button - syncing is now automatic
            
            // Test the gallery with some demo images after everything loads
            setTimeout(() => {
                console.log('[INIT] ===== Initial gallery setup =====');
                console.log('[INIT] imageGalleryData before sync:', imageGalleryData.length);
                
                // First, sync any existing legacy images
                console.log('[INIT] Step 1: Syncing existing legacy images...');
                syncLegacyImagesToGallery();
                
                console.log('[INIT] imageGalleryData after sync:', imageGalleryData.length);
                
                // Check if we have any real images (non-demo)
                const realImagesCount = imageGalleryData.filter(item => !item.name?.includes('Demo Image') && !item.name?.includes('Blank Canvas')).length;
                console.log('[INIT] Real images found:', realImagesCount);
                
                // Do not add demo/blank images; keep gallery empty until user adds/loads
                console.log(`[INIT] Skipping demo images. Real count: ${realImagesCount}`);
                
                // Test the addImageToSidebar function to see if hooking works
                if (window.addImageToSidebar) {
                    console.log('[TEST] addImageToSidebar function is available');
                } else {
                    console.log('[TEST] addImageToSidebar not available yet');
                }
                
                console.log('[INIT] ===== Initial setup complete =====');
                
                // Initialize image list centering observer (if function exists and imageList has containers)
                const imageList = document.getElementById('imageList');
                if (imageList && imageList.querySelectorAll('.image-container').length > 0) {
                    if (typeof initImageListCenteringObserver === 'function') {
                        initImageListCenteringObserver();
                    } else {
                        console.warn('[INIT] initImageListCenteringObserver not available yet, will initialize when images are added');
                    }
                } else {
                    console.log('[INIT] No images yet, observer will initialize when first image is added');
                }
                
                // Ensure we always start with the first image
                if (imageList) {
                    const firstContainer = imageList.querySelector('.image-container');
                    if (firstContainer) {
                        const firstLabel = firstContainer.dataset.label;
                        if (firstLabel) {
                            console.log('[INIT] Centering and selecting first image:', firstLabel);
                            
                            // Center the first container
                            window.__imageListProgrammaticScrollUntil = Date.now() + 1000;
                            firstContainer.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                            
                            // Switch to the first image view
                    setTimeout(() => {
                                if (window.projectManager && typeof window.projectManager.switchView === 'function') {
                                    window.projectManager.switchView(firstLabel);
                                }
                                
                                // Update pills
                                if (typeof updatePills === 'function') {
                                    updatePills();
                                }
                                if (typeof updateActivePill === 'function') {
                                    updateActivePill();
                                }
                            }, 300);
                        }
                    }
                    
                    if (typeof updateImageListPadding === 'function') {
                        updateImageListPadding();
                    }
                }
            }, 2000);
            
            // Track last known legacy count to avoid unnecessary syncs
            let lastLegacyCount = 0;
            
            // Also set up a periodic sync to catch any images that get added later (less frequent)
            // Only run when tab is visible to reduce performance impact
            let syncInterval;
            const startSyncInterval = () => {
                syncInterval = setInterval(() => {
                    // Skip if tab is not visible
                    if (document.hidden) return;
                    
                    const currentLegacyCount = document.getElementById('imageList')?.querySelectorAll('.image-container').length || 0;
                    const currentRealImagesCount = imageGalleryData.filter(item => !item.name?.includes('Demo Image') && !item.name?.includes('Blank Canvas')).length;
                    
                    // Only sync if there's actually a change in legacy count
                    if (currentLegacyCount > lastLegacyCount) {
                        console.log('[PERIODIC] New legacy images detected, syncing...');
                        console.log(`[PERIODIC] Legacy: ${currentLegacyCount} (was ${lastLegacyCount}), Gallery real: ${currentRealImagesCount}`);
                        
                        // No demo images are used anymore; skip clearing
                        
                        syncLegacyImagesToGallery();
                        
                        // Don't automatically switch views during periodic sync
                        // Let ProjectManager handle view switching based on user interaction
                        // Only update pills to reflect new images
                        if (typeof updatePills === 'function') {
                            setTimeout(() => {
                                updatePills();
                                if (typeof updateActivePill === 'function') {
                                    updateActivePill();
                                }
                            }, 100);

                                    if (typeof window.ensureImageListObserver === 'function') {
                                        window.ensureImageListObserver();
                                    } else {
                                        window.__pendingImageListObserverInit = true;
                                    }
                        }
                        
                        lastLegacyCount = currentLegacyCount;
                    }
                }, 3000);  // Check every 3 seconds instead of 2
            };
            
            // Start interval and handle visibility changes
            startSyncInterval();
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    clearInterval(syncInterval);
                } else {
                    startSyncInterval();
                }
            });
        });

        // View Measurements toggle functionality
        document.addEventListener('DOMContentLoaded', () => {
            // View Measurements toggle functionality
            const viewMeasurementsToggle = document.getElementById('viewMeasurementsToggle');
            if (viewMeasurementsToggle) {
                let measurementsVisible = true; // Default state

                const updateToggleAppearance = () => {
                    if (measurementsVisible) {
                        viewMeasurementsToggle.classList.remove('bg-gray-500', 'text-white');
                        viewMeasurementsToggle.classList.add('bg-blue-500', 'text-white');
                        viewMeasurementsToggle.textContent = 'Show Labels';
                        viewMeasurementsToggle.title = 'Hide measurement labels';
                    } else {
                        viewMeasurementsToggle.classList.remove('bg-blue-500', 'text-white');
                        viewMeasurementsToggle.classList.add('bg-gray-500', 'text-white');
                        viewMeasurementsToggle.textContent = 'Hide Labels';
                        viewMeasurementsToggle.title = 'Show measurement labels';
                    }
                };

                viewMeasurementsToggle.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent panel dragging
                    measurementsVisible = !measurementsVisible;
                    updateToggleAppearance();

                    // Toggle all measurement labels visibility
                    if (window.strokeLabelVisibility && window.currentImageLabel) {
                        const imageLabels = window.strokeLabelVisibility[window.currentImageLabel];
                        if (imageLabels) {
                            for (const strokeLabel in imageLabels) {
                                window.strokeLabelVisibility[window.currentImageLabel][strokeLabel] = measurementsVisible;
                            }
                        }
                    }

                    // Update all label toggle buttons in the stroke list
                    const labelToggleBtns = document.querySelectorAll('.stroke-label-toggle');
                    labelToggleBtns.forEach(btn => {
                        btn.innerHTML = measurementsVisible ? 'üè∑Ô∏è' : ' üè∑Ô∏è ';
                        btn.title = measurementsVisible ? 'Hide Label' : 'Show Label';
                    });

                    // Redraw canvas to apply changes
                    if (typeof window.redrawCanvasWithVisibility === 'function') {
                        window.redrawCanvasWithVisibility();
                    }
                });

                // Set initial appearance
                updateToggleAppearance();
            }
        });
    </script>
    
    <!-- Scale Dropdown - positioned outside panel hierarchy -->
    <div id="scaleDropdown" class="fixed bg-white border border-gray-300 rounded shadow-lg hidden max-h-64 overflow-y-auto" style="z-index: 9999; min-width: 80px;">
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.1">10%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.15">15%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.2">20%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.25">25%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.33">33%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.5">50%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.67">67%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.75">75%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.8">80%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="0.9">90%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm bg-blue-50" data-scale="1" data-default="true">100%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.1">110%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.25">125%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.5">150%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="1.75">175%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="2">200%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="2.5">250%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="3">300%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="4">400%</div>
        <div class="scale-option px-3 py-1 hover:bg-gray-100 cursor-pointer text-sm" data-scale="5">500%</div>
    </div>

    <script>console.log('[INDEX] before paint.js'); window.onerror=(m,s,l,c,e)=>console.error('[INDEX] onerror',m,s,l,c,e);</script>
    <script>(function(){try{window.NEXT_PUBLIC_REMBG_SAFESHIM='1';}catch(_){}})();</script>
    <!-- New coordinate system scripts -->
    <script src="js/transform.js?v=20250820123456"></script>
    <script src="js/geometry.js?v=20250820123456"></script>
    <script src="js/migration.js?v=20250820123456"></script>

    <!-- Load AI Export Module before paint.js -->
    <script type="module">
        try {
            console.log('[AI Export] Starting to load AI export module...');
            const module = await import('./js/ai-export.js');
            console.log('[AI Export] Module loaded, exports:', Object.keys(module));
            
            const { exportAIEnhancedSVG, assistMeasurement, enhanceAnnotations } = module;
            
            // Make functions available globally
            window.exportAIEnhancedSVG = exportAIEnhancedSVG;
            window.assistMeasurement = assistMeasurement;
            window.enhanceAnnotations = enhanceAnnotations;
            
            // Initialize AI exports storage
            if (!window.aiExports) {
                window.aiExports = {};
            }
            
            console.log('[AI Export] Functions loaded and available globally');
            console.log('[AI Export] window.exportAIEnhancedSVG:', typeof window.exportAIEnhancedSVG);
        } catch (error) {
            console.error('[AI Export] Failed to load AI export module:', error);
            console.error('[AI Export] Error stack:', error.stack);
            // Create stub functions to prevent errors
            window.exportAIEnhancedSVG = () => Promise.reject(new Error('AI Export module failed to load: ' + error.message));
            window.assistMeasurement = () => Promise.reject(new Error('AI Export module failed to load: ' + error.message));
            window.enhanceAnnotations = () => Promise.reject(new Error('AI Export module failed to load: ' + error.message));
        }
    </script>

    <!-- Fabric.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    
    <!-- New Modules -->
    <script type="module" src="js/modules/main.js"></script>

    <!-- Minimal Numeric Pill Strip Implementation (Moved to mini-stepper.js) -->

    <!-- AI Preview Modal -->
    <div id="aiPreviewModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg p-6 max-w-4xl w-full max-h-[90vh] overflow-auto m-4">
            <h2 class="text-xl font-bold mb-4">AI SVG Preview</h2>
            <div id="aiPreviewContainer" class="border border-gray-300 rounded mb-4 relative bg-gray-50 min-h-[400px] flex items-center justify-center">
                <!-- SVG overlay will be inserted here -->
                <p class="text-gray-400">Loading preview...</p>
            </div>
            <div class="flex gap-2 flex-wrap">
                <button id="aiAccept" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors">Accept</button>
                <button id="aiSaveToProject" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors">Save to Project</button>
                <button id="aiDownloadSVG" class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors">Download SVG</button>
                <button id="aiDownloadPNG" class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors">Download PNG</button>
                <button id="aiCancel" class="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400 transition-colors">Cancel</button>
            </div>
        </div>
    </div>

    <!-- AI Calibration Dialog -->
    <dialog id="ai-calibration-dialog" class="backdrop:bg-black backdrop:bg-opacity-50 bg-white rounded-2xl shadow-2xl border-0 p-0 max-w-md w-full">
        <div class="p-6">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-bold text-slate-800">AI Calibration</h3>
                <button onclick="document.getElementById('ai-calibration-dialog').close()" class="text-slate-400 hover:text-slate-600 text-xl">&times;</button>
            </div>

            <div class="mb-4">
                <p class="text-sm text-slate-600 mb-2">AI detected the overall width as:</p>
                <div class="bg-slate-100 rounded-lg p-3 text-center">
                    <span id="detected-width-pixels" class="text-lg font-semibold text-slate-800">0px</span>
                </div>
            </div>

            <form id="calibration-form" onsubmit="handleCalibrationSubmit(event)">
                <div class="mb-4">
                    <label for="real-width" class="block text-sm font-semibold text-slate-700 mb-2">Real width:</label>
                    <input type="number" id="real-width" name="real-width" step="0.1" min="0.1" max="1000"
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-purple-500"
                           placeholder="Enter real width" required>
                </div>

                <div class="mb-6">
                    <label for="unit" class="block text-sm font-semibold text-slate-700 mb-2">Unit:</label>
                    <select id="unit" name="unit" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-purple-500">
                        <option value="cm">Centimeters (cm)</option>
                        <option value="mm">Millimeters (mm)</option>
                        <option value="in">Inches (in)</option>
                    </select>
                </div>

                <div class="flex gap-3">
                    <button type="submit" class="flex-1 px-4 py-2 bg-purple-500 hover:bg-purple-600 text-white font-semibold rounded-lg transition-colors">
                        Generate
                    </button>
                    <button type="button" onclick="document.getElementById('ai-calibration-dialog').close()"
                            class="flex-1 px-4 py-2 bg-gray-300 hover:bg-gray-400 text-gray-700 font-semibold rounded-lg transition-colors">
                        Cancel
                    </button>
                </div>
            </form>
        </div>
    </dialog>

    <!-- AI Preview Modal -->
    <dialog id="ai-preview-modal" class="backdrop:bg-black backdrop:bg-opacity-50 bg-white rounded-2xl shadow-2xl border-0 p-0 max-w-2xl w-full">
        <div class="p-6">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-bold text-slate-800">AI Dimension Preview</h3>
                <button onclick="document.getElementById('ai-preview-modal').close()" class="text-slate-400 hover:text-slate-600 text-xl">&times;</button>
            </div>

            <div class="mb-4">
                <div id="ai-status-text" class="text-sm text-slate-600 mb-3">Calibrated: 1 cm = 0 px</div>
                <div id="ai-dimension-summary" class="bg-slate-50 rounded-lg p-4 space-y-2">
                    <!-- Dimension summary will be populated here -->
                </div>
            </div>

            <div class="flex gap-3">
                <button onclick="handlePreviewAction('accept')" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg transition-colors">
                    Accept
                </button>
                <button onclick="handlePreviewAction('save')" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-lg transition-colors">
                    Save to Project
                </button>
                <button onclick="handlePreviewAction('download-svg')" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white font-semibold rounded-lg transition-colors">
                    Download SVG
                </button>
                <button onclick="handlePreviewAction('download-png')" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white font-semibold rounded-lg transition-colors">
                    Download PNG
                </button>
                <button onclick="document.getElementById('ai-preview-modal').close()" class="px-4 py-2 bg-gray-300 hover:bg-gray-400 text-gray-700 font-semibold rounded-lg transition-colors">
                    Cancel
                </button>
            </div>
        </div>
    </dialog>

    <!-- Load AI Integration Module -->
    <script src="js/ai-integration.js"></script>

    <script>
        // Enhanced status message with loading support
        window.showStatusMessage = function(message, type = 'info') {
            // Get or create status element
            let statusElement = document.getElementById('statusMessage');
            if (!statusElement) {
                statusElement = document.createElement('div');
                statusElement.id = 'statusMessage';
                statusElement.style.cssText = `
                    position: fixed;
                    bottom: 80px; /* Moved up to avoid bottom navigation */
                    left: 50%;
                    transform: translateX(-50%);
                    padding: 12px 24px;
                    border-radius: 50px;
                    color: white;
                    font-weight: 500;
                    font-size: 14px;
                    z-index: 9999;
                    opacity: 0;
                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    max-width: 80%;
                    text-align: center;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    backdrop-filter: blur(8px);
                `;
                document.body.appendChild(statusElement);
            }

            // Reset any previous styles
            statusElement.className = '';
            statusElement.innerHTML = ''; // Clear content

            // Set content based on type
            if (type === 'loading') {
                // Spinner SVG
                const spinner = document.createElement('div');
                spinner.innerHTML = `<svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>`;
                statusElement.appendChild(spinner.firstChild);

                const text = document.createElement('span');
                text.textContent = message;
                statusElement.appendChild(text);

                statusElement.style.backgroundColor = 'rgba(59, 130, 246, 0.9)'; // Blue for loading
            } else {
                statusElement.textContent = message;

                // Set color based on message type
                switch (type) {
                    case 'success':
                        statusElement.style.backgroundColor = 'rgba(34, 197, 94, 0.95)'; // Green
                        break;
                    case 'error':
                        statusElement.style.backgroundColor = 'rgba(239, 68, 68, 0.95)'; // Red
                        break;
                    case 'info':
                    default:
                        statusElement.style.backgroundColor = 'rgba(31, 41, 55, 0.95)'; // Dark Gray
                        break;
                }
            }

            // Show
            requestAnimationFrame(() => {
                statusElement.style.opacity = '1';
                statusElement.style.transform = 'translateX(-50%) translateY(0)';
            });

            // Clear existing timer
            if (statusElement.timer) {
                clearTimeout(statusElement.timer);
                statusElement.timer = null;
            }

            // Hide after timeout (longer for loading, or manual clear)
            if (type !== 'loading') {
                statusElement.timer = setTimeout(() => {
                    statusElement.style.opacity = '0';
                    statusElement.style.transform = 'translateX(-50%) translateY(10px)';
                }, 4000);
            }
        };

        // Helper to hide status message manually (useful for finishing loading states)
        window.hideStatusMessage = function() {
            const statusElement = document.getElementById('statusMessage');
            if (statusElement) {
                statusElement.style.opacity = '0';
                statusElement.style.transform = 'translateX(-50%) translateY(10px)';
            }
        };
    </script>

    <!-- Image Management Modules (Modularized) -->
    <script src="js/image-list-padding.js"></script>
    <script src="js/scroll-select-system.js"></script>
    <script src="js/image-gallery.js"></script>
    <script src="js/mini-stepper.js"></script>

</body>
</html>
